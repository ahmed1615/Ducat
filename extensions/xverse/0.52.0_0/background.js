(() => {
  var t,
    e,
    r = {
      73513: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer,
          i = r(9598),
          o = r(39615),
          s = r(22623);
        function a(t) {
          var e = Object.create(null);
          return (
            t &&
              Object.keys(t).forEach(function (r) {
                if ("default" !== r) {
                  var n = Object.getOwnPropertyDescriptor(t, r);
                  Object.defineProperty(
                    e,
                    r,
                    n.get
                      ? n
                      : {
                          enumerable: !0,
                          get: function () {
                            return t[r];
                          },
                        },
                  );
                }
              }),
            (e.default = t),
            Object.freeze(e)
          );
        }
        var u = a(i);
        (u.utils.hmacSha256Sync = (t, ...e) =>
          o.hmac(s.sha256, t, u.utils.concatBytes(...e))),
          (u.utils.sha256Sync = (...t) => s.sha256(u.utils.concatBytes(...t)));
        const c = u.utils._normalizePrivateKey,
          f = new Uint8Array([
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94,
            140, 208, 54, 65, 65,
          ]);
        function h(t, e) {
          for (let r = 0; r < 32; ++r)
            if (t[r] !== e[r]) return t[r] < e[r] ? -1 : 1;
          return 0;
        }
        function l(t) {
          return t instanceof Uint8Array && 32 === t.length && !(h(t, f) >= 0);
        }
        function d(t) {
          return (
            t instanceof Uint8Array &&
            64 === t.length &&
            h(t.subarray(0, 32), f) < 0 &&
            h(t.subarray(32, 64), f) < 0
          );
        }
        function p(t) {
          return t instanceof Uint8Array && 32 === t.length;
        }
        function y(t) {
          return void 0 === t || (t instanceof Uint8Array && 32 === t.length);
        }
        function g(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t,
            );
          return BigInt(`0x${t}`);
        }
        function m(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t >= 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (64 !== t.length)
              throw new Error("Expected 32 bytes of private scalar");
            e = g(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private scalar");
            if (32 !== t.length)
              throw new Error("Expected 32 bytes of private scalar");
            (r = t), (e = g(u.utils.bytesToHex(r)));
          }
          var r;
          if (e < 0) throw new Error("Expected private scalar >= 0");
          return e;
        }
        const b = (t, e, r) => {
          const n = u.Point.fromHex(t),
            i = m(e),
            o = u.Point.BASE.multiplyAndAddUnsafe(n, i, 1n);
          if (!o) throw new Error("Tweaked point at infinity");
          return o.toRawBytes(r);
        };
        function w(t, e) {
          return void 0 === t ? void 0 === e || S(e) : !!t;
        }
        function v(t) {
          try {
            return t();
          } catch (t) {
            return null;
          }
        }
        function _(t, e) {
          if ((32 === t.length) !== e) return !1;
          try {
            return !!u.Point.fromHex(t);
          } catch (t) {
            return !1;
          }
        }
        function E(t) {
          return _(t, !1);
        }
        function S(t) {
          return _(t, !1) && 33 === t.length;
        }
        function I(t) {
          return u.utils.isValidPrivateKey(t);
        }
        function M(t) {
          return _(t, !0);
        }
        function A(t) {
          if (!E(t)) throw new Error("Expected Point");
          return t.slice(1, 33);
        }
        function T(t, e) {
          if (!I(t)) throw new Error("Expected Private");
          return v(() => u.getPublicKey(t, w(e)));
        }
        (e.isPoint = E),
          (e.isPointCompressed = S),
          (e.isPrivate = I),
          (e.isXOnlyPoint = M),
          (e.pointAdd = function (t, e, r) {
            if (!E(t) || !E(e)) throw new Error("Expected Point");
            return v(() => {
              const n = u.Point.fromHex(t),
                i = u.Point.fromHex(e);
              return n.equals(i.negate()) ? null : n.add(i).toRawBytes(w(r, t));
            });
          }),
          (e.pointAddScalar = function (t, e, r) {
            if (!E(t)) throw new Error("Expected Point");
            if (!l(e)) throw new Error("Expected Tweak");
            return v(() => b(t, e, w(r, t)));
          }),
          (e.pointCompress = function (t, e) {
            if (!E(t)) throw new Error("Expected Point");
            return u.Point.fromHex(t).toRawBytes(w(e, t));
          }),
          (e.pointFromScalar = T),
          (e.pointMultiply = function (t, e, r) {
            if (!E(t)) throw new Error("Expected Point");
            if (!l(e)) throw new Error("Expected Tweak");
            return v(() =>
              ((t, e, r) => {
                const n = u.Point.fromHex(t),
                  i = "string" == typeof e ? e : u.utils.bytesToHex(e),
                  o = BigInt(`0x${i}`);
                return n.multiply(o).toRawBytes(r);
              })(t, e, w(r, t)),
            );
          }),
          (e.privateAdd = function (t, e) {
            if (!1 === I(t)) throw new Error("Expected Private");
            if (!1 === l(e)) throw new Error("Expected Tweak");
            return v(() =>
              ((t, e) => {
                const r = c(t),
                  n = m(e),
                  i = u.utils._bigintTo32Bytes(u.utils.mod(r + n, u.CURVE.n));
                return u.utils.isValidPrivateKey(i) ? i : null;
              })(t, e),
            );
          }),
          (e.privateNegate = function (t) {
            if (!1 === I(t)) throw new Error("Expected Private");
            return ((t) => {
              const e = c(t),
                r = u.utils._bigintTo32Bytes(u.CURVE.n - e);
              return u.utils.isValidPrivateKey(r) ? r : null;
            })(t);
          }),
          (e.privateSub = function (t, e) {
            if (!1 === I(t)) throw new Error("Expected Private");
            if (!1 === l(e)) throw new Error("Expected Tweak");
            return v(() =>
              ((t, e) => {
                const r = c(t),
                  n = m(e),
                  i = u.utils._bigintTo32Bytes(u.utils.mod(r - n, u.CURVE.n));
                return u.utils.isValidPrivateKey(i) ? i : null;
              })(t, e),
            );
          }),
          (e.sign = function (t, e, r) {
            if (!I(e)) throw new Error("Expected Private");
            if (!p(t)) throw new Error("Expected Scalar");
            if (!y(r)) throw new Error("Expected Extra Data (32 bytes)");
            return u.signSync(t, e, { der: !1, extraEntropy: r });
          }),
          (e.signSchnorr = function (t, e, r = n.alloc(32, 0)) {
            if (!I(e)) throw new Error("Expected Private");
            if (!p(t)) throw new Error("Expected Scalar");
            if (!y(r)) throw new Error("Expected Extra Data (32 bytes)");
            return u.schnorr.signSync(t, e, r);
          }),
          (e.verify = function (t, e, r, n) {
            if (!E(e)) throw new Error("Expected Point");
            if (!d(r)) throw new Error("Expected Signature");
            if (!p(t)) throw new Error("Expected Scalar");
            return u.verify(r, t, e, { strict: n });
          }),
          (e.verifySchnorr = function (t, e, r) {
            if (!M(e)) throw new Error("Expected Point");
            if (!d(r)) throw new Error("Expected Signature");
            if (!p(t)) throw new Error("Expected Scalar");
            return u.schnorr.verifySync(r, t, e);
          }),
          (e.xOnlyPointAddTweak = function (t, e) {
            if (!M(t)) throw new Error("Expected Point");
            if (!l(e)) throw new Error("Expected Tweak");
            return v(() => {
              const r = b(t, e, !0);
              return { parity: r[0] % 2 == 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
            });
          }),
          (e.xOnlyPointFromPoint = A),
          (e.xOnlyPointFromScalar = function (t) {
            if (!I(t)) throw new Error("Expected Private");
            return A(T(t));
          });
      },
      91284: (t, e, r) => {
        "use strict";
        r.r(e), r.d(e, { default: () => i });
        var n = function (t, e, r) {
          var n = Math.floor(r() * t.prob.length);
          return e[r() < t.prob[n] ? n : t.alias[n]];
        };
        const i = function (t, e, r) {
          if ((void 0 === r && (r = Math.random), !Array.isArray(t)))
            throw new Error("Probabilities must be an array.");
          if (0 === t.length)
            throw new Error("Probabilities array must not be empty.");
          var i = t.length,
            o =
              null != e
                ? e
                : Array.from({ length: i }, function (t, e) {
                    return e;
                  }),
            s = (function (t, e) {
              var r = t.reduce(function (e, r) {
                if (r < 0)
                  throw new Error(
                    "Probability must be a positive: p[" +
                      t.indexOf(r) +
                      "]=" +
                      r,
                  );
                return e + r;
              }, 0);
              if (0 === r)
                throw new Error("Probability sum must be greater than zero.");
              for (
                var n = t.map(function (t) {
                    return (t * e) / r;
                  }),
                  i = { prob: new Array(e), alias: new Array(e) },
                  o = [],
                  s = [],
                  a = e - 1;
                a >= 0;
                a--
              )
                n[a] < 1 ? o.push(a) : s.push(a);
              for (; o.length > 0 && s.length > 0; ) {
                var u = o.pop(),
                  c = s.pop();
                (i.prob[u] = n[u]),
                  (i.alias[u] = c),
                  (n[c] = n[c] + n[u] - 1),
                  n[c] < 1 ? o.push(c) : s.push(c);
              }
              for (; s.length > 0; ) i.prob[s.pop()] = 1;
              for (; o.length > 0; ) i.prob[o.pop()] = 1;
              return i;
            })(t, i);
          return {
            next: function (t) {
              return (
                void 0 === t && (t = 1),
                (function (t, e, r, i) {
                  if ((void 0 === i && (i = 1), 1 === i)) return n(t, e, r);
                  for (var o = [], s = 0; s < i; s++) o.push(n(t, e, r));
                  return o;
                })(s, o, r, t)
              );
            },
          };
        };
      },
      40793: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = r(14456),
          o = r(10611);
        const s = {
            BTC_SIGN_REQUEST: new i.RegistryType("btc-sign-request", 8101),
            BTC_SIGNATURE: new i.RegistryType("btc-signature", 8102),
          },
          { decodeToDataItem: a, RegistryTypes: u } = i.extend;
        var c, f;
        ((c = e.DataType || (e.DataType = {}))[(c.message = 1)] = "message"),
          (function (t) {
            (t[(t.requestId = 1)] = "requestId"),
              (t[(t.signData = 2)] = "signData"),
              (t[(t.dataType = 3)] = "dataType"),
              (t[(t.derivationPaths = 4)] = "derivationPaths"),
              (t[(t.addresses = 5)] = "addresses"),
              (t[(t.origin = 6)] = "origin");
          })(f || (f = {}));
        class h extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.getRegistryType = () => s.BTC_SIGN_REQUEST),
              (this.getRequestId = () => this.requestId),
              (this.getSignData = () => this.signData),
              (this.getDataype = () => this.dataType),
              (this.getDerivationPaths = () =>
                this.derivationPaths.map((t) => t.getPath())),
              (this.getAddress = () => this.addresses),
              (this.getOrigin = () => this.origin),
              (this.toDataItem = () => {
                const t = {};
                return (
                  (t[f.requestId] = new i.DataItem(
                    this.requestId,
                    u.UUID.getTag(),
                  )),
                  (t[f.signData] = this.signData),
                  (t[f.dataType] = this.dataType),
                  (t[f.derivationPaths] = this.derivationPaths.map((t) => {
                    const e = t.toDataItem();
                    return e.setTag(t.getRegistryType().getTag()), e;
                  })),
                  this.addresses && (t[f.addresses] = this.addresses),
                  this.origin && (t[f.origin] = this.origin),
                  new i.DataItem(t)
                );
              }),
              (this.requestId = t.requestId),
              (this.signData = t.signData),
              (this.dataType = t.dataType),
              (this.derivationPaths = t.derivationPaths),
              (this.addresses = t.addresses),
              (this.origin = t.origin);
          }
          static constructBtcRequest(t, r, s, a, u, c, f) {
            const l = u.map((t, e) => {
              const o = t
                .replace(/[m|M]\//, "")
                .split("/")
                .map((t) => {
                  const e = parseInt(t.replace("'", ""));
                  let r = !1;
                  return (
                    t.endsWith("'") && (r = !0),
                    new i.PathComponent({ index: e, hardened: r })
                  );
                });
              return new i.CryptoKeypath(o, n.from(r[e], "hex"));
            });
            return new h({
              requestId: n.from(o.parse(t)),
              signData: s,
              dataType: a || e.DataType.message,
              derivationPaths: l,
              addresses: c || void 0,
              origin: f || void 0,
            });
          }
        }
        (h.fromDataItem = (t) => {
          const e = t.getData(),
            r = e[f.requestId] ? e[f.requestId].getData() : void 0,
            n = e[f.signData],
            o = e[f.dataType],
            s = e[f.derivationPaths].map((t) =>
              i.CryptoKeypath.fromDataItem(t),
            );
          return new h({
            requestId: r,
            signData: n,
            dataType: o,
            derivationPaths: s,
            addresses: e[f.addresses] ? e[f.addresses] : void 0,
            origin: e[f.origin] ? e[f.origin] : void 0,
          });
        }),
          (h.fromCBOR = (t) => {
            const e = a(t);
            return h.fromDataItem(e);
          });
        const { RegistryTypes: l, decodeToDataItem: d } = i.extend;
        var p;
        !(function (t) {
          (t[(t.requestId = 1)] = "requestId"),
            (t[(t.signature = 2)] = "signature"),
            (t[(t.publicKey = 3)] = "publicKey");
        })(p || (p = {}));
        class y extends i.RegistryItem {
          constructor(t, e, r) {
            super(),
              (this.getRegistryType = () => s.BTC_SIGNATURE),
              (this.getRequestId = () => this.requestId),
              (this.getSignature = () => this.signature),
              (this.getPublicKey = () => this.publicKey),
              (this.toDataItem = () => {
                const t = {};
                return (
                  (t[p.requestId] = new i.DataItem(
                    this.requestId,
                    l.UUID.getTag(),
                  )),
                  (t[p.signature] = this.signature),
                  (t[p.publicKey] = this.publicKey),
                  new i.DataItem(t)
                );
              }),
              (this.signature = t),
              (this.requestId = e),
              (this.publicKey = r);
          }
        }
        (y.fromDataItem = (t) => {
          const e = t.getData(),
            r = e[p.signature],
            n = e[p.requestId].getData();
          return new y(r, n, e[p.publicKey]);
        }),
          (y.fromCBOR = (t) => {
            const e = d(t);
            return y.fromDataItem(e);
          }),
          i.patchTags(
            Object.values(s)
              .filter((t) => !!t.getTag())
              .map((t) => t.getTag()),
          ),
          Object.keys(i).forEach(function (t) {
            "default" !== t &&
              Object.defineProperty(e, t, {
                enumerable: !0,
                get: function () {
                  return i[t];
                },
              });
          }),
          (e.BtcSignRequest = h),
          (e.BtcSignature = y);
      },
      97361: (t, e, r) => {
        "use strict";
        t.exports = r(40793);
      },
      33291: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Bytes = void 0);
        const n = r(20916),
          i = r(9798),
          o = r(36345);
        class s extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.bytes = t),
              (this.getRegistryType = () => o.RegistryTypes.BYTES),
              (this.getData = () => this.bytes),
              (this.toDataItem = () => new n.DataItem(this.bytes));
          }
        }
        (e.Bytes = s),
          (s.fromDataItem = (t) => {
            const e = t.getData();
            if (!e)
              throw new Error(
                `#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${t}`,
              );
            return new s(e);
          }),
          (s.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return s.fromDataItem(e);
          });
      },
      11980: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoAccount = void 0);
        const i = r(14456),
          o = r(20916),
          s = r(9798),
          a = r(36345);
        var u;
        !(function (t) {
          (t[(t.masterFingerprint = 1)] = "masterFingerprint"),
            (t[(t.outputDescriptors = 2)] = "outputDescriptors");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e) {
            super(),
              (this.masterFingerprint = t),
              (this.outputDescriptors = e),
              (this.getRegistryType = () => a.RegistryTypes.CRYPTO_ACCOUNT),
              (this.getMasterFingerprint = () => this.masterFingerprint),
              (this.getOutputDescriptors = () => this.outputDescriptors),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.masterFingerprint &&
                    (t[u.masterFingerprint] =
                      this.masterFingerprint.readUInt32BE(0)),
                  this.outputDescriptors &&
                    (t[u.outputDescriptors] = this.outputDescriptors.map((t) =>
                      t.toDataItem(),
                    )),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.CryptoAccount = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = n.alloc(4),
              o = e[u.masterFingerprint];
            o && r.writeUInt32BE(o, 0);
            const s = e[u.outputDescriptors].map((t) =>
              i.CryptoOutput.fromDataItem(t),
            );
            return new c(r, s);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      48638: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoCoinInfo = e.Network = e.Type = void 0);
        const n = r(20916),
          i = r(9798),
          o = r(36345);
        var s, a, u;
        !(function (t) {
          (t.type = "1"), (t.network = "2");
        })(s || (s = {})),
          (function (t) {
            t[(t.bitcoin = 0)] = "bitcoin";
          })((a = e.Type || (e.Type = {}))),
          (function (t) {
            (t[(t.mainnet = 0)] = "mainnet"), (t[(t.testnet = 1)] = "testnet");
          })((u = e.Network || (e.Network = {})));
        class c extends i.RegistryItem {
          constructor(t, e) {
            super(),
              (this.type = t),
              (this.network = e),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_COIN_INFO),
              (this.getType = () => this.type || a.bitcoin),
              (this.getNetwork = () => this.network || u.mainnet),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.type && (t[s.type] = this.type),
                  this.network && (t[s.network] = this.network),
                  new n.DataItem(t)
                );
              });
          }
        }
        (e.CryptoCoinInfo = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[s.type],
              n = e[s.network];
            return new c(r, n);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      51320: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoECKey = void 0);
        const n = r(20916),
          i = r(9798),
          o = r(36345);
        var s;
        !(function (t) {
          (t[(t.curve = 1)] = "curve"),
            (t[(t.private = 2)] = "private"),
            (t[(t.data = 3)] = "data");
        })(s || (s = {}));
        class a extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.isECKey = () => !0),
              (this.getCurve = () => this.curve || 0),
              (this.isPrivateKey = () => this.privateKey || !1),
              (this.getData = () => this.data),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_ECKEY),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.curve && (t[s.curve] = this.curve),
                  void 0 !== this.privateKey &&
                    (t[s.private] = this.privateKey),
                  (t[s.data] = this.data),
                  new n.DataItem(t)
                );
              }),
              (this.getOutputDescriptorContent = () =>
                this.data.toString("hex")),
              (this.data = t.data),
              (this.curve = t.curve),
              (this.privateKey = t.privateKey || void 0);
          }
        }
        (e.CryptoECKey = a),
          (a.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[s.curve],
              n = e[s.private],
              i = e[s.data];
            if (!i)
              throw new Error(
                `#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${t}`,
              );
            return new a({ data: i, curve: r, privateKey: n });
          }),
          (a.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return a.fromDataItem(e);
          });
      },
      75208: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoHDKey = void 0);
        const i = r(91889),
          o = r(48638),
          s = r(83831),
          a = r(20916),
          u = r(9798),
          c = r(36345);
        var f;
        !(function (t) {
          (t[(t.is_master = 1)] = "is_master"),
            (t[(t.is_private = 2)] = "is_private"),
            (t[(t.key_data = 3)] = "key_data"),
            (t[(t.chain_code = 4)] = "chain_code"),
            (t[(t.use_info = 5)] = "use_info"),
            (t[(t.origin = 6)] = "origin"),
            (t[(t.children = 7)] = "children"),
            (t[(t.parent_fingerprint = 8)] = "parent_fingerprint"),
            (t[(t.name = 9)] = "name"),
            (t[(t.note = 10)] = "note");
        })(f || (f = {}));
        class h extends u.RegistryItem {
          constructor(t) {
            super(),
              (this.isECKey = () => !1),
              (this.getKey = () => this.key),
              (this.getChainCode = () => this.chainCode),
              (this.isMaster = () => this.master),
              (this.isPrivateKey = () => !!this.privateKey),
              (this.getUseInfo = () => this.useInfo),
              (this.getOrigin = () => this.origin),
              (this.getChildren = () => this.children),
              (this.getParentFingerprint = () => this.parentFingerprint),
              (this.getName = () => this.name),
              (this.getNote = () => this.note),
              (this.getBip32Key = () => {
                var t, e, r;
                let o,
                  s,
                  a = 0,
                  u = n.alloc(4).fill(0);
                if (this.isMaster())
                  (o = n.from("0488ADE4", "hex")), (s = 0), (a = 0);
                else {
                  s =
                    (null === (t = this.getOrigin()) || void 0 === t
                      ? void 0
                      : t.getComponents().length) ||
                    (null === (e = this.getOrigin()) || void 0 === e
                      ? void 0
                      : e.getDepth());
                  const i =
                      null === (r = this.getOrigin()) || void 0 === r
                        ? void 0
                        : r.getComponents(),
                    c = i[i.length - 1];
                  c &&
                    ((a = c.isHardened()
                      ? c.getIndex() + 2147483648
                      : c.getIndex()),
                    this.getParentFingerprint() &&
                      (u = this.getParentFingerprint())),
                    (o = this.isPrivateKey()
                      ? n.from("0488ADE4", "hex")
                      : n.from("0488B21E", "hex"));
                }
                const c = n.alloc(1);
                c.writeUInt8(s, 0);
                const f = n.alloc(4);
                f.writeUInt32BE(a, 0);
                const h = this.getChainCode(),
                  l = this.getKey();
                return (0, i.encode)(n.concat([o, c, u, f, h, l]));
              }),
              (this.getRegistryType = () => c.RegistryTypes.CRYPTO_HDKEY),
              (this.getOutputDescriptorContent = () => {
                var t, e, r, n, i, o, s;
                let a = "";
                return (
                  this.getOrigin() &&
                    (null === (t = this.getOrigin()) || void 0 === t
                      ? void 0
                      : t.getSourceFingerprint()) &&
                    (null === (e = this.getOrigin()) || void 0 === e
                      ? void 0
                      : e.getPath()) &&
                    (a += `${null === (n = null === (r = this.getOrigin()) || void 0 === r ? void 0 : r.getSourceFingerprint()) || void 0 === n ? void 0 : n.toString("hex")}/${null === (i = this.getOrigin()) || void 0 === i ? void 0 : i.getPath()}`),
                  (a += this.getBip32Key()),
                  this.getChildren() &&
                    (null === (o = this.getChildren()) || void 0 === o
                      ? void 0
                      : o.getPath()) &&
                    (a += `/${null === (s = this.getChildren()) || void 0 === s ? void 0 : s.getPath()}`),
                  a
                );
              }),
              (this.setupMasterKey = (t) => {
                (this.master = !0),
                  (this.key = t.key),
                  (this.chainCode = t.chainCode);
              }),
              (this.setupDeriveKey = (t) => {
                (this.master = !1),
                  (this.privateKey = t.isPrivateKey),
                  (this.key = t.key),
                  (this.chainCode = t.chainCode),
                  (this.useInfo = t.useInfo),
                  (this.origin = t.origin),
                  (this.children = t.children),
                  (this.parentFingerprint = t.parentFingerprint),
                  (this.name = t.name),
                  (this.note = t.note);
              }),
              (this.toDataItem = () => {
                const t = {};
                if (this.master)
                  (t[f.is_master] = !0),
                    (t[f.key_data] = this.key),
                    (t[f.chain_code] = this.chainCode);
                else {
                  if (
                    (void 0 !== this.privateKey &&
                      (t[f.is_private] = this.privateKey),
                    (t[f.key_data] = this.key),
                    this.chainCode && (t[f.chain_code] = this.chainCode),
                    this.useInfo)
                  ) {
                    const e = this.useInfo.toDataItem();
                    e.setTag(this.useInfo.getRegistryType().getTag()),
                      (t[f.use_info] = e);
                  }
                  if (this.origin) {
                    const e = this.origin.toDataItem();
                    e.setTag(this.origin.getRegistryType().getTag()),
                      (t[f.origin] = e);
                  }
                  if (this.children) {
                    const e = this.children.toDataItem();
                    e.setTag(this.children.getRegistryType().getTag()),
                      (t[f.children] = e);
                  }
                  this.parentFingerprint &&
                    (t[f.parent_fingerprint] =
                      this.parentFingerprint.readUInt32BE(0)),
                    void 0 !== this.name && (t[f.name] = this.name),
                    void 0 !== this.note && (t[f.note] = this.note);
                }
                return new a.DataItem(t);
              }),
              t.isMaster ? this.setupMasterKey(t) : this.setupDeriveKey(t);
          }
        }
        (e.CryptoHDKey = h),
          (h.fromDataItem = (t) => {
            const e = t.getData(),
              r = !!e[f.is_master],
              i = e[f.is_private],
              a = e[f.key_data],
              u = e[f.chain_code],
              c = e[f.use_info]
                ? o.CryptoCoinInfo.fromDataItem(e[f.use_info])
                : void 0,
              l = e[f.origin]
                ? s.CryptoKeypath.fromDataItem(e[f.origin])
                : void 0,
              d = e[f.children]
                ? s.CryptoKeypath.fromDataItem(e[f.children])
                : void 0,
              p = e[f.parent_fingerprint];
            let y;
            p && ((y = n.alloc(4)), y.writeUInt32BE(p, 0));
            const g = e[f.name],
              m = e[f.note];
            return new h({
              isMaster: r,
              isPrivateKey: i,
              key: a,
              chainCode: u,
              useInfo: c,
              origin: l,
              children: d,
              parentFingerprint: y,
              name: g,
              note: m,
            });
          }),
          (h.fromCBOR = (t) => {
            const e = (0, a.decodeToDataItem)(t);
            return h.fromDataItem(e);
          });
      },
      83831: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoKeypath = void 0);
        const i = r(20916),
          o = r(92166),
          s = r(9798),
          a = r(36345);
        var u;
        !(function (t) {
          (t[(t.components = 1)] = "components"),
            (t[(t.source_fingerprint = 2)] = "source_fingerprint"),
            (t[(t.depth = 3)] = "depth");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t = [], e, r) {
            super(),
              (this.components = t),
              (this.sourceFingerprint = e),
              (this.depth = r),
              (this.getRegistryType = () => a.RegistryTypes.CRYPTO_KEYPATH),
              (this.getPath = () => {
                if (0 === this.components.length) return;
                return this.components
                  .map(
                    (t) =>
                      `${t.isWildcard() ? "*" : t.getIndex()}${t.isHardened() ? "'" : ""}`,
                  )
                  .join("/");
              }),
              (this.getComponents = () => this.components),
              (this.getSourceFingerprint = () => this.sourceFingerprint),
              (this.getDepth = () => this.depth),
              (this.toDataItem = () => {
                const t = {},
                  e = [];
                return (
                  this.components &&
                    this.components.forEach((t) => {
                      t.isWildcard() ? e.push([]) : e.push(t.getIndex()),
                        e.push(t.isHardened());
                    }),
                  (t[u.components] = e),
                  this.sourceFingerprint &&
                    (t[u.source_fingerprint] =
                      this.sourceFingerprint.readUInt32BE(0)),
                  void 0 !== this.depth && (t[u.depth] = this.depth),
                  new i.DataItem(t)
                );
              });
          }
        }
        (e.CryptoKeypath = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = [],
              i = e[u.components];
            if (i)
              for (let t = 0; t < i.length; t += 2) {
                const e = i[t + 1],
                  n = i[t];
                "number" == typeof n
                  ? r.push(new o.PathComponent({ index: n, hardened: e }))
                  : r.push(new o.PathComponent({ hardened: e }));
              }
            const s = e[u.source_fingerprint];
            let a;
            s && ((a = n.alloc(4)), a.writeUInt32BE(s, 0));
            const f = e[u.depth];
            return new c(r, a, f);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, i.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      90830: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoOutput = void 0);
        const n = r(51320),
          i = r(75208),
          o = r(20916),
          s = r(57330),
          a = r(9798),
          u = r(36345),
          c = r(98599);
        class f extends a.RegistryItem {
          constructor(t, e) {
            super(),
              (this.scriptExpressions = t),
              (this.cryptoKey = e),
              (this.getRegistryType = () => u.RegistryTypes.CRYPTO_OUTPUT),
              (this.getCryptoKey = () => this.cryptoKey),
              (this.getHDKey = () =>
                this.cryptoKey instanceof i.CryptoHDKey
                  ? this.cryptoKey
                  : void 0),
              (this.getECKey = () =>
                this.cryptoKey instanceof n.CryptoECKey
                  ? this.cryptoKey
                  : void 0),
              (this.getMultiKey = () =>
                this.cryptoKey instanceof s.MultiKey ? this.cryptoKey : void 0),
              (this.getScriptExpressions = () => this.scriptExpressions),
              (this._toOutputDescriptor = (t) =>
                t >= this.scriptExpressions.length
                  ? this.cryptoKey.getOutputDescriptorContent()
                  : `${this.scriptExpressions[t].getExpression()}(${this._toOutputDescriptor(t + 1)})`),
              (this.toString = () => this._toOutputDescriptor(0)),
              (this.toDataItem = () => {
                let t = this.cryptoKey.toDataItem();
                (this.cryptoKey instanceof n.CryptoECKey ||
                  this.cryptoKey instanceof i.CryptoHDKey) &&
                  t.setTag(this.cryptoKey.getRegistryType().getTag());
                return (
                  [...this.scriptExpressions].reverse().forEach((e) => {
                    const r = e.getTag();
                    void 0 === t.getTag()
                      ? t.setTag(r)
                      : (t = new o.DataItem(t, r));
                  }),
                  t
                );
              });
          }
        }
        (e.CryptoOutput = f),
          (f.fromDataItem = (t) => {
            const e = [];
            let r = t;
            for (;;) {
              let t = r.getTag();
              const n = c.ScriptExpression.fromTag(t);
              if (!n) break;
              if ((e.push(n), !(r.getData() instanceof o.DataItem))) break;
              (r = r.getData()), (t = r.getTag());
            }
            const a = e.length;
            if (
              a > 0 &&
              (e[a - 1].getExpression() ===
                c.ScriptExpressions.MULTISIG.getExpression() ||
                e[a - 1].getExpression() ===
                  c.ScriptExpressions.SORTED_MULTISIG.getExpression())
            ) {
              const t = s.MultiKey.fromDataItem(r);
              return new f(e, t);
            }
            if (r.getTag() === u.RegistryTypes.CRYPTO_HDKEY.getTag()) {
              const t = i.CryptoHDKey.fromDataItem(r);
              return new f(e, t);
            }
            {
              const t = n.CryptoECKey.fromDataItem(r);
              return new f(e, t);
            }
          }),
          (f.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return f.fromDataItem(e);
          });
      },
      71452: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoPSBT = void 0);
        const n = r(20916),
          i = r(9798),
          o = r(36345);
        class s extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.psbt = t),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_PSBT),
              (this.getPSBT = () => this.psbt),
              (this.toDataItem = () => new n.DataItem(this.psbt));
          }
        }
        (e.CryptoPSBT = s),
          (s.fromDataItem = (t) => {
            const e = t.getData();
            if (!e)
              throw new Error(
                `#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${t}`,
              );
            return new s(e);
          }),
          (s.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return s.fromDataItem(e);
          });
      },
      8675: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.URRegistryDecoder = void 0);
        const n = r(17539),
          i = r(14456),
          o = r(36345),
          s = r(70066);
        class a extends n.URDecoder {
          constructor() {
            super(...arguments),
              (this.resultRegistryType = () => {
                const t = this.resultUR();
                switch (t.type) {
                  case o.RegistryTypes.BYTES.getType():
                    return i.Bytes.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_HDKEY.getType():
                    return i.CryptoHDKey.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return i.CryptoKeypath.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return i.CryptoCoinInfo.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_ECKEY.getType():
                    return i.CryptoECKey.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return i.CryptoOutput.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_PSBT.getType():
                    return i.CryptoPSBT.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return i.CryptoAccount.fromCBOR(t.cbor);
                  default:
                    throw new s.UnknownURTypeError(
                      `#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${t.type} is not supported now`,
                    );
                }
              });
          }
        }
        e.URRegistryDecoder = a;
      },
      57330: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.MultiKey = void 0);
        const n = r(51320),
          i = r(75208),
          o = r(38501),
          s = r(9798),
          a = r(36345);
        var u;
        !(function (t) {
          (t[(t.threshold = 1)] = "threshold"), (t[(t.keys = 2)] = "keys");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e) {
            super(),
              (this.threshold = t),
              (this.keys = e),
              (this.getThreshold = () => this.threshold),
              (this.getKeys = () => this.keys),
              (this.toDataItem = () => {
                const t = {};
                t[u.threshold] = this.threshold;
                const e = this.keys.map((t) => {
                  const e = t.toDataItem();
                  return e.setTag(t.getRegistryType().getTag()), e;
                });
                return (t[u.keys] = e), new o.DataItem(t);
              }),
              (this.getOutputDescriptorContent = () =>
                [
                  this.getThreshold(),
                  this.keys
                    .map((t) => t.getOutputDescriptorContent())
                    .join(","),
                ].join(","));
          }
        }
        (e.MultiKey = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[u.threshold],
              o = e[u.keys],
              s = [];
            return (
              o.forEach((t) => {
                t.getTag() === a.RegistryTypes.CRYPTO_HDKEY.getTag()
                  ? s.push(i.CryptoHDKey.fromDataItem(t))
                  : t.getTag() === a.RegistryTypes.CRYPTO_ECKEY.getTag() &&
                    s.push(n.CryptoECKey.fromDataItem(t));
              }),
              new c(r, s)
            );
          });
      },
      92166: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.PathComponent = void 0);
        class r {
          constructor(t) {
            if (
              ((this.getIndex = () => this.index),
              (this.isWildcard = () => this.wildcard),
              (this.isHardened = () => this.hardened),
              (this.index = t.index),
              (this.hardened = t.hardened),
              void 0 !== this.index
                ? (this.wildcard = !1)
                : (this.wildcard = !0),
              this.index && this.index & r.HARDENED_BIT)
            )
              throw new Error(
                `#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`,
              );
          }
        }
        (e.PathComponent = r), (r.HARDENED_BIT = 2147483648);
      },
      9798: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.RegistryItem = void 0);
        const n = r(17539),
          i = r(20916);
        e.RegistryItem = class {
          constructor() {
            (this.toCBOR = () => {
              if (void 0 === this.toDataItem())
                throw new Error(
                  `#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`,
                );
              return (0, i.encodeDataItem)(this.toDataItem());
            }),
              (this.toUR = () =>
                new n.UR(this.toCBOR(), this.getRegistryType().getType())),
              (this.toUREncoder = (t, e, r) => {
                const i = this.toUR();
                return new n.UREncoder(i, t, e, r);
              });
          }
        };
      },
      36345: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.RegistryTypes = e.RegistryType = void 0);
        class r {
          constructor(t, e) {
            (this.type = t),
              (this.tag = e),
              (this.getTag = () => this.tag),
              (this.getType = () => this.type);
          }
        }
        (e.RegistryType = r),
          (e.RegistryTypes = {
            UUID: new r("uuid", 37),
            BYTES: new r("bytes", void 0),
            CRYPTO_HDKEY: new r("crypto-hdkey", 303),
            CRYPTO_KEYPATH: new r("crypto-keypath", 304),
            CRYPTO_COIN_INFO: new r("crypto-coin-info", 305),
            CRYPTO_ECKEY: new r("crypto-eckey", 306),
            CRYPTO_OUTPUT: new r("crypto-output", 308),
            CRYPTO_PSBT: new r("crypto-psbt", 310),
            CRYPTO_ACCOUNT: new r("crypto-account", 311),
            CRYPTO_MULTI_ACCOUNTS: new r("crypto-multi-accounts", 1103),
            QR_HARDWARE_CALL: new r("qr-hardware-call", 1201),
            KEY_DERIVATION_CALL: new r("key-derivation-call", 1301),
            KEY_DERIVATION_SCHEMA: new r("key-derivation-schema", 1302),
          });
      },
      98599: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ScriptExpressions = e.ScriptExpression = void 0);
        class r {
          constructor(t, e) {
            (this.tag = t),
              (this.expression = e),
              (this.getTag = () => this.tag),
              (this.getExpression = () => this.expression);
          }
        }
        (e.ScriptExpression = r),
          (r.fromTag = (t) =>
            Object.values(e.ScriptExpressions).find((e) => e.getTag() === t)),
          (e.ScriptExpressions = {
            SCRIPT_HASH: new r(400, "sh"),
            WITNESS_SCRIPT_HASH: new r(401, "wsh"),
            PUBLIC_KEY: new r(402, "pk"),
            PUBLIC_KEY_HASH: new r(403, "pkh"),
            WITNESS_PUBLIC_KEY_HASH: new r(404, "wpkh"),
            COMBO: new r(405, "combo"),
            MULTISIG: new r(406, "multi"),
            SORTED_MULTISIG: new r(407, "sortedmulti"),
            ADDRESS: new r(307, "addr"),
            RAW_SCRIPT: new r(408, "raw"),
          });
      },
      70066: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.UnknownURTypeError = void 0);
        class r extends Error {
          constructor(t) {
            super(t);
          }
        }
        e.UnknownURTypeError = r;
      },
      1166: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoMultiAccounts = void 0);
        const i = r(36345),
          o = r(75208),
          s = r(9798),
          a = r(20916);
        var u;
        !(function (t) {
          (t[(t.masterFingerprint = 1)] = "masterFingerprint"),
            (t[(t.keys = 2)] = "keys"),
            (t[(t.device = 3)] = "device"),
            (t[(t.deviceId = 4)] = "deviceId"),
            (t[(t.version = 5)] = "version");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e, r, n, o) {
            super(),
              (this.masterFingerprint = t),
              (this.keys = e),
              (this.device = r),
              (this.deviceId = n),
              (this.version = o),
              (this.getRegistryType = () =>
                i.RegistryTypes.CRYPTO_MULTI_ACCOUNTS),
              (this.getMasterFingerprint = () => this.masterFingerprint),
              (this.getKeys = () => this.keys),
              (this.getDevice = () => this.device),
              (this.getDeviceId = () => this.deviceId),
              (this.getVersion = () => this.version),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.masterFingerprint &&
                    (t[u.masterFingerprint] =
                      this.masterFingerprint.readUInt32BE(0)),
                  this.keys &&
                    (t[u.keys] = this.keys.map((t) => {
                      const e = t.toDataItem();
                      return e.setTag(t.getRegistryType().getTag()), e;
                    })),
                  this.device && (t[u.device] = this.device),
                  this.deviceId && (t[u.deviceId] = this.deviceId),
                  this.version && (t[u.version] = this.version),
                  new a.DataItem(t)
                );
              });
          }
        }
        (e.CryptoMultiAccounts = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = n.alloc(4),
              i = e[u.masterFingerprint];
            i && r.writeUInt32BE(i, 0);
            const s = e[u.keys].map((t) => o.CryptoHDKey.fromDataItem(t)),
              a = e[u.device],
              f = e[u.deviceId],
              h = e[u.version];
            return new c(r, s, a, f, h);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, a.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      9148: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.KeyDerivationSchema = e.DerivationAlgorithm = e.Curve = void 0);
        const n = r(36345),
          i = r(9798),
          o = r(20916),
          s = r(83831);
        var a, u, c;
        !(function (t) {
          (t[(t.keyPath = 1)] = "keyPath"),
            (t[(t.curve = 2)] = "curve"),
            (t[(t.algo = 3)] = "algo");
        })(a || (a = {})),
          (function (t) {
            (t[(t.secp256k1 = 0)] = "secp256k1"),
              (t[(t.ed25519 = 1)] = "ed25519");
          })((u = e.Curve || (e.Curve = {}))),
          (function (t) {
            (t[(t.slip10 = 0)] = "slip10"),
              (t[(t.bip32ed25519 = 1)] = "bip32ed25519");
          })((c = e.DerivationAlgorithm || (e.DerivationAlgorithm = {})));
        class f extends i.RegistryItem {
          constructor(t, e = u.secp256k1, r = c.slip10) {
            super(),
              (this.keypath = t),
              (this.curve = e),
              (this.algo = r),
              (this.getRegistryType = () =>
                n.RegistryTypes.KEY_DERIVATION_SCHEMA),
              (this.getKeypath = () => this.keypath),
              (this.getCurve = () => this.curve),
              (this.getAlgo = () => this.algo),
              (this.toDataItem = () => {
                const t = {},
                  e = this.getKeypath().toDataItem();
                return (
                  e.setTag(this.getKeypath().getRegistryType().getTag()),
                  (t[a.keyPath] = e),
                  (t[a.curve] = this.curve),
                  (t[a.algo] = this.algo),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.KeyDerivationSchema = f),
          (f.fromDataItem = (t) => {
            const e = t.getData(),
              r = s.CryptoKeypath.fromDataItem(e[a.keyPath]),
              n = e[a.curve],
              i = e[a.algo];
            return new f(r, n, i);
          }),
          (f.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return f.fromDataItem(e);
          });
      },
      66842: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.KeyDerivation = void 0);
        const n = r(36345),
          i = r(9798),
          o = r(20916),
          s = r(9148);
        var a;
        !(function (t) {
          t[(t.schemas = 1)] = "schemas";
        })(a || (a = {}));
        class u extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.schemas = t),
              (this.getRegistryType = () =>
                n.RegistryTypes.KEY_DERIVATION_CALL),
              (this.getSchemas = () => this.schemas),
              (this.toDataItem = () => {
                const t = {};
                return (
                  (t[a.schemas] = this.schemas.map((t) => {
                    const e = t.toDataItem();
                    return e.setTag(t.getRegistryType().getTag()), e;
                  })),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.KeyDerivation = u),
          (u.fromDataItem = (t) => {
            const e = t
              .getData()
              [a.schemas].map((t) => s.KeyDerivationSchema.fromDataItem(t));
            return new u(e);
          }),
          (u.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return u.fromDataItem(e);
          });
      },
      62757: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.QRHardwareCall = e.QRHardwareCallType = void 0);
        const n = r(36345),
          i = r(9798),
          o = r(20916),
          s = r(66842);
        var a, u;
        !(function (t) {
          (t[(t.type = 1)] = "type"),
            (t[(t.params = 2)] = "params"),
            (t[(t.origin = 3)] = "origin");
        })(a || (a = {})),
          (function (t) {
            t[(t.KeyDerivation = 0)] = "KeyDerivation";
          })((u = e.QRHardwareCallType || (e.QRHardwareCallType = {})));
        class c extends i.RegistryItem {
          constructor(t, e, r) {
            super(),
              (this.type = t),
              (this.params = e),
              (this.origin = r),
              (this.getRegistryType = () => n.RegistryTypes.QR_HARDWARE_CALL),
              (this.getType = () => this.type),
              (this.getParams = () => this.params),
              (this.getOrigin = () => this.origin),
              (this.toDataItem = () => {
                const t = {};
                t[a.type] = this.type;
                const e = this.params.toDataItem();
                return (
                  e.setTag(this.params.getRegistryType().getTag()),
                  (t[a.params] = e),
                  this.origin && (t[a.origin] = this.origin),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.QRHardwareCall = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[a.type] || u.KeyDerivation;
            let n;
            if (r === u.KeyDerivation)
              n = s.KeyDerivation.fromDataItem(e[a.params]);
            const i = e[a.origin];
            return new c(r, n, i);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      14456: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Buffer =
            e.extend =
            e.PathComponent =
            e.ScriptExpressions =
            e.MultiKey =
            e.CryptoPSBT =
            e.CryptoOutput =
            e.CryptoECKey =
            e.CryptoCoinInfoNetwork =
            e.CryptoCoinInfoType =
            e.CryptoCoinInfo =
            e.CryptoKeypath =
            e.CryptoMultiAccounts =
            e.CryptoHDKey =
            e.CryptoAccount =
            e.Bytes =
            e.URRegistryDecoder =
            e.DataItem =
              void 0);
        const n = r(31635);
        r(33922);
        const i = r(48287);
        Object.defineProperty(e, "Buffer", {
          enumerable: !0,
          get: function () {
            return i.Buffer;
          },
        });
        const o = r(75208);
        Object.defineProperty(e, "CryptoHDKey", {
          enumerable: !0,
          get: function () {
            return o.CryptoHDKey;
          },
        });
        const s = r(83831);
        Object.defineProperty(e, "CryptoKeypath", {
          enumerable: !0,
          get: function () {
            return s.CryptoKeypath;
          },
        });
        const a = r(48638);
        Object.defineProperty(e, "CryptoCoinInfo", {
          enumerable: !0,
          get: function () {
            return a.CryptoCoinInfo;
          },
        }),
          Object.defineProperty(e, "CryptoCoinInfoType", {
            enumerable: !0,
            get: function () {
              return a.Type;
            },
          }),
          Object.defineProperty(e, "CryptoCoinInfoNetwork", {
            enumerable: !0,
            get: function () {
              return a.Network;
            },
          });
        const u = r(51320);
        Object.defineProperty(e, "CryptoECKey", {
          enumerable: !0,
          get: function () {
            return u.CryptoECKey;
          },
        });
        const c = r(33291);
        Object.defineProperty(e, "Bytes", {
          enumerable: !0,
          get: function () {
            return c.Bytes;
          },
        });
        const f = r(90830);
        Object.defineProperty(e, "CryptoOutput", {
          enumerable: !0,
          get: function () {
            return f.CryptoOutput;
          },
        });
        const h = r(71452);
        Object.defineProperty(e, "CryptoPSBT", {
          enumerable: !0,
          get: function () {
            return h.CryptoPSBT;
          },
        });
        const l = r(11980);
        Object.defineProperty(e, "CryptoAccount", {
          enumerable: !0,
          get: function () {
            return l.CryptoAccount;
          },
        });
        const d = r(8675);
        Object.defineProperty(e, "URRegistryDecoder", {
          enumerable: !0,
          get: function () {
            return d.URRegistryDecoder;
          },
        });
        const p = r(57330);
        Object.defineProperty(e, "MultiKey", {
          enumerable: !0,
          get: function () {
            return p.MultiKey;
          },
        });
        const y = r(98599);
        Object.defineProperty(e, "ScriptExpressions", {
          enumerable: !0,
          get: function () {
            return y.ScriptExpressions;
          },
        });
        const g = r(92166);
        Object.defineProperty(e, "PathComponent", {
          enumerable: !0,
          get: function () {
            return g.PathComponent;
          },
        });
        const m = r(9798),
          b = r(36345),
          w = r(20916);
        var v = r(20916);
        Object.defineProperty(e, "DataItem", {
          enumerable: !0,
          get: function () {
            return v.DataItem;
          },
        });
        const _ = r(20193),
          E = r(1166);
        Object.defineProperty(e, "CryptoMultiAccounts", {
          enumerable: !0,
          get: function () {
            return E.CryptoMultiAccounts;
          },
        });
        const S = {
            URRegistryDecoder: d.URRegistryDecoder,
            Bytes: c.Bytes,
            CryptoAccount: l.CryptoAccount,
            CryptoHDKey: o.CryptoHDKey,
            CryptoMultiAccounts: E.CryptoMultiAccounts,
            CryptoKeypath: s.CryptoKeypath,
            CryptoCoinInfo: a.CryptoCoinInfo,
            CryptoCoinInfoType: a.Type,
            CryptoCoinInfoNetwork: a.Network,
            CryptoECKey: u.CryptoECKey,
            CryptoOutput: f.CryptoOutput,
            CryptoPSBT: h.CryptoPSBT,
            MultiKey: p.MultiKey,
            ScriptExpressions: y.ScriptExpressions,
            PathComponent: g.PathComponent,
          },
          I = {
            addReader: w.addReader,
            addSemanticDecode: w.addSemanticDecode,
            addSemanticEncode: w.addSemanticEncode,
            addWriter: w.addWriter,
            patchTags: _.patchTags,
          },
          M = {
            RegistryTypes: b.RegistryTypes,
            RegistryItem: m.RegistryItem,
            RegistryType: b.RegistryType,
            decodeToDataItem: w.decodeToDataItem,
            encodeDataItem: w.encodeDataItem,
            cbor: I,
          };
        (e.extend = M),
          (0, n.__exportStar)(r(70066), e),
          (0, n.__exportStar)(r(8675), e),
          (0, n.__exportStar)(r(20916), e),
          (0, n.__exportStar)(r(11980), e),
          (0, n.__exportStar)(r(71452), e),
          (0, n.__exportStar)(r(75208), e),
          (0, n.__exportStar)(r(1166), e),
          (0, n.__exportStar)(r(62757), e),
          (0, n.__exportStar)(r(66842), e),
          (0, n.__exportStar)(r(9148), e),
          (0, n.__exportStar)(r(90830), e),
          (0, n.__exportStar)(r(48638), e),
          (0, n.__exportStar)(r(51320), e),
          (0, n.__exportStar)(r(57330), e),
          (0, n.__exportStar)(r(83831), e),
          (0, n.__exportStar)(r(33922), e),
          (0, n.__exportStar)(r(92166), e),
          (0, n.__exportStar)(r(9798), e),
          (0, n.__exportStar)(r(36345), e),
          (0, n.__exportStar)(r(75357), e),
          (0, n.__exportStar)(r(20193), e),
          (e.default = S);
      },
      38501: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DataItem = void 0);
        e.DataItem = class {
          constructor(t, e) {
            (this.setTag = (t) => {
              this.tag = t;
            }),
              (this.clearTag = () => {
                this.tag = void 0;
              }),
              (this.getTag = () => this.tag),
              (this.getData = () => this.data),
              (this.data = t),
              (this.tag = e);
          }
        };
      },
      25972: function (t, e, r) {
        "use strict";
        var n,
          i,
          o,
          s = r(48287).Buffer;
        (i = []),
          void 0 ===
            (o =
              "function" ==
              typeof (n = function () {
                const { DataItem: t } = r(38501);
                var e = (function () {
                  function e(t) {
                    this.$hex = t;
                  }
                  (e.prototype = {
                    length: function () {
                      return this.$hex.length / 2;
                    },
                    toString: function (t) {
                      if (!t || "hex" === t || 16 === t) return this.$hex;
                      if ("utf-8" === t) {
                        for (var e = "", r = 0; r < this.$hex.length; r += 2)
                          e += "%" + this.$hex.substring(r, r + 2);
                        return decodeURIComponent(e);
                      }
                      if ("latin" === t) {
                        for (e = [], r = 0; r < this.$hex.length; r += 2)
                          e.push(parseInt(this.$hex.substring(r, r + 2), 16));
                        return String.fromCharCode.apply(String, e);
                      }
                      throw new Error("Unrecognised format: " + t);
                    },
                  }),
                    (e.fromLatinString = function (t) {
                      for (var r = "", n = 0; n < t.length; n++) {
                        var i = t.charCodeAt(n).toString(16);
                        1 === i.length && (i = "0" + i), (r += i);
                      }
                      return new e(r);
                    }),
                    (e.fromUtf8String = function (t) {
                      for (
                        var r = encodeURIComponent(t), n = "", i = 0;
                        i < r.length;
                        i++
                      )
                        if ("%" === r.charAt(i))
                          (n += r.substring(i + 1, i + 3)), (i += 2);
                        else {
                          var o = r.charCodeAt(i).toString(16);
                          o.length < 2 && (o = "0" + o), (n += o);
                        }
                      return new e(n);
                    });
                  var r = [],
                    n = {},
                    i = function (t) {
                      return function () {
                        throw new Error(t + " not implemented");
                      };
                    };
                  function o() {}
                  function a() {}
                  function u(t) {
                    var e = t.readByte();
                    return { type: e >> 5, value: 31 & e };
                  }
                  function c(t, e) {
                    var r = t.value;
                    return r < 24
                      ? r
                      : 24 == r
                        ? e.readByte()
                        : 25 == r
                          ? e.readUint16()
                          : 26 == r
                            ? e.readUint32()
                            : 27 == r
                              ? e.readUint64()
                              : 31 == r
                                ? null
                                : void i("Additional info: " + r)();
                  }
                  function f(t, e, r) {
                    r.writeByte((t << 5) | e);
                  }
                  function h(t, e, r) {
                    var n = t << 5;
                    e < 24
                      ? r.writeByte(n | e)
                      : e < 256
                        ? (r.writeByte(24 | n), r.writeByte(e))
                        : e < 65536
                          ? (r.writeByte(25 | n), r.writeUint16(e))
                          : e < 4294967296
                            ? (r.writeByte(26 | n), r.writeUint32(e))
                            : (r.writeByte(27 | n), r.writeUint64(e));
                  }
                  (o.prototype = {
                    peekByte: i("peekByte"),
                    readByte: i("readByte"),
                    readChunk: i("readChunk"),
                    readFloat16: function () {
                      var t = this.readUint16(),
                        e = (32767 & t) >> 10,
                        r = 1023 & t,
                        n = 32768 & t;
                      if (31 === e) return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 25) * (1024 + r)
                        : Math.pow(2, -24) * r;
                      return n ? -i : i;
                    },
                    readFloat32: function () {
                      var t = this.readUint32(),
                        e = (2147483647 & t) >> 23,
                        r = 8388607 & t,
                        n = 2147483648 & t;
                      if (255 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 23 - 127) * (8388608 + r)
                        : Math.pow(2, -149) * r;
                      return n ? -i : i;
                    },
                    readFloat64: function () {
                      var t = this.readUint32(),
                        e = (t >> 20) & 2047,
                        r = 4294967296 * (1048575 & t) + this.readUint32(),
                        n = 2147483648 & t;
                      if (2047 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 52 - 1023) * (4503599627370496 + r)
                        : Math.pow(2, -1074) * r;
                      return n ? -i : i;
                    },
                    readUint16: function () {
                      return 256 * this.readByte() + this.readByte();
                    },
                    readUint32: function () {
                      return 65536 * this.readUint16() + this.readUint16();
                    },
                    readUint64: function () {
                      return 4294967296 * this.readUint32() + this.readUint32();
                    },
                  }),
                    (a.prototype = {
                      writeByte: i("writeByte"),
                      result: i("result"),
                      writeFloat16: i("writeFloat16"),
                      writeFloat32: i("writeFloat32"),
                      writeFloat64: i("writeFloat64"),
                      writeUint16: function (t) {
                        this.writeByte((t >> 8) & 255), this.writeByte(255 & t);
                      },
                      writeUint32: function (t) {
                        this.writeUint16((t >> 16) & 65535),
                          this.writeUint16(65535 & t);
                      },
                      writeUint64: function (t) {
                        if (t >= 9007199254740992 || t <= -9007199254740992)
                          throw new Error(
                            "Cannot encode Uint64 of: " +
                              t +
                              " magnitude to big (floating point errors)",
                          );
                        this.writeUint32(Math.floor(t / 4294967296)),
                          this.writeUint32(t % 4294967296);
                      },
                      writeString: i("writeString"),
                      canWriteBinary: function (t) {
                        return !1;
                      },
                      writeBinary: i("writeChunk"),
                    });
                  var l = new Error();
                  function d(t) {
                    var e = u(t);
                    switch (e.type) {
                      case 0:
                        return c(e, t);
                      case 1:
                        return -1 - c(e, t);
                      case 2:
                        return t.readChunk(c(e, t));
                      case 3:
                        return t.readChunk(c(e, t)).toString("utf-8");
                      case 4:
                      case 5:
                        var r = c(e, t),
                          i = [];
                        if (null !== r) {
                          5 === e.type && (r *= 2);
                          for (var o = 0; o < r; o++) i[o] = d(t);
                        } else for (var s; (s = d(t)) !== l; ) i.push(s);
                        if (5 === e.type) {
                          var a = {};
                          for (o = 0; o < i.length; o += 2) a[i[o]] = i[o + 1];
                          return a;
                        }
                        return i;
                      case 6:
                        var f = c(e, t),
                          h = n[f];
                        return (i = d(t)), h ? h(i) : i;
                      case 7:
                        if (25 === e.value) return t.readFloat16();
                        if (26 === e.value) return t.readFloat32();
                        if (27 === e.value) return t.readFloat64();
                        switch (c(e, t)) {
                          case 20:
                            return !1;
                          case 21:
                            return !0;
                          case 22:
                            return null;
                          case 23:
                            return;
                          case null:
                            return l;
                          default:
                            throw new Error("Unknown fixed value: " + e.value);
                        }
                      default:
                        throw new Error(
                          "Unsupported header: " + JSON.stringify(e),
                        );
                    }
                    throw new Error("not implemented yet");
                  }
                  function p(t, e) {
                    for (var n = 0; n < r.length; n++) {
                      var i = r[n].fn(t);
                      if (void 0 !== i) return h(6, r[n].tag, e), p(i, e);
                    }
                    if (
                      (t && "function" == typeof t.toCBOR && (t = t.toCBOR()),
                      !1 === t)
                    )
                      h(7, 20, e);
                    else if (!0 === t) h(7, 21, e);
                    else if (null === t) h(7, 22, e);
                    else if (void 0 === t) h(7, 23, e);
                    else if ("number" == typeof t)
                      Math.floor(t) === t &&
                      t < 9007199254740992 &&
                      t > -9007199254740992
                        ? t < 0
                          ? h(1, -1 - t, e)
                          : h(0, t, e)
                        : (f(7, 27, e), e.writeFloat64(t));
                    else if ("string" == typeof t)
                      e.writeString(t, function (t) {
                        h(3, t, e);
                      });
                    else if (e.canWriteBinary(t))
                      e.writeBinary(t, function (t) {
                        h(2, t, e);
                      });
                    else {
                      if ("object" != typeof t)
                        throw new Error("CBOR encoding not supported: " + t);
                      if (
                        (m.config.useToJSON &&
                          "function" == typeof t.toJSON &&
                          (t = t.toJSON()),
                        Array.isArray(t))
                      )
                        for (h(4, t.length, e), n = 0; n < t.length; n++)
                          p(t[n], e);
                      else {
                        var o = Object.keys(t);
                        for (h(5, o.length, e), n = 0; n < o.length; n++) {
                          const r = parseInt(o[n]);
                          isNaN(r)
                            ? (p(o[n], e), p(t[o[n]], e))
                            : (p(r, e), p(t[o[n]], e));
                        }
                      }
                    }
                  }
                  var y = [],
                    g = [],
                    m = {
                      config: { useToJSON: !0 },
                      addWriter: function (t, e) {
                        "string" == typeof t
                          ? g.push(function (r) {
                              if (t === r) return e(r);
                            })
                          : g.push(t);
                      },
                      addReader: function (t, e) {
                        "string" == typeof t
                          ? y.push(function (r, n) {
                              if (t === n) return e(r, n);
                            })
                          : y.push(t);
                      },
                      encode: function (t, e) {
                        for (var r = 0; r < g.length; r++) {
                          var n = (0, g[r])(e);
                          if (n) return p(t, n), n.result();
                        }
                        throw new Error("Unsupported output format: " + e);
                      },
                      encodeDataItem: function (t, e) {
                        for (var r = 0; r < g.length; r++) {
                          var n = (0, g[r])(e);
                          if (n)
                            return void 0 !== t.getTag()
                              ? (p(t, n), n.result())
                              : (p(t.getData(), n), n.result());
                        }
                        throw new Error("Unsupported output format: " + e);
                      },
                      decode: function (t, e) {
                        for (var r = 0; r < y.length; r++) {
                          var n = (0, y[r])(t, e);
                          if (n) return d(n);
                        }
                        throw new Error("Unsupported input format: " + e);
                      },
                      decodeToDataItem: function (e, r) {
                        for (var n = 0; n < y.length; n++) {
                          var i = (0, y[n])(e, r);
                          if (i) {
                            const e = d(i);
                            return e instanceof t ? e : new t(e);
                          }
                        }
                        throw new Error("Unsupported input format: " + r);
                      },
                      addSemanticEncode: function (t, e) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return r.push({ tag: t, fn: e }), this;
                      },
                      addSemanticDecode: function (t, e) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return (n[t] = e), this;
                      },
                    };
                  function b(t) {
                    (this.buffer = t), (this.pos = 0);
                  }
                  function w(t) {
                    (this.byteLength = 0),
                      (this.defaultBufferLength = 16384),
                      (this.latestBuffer = s.alloc(this.defaultBufferLength)),
                      (this.latestBufferOffset = 0),
                      (this.completeBuffers = []),
                      (this.stringFormat = t);
                  }
                  function v(t) {
                    (this.hex = t), (this.pos = 0);
                  }
                  function _(t) {
                    (this.$hex = ""), (this.finalFormat = t || "hex");
                  }
                  return (
                    (b.prototype = Object.create(o.prototype)),
                    (b.prototype.peekByte = function () {
                      return this.buffer[this.pos];
                    }),
                    (b.prototype.readByte = function () {
                      return this.buffer[this.pos++];
                    }),
                    (b.prototype.readUint16 = function () {
                      var t = this.buffer.readUInt16BE(this.pos);
                      return (this.pos += 2), t;
                    }),
                    (b.prototype.readUint32 = function () {
                      var t = this.buffer.readUInt32BE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (b.prototype.readFloat32 = function () {
                      var t = this.buffer.readFloatBE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (b.prototype.readFloat64 = function () {
                      var t = this.buffer.readDoubleBE(this.pos);
                      return (this.pos += 8), t;
                    }),
                    (b.prototype.readChunk = function (t) {
                      var e = s.alloc(t);
                      return (
                        this.buffer.copy(e, 0, this.pos, (this.pos += t)), e
                      );
                    }),
                    (w.prototype = Object.create(a.prototype)),
                    (w.prototype.writeByte = function (t) {
                      (this.latestBuffer[this.latestBufferOffset++] = t),
                        this.latestBufferOffset >= this.latestBuffer.length &&
                          (this.completeBuffers.push(this.latestBuffer),
                          (this.latestBuffer = s.alloc(
                            this.defaultBufferLength,
                          )),
                          (this.latestBufferOffset = 0)),
                        this.byteLength++;
                    }),
                    (w.prototype.writeFloat32 = function (t) {
                      var e = s.alloc(4);
                      e.writeFloatBE(t, 0), this.writeBuffer(e);
                    }),
                    (w.prototype.writeFloat64 = function (t) {
                      var e = s.alloc(8);
                      e.writeDoubleBE(t, 0), this.writeBuffer(e);
                    }),
                    (w.prototype.writeString = function (t, e) {
                      var r = s.from(t, "utf-8");
                      e(r.length), this.writeBuffer(r);
                    }),
                    (w.prototype.canWriteBinary = function (t) {
                      return t instanceof s;
                    }),
                    (w.prototype.writeBinary = function (t, e) {
                      e(t.length), this.writeBuffer(t);
                    }),
                    (w.prototype.writeBuffer = function (t) {
                      if (!(t instanceof s))
                        throw new TypeError(
                          "BufferWriter only accepts Buffers",
                        );
                      this.latestBufferOffset
                        ? this.latestBuffer.length - this.latestBufferOffset >=
                          t.length
                          ? (t.copy(this.latestBuffer, this.latestBufferOffset),
                            (this.latestBufferOffset += t.length),
                            this.latestBufferOffset >=
                              this.latestBuffer.length &&
                              (this.completeBuffers.push(this.latestBuffer),
                              (this.latestBuffer = s.alloc(
                                this.defaultBufferLength,
                              )),
                              (this.latestBufferOffset = 0)))
                          : (this.completeBuffers.push(
                              this.latestBuffer.slice(
                                0,
                                this.latestBufferOffset,
                              ),
                            ),
                            this.completeBuffers.push(t),
                            (this.latestBuffer = s.alloc(
                              this.defaultBufferLength,
                            )),
                            (this.latestBufferOffset = 0))
                        : this.completeBuffers.push(t),
                        (this.byteLength += t.length);
                    }),
                    (w.prototype.result = function () {
                      for (
                        var t = s.alloc(this.byteLength), e = 0, r = 0;
                        r < this.completeBuffers.length;
                        r++
                      ) {
                        var n = this.completeBuffers[r];
                        n.copy(t, e, 0, n.length), (e += n.length);
                      }
                      return (
                        this.latestBufferOffset &&
                          this.latestBuffer.copy(
                            t,
                            e,
                            0,
                            this.latestBufferOffset,
                          ),
                        this.stringFormat ? t.toString(this.stringFormat) : t
                      );
                    }),
                    "function" == typeof s &&
                      (m.addReader(function (t, e) {
                        return s.isBuffer(t)
                          ? new b(t)
                          : "hex" === e || "base64" === e
                            ? new b(s.from(t, e))
                            : void 0;
                      }),
                      m.addWriter(function (t) {
                        return t && "buffer" !== t
                          ? "hex" === t || "base64" === t
                            ? new w(t)
                            : void 0
                          : new w();
                      })),
                    (v.prototype = Object.create(o.prototype)),
                    (v.prototype.peekByte = function () {
                      var t = this.hex.substring(this.pos, 2);
                      return parseInt(t, 16);
                    }),
                    (v.prototype.readByte = function () {
                      var t = this.hex.substring(this.pos, this.pos + 2);
                      return (this.pos += 2), parseInt(t, 16);
                    }),
                    (v.prototype.readChunk = function (t) {
                      var r = this.hex.substring(this.pos, this.pos + 2 * t);
                      return (
                        (this.pos += 2 * t),
                        "function" == typeof s ? s.from(r, "hex") : new e(r)
                      );
                    }),
                    (_.prototype = Object.create(a.prototype)),
                    (_.prototype.writeByte = function (t) {
                      if (t < 0 || t > 255)
                        throw new Error("Byte value out of range: " + t);
                      var e = t.toString(16);
                      1 == e.length && (e = "0" + e), (this.$hex += e);
                    }),
                    (_.prototype.canWriteBinary = function (t) {
                      return (
                        t instanceof e ||
                        ("function" == typeof s && t instanceof s)
                      );
                    }),
                    (_.prototype.writeBinary = function (t, r) {
                      if (t instanceof e) r(t.length()), (this.$hex += t.$hex);
                      else {
                        if (!("function" == typeof s && t instanceof s))
                          throw new TypeError(
                            "HexWriter only accepts BinaryHex or Buffers",
                          );
                        r(t.length), (this.$hex += t.toString("hex"));
                      }
                    }),
                    (_.prototype.result = function () {
                      return "buffer" === this.finalFormat &&
                        "function" == typeof s
                        ? s.from(this.$hex, "hex")
                        : new e(this.$hex).toString(this.finalFormat);
                    }),
                    (_.prototype.writeString = function (t, r) {
                      var n = e.fromUtf8String(t);
                      r(n.length()), (this.$hex += n.$hex);
                    }),
                    m.addReader(function (t, r) {
                      return t instanceof e || t.$hex
                        ? new v(t.$hex)
                        : "hex" === r
                          ? new v(t)
                          : void 0;
                    }),
                    m.addWriter(function (t) {
                      if ("hex" === t) return new _();
                    }),
                    m
                  );
                })();
                return (
                  e
                    .addSemanticEncode(0, function (t) {
                      if (t instanceof Date) return t.toISOString();
                    })
                    .addSemanticDecode(0, function (t) {
                      return new Date(t);
                    })
                    .addSemanticDecode(1, function (t) {
                      return new Date(t);
                    }),
                  e
                );
              })
                ? n.apply(e, i)
                : n) || (t.exports = o);
      },
      20916: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DataItem =
            e.addWriter =
            e.addReader =
            e.addSemanticEncode =
            e.addSemanticDecode =
            e.decodeToDataItem =
            e.encodeDataItem =
              void 0);
        var n = r(25972);
        Object.defineProperty(e, "encodeDataItem", {
          enumerable: !0,
          get: function () {
            return n.encodeDataItem;
          },
        }),
          Object.defineProperty(e, "decodeToDataItem", {
            enumerable: !0,
            get: function () {
              return n.decodeToDataItem;
            },
          }),
          Object.defineProperty(e, "addSemanticDecode", {
            enumerable: !0,
            get: function () {
              return n.addSemanticDecode;
            },
          }),
          Object.defineProperty(e, "addSemanticEncode", {
            enumerable: !0,
            get: function () {
              return n.addSemanticEncode;
            },
          }),
          Object.defineProperty(e, "addReader", {
            enumerable: !0,
            get: function () {
              return n.addReader;
            },
          }),
          Object.defineProperty(e, "addWriter", {
            enumerable: !0,
            get: function () {
              return n.addWriter;
            },
          });
        var i = r(38501);
        Object.defineProperty(e, "DataItem", {
          enumerable: !0,
          get: function () {
            return i.DataItem;
          },
        });
      },
      33922: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const n = r(20193),
          i = r(36345),
          o = r(98599),
          s = Object.values(i.RegistryTypes)
            .filter((t) => !!t.getTag())
            .map((t) => t.getTag()),
          a = Object.values(o.ScriptExpressions).map((t) => t.getTag());
        (0, n.patchTags)(s.concat(a));
      },
      75357: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
      },
      20193: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.patchTags = void 0);
        const n = r(20916),
          i = [];
        e.patchTags = (t) => {
          t.forEach((t) => {
            i.find((e) => e === t) ||
              ((0, n.addSemanticEncode)(t, (e) => {
                if (e instanceof n.DataItem && e.getTag() === t)
                  return e.getData();
              }),
              (0, n.addSemanticDecode)(t, (e) => new n.DataItem(e, t)),
              i.push(t));
          });
        };
      },
      52752: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Bytes = void 0);
        const n = r(9707),
          i = r(56295),
          o = r(35212);
        class s extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.bytes = t),
              (this.getRegistryType = () => o.RegistryTypes.BYTES),
              (this.getData = () => this.bytes),
              (this.toDataItem = () => new n.DataItem(this.bytes));
          }
        }
        (e.Bytes = s),
          (s.fromDataItem = (t) => {
            const e = t.getData();
            if (!e)
              throw new Error(
                `#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${t}`,
              );
            return new s(e);
          }),
          (s.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return s.fromDataItem(e);
          });
      },
      10463: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoAccount = void 0);
        const i = r(98779),
          o = r(9707),
          s = r(56295),
          a = r(35212);
        var u;
        !(function (t) {
          (t[(t.masterFingerprint = 1)] = "masterFingerprint"),
            (t[(t.outputDescriptors = 2)] = "outputDescriptors");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e) {
            super(),
              (this.masterFingerprint = t),
              (this.outputDescriptors = e),
              (this.getRegistryType = () => a.RegistryTypes.CRYPTO_ACCOUNT),
              (this.getMasterFingerprint = () => this.masterFingerprint),
              (this.getOutputDescriptors = () => this.outputDescriptors),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.masterFingerprint &&
                    (t[u.masterFingerprint] =
                      this.masterFingerprint.readUInt32BE(0)),
                  this.outputDescriptors &&
                    (t[u.outputDescriptors] = this.outputDescriptors.map((t) =>
                      t.toDataItem(),
                    )),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.CryptoAccount = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = n.alloc(4),
              o = e[u.masterFingerprint];
            o && r.writeUInt32BE(o, 0);
            const s = e[u.outputDescriptors].map((t) =>
              i.CryptoOutput.fromDataItem(t),
            );
            return new c(r, s);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      72251: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoCoinInfo = e.Network = e.Type = void 0);
        const n = r(9707),
          i = r(56295),
          o = r(35212);
        var s, a, u;
        !(function (t) {
          (t.type = "1"), (t.network = "2");
        })(s || (s = {})),
          (function (t) {
            t[(t.bitcoin = 0)] = "bitcoin";
          })((a = e.Type || (e.Type = {}))),
          (function (t) {
            (t[(t.mainnet = 0)] = "mainnet"), (t[(t.testnet = 1)] = "testnet");
          })((u = e.Network || (e.Network = {})));
        class c extends i.RegistryItem {
          constructor(t, e) {
            super(),
              (this.type = t),
              (this.network = e),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_COIN_INFO),
              (this.getType = () => this.type || a.bitcoin),
              (this.getNetwork = () => this.network || u.mainnet),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.type && (t[s.type] = this.type),
                  this.network && (t[s.network] = this.network),
                  new n.DataItem(t)
                );
              });
          }
        }
        (e.CryptoCoinInfo = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[s.type],
              n = e[s.network];
            return new c(r, n);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      48379: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoECKey = void 0);
        const n = r(9707),
          i = r(56295),
          o = r(35212);
        var s;
        !(function (t) {
          (t[(t.curve = 1)] = "curve"),
            (t[(t.private = 2)] = "private"),
            (t[(t.data = 3)] = "data");
        })(s || (s = {}));
        class a extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.isECKey = () => !0),
              (this.getCurve = () => this.curve || 0),
              (this.isPrivateKey = () => this.privateKey || !1),
              (this.getData = () => this.data),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_ECKEY),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.curve && (t[s.curve] = this.curve),
                  void 0 !== this.privateKey &&
                    (t[s.private] = this.privateKey),
                  (t[s.data] = this.data),
                  new n.DataItem(t)
                );
              }),
              (this.getOutputDescriptorContent = () =>
                this.data.toString("hex")),
              (this.data = t.data),
              (this.curve = t.curve),
              (this.privateKey = t.privateKey || void 0);
          }
        }
        (e.CryptoECKey = a),
          (a.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[s.curve],
              n = e[s.private],
              i = e[s.data];
            if (!i)
              throw new Error(
                `#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${t}`,
              );
            return new a({ data: i, curve: r, privateKey: n });
          }),
          (a.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return a.fromDataItem(e);
          });
      },
      65035: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoHDKey = void 0);
        const i = r(91889),
          o = r(72251),
          s = r(96636),
          a = r(9707),
          u = r(56295),
          c = r(35212);
        var f;
        !(function (t) {
          (t[(t.is_master = 1)] = "is_master"),
            (t[(t.is_private = 2)] = "is_private"),
            (t[(t.key_data = 3)] = "key_data"),
            (t[(t.chain_code = 4)] = "chain_code"),
            (t[(t.use_info = 5)] = "use_info"),
            (t[(t.origin = 6)] = "origin"),
            (t[(t.children = 7)] = "children"),
            (t[(t.parent_fingerprint = 8)] = "parent_fingerprint"),
            (t[(t.name = 9)] = "name"),
            (t[(t.note = 10)] = "note");
        })(f || (f = {}));
        class h extends u.RegistryItem {
          constructor(t) {
            super(),
              (this.isECKey = () => !1),
              (this.getKey = () => this.key),
              (this.getChainCode = () => this.chainCode),
              (this.isMaster = () => this.master),
              (this.isPrivateKey = () => !!this.privateKey),
              (this.getUseInfo = () => this.useInfo),
              (this.getOrigin = () => this.origin),
              (this.getChildren = () => this.children),
              (this.getParentFingerprint = () => this.parentFingerprint),
              (this.getName = () => this.name),
              (this.getNote = () => this.note),
              (this.getBip32Key = () => {
                var t, e, r;
                let o,
                  s,
                  a = 0,
                  u = n.alloc(4).fill(0);
                if (this.isMaster())
                  (o = n.from("0488ADE4", "hex")), (s = 0), (a = 0);
                else {
                  s =
                    (null === (t = this.getOrigin()) || void 0 === t
                      ? void 0
                      : t.getComponents().length) ||
                    (null === (e = this.getOrigin()) || void 0 === e
                      ? void 0
                      : e.getDepth());
                  const i =
                      null === (r = this.getOrigin()) || void 0 === r
                        ? void 0
                        : r.getComponents(),
                    c = i[i.length - 1];
                  c &&
                    ((a = c.isHardened()
                      ? c.getIndex() + 2147483648
                      : c.getIndex()),
                    this.getParentFingerprint() &&
                      (u = this.getParentFingerprint())),
                    (o = this.isPrivateKey()
                      ? n.from("0488ADE4", "hex")
                      : n.from("0488B21E", "hex"));
                }
                const c = n.alloc(1);
                c.writeUInt8(s, 0);
                const f = n.alloc(4);
                f.writeUInt32BE(a, 0);
                const h = this.getChainCode(),
                  l = this.getKey();
                return (0, i.encode)(n.concat([o, c, u, f, h, l]));
              }),
              (this.getRegistryType = () => c.RegistryTypes.CRYPTO_HDKEY),
              (this.getOutputDescriptorContent = () => {
                var t, e, r, n, i, o, s;
                let a = "";
                return (
                  this.getOrigin() &&
                    (null === (t = this.getOrigin()) || void 0 === t
                      ? void 0
                      : t.getSourceFingerprint()) &&
                    (null === (e = this.getOrigin()) || void 0 === e
                      ? void 0
                      : e.getPath()) &&
                    (a += `${null === (n = null === (r = this.getOrigin()) || void 0 === r ? void 0 : r.getSourceFingerprint()) || void 0 === n ? void 0 : n.toString("hex")}/${null === (i = this.getOrigin()) || void 0 === i ? void 0 : i.getPath()}`),
                  (a += this.getBip32Key()),
                  this.getChildren() &&
                    (null === (o = this.getChildren()) || void 0 === o
                      ? void 0
                      : o.getPath()) &&
                    (a += `/${null === (s = this.getChildren()) || void 0 === s ? void 0 : s.getPath()}`),
                  a
                );
              }),
              (this.setupMasterKey = (t) => {
                (this.master = !0),
                  (this.key = t.key),
                  (this.chainCode = t.chainCode);
              }),
              (this.setupDeriveKey = (t) => {
                (this.master = !1),
                  (this.privateKey = t.isPrivateKey),
                  (this.key = t.key),
                  (this.chainCode = t.chainCode),
                  (this.useInfo = t.useInfo),
                  (this.origin = t.origin),
                  (this.children = t.children),
                  (this.parentFingerprint = t.parentFingerprint),
                  (this.name = t.name),
                  (this.note = t.note);
              }),
              (this.toDataItem = () => {
                const t = {};
                if (this.master)
                  (t[f.is_master] = !0),
                    (t[f.key_data] = this.key),
                    (t[f.chain_code] = this.chainCode);
                else {
                  if (
                    (void 0 !== this.privateKey &&
                      (t[f.is_private] = this.privateKey),
                    (t[f.key_data] = this.key),
                    this.chainCode && (t[f.chain_code] = this.chainCode),
                    this.useInfo)
                  ) {
                    const e = this.useInfo.toDataItem();
                    e.setTag(this.useInfo.getRegistryType().getTag()),
                      (t[f.use_info] = e);
                  }
                  if (this.origin) {
                    const e = this.origin.toDataItem();
                    e.setTag(this.origin.getRegistryType().getTag()),
                      (t[f.origin] = e);
                  }
                  if (this.children) {
                    const e = this.children.toDataItem();
                    e.setTag(this.children.getRegistryType().getTag()),
                      (t[f.children] = e);
                  }
                  this.parentFingerprint &&
                    (t[f.parent_fingerprint] =
                      this.parentFingerprint.readUInt32BE(0)),
                    void 0 !== this.name && (t[f.name] = this.name),
                    void 0 !== this.note && (t[f.note] = this.note);
                }
                return new a.DataItem(t);
              }),
              t.isMaster ? this.setupMasterKey(t) : this.setupDeriveKey(t);
          }
        }
        (e.CryptoHDKey = h),
          (h.fromDataItem = (t) => {
            const e = t.getData(),
              r = !!e[f.is_master],
              i = e[f.is_private],
              a = e[f.key_data],
              u = e[f.chain_code],
              c = e[f.use_info]
                ? o.CryptoCoinInfo.fromDataItem(e[f.use_info])
                : void 0,
              l = e[f.origin]
                ? s.CryptoKeypath.fromDataItem(e[f.origin])
                : void 0,
              d = e[f.children]
                ? s.CryptoKeypath.fromDataItem(e[f.children])
                : void 0,
              p = e[f.parent_fingerprint];
            let y;
            p && ((y = n.alloc(4)), y.writeUInt32BE(p, 0));
            const g = e[f.name],
              m = e[f.note];
            return new h({
              isMaster: r,
              isPrivateKey: i,
              key: a,
              chainCode: u,
              useInfo: c,
              origin: l,
              children: d,
              parentFingerprint: y,
              name: g,
              note: m,
            });
          }),
          (h.fromCBOR = (t) => {
            const e = (0, a.decodeToDataItem)(t);
            return h.fromDataItem(e);
          });
      },
      96636: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoKeypath = void 0);
        const i = r(9707),
          o = r(43013),
          s = r(56295),
          a = r(35212);
        var u;
        !(function (t) {
          (t[(t.components = 1)] = "components"),
            (t[(t.source_fingerprint = 2)] = "source_fingerprint"),
            (t[(t.depth = 3)] = "depth");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t = [], e, r) {
            super(),
              (this.components = t),
              (this.sourceFingerprint = e),
              (this.depth = r),
              (this.getRegistryType = () => a.RegistryTypes.CRYPTO_KEYPATH),
              (this.getPath = () => {
                if (0 === this.components.length) return;
                return this.components
                  .map(
                    (t) =>
                      `${t.isWildcard() ? "*" : t.getIndex()}${t.isHardened() ? "'" : ""}`,
                  )
                  .join("/");
              }),
              (this.getComponents = () => this.components),
              (this.getSourceFingerprint = () => this.sourceFingerprint),
              (this.getDepth = () => this.depth),
              (this.toDataItem = () => {
                const t = {},
                  e = [];
                return (
                  this.components &&
                    this.components.forEach((t) => {
                      t.isWildcard() ? e.push([]) : e.push(t.getIndex()),
                        e.push(t.isHardened());
                    }),
                  (t[u.components] = e),
                  this.sourceFingerprint &&
                    (t[u.source_fingerprint] =
                      this.sourceFingerprint.readUInt32BE(0)),
                  void 0 !== this.depth && (t[u.depth] = this.depth),
                  new i.DataItem(t)
                );
              });
          }
        }
        (e.CryptoKeypath = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = [],
              i = e[u.components];
            if (i)
              for (let t = 0; t < i.length; t += 2) {
                const e = i[t + 1],
                  n = i[t];
                "number" == typeof n
                  ? r.push(new o.PathComponent({ index: n, hardened: e }))
                  : r.push(new o.PathComponent({ hardened: e }));
              }
            const s = e[u.source_fingerprint];
            let a;
            s && ((a = n.alloc(4)), a.writeUInt32BE(s, 0));
            const f = e[u.depth];
            return new c(r, a, f);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, i.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      37735: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoOutput = void 0);
        const n = r(48379),
          i = r(65035),
          o = r(9707),
          s = r(71123),
          a = r(56295),
          u = r(35212),
          c = r(21702);
        class f extends a.RegistryItem {
          constructor(t, e) {
            super(),
              (this.scriptExpressions = t),
              (this.cryptoKey = e),
              (this.getRegistryType = () => u.RegistryTypes.CRYPTO_OUTPUT),
              (this.getCryptoKey = () => this.cryptoKey),
              (this.getHDKey = () =>
                this.cryptoKey instanceof i.CryptoHDKey
                  ? this.cryptoKey
                  : void 0),
              (this.getECKey = () =>
                this.cryptoKey instanceof n.CryptoECKey
                  ? this.cryptoKey
                  : void 0),
              (this.getMultiKey = () =>
                this.cryptoKey instanceof s.MultiKey ? this.cryptoKey : void 0),
              (this.getScriptExpressions = () => this.scriptExpressions),
              (this._toOutputDescriptor = (t) =>
                t >= this.scriptExpressions.length
                  ? this.cryptoKey.getOutputDescriptorContent()
                  : `${this.scriptExpressions[t].getExpression()}(${this._toOutputDescriptor(t + 1)})`),
              (this.toString = () => this._toOutputDescriptor(0)),
              (this.toDataItem = () => {
                let t = this.cryptoKey.toDataItem();
                (this.cryptoKey instanceof n.CryptoECKey ||
                  this.cryptoKey instanceof i.CryptoHDKey) &&
                  t.setTag(this.cryptoKey.getRegistryType().getTag());
                return (
                  [...this.scriptExpressions].reverse().forEach((e) => {
                    const r = e.getTag();
                    void 0 === t.getTag()
                      ? t.setTag(r)
                      : (t = new o.DataItem(t, r));
                  }),
                  t
                );
              });
          }
        }
        (e.CryptoOutput = f),
          (f.fromDataItem = (t) => {
            const e = [];
            let r = t;
            for (;;) {
              let t = r.getTag();
              const n = c.ScriptExpression.fromTag(t);
              if (!n) break;
              if ((e.push(n), !(r.getData() instanceof o.DataItem))) break;
              (r = r.getData()), (t = r.getTag());
            }
            const a = e.length;
            if (
              a > 0 &&
              (e[a - 1].getExpression() ===
                c.ScriptExpressions.MULTISIG.getExpression() ||
                e[a - 1].getExpression() ===
                  c.ScriptExpressions.SORTED_MULTISIG.getExpression())
            ) {
              const t = s.MultiKey.fromDataItem(r);
              return new f(e, t);
            }
            if (r.getTag() === u.RegistryTypes.CRYPTO_HDKEY.getTag()) {
              const t = i.CryptoHDKey.fromDataItem(r);
              return new f(e, t);
            }
            {
              const t = n.CryptoECKey.fromDataItem(r);
              return new f(e, t);
            }
          }),
          (f.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return f.fromDataItem(e);
          });
      },
      31425: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoPSBT = void 0);
        const n = r(9707),
          i = r(56295),
          o = r(35212);
        class s extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.psbt = t),
              (this.getRegistryType = () => o.RegistryTypes.CRYPTO_PSBT),
              (this.getPSBT = () => this.psbt),
              (this.toDataItem = () => new n.DataItem(this.psbt));
          }
        }
        (e.CryptoPSBT = s),
          (s.fromDataItem = (t) => {
            const e = t.getData();
            if (!e)
              throw new Error(
                `#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${t}`,
              );
            return new s(e);
          }),
          (s.fromCBOR = (t) => {
            const e = (0, n.decodeToDataItem)(t);
            return s.fromDataItem(e);
          });
      },
      12096: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.URRegistryDecoder = void 0);
        const n = r(17539),
          i = r(98779),
          o = r(35212),
          s = r(68523);
        class a extends n.URDecoder {
          constructor() {
            super(...arguments),
              (this.resultRegistryType = () => {
                const t = this.resultUR();
                switch (t.type) {
                  case o.RegistryTypes.BYTES.getType():
                    return i.Bytes.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_HDKEY.getType():
                    return i.CryptoHDKey.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return i.CryptoKeypath.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return i.CryptoCoinInfo.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_ECKEY.getType():
                    return i.CryptoECKey.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return i.CryptoOutput.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_PSBT.getType():
                    return i.CryptoPSBT.fromCBOR(t.cbor);
                  case o.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return i.CryptoAccount.fromCBOR(t.cbor);
                  default:
                    throw new s.UnknownURTypeError(
                      `#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${t.type} is not supported now`,
                    );
                }
              });
          }
        }
        e.URRegistryDecoder = a;
      },
      71123: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.MultiKey = void 0);
        const n = r(48379),
          i = r(65035),
          o = r(3124),
          s = r(56295),
          a = r(35212);
        var u;
        !(function (t) {
          (t[(t.threshold = 1)] = "threshold"), (t[(t.keys = 2)] = "keys");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e) {
            super(),
              (this.threshold = t),
              (this.keys = e),
              (this.getThreshold = () => this.threshold),
              (this.getKeys = () => this.keys),
              (this.toDataItem = () => {
                const t = {};
                t[u.threshold] = this.threshold;
                const e = this.keys.map((t) => {
                  const e = t.toDataItem();
                  return e.setTag(t.getRegistryType().getTag()), e;
                });
                return (t[u.keys] = e), new o.DataItem(t);
              }),
              (this.getOutputDescriptorContent = () =>
                [
                  this.getThreshold(),
                  this.keys
                    .map((t) => t.getOutputDescriptorContent())
                    .join(","),
                ].join(","));
          }
        }
        (e.MultiKey = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[u.threshold],
              o = e[u.keys],
              s = [];
            return (
              o.forEach((t) => {
                t.getTag() === a.RegistryTypes.CRYPTO_HDKEY.getTag()
                  ? s.push(i.CryptoHDKey.fromDataItem(t))
                  : t.getTag() === a.RegistryTypes.CRYPTO_ECKEY.getTag() &&
                    s.push(n.CryptoECKey.fromDataItem(t));
              }),
              new c(r, s)
            );
          });
      },
      43013: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.PathComponent = void 0);
        class r {
          constructor(t) {
            if (
              ((this.getIndex = () => this.index),
              (this.isWildcard = () => this.wildcard),
              (this.isHardened = () => this.hardened),
              (this.index = t.index),
              (this.hardened = t.hardened),
              void 0 !== this.index
                ? (this.wildcard = !1)
                : (this.wildcard = !0),
              this.index && this.index & r.HARDENED_BIT)
            )
              throw new Error(
                `#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`,
              );
          }
        }
        (e.PathComponent = r), (r.HARDENED_BIT = 2147483648);
      },
      56295: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.RegistryItem = void 0);
        const n = r(17539),
          i = r(9707);
        e.RegistryItem = class {
          constructor() {
            (this.toCBOR = () => {
              if (void 0 === this.toDataItem())
                throw new Error(
                  `#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`,
                );
              return (0, i.encodeDataItem)(this.toDataItem());
            }),
              (this.toUR = () =>
                new n.UR(this.toCBOR(), this.getRegistryType().getType())),
              (this.toUREncoder = (t, e, r) => {
                const i = this.toUR();
                return new n.UREncoder(i, t, e, r);
              });
          }
        };
      },
      35212: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.RegistryTypes = e.RegistryType = void 0);
        class r {
          constructor(t, e) {
            (this.type = t),
              (this.tag = e),
              (this.getTag = () => this.tag),
              (this.getType = () => this.type);
          }
        }
        (e.RegistryType = r),
          (e.RegistryTypes = {
            UUID: new r("uuid", 37),
            BYTES: new r("bytes", void 0),
            CRYPTO_HDKEY: new r("crypto-hdkey", 303),
            CRYPTO_KEYPATH: new r("crypto-keypath", 304),
            CRYPTO_COIN_INFO: new r("crypto-coin-info", 305),
            CRYPTO_ECKEY: new r("crypto-eckey", 306),
            CRYPTO_OUTPUT: new r("crypto-output", 308),
            CRYPTO_PSBT: new r("crypto-psbt", 310),
            CRYPTO_ACCOUNT: new r("crypto-account", 311),
            CRYPTO_MULTI_ACCOUNTS: new r("crypto-multi-accounts", 1103),
            QR_HARDWARE_CALL: new r("qr-hardware-call", 1201),
            KEY_DERIVATION_CALL: new r("key-derivation-call", 1301),
            KEY_DERIVATION_SCHEMA: new r("key-derivation-schema", 1302),
          });
      },
      21702: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ScriptExpressions = e.ScriptExpression = void 0);
        class r {
          constructor(t, e) {
            (this.tag = t),
              (this.expression = e),
              (this.getTag = () => this.tag),
              (this.getExpression = () => this.expression);
          }
        }
        (e.ScriptExpression = r),
          (r.fromTag = (t) =>
            Object.values(e.ScriptExpressions).find((e) => e.getTag() === t)),
          (e.ScriptExpressions = {
            SCRIPT_HASH: new r(400, "sh"),
            WITNESS_SCRIPT_HASH: new r(401, "wsh"),
            PUBLIC_KEY: new r(402, "pk"),
            PUBLIC_KEY_HASH: new r(403, "pkh"),
            WITNESS_PUBLIC_KEY_HASH: new r(404, "wpkh"),
            COMBO: new r(405, "combo"),
            MULTISIG: new r(406, "multi"),
            SORTED_MULTISIG: new r(407, "sortedmulti"),
            ADDRESS: new r(307, "addr"),
            RAW_SCRIPT: new r(408, "raw"),
          });
      },
      68523: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.UnknownURTypeError = void 0);
        class r extends Error {
          constructor(t) {
            super(t);
          }
        }
        e.UnknownURTypeError = r;
      },
      85731: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.CryptoMultiAccounts = void 0);
        const i = r(35212),
          o = r(65035),
          s = r(56295),
          a = r(9707);
        var u;
        !(function (t) {
          (t[(t.masterFingerprint = 1)] = "masterFingerprint"),
            (t[(t.keys = 2)] = "keys"),
            (t[(t.device = 3)] = "device"),
            (t[(t.deviceId = 4)] = "deviceId"),
            (t[(t.version = 5)] = "version");
        })(u || (u = {}));
        class c extends s.RegistryItem {
          constructor(t, e, r, n, o) {
            super(),
              (this.masterFingerprint = t),
              (this.keys = e),
              (this.device = r),
              (this.deviceId = n),
              (this.version = o),
              (this.getRegistryType = () =>
                i.RegistryTypes.CRYPTO_MULTI_ACCOUNTS),
              (this.getMasterFingerprint = () => this.masterFingerprint),
              (this.getKeys = () => this.keys),
              (this.getDevice = () => this.device),
              (this.getDeviceId = () => this.deviceId),
              (this.getVersion = () => this.version),
              (this.toDataItem = () => {
                const t = {};
                return (
                  this.masterFingerprint &&
                    (t[u.masterFingerprint] =
                      this.masterFingerprint.readUInt32BE(0)),
                  this.keys &&
                    (t[u.keys] = this.keys.map((t) => {
                      const e = t.toDataItem();
                      return e.setTag(t.getRegistryType().getTag()), e;
                    })),
                  this.device && (t[u.device] = this.device),
                  this.deviceId && (t[u.deviceId] = this.deviceId),
                  this.version && (t[u.version] = this.version),
                  new a.DataItem(t)
                );
              });
          }
        }
        (e.CryptoMultiAccounts = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = n.alloc(4),
              i = e[u.masterFingerprint];
            i && r.writeUInt32BE(i, 0);
            const s = e[u.keys].map((t) => o.CryptoHDKey.fromDataItem(t)),
              a = e[u.device],
              f = e[u.deviceId],
              h = e[u.version];
            return new c(r, s, a, f, h);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, a.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      98335: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.KeyDerivationSchema = e.DerivationAlgorithm = e.Curve = void 0);
        const n = r(35212),
          i = r(56295),
          o = r(9707),
          s = r(96636);
        var a, u, c;
        !(function (t) {
          (t[(t.keyPath = 1)] = "keyPath"),
            (t[(t.curve = 2)] = "curve"),
            (t[(t.algo = 3)] = "algo"),
            (t[(t.chainType = 4)] = "chainType");
        })(a || (a = {})),
          (function (t) {
            (t[(t.secp256k1 = 0)] = "secp256k1"),
              (t[(t.ed25519 = 1)] = "ed25519");
          })((u = e.Curve || (e.Curve = {}))),
          (function (t) {
            (t[(t.slip10 = 0)] = "slip10"),
              (t[(t.bip32ed25519 = 1)] = "bip32ed25519");
          })((c = e.DerivationAlgorithm || (e.DerivationAlgorithm = {})));
        class f extends i.RegistryItem {
          constructor(t, e = u.secp256k1, r = c.slip10, i) {
            super(),
              (this.keypath = t),
              (this.curve = e),
              (this.algo = r),
              (this.chainType = i),
              (this.getRegistryType = () =>
                n.RegistryTypes.KEY_DERIVATION_SCHEMA),
              (this.getKeypath = () => this.keypath),
              (this.getCurve = () => this.curve),
              (this.getAlgo = () => this.algo),
              (this.getChainType = () => this.chainType),
              (this.toDataItem = () => {
                const t = {},
                  e = this.getKeypath().toDataItem();
                return (
                  e.setTag(this.getKeypath().getRegistryType().getTag()),
                  (t[a.keyPath] = e),
                  (t[a.curve] = this.curve),
                  (t[a.algo] = this.algo),
                  this.chainType && (t[a.chainType] = this.chainType),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.KeyDerivationSchema = f),
          (f.fromDataItem = (t) => {
            const e = t.getData(),
              r = s.CryptoKeypath.fromDataItem(e[a.keyPath]),
              n = e[a.curve],
              i = e[a.algo],
              o = e[a.chainType];
            return new f(r, n, i, o);
          }),
          (f.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return f.fromDataItem(e);
          });
      },
      37015: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.KeyDerivation = void 0);
        const n = r(35212),
          i = r(56295),
          o = r(9707),
          s = r(98335);
        var a;
        !(function (t) {
          t[(t.schemas = 1)] = "schemas";
        })(a || (a = {}));
        class u extends i.RegistryItem {
          constructor(t) {
            super(),
              (this.schemas = t),
              (this.getRegistryType = () =>
                n.RegistryTypes.KEY_DERIVATION_CALL),
              (this.getSchemas = () => this.schemas),
              (this.toDataItem = () => {
                const t = {};
                return (
                  (t[a.schemas] = this.schemas.map((t) => {
                    const e = t.toDataItem();
                    return e.setTag(t.getRegistryType().getTag()), e;
                  })),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.KeyDerivation = u),
          (u.fromDataItem = (t) => {
            const e = t
              .getData()
              [a.schemas].map((t) => s.KeyDerivationSchema.fromDataItem(t));
            return new u(e);
          }),
          (u.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return u.fromDataItem(e);
          });
      },
      2458: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.QRHardwareCall =
            e.QRHardwareCallVersion =
            e.QRHardwareCallType =
              void 0);
        const n = r(35212),
          i = r(56295),
          o = r(9707),
          s = r(37015);
        var a, u;
        !(function (t) {
          (t[(t.type = 1)] = "type"),
            (t[(t.params = 2)] = "params"),
            (t[(t.origin = 3)] = "origin"),
            (t[(t.version = 4)] = "version");
        })(a || (a = {})),
          (function (t) {
            t[(t.KeyDerivation = 0)] = "KeyDerivation";
          })((u = e.QRHardwareCallType || (e.QRHardwareCallType = {}))),
          (function (t) {
            (t[(t.V0 = 0)] = "V0"), (t[(t.V1 = 1)] = "V1");
          })(e.QRHardwareCallVersion || (e.QRHardwareCallVersion = {}));
        class c extends i.RegistryItem {
          constructor(t, e, r, i) {
            super(),
              (this.type = t),
              (this.params = e),
              (this.origin = r),
              (this.version = i),
              (this.getRegistryType = () => n.RegistryTypes.QR_HARDWARE_CALL),
              (this.getType = () => this.type),
              (this.getParams = () => this.params),
              (this.getOrigin = () => this.origin),
              (this.getVersion = () => this.version),
              (this.toDataItem = () => {
                const t = {};
                t[a.type] = this.type;
                const e = this.params.toDataItem();
                return (
                  e.setTag(this.params.getRegistryType().getTag()),
                  (t[a.params] = e),
                  this.origin && (t[a.origin] = this.origin),
                  this.version && (t[a.version] = this.version),
                  new o.DataItem(t)
                );
              });
          }
        }
        (e.QRHardwareCall = c),
          (c.fromDataItem = (t) => {
            const e = t.getData(),
              r = e[a.type] || u.KeyDerivation;
            let n;
            if (r === u.KeyDerivation)
              n = s.KeyDerivation.fromDataItem(e[a.params]);
            const i = e[a.origin],
              o = e[a.version];
            return new c(r, n, i, o);
          }),
          (c.fromCBOR = (t) => {
            const e = (0, o.decodeToDataItem)(t);
            return c.fromDataItem(e);
          });
      },
      98779: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Buffer =
            e.extend =
            e.PathComponent =
            e.ScriptExpressions =
            e.MultiKey =
            e.CryptoPSBT =
            e.CryptoOutput =
            e.CryptoECKey =
            e.CryptoCoinInfoNetwork =
            e.CryptoCoinInfoType =
            e.CryptoCoinInfo =
            e.CryptoKeypath =
            e.CryptoMultiAccounts =
            e.CryptoHDKey =
            e.CryptoAccount =
            e.Bytes =
            e.URRegistryDecoder =
            e.DataItem =
              void 0);
        const n = r(31635);
        r(62097);
        const i = r(48287);
        Object.defineProperty(e, "Buffer", {
          enumerable: !0,
          get: function () {
            return i.Buffer;
          },
        });
        const o = r(65035);
        Object.defineProperty(e, "CryptoHDKey", {
          enumerable: !0,
          get: function () {
            return o.CryptoHDKey;
          },
        });
        const s = r(96636);
        Object.defineProperty(e, "CryptoKeypath", {
          enumerable: !0,
          get: function () {
            return s.CryptoKeypath;
          },
        });
        const a = r(72251);
        Object.defineProperty(e, "CryptoCoinInfo", {
          enumerable: !0,
          get: function () {
            return a.CryptoCoinInfo;
          },
        }),
          Object.defineProperty(e, "CryptoCoinInfoType", {
            enumerable: !0,
            get: function () {
              return a.Type;
            },
          }),
          Object.defineProperty(e, "CryptoCoinInfoNetwork", {
            enumerable: !0,
            get: function () {
              return a.Network;
            },
          });
        const u = r(48379);
        Object.defineProperty(e, "CryptoECKey", {
          enumerable: !0,
          get: function () {
            return u.CryptoECKey;
          },
        });
        const c = r(52752);
        Object.defineProperty(e, "Bytes", {
          enumerable: !0,
          get: function () {
            return c.Bytes;
          },
        });
        const f = r(37735);
        Object.defineProperty(e, "CryptoOutput", {
          enumerable: !0,
          get: function () {
            return f.CryptoOutput;
          },
        });
        const h = r(31425);
        Object.defineProperty(e, "CryptoPSBT", {
          enumerable: !0,
          get: function () {
            return h.CryptoPSBT;
          },
        });
        const l = r(10463);
        Object.defineProperty(e, "CryptoAccount", {
          enumerable: !0,
          get: function () {
            return l.CryptoAccount;
          },
        });
        const d = r(12096);
        Object.defineProperty(e, "URRegistryDecoder", {
          enumerable: !0,
          get: function () {
            return d.URRegistryDecoder;
          },
        });
        const p = r(71123);
        Object.defineProperty(e, "MultiKey", {
          enumerable: !0,
          get: function () {
            return p.MultiKey;
          },
        });
        const y = r(21702);
        Object.defineProperty(e, "ScriptExpressions", {
          enumerable: !0,
          get: function () {
            return y.ScriptExpressions;
          },
        });
        const g = r(43013);
        Object.defineProperty(e, "PathComponent", {
          enumerable: !0,
          get: function () {
            return g.PathComponent;
          },
        });
        const m = r(56295),
          b = r(35212),
          w = r(9707);
        var v = r(9707);
        Object.defineProperty(e, "DataItem", {
          enumerable: !0,
          get: function () {
            return v.DataItem;
          },
        });
        const _ = r(90310),
          E = r(85731);
        Object.defineProperty(e, "CryptoMultiAccounts", {
          enumerable: !0,
          get: function () {
            return E.CryptoMultiAccounts;
          },
        });
        const S = {
            URRegistryDecoder: d.URRegistryDecoder,
            Bytes: c.Bytes,
            CryptoAccount: l.CryptoAccount,
            CryptoHDKey: o.CryptoHDKey,
            CryptoMultiAccounts: E.CryptoMultiAccounts,
            CryptoKeypath: s.CryptoKeypath,
            CryptoCoinInfo: a.CryptoCoinInfo,
            CryptoCoinInfoType: a.Type,
            CryptoCoinInfoNetwork: a.Network,
            CryptoECKey: u.CryptoECKey,
            CryptoOutput: f.CryptoOutput,
            CryptoPSBT: h.CryptoPSBT,
            MultiKey: p.MultiKey,
            ScriptExpressions: y.ScriptExpressions,
            PathComponent: g.PathComponent,
          },
          I = {
            addReader: w.addReader,
            addSemanticDecode: w.addSemanticDecode,
            addSemanticEncode: w.addSemanticEncode,
            addWriter: w.addWriter,
            patchTags: _.patchTags,
          },
          M = {
            RegistryTypes: b.RegistryTypes,
            RegistryItem: m.RegistryItem,
            RegistryType: b.RegistryType,
            decodeToDataItem: w.decodeToDataItem,
            encodeDataItem: w.encodeDataItem,
            cbor: I,
          };
        (e.extend = M),
          (0, n.__exportStar)(r(68523), e),
          (0, n.__exportStar)(r(12096), e),
          (0, n.__exportStar)(r(9707), e),
          (0, n.__exportStar)(r(10463), e),
          (0, n.__exportStar)(r(31425), e),
          (0, n.__exportStar)(r(65035), e),
          (0, n.__exportStar)(r(85731), e),
          (0, n.__exportStar)(r(2458), e),
          (0, n.__exportStar)(r(37015), e),
          (0, n.__exportStar)(r(98335), e),
          (0, n.__exportStar)(r(37735), e),
          (0, n.__exportStar)(r(72251), e),
          (0, n.__exportStar)(r(48379), e),
          (0, n.__exportStar)(r(71123), e),
          (0, n.__exportStar)(r(96636), e),
          (0, n.__exportStar)(r(62097), e),
          (0, n.__exportStar)(r(43013), e),
          (0, n.__exportStar)(r(56295), e),
          (0, n.__exportStar)(r(35212), e),
          (0, n.__exportStar)(r(98010), e),
          (0, n.__exportStar)(r(90310), e),
          (e.default = S);
      },
      3124: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DataItem = void 0);
        e.DataItem = class {
          constructor(t, e) {
            (this.setTag = (t) => {
              this.tag = t;
            }),
              (this.clearTag = () => {
                this.tag = void 0;
              }),
              (this.getTag = () => this.tag),
              (this.getData = () => this.data),
              (this.data = t),
              (this.tag = e);
          }
        };
      },
      93791: function (t, e, r) {
        "use strict";
        var n,
          i,
          o,
          s = r(48287).Buffer;
        (i = []),
          void 0 ===
            (o =
              "function" ==
              typeof (n = function () {
                const { DataItem: t } = r(3124);
                var e = (function () {
                  function e(t) {
                    this.$hex = t;
                  }
                  (e.prototype = {
                    length: function () {
                      return this.$hex.length / 2;
                    },
                    toString: function (t) {
                      if (!t || "hex" === t || 16 === t) return this.$hex;
                      if ("utf-8" === t) {
                        for (var e = "", r = 0; r < this.$hex.length; r += 2)
                          e += "%" + this.$hex.substring(r, r + 2);
                        return decodeURIComponent(e);
                      }
                      if ("latin" === t) {
                        for (e = [], r = 0; r < this.$hex.length; r += 2)
                          e.push(parseInt(this.$hex.substring(r, r + 2), 16));
                        return String.fromCharCode.apply(String, e);
                      }
                      throw new Error("Unrecognised format: " + t);
                    },
                  }),
                    (e.fromLatinString = function (t) {
                      for (var r = "", n = 0; n < t.length; n++) {
                        var i = t.charCodeAt(n).toString(16);
                        1 === i.length && (i = "0" + i), (r += i);
                      }
                      return new e(r);
                    }),
                    (e.fromUtf8String = function (t) {
                      for (
                        var r = encodeURIComponent(t), n = "", i = 0;
                        i < r.length;
                        i++
                      )
                        if ("%" === r.charAt(i))
                          (n += r.substring(i + 1, i + 3)), (i += 2);
                        else {
                          var o = r.charCodeAt(i).toString(16);
                          o.length < 2 && (o = "0" + o), (n += o);
                        }
                      return new e(n);
                    });
                  var r = [],
                    n = {},
                    i = function (t) {
                      return function () {
                        throw new Error(t + " not implemented");
                      };
                    };
                  function o() {}
                  function a() {}
                  function u(t) {
                    var e = t.readByte();
                    return { type: e >> 5, value: 31 & e };
                  }
                  function c(t, e) {
                    var r = t.value;
                    return r < 24
                      ? r
                      : 24 == r
                        ? e.readByte()
                        : 25 == r
                          ? e.readUint16()
                          : 26 == r
                            ? e.readUint32()
                            : 27 == r
                              ? e.readUint64()
                              : 31 == r
                                ? null
                                : void i("Additional info: " + r)();
                  }
                  function f(t, e, r) {
                    r.writeByte((t << 5) | e);
                  }
                  function h(t, e, r) {
                    var n = t << 5;
                    e < 24
                      ? r.writeByte(n | e)
                      : e < 256
                        ? (r.writeByte(24 | n), r.writeByte(e))
                        : e < 65536
                          ? (r.writeByte(25 | n), r.writeUint16(e))
                          : e < 4294967296
                            ? (r.writeByte(26 | n), r.writeUint32(e))
                            : (r.writeByte(27 | n), r.writeUint64(e));
                  }
                  (o.prototype = {
                    peekByte: i("peekByte"),
                    readByte: i("readByte"),
                    readChunk: i("readChunk"),
                    readFloat16: function () {
                      var t = this.readUint16(),
                        e = (32767 & t) >> 10,
                        r = 1023 & t,
                        n = 32768 & t;
                      if (31 === e) return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 25) * (1024 + r)
                        : Math.pow(2, -24) * r;
                      return n ? -i : i;
                    },
                    readFloat32: function () {
                      var t = this.readUint32(),
                        e = (2147483647 & t) >> 23,
                        r = 8388607 & t,
                        n = 2147483648 & t;
                      if (255 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 23 - 127) * (8388608 + r)
                        : Math.pow(2, -149) * r;
                      return n ? -i : i;
                    },
                    readFloat64: function () {
                      var t = this.readUint32(),
                        e = (t >> 20) & 2047,
                        r = 4294967296 * (1048575 & t) + this.readUint32(),
                        n = 2147483648 & t;
                      if (2047 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 52 - 1023) * (4503599627370496 + r)
                        : Math.pow(2, -1074) * r;
                      return n ? -i : i;
                    },
                    readUint16: function () {
                      return 256 * this.readByte() + this.readByte();
                    },
                    readUint32: function () {
                      return 65536 * this.readUint16() + this.readUint16();
                    },
                    readUint64: function () {
                      return 4294967296 * this.readUint32() + this.readUint32();
                    },
                  }),
                    (a.prototype = {
                      writeByte: i("writeByte"),
                      result: i("result"),
                      writeFloat16: i("writeFloat16"),
                      writeFloat32: i("writeFloat32"),
                      writeFloat64: i("writeFloat64"),
                      writeUint16: function (t) {
                        this.writeByte((t >> 8) & 255), this.writeByte(255 & t);
                      },
                      writeUint32: function (t) {
                        this.writeUint16((t >> 16) & 65535),
                          this.writeUint16(65535 & t);
                      },
                      writeUint64: function (t) {
                        if (t >= 9007199254740992 || t <= -9007199254740992)
                          throw new Error(
                            "Cannot encode Uint64 of: " +
                              t +
                              " magnitude to big (floating point errors)",
                          );
                        this.writeUint32(Math.floor(t / 4294967296)),
                          this.writeUint32(t % 4294967296);
                      },
                      writeString: i("writeString"),
                      canWriteBinary: function (t) {
                        return !1;
                      },
                      writeBinary: i("writeChunk"),
                    });
                  var l = new Error();
                  function d(t) {
                    var e = u(t);
                    switch (e.type) {
                      case 0:
                        return c(e, t);
                      case 1:
                        return -1 - c(e, t);
                      case 2:
                        return t.readChunk(c(e, t));
                      case 3:
                        return t.readChunk(c(e, t)).toString("utf-8");
                      case 4:
                      case 5:
                        var r = c(e, t),
                          i = [];
                        if (null !== r) {
                          5 === e.type && (r *= 2);
                          for (var o = 0; o < r; o++) i[o] = d(t);
                        } else for (var s; (s = d(t)) !== l; ) i.push(s);
                        if (5 === e.type) {
                          var a = {};
                          for (o = 0; o < i.length; o += 2) a[i[o]] = i[o + 1];
                          return a;
                        }
                        return i;
                      case 6:
                        var f = c(e, t),
                          h = n[f];
                        return (i = d(t)), h ? h(i) : i;
                      case 7:
                        if (25 === e.value) return t.readFloat16();
                        if (26 === e.value) return t.readFloat32();
                        if (27 === e.value) return t.readFloat64();
                        switch (c(e, t)) {
                          case 20:
                            return !1;
                          case 21:
                            return !0;
                          case 22:
                            return null;
                          case 23:
                            return;
                          case null:
                            return l;
                          default:
                            throw new Error("Unknown fixed value: " + e.value);
                        }
                      default:
                        throw new Error(
                          "Unsupported header: " + JSON.stringify(e),
                        );
                    }
                    throw new Error("not implemented yet");
                  }
                  function p(t, e) {
                    for (var n = 0; n < r.length; n++) {
                      var i = r[n].fn(t);
                      if (void 0 !== i) return h(6, r[n].tag, e), p(i, e);
                    }
                    if (
                      (t && "function" == typeof t.toCBOR && (t = t.toCBOR()),
                      !1 === t)
                    )
                      h(7, 20, e);
                    else if (!0 === t) h(7, 21, e);
                    else if (null === t) h(7, 22, e);
                    else if (void 0 === t) h(7, 23, e);
                    else if ("number" == typeof t)
                      Math.floor(t) === t &&
                      t < 9007199254740992 &&
                      t > -9007199254740992
                        ? t < 0
                          ? h(1, -1 - t, e)
                          : h(0, t, e)
                        : (f(7, 27, e), e.writeFloat64(t));
                    else if ("string" == typeof t)
                      e.writeString(t, function (t) {
                        h(3, t, e);
                      });
                    else if (e.canWriteBinary(t))
                      e.writeBinary(t, function (t) {
                        h(2, t, e);
                      });
                    else {
                      if ("object" != typeof t)
                        throw new Error("CBOR encoding not supported: " + t);
                      if (
                        (m.config.useToJSON &&
                          "function" == typeof t.toJSON &&
                          (t = t.toJSON()),
                        Array.isArray(t))
                      )
                        for (h(4, t.length, e), n = 0; n < t.length; n++)
                          p(t[n], e);
                      else {
                        var o = Object.keys(t);
                        for (h(5, o.length, e), n = 0; n < o.length; n++) {
                          const r = parseInt(o[n]);
                          isNaN(r)
                            ? (p(o[n], e), p(t[o[n]], e))
                            : (p(r, e), p(t[o[n]], e));
                        }
                      }
                    }
                  }
                  var y = [],
                    g = [],
                    m = {
                      config: { useToJSON: !0 },
                      addWriter: function (t, e) {
                        "string" == typeof t
                          ? g.push(function (r) {
                              if (t === r) return e(r);
                            })
                          : g.push(t);
                      },
                      addReader: function (t, e) {
                        "string" == typeof t
                          ? y.push(function (r, n) {
                              if (t === n) return e(r, n);
                            })
                          : y.push(t);
                      },
                      encode: function (t, e) {
                        for (var r = 0; r < g.length; r++) {
                          var n = (0, g[r])(e);
                          if (n) return p(t, n), n.result();
                        }
                        throw new Error("Unsupported output format: " + e);
                      },
                      encodeDataItem: function (t, e) {
                        for (var r = 0; r < g.length; r++) {
                          var n = (0, g[r])(e);
                          if (n)
                            return void 0 !== t.getTag()
                              ? (p(t, n), n.result())
                              : (p(t.getData(), n), n.result());
                        }
                        throw new Error("Unsupported output format: " + e);
                      },
                      decode: function (t, e) {
                        for (var r = 0; r < y.length; r++) {
                          var n = (0, y[r])(t, e);
                          if (n) return d(n);
                        }
                        throw new Error("Unsupported input format: " + e);
                      },
                      decodeToDataItem: function (e, r) {
                        for (var n = 0; n < y.length; n++) {
                          var i = (0, y[n])(e, r);
                          if (i) {
                            const e = d(i);
                            return e instanceof t ? e : new t(e);
                          }
                        }
                        throw new Error("Unsupported input format: " + r);
                      },
                      addSemanticEncode: function (t, e) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return r.push({ tag: t, fn: e }), this;
                      },
                      addSemanticDecode: function (t, e) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return (n[t] = e), this;
                      },
                    };
                  function b(t) {
                    (this.buffer = t), (this.pos = 0);
                  }
                  function w(t) {
                    (this.byteLength = 0),
                      (this.defaultBufferLength = 16384),
                      (this.latestBuffer = s.alloc(this.defaultBufferLength)),
                      (this.latestBufferOffset = 0),
                      (this.completeBuffers = []),
                      (this.stringFormat = t);
                  }
                  function v(t) {
                    (this.hex = t), (this.pos = 0);
                  }
                  function _(t) {
                    (this.$hex = ""), (this.finalFormat = t || "hex");
                  }
                  return (
                    (b.prototype = Object.create(o.prototype)),
                    (b.prototype.peekByte = function () {
                      return this.buffer[this.pos];
                    }),
                    (b.prototype.readByte = function () {
                      return this.buffer[this.pos++];
                    }),
                    (b.prototype.readUint16 = function () {
                      var t = this.buffer.readUInt16BE(this.pos);
                      return (this.pos += 2), t;
                    }),
                    (b.prototype.readUint32 = function () {
                      var t = this.buffer.readUInt32BE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (b.prototype.readFloat32 = function () {
                      var t = this.buffer.readFloatBE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (b.prototype.readFloat64 = function () {
                      var t = this.buffer.readDoubleBE(this.pos);
                      return (this.pos += 8), t;
                    }),
                    (b.prototype.readChunk = function (t) {
                      var e = s.alloc(t);
                      return (
                        this.buffer.copy(e, 0, this.pos, (this.pos += t)), e
                      );
                    }),
                    (w.prototype = Object.create(a.prototype)),
                    (w.prototype.writeByte = function (t) {
                      (this.latestBuffer[this.latestBufferOffset++] = t),
                        this.latestBufferOffset >= this.latestBuffer.length &&
                          (this.completeBuffers.push(this.latestBuffer),
                          (this.latestBuffer = s.alloc(
                            this.defaultBufferLength,
                          )),
                          (this.latestBufferOffset = 0)),
                        this.byteLength++;
                    }),
                    (w.prototype.writeFloat32 = function (t) {
                      var e = s.alloc(4);
                      e.writeFloatBE(t, 0), this.writeBuffer(e);
                    }),
                    (w.prototype.writeFloat64 = function (t) {
                      var e = s.alloc(8);
                      e.writeDoubleBE(t, 0), this.writeBuffer(e);
                    }),
                    (w.prototype.writeString = function (t, e) {
                      var r = s.from(t, "utf-8");
                      e(r.length), this.writeBuffer(r);
                    }),
                    (w.prototype.canWriteBinary = function (t) {
                      return t instanceof s;
                    }),
                    (w.prototype.writeBinary = function (t, e) {
                      e(t.length), this.writeBuffer(t);
                    }),
                    (w.prototype.writeBuffer = function (t) {
                      if (!(t instanceof s))
                        throw new TypeError(
                          "BufferWriter only accepts Buffers",
                        );
                      this.latestBufferOffset
                        ? this.latestBuffer.length - this.latestBufferOffset >=
                          t.length
                          ? (t.copy(this.latestBuffer, this.latestBufferOffset),
                            (this.latestBufferOffset += t.length),
                            this.latestBufferOffset >=
                              this.latestBuffer.length &&
                              (this.completeBuffers.push(this.latestBuffer),
                              (this.latestBuffer = s.alloc(
                                this.defaultBufferLength,
                              )),
                              (this.latestBufferOffset = 0)))
                          : (this.completeBuffers.push(
                              this.latestBuffer.slice(
                                0,
                                this.latestBufferOffset,
                              ),
                            ),
                            this.completeBuffers.push(t),
                            (this.latestBuffer = s.alloc(
                              this.defaultBufferLength,
                            )),
                            (this.latestBufferOffset = 0))
                        : this.completeBuffers.push(t),
                        (this.byteLength += t.length);
                    }),
                    (w.prototype.result = function () {
                      for (
                        var t = s.alloc(this.byteLength), e = 0, r = 0;
                        r < this.completeBuffers.length;
                        r++
                      ) {
                        var n = this.completeBuffers[r];
                        n.copy(t, e, 0, n.length), (e += n.length);
                      }
                      return (
                        this.latestBufferOffset &&
                          this.latestBuffer.copy(
                            t,
                            e,
                            0,
                            this.latestBufferOffset,
                          ),
                        this.stringFormat ? t.toString(this.stringFormat) : t
                      );
                    }),
                    "function" == typeof s &&
                      (m.addReader(function (t, e) {
                        return s.isBuffer(t)
                          ? new b(t)
                          : "hex" === e || "base64" === e
                            ? new b(s.from(t, e))
                            : void 0;
                      }),
                      m.addWriter(function (t) {
                        return t && "buffer" !== t
                          ? "hex" === t || "base64" === t
                            ? new w(t)
                            : void 0
                          : new w();
                      })),
                    (v.prototype = Object.create(o.prototype)),
                    (v.prototype.peekByte = function () {
                      var t = this.hex.substring(this.pos, 2);
                      return parseInt(t, 16);
                    }),
                    (v.prototype.readByte = function () {
                      var t = this.hex.substring(this.pos, this.pos + 2);
                      return (this.pos += 2), parseInt(t, 16);
                    }),
                    (v.prototype.readChunk = function (t) {
                      var r = this.hex.substring(this.pos, this.pos + 2 * t);
                      return (
                        (this.pos += 2 * t),
                        "function" == typeof s ? s.from(r, "hex") : new e(r)
                      );
                    }),
                    (_.prototype = Object.create(a.prototype)),
                    (_.prototype.writeByte = function (t) {
                      if (t < 0 || t > 255)
                        throw new Error("Byte value out of range: " + t);
                      var e = t.toString(16);
                      1 == e.length && (e = "0" + e), (this.$hex += e);
                    }),
                    (_.prototype.canWriteBinary = function (t) {
                      return (
                        t instanceof e ||
                        ("function" == typeof s && t instanceof s)
                      );
                    }),
                    (_.prototype.writeBinary = function (t, r) {
                      if (t instanceof e) r(t.length()), (this.$hex += t.$hex);
                      else {
                        if (!("function" == typeof s && t instanceof s))
                          throw new TypeError(
                            "HexWriter only accepts BinaryHex or Buffers",
                          );
                        r(t.length), (this.$hex += t.toString("hex"));
                      }
                    }),
                    (_.prototype.result = function () {
                      return "buffer" === this.finalFormat &&
                        "function" == typeof s
                        ? s.from(this.$hex, "hex")
                        : new e(this.$hex).toString(this.finalFormat);
                    }),
                    (_.prototype.writeString = function (t, r) {
                      var n = e.fromUtf8String(t);
                      r(n.length()), (this.$hex += n.$hex);
                    }),
                    m.addReader(function (t, r) {
                      return t instanceof e || t.$hex
                        ? new v(t.$hex)
                        : "hex" === r
                          ? new v(t)
                          : void 0;
                    }),
                    m.addWriter(function (t) {
                      if ("hex" === t) return new _();
                    }),
                    m
                  );
                })();
                return (
                  e
                    .addSemanticEncode(0, function (t) {
                      if (t instanceof Date) return t.toISOString();
                    })
                    .addSemanticDecode(0, function (t) {
                      return new Date(t);
                    })
                    .addSemanticDecode(1, function (t) {
                      return new Date(t);
                    }),
                  e
                );
              })
                ? n.apply(e, i)
                : n) || (t.exports = o);
      },
      9707: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DataItem =
            e.addWriter =
            e.addReader =
            e.addSemanticEncode =
            e.addSemanticDecode =
            e.decodeToDataItem =
            e.encodeDataItem =
              void 0);
        var n = r(93791);
        Object.defineProperty(e, "encodeDataItem", {
          enumerable: !0,
          get: function () {
            return n.encodeDataItem;
          },
        }),
          Object.defineProperty(e, "decodeToDataItem", {
            enumerable: !0,
            get: function () {
              return n.decodeToDataItem;
            },
          }),
          Object.defineProperty(e, "addSemanticDecode", {
            enumerable: !0,
            get: function () {
              return n.addSemanticDecode;
            },
          }),
          Object.defineProperty(e, "addSemanticEncode", {
            enumerable: !0,
            get: function () {
              return n.addSemanticEncode;
            },
          }),
          Object.defineProperty(e, "addReader", {
            enumerable: !0,
            get: function () {
              return n.addReader;
            },
          }),
          Object.defineProperty(e, "addWriter", {
            enumerable: !0,
            get: function () {
              return n.addWriter;
            },
          });
        var i = r(3124);
        Object.defineProperty(e, "DataItem", {
          enumerable: !0,
          get: function () {
            return i.DataItem;
          },
        });
      },
      62097: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const n = r(90310),
          i = r(35212),
          o = r(21702),
          s = Object.values(i.RegistryTypes)
            .filter((t) => !!t.getTag())
            .map((t) => t.getTag()),
          a = Object.values(o.ScriptExpressions).map((t) => t.getTag());
        (0, n.patchTags)(s.concat(a));
      },
      98010: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
      },
      90310: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.patchTags = void 0);
        const n = r(9707),
          i = [];
        e.patchTags = (t) => {
          t.forEach((t) => {
            i.find((e) => e === t) ||
              ((0, n.addSemanticEncode)(t, (e) => {
                if (e instanceof n.DataItem && e.getTag() === t)
                  return e.getData();
              }),
              (0, n.addSemanticDecode)(t, (e) => new n.DataItem(e, t)),
              i.push(t));
          });
        };
      },
      18820: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          o =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  i(e, t, r);
            },
          s =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.URDecoder =
            e.UREncoder =
            e.UR =
            e.CryptoAccount =
            e.DerivationAlgorithm =
            e.Curve =
            e.CryptoMultiAccounts =
            e.buildCryptoHDKey =
            e.buildCryptoAccount =
            e.parseResponoseUR =
            e.pathToKeypath =
              void 0);
        const a = r(98779);
        Object.defineProperty(e, "Curve", {
          enumerable: !0,
          get: function () {
            return a.Curve;
          },
        }),
          Object.defineProperty(e, "DerivationAlgorithm", {
            enumerable: !0,
            get: function () {
              return a.DerivationAlgorithm;
            },
          }),
          Object.defineProperty(e, "CryptoMultiAccounts", {
            enumerable: !0,
            get: function () {
              return a.CryptoMultiAccounts;
            },
          }),
          Object.defineProperty(e, "CryptoAccount", {
            enumerable: !0,
            get: function () {
              return a.CryptoAccount;
            },
          });
        const u = r(17539);
        Object.defineProperty(e, "UR", {
          enumerable: !0,
          get: function () {
            return u.UR;
          },
        }),
          Object.defineProperty(e, "UREncoder", {
            enumerable: !0,
            get: function () {
              return u.UREncoder;
            },
          }),
          Object.defineProperty(e, "URDecoder", {
            enumerable: !0,
            get: function () {
              return u.URDecoder;
            },
          });
        const c = r(31860),
          f = r(77839);
        e.default = class {
          constructor(t, e) {
            (this.transport = t), e && (this.mfp = e);
          }
          precheck() {
            if (
              (this.transport ||
                (0, f.throwTransportError)(
                  f.Status.ERR_TRANSPORT_HAS_NOT_BEEN_SET,
                ),
              !this.mfp)
            )
              throw new Error("missing mfp for this wallet");
          }
          sendToDevice(t, e) {
            return s(this, void 0, void 0, function* () {
              return this.transport.send(t, e);
            });
          }
          checkDeviceLockStatus() {
            return s(this, void 0, void 0, function* () {
              return (yield this.sendToDevice(
                c.Actions.CMD_CHECK_LOCK_STATUS,
                "",
              )).payload;
            });
          }
          getURAccount(t, r, n) {
            return s(this, void 0, void 0, function* () {
              const i = new a.KeyDerivationSchema(
                  (0, e.pathToKeypath)(t),
                  r,
                  n,
                  "ETH",
                ),
                o = new a.KeyDerivation([i]),
                s = new a.QRHardwareCall(
                  a.QRHardwareCallType.KeyDerivation,
                  o,
                  "Keystone USB SDK",
                  a.QRHardwareCallVersion.V1,
                ).toUR(),
                f = new u.UREncoder(s, 1 / 0).nextPart().toUpperCase(),
                h = yield this.sendToDevice(c.Actions.CMD_RESOLVE_UR, f),
                l = (0, e.parseResponoseUR)(h.payload);
              return a.CryptoMultiAccounts.fromCBOR(l.cbor);
            });
          }
          sendURRequest(t) {
            return s(this, void 0, void 0, function* () {
              const r = yield this.sendToDevice(c.Actions.CMD_RESOLVE_UR, t);
              return (0, e.parseResponoseUR)(r.payload);
            });
          }
          getPubkey(t, e, r) {
            return s(this, void 0, void 0, function* () {
              const n = yield this.getURAccount(t, e, r),
                i = n.getKeys()[0];
              this.mfp = n.getMasterFingerprint().toString("hex");
              return {
                publicKey: i.getKey().toString("hex"),
                mfp: this.mfp,
                chainCode: i.getChainCode(),
              };
            });
          }
          getAppConfig() {
            return s(this, void 0, void 0, function* () {
              const t = yield this.sendToDevice(
                c.Actions.CMD_GET_DEVICE_VERSION,
                "",
              );
              return { version: t.firmwareVersion, mfp: t.walletMFP };
            });
          }
        };
        e.pathToKeypath = (t, e) => {
          const r = t
            .replace(/[m|M]\//, "")
            .split("/")
            .map((t) => {
              const r = t.endsWith("'"),
                n = t.replace("'", "");
              return "x" === n || "X" === n
                ? null != e
                  ? new a.PathComponent({ index: e, hardened: r })
                  : new a.PathComponent({ hardened: r })
                : new a.PathComponent({ index: parseInt(n, 10), hardened: r });
            });
          return new a.CryptoKeypath(r);
        };
        e.parseResponoseUR = (t) => {
          const e = new u.URDecoder();
          e.receivePart(t),
            e.isComplete() ||
              (0, f.throwTransportError)(f.Status.ERR_UR_INCOMPLETE);
          return e.resultUR();
        };
        e.buildCryptoAccount = (t) => {
          const { keys: r, origin: i, note: o, startIndex: s = 0 } = t;
          return new a.CryptoAccount(
            n.from(r[0].mfp, "hex"),
            r.map(
              (t, r) =>
                new a.CryptoOutput(
                  [],
                  (0, e.buildCryptoHDKey)({
                    publicKey: t.publicKey,
                    chainCode: t.chainCode,
                    mfp: t.mfp,
                    origin: i,
                    originIndex: s + r,
                    note: o,
                  }),
                ),
            ),
          );
        };
        (e.buildCryptoHDKey = (t) => {
          const {
            publicKey: r,
            chainCode: i,
            mfp: o,
            origin: s,
            children: u,
            originIndex: c,
            childIndex: f,
            note: h,
          } = t;
          return new a.CryptoHDKey({
            isMaster: !1,
            isPrivateKey: !1,
            key: n.from(r, "hex"),
            chainCode: n.from(i, "hex"),
            origin: (0, e.pathToKeypath)(s, c),
            children: u ? (0, e.pathToKeypath)(u, f) : void 0,
            parentFingerprint: n.from(o, "hex"),
            name: "Keystone",
            note: h,
          });
        }),
          o(r(774), e);
      },
      774: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.generateURString = e.convertMulitAccountToCryptoAccount = void 0);
        const i = r(98779),
          o = r(17539);
        e.convertMulitAccountToCryptoAccount = (t) => {
          const e = t.map((t) => t.getMasterFingerprint().toString("hex"));
          if (0 === e.length) throw new Error("input list is empty");
          if (1 !== new Set(e).size)
            throw new Error(
              "All accounts must have the same Master Fingerprint",
            );
          return new i.CryptoAccount(
            n.from(e[0], "hex"),
            t
              .flatMap((t) => t.getKeys())
              .map(
                (t) => new i.CryptoOutput([i.ScriptExpressions.RAW_SCRIPT], t),
              ),
          );
        };
        e.generateURString = (t, e) => {
          const r = new o.UR(n.from(t, "hex"), e);
          return new o.UREncoder(r, 1 / 0).nextPart().toUpperCase();
        };
      },
      88799: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Actions = void 0),
          (function (t) {
            (t[(t.CMD_ECHO_TEST = 1)] = "CMD_ECHO_TEST"),
              (t[(t.CMD_RESOLVE_UR = 2)] = "CMD_RESOLVE_UR"),
              (t[(t.CMD_CHECK_LOCK_STATUS = 3)] = "CMD_CHECK_LOCK_STATUS"),
              (t[(t.CMD_EXPORT_ADDRESS = 4)] = "CMD_EXPORT_ADDRESS"),
              (t[(t.CMD_GET_DEVICE_VERSION = 5)] = "CMD_GET_DEVICE_VERSION");
          })(r || (e.Actions = r = {}));
      },
      76021: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Chain = void 0),
          (function (t) {
            t[(t.ETH = 0)] = "ETH";
          })(r || (e.Chain = r = {}));
      },
      95225: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.OFFSET_CDATA =
            e.OFFSET_LC =
            e.OFFSET_P2 =
            e.OFFSET_P1 =
            e.OFFSET_INS =
            e.OFFSET_CLA =
            e.USBTimeout =
            e.MAXUSBPackets =
            e.USBPackageSize =
            e.USBInterfaceNumber =
            e.USBConfigurationValue =
              void 0),
          (e.USBConfigurationValue = 1),
          (e.USBInterfaceNumber =
            "development" === "MISSING_ENV_VAR".KEYSTONE_USB_ENV ? 1 : 0),
          (e.USBPackageSize = 64),
          (e.MAXUSBPackets = 200),
          (e.USBTimeout = 15e3),
          (e.OFFSET_CLA = 0),
          (e.OFFSET_INS = 1),
          (e.OFFSET_P1 = 3),
          (e.OFFSET_P2 = 5),
          (e.OFFSET_LC = 7),
          (e.OFFSET_CDATA = 9);
      },
      48328: function (t, e) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (t, e, r, n) {
            return new (r || (r = Promise))(function (i, o) {
              function s(t) {
                try {
                  u(n.next(t));
                } catch (t) {
                  o(t);
                }
              }
              function a(t) {
                try {
                  u(n.throw(t));
                } catch (t) {
                  o(t);
                }
              }
              function u(t) {
                var e;
                t.done
                  ? i(t.value)
                  : ((e = t.value),
                    e instanceof r
                      ? e
                      : new r(function (t) {
                          t(e);
                        })).then(s, a);
              }
              u((n = n.apply(t, e || [])).next());
            });
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.logMethod = void 0);
        const n = "development" === "MISSING_ENV_VAR".KEYSTONE_USB_ENV;
        e.logMethod = function (t, e, i) {
          const o = i.value;
          return (
            (i.value = function (...t) {
              return r(this, void 0, void 0, function* () {
                const r = t.map((t) => JSON.stringify(t)).join(),
                  i = yield o.apply(this, t);
                return (
                  n &&
                    console.log(
                      `[${new Date().toISOString()}] Call: ${e}(${r}) => ${JSON.stringify(i)}`,
                    ),
                  i
                );
              });
            }),
            i
          );
        };
      },
      44357: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = e.encode = void 0);
        const n = r(38658),
          i = r(95225),
          o = r(77839);
        e.encode = (t, e, r) => {
          if ((0, n.isString)(r) && (!r || 0 === r.length)) {
            const r = new Uint8Array(9);
            return (
              (r[i.OFFSET_CLA] = 0),
              (0, n.setUint16)(r, i.OFFSET_INS, t),
              (0, n.setUint16)(r, i.OFFSET_P1, 1),
              (0, n.setUint16)(r, i.OFFSET_P2, 0),
              (0, n.setUint16)(r, i.OFFSET_LC, e),
              [r]
            );
          }
          const o = (0, n.isString)(r) ? new TextEncoder().encode(r) : r,
            s = [],
            a = Math.ceil(o.length / 55);
          for (let r = 0; r < a; r++) {
            const u = o.slice(55 * r, 55 * (r + 1)),
              c = 9 + u.length,
              f = new Uint8Array(c);
            (f[i.OFFSET_CLA] = 0),
              (0, n.setUint16)(f, i.OFFSET_INS, t),
              (0, n.setUint16)(f, i.OFFSET_P1, a),
              (0, n.setUint16)(f, i.OFFSET_P2, r),
              (0, n.setUint16)(f, i.OFFSET_LC, e),
              f.set(u, 9),
              s.push(f);
          }
          return s;
        };
        const s = (t) => {
          t.length < 9 &&
            (0, o.throwTransportError)(o.Status.ERR_INVALID_PACKET_SIZE);
          const e = new DataView(t.buffer),
            r = e.getUint8(0),
            n = e.getUint16(i.OFFSET_INS),
            s = e.getUint16(i.OFFSET_P1),
            a = e.getUint16(i.OFFSET_P2),
            u = e.getUint16(i.OFFSET_LC),
            c = t.buffer.byteLength - 2,
            f = e.getUint16(c),
            h = c - i.OFFSET_CDATA,
            l = new Uint8Array(t.buffer, i.OFFSET_CDATA, h);
          var d;
          return {
            cla: r,
            ins: n,
            totalPackets: s,
            packetIndex: a,
            requestID: u,
            data:
              0 === (d = l).length ? null : new TextDecoder("utf-8").decode(d),
            status: f,
          };
        };
        e.decode = (t) =>
          t
            .map((t) => s(t))
            .sort(({ packetIndex: t }, { packetIndex: e }) => t - e)
            .reduce(
              (t, { data: e, status: r }) => ({ data: t.data + e, status: r }),
              { data: "" },
            );
      },
      38658: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.isString =
            e.isUint8Array =
            e.generateRequestID =
            e.isEmpty =
            e.setUint16 =
            e.safeJSONparse =
            e.safeJSONStringify =
              void 0);
        e.safeJSONStringify = (t) => {
          try {
            return JSON.stringify(t);
          } catch (t) {
            return "";
          }
        };
        e.safeJSONparse = (t) => {
          try {
            return JSON.parse(t);
          } catch (e) {
            return t;
          }
        };
        e.setUint16 = (t, e, r) => {
          (t[e] = (r >> 8) & 255), (t[e + 1] = 255 & r);
        };
        e.isEmpty = (t) =>
          Array.isArray(t)
            ? 0 === t.length
            : "object" == typeof t
              ? 0 === Object.keys(t).length
              : !t;
        e.generateRequestID = () => Math.floor(65535 * Math.random());
        e.isUint8Array = (t) => t instanceof Uint8Array;
        e.isString = (t) => "string" == typeof t;
      },
      31860: function (t, e, r) {
        "use strict";
        var n,
          i,
          o,
          s =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          a =
            (this && this.__decorate) ||
            function (t, e, r, n) {
              var i,
                o = arguments.length,
                s =
                  o < 3
                    ? e
                    : null === n
                      ? (n = Object.getOwnPropertyDescriptor(e, r))
                      : n;
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.decorate
              )
                s = Reflect.decorate(t, e, r, n);
              else
                for (var a = t.length - 1; a >= 0; a--)
                  (i = t[a]) &&
                    (s = (o < 3 ? i(s) : o > 3 ? i(e, r, s) : i(e, r)) || s);
              return o > 3 && s && Object.defineProperty(e, r, s), s;
            },
          u =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  s(e, t, r);
            },
          c =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            },
          f =
            (this && this.__classPrivateFieldGet) ||
            function (t, e, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof e ? t !== e || !n : !e.has(t))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                  ? n.call(t)
                  : n
                    ? n.value
                    : e.get(t);
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.TransportWebUSB = e.Chain = e.StatusCode = e.Actions = void 0);
        const h = r(48287),
          l = r(77839),
          d = r(44357),
          p = r(95225),
          y = r(17202),
          g = r(38658),
          m = r(48328);
        var b = r(88799);
        Object.defineProperty(e, "Actions", {
          enumerable: !0,
          get: function () {
            return b.Actions;
          },
        }),
          u(r(17202), e);
        var w = r(77839);
        Object.defineProperty(e, "StatusCode", {
          enumerable: !0,
          get: function () {
            return w.Status;
          },
        });
        var v = r(76021);
        Object.defineProperty(e, "Chain", {
          enumerable: !0,
          get: function () {
            return v.Chain;
          },
        }),
          u(r(48328), e),
          u(r(38658), e);
        class _ {
          constructor(t, e) {
            var r, i, o;
            n.add(this),
              (this.endpoint = 3),
              (this.requestTimeout = p.USBTimeout),
              (this.maxPacketSize = p.MAXUSBPackets),
              (this.receive = (t, e) =>
                c(this, void 0, void 0, function* () {
                  var r, n, i, o, s, a, u;
                  if (
                    !(null === (r = this.device) || void 0 === r
                      ? void 0
                      : r.opened)
                  )
                    return null;
                  const c = [];
                  let f = 0,
                    y = 0,
                    m = !0;
                  do {
                    const r = yield this.device.transferIn(
                      this.endpoint,
                      p.USBPackageSize,
                    );
                    "babble" === r.status &&
                      (0, l.throwTransportError)(l.Status.ERR_RECEIVED_BABBLE);
                    const s = !!(null === (n = null == r ? void 0 : r.data) ||
                      void 0 === n
                        ? void 0
                        : n.buffer),
                      a =
                        0 ===
                        (null ===
                          (o =
                            null === (i = null == r ? void 0 : r.data) ||
                            void 0 === i
                              ? void 0
                              : i.buffer) || void 0 === o
                          ? void 0
                          : o.byteLength);
                    s &&
                    !a &&
                    new DataView(r.data.buffer).getUint16(p.OFFSET_INS) === t &&
                    new DataView(r.data.buffer).getUint16(p.OFFSET_LC) === e
                      ? ((m = !1),
                        c.push(h.Buffer.from(r.data.buffer)),
                        (y = new DataView(r.data.buffer).getUint16(
                          p.OFFSET_P1,
                        )),
                        (f += 1))
                      : yield this.open();
                  } while (f < y || m);
                  const b = (0, d.decode)(c);
                  if (b.status !== l.Status.RSP_SUCCESS_CODE)
                    throw new l.TransportError(
                      `${null !== (a = null === (s = (0, g.safeJSONparse)(b.data)) || void 0 === s ? void 0 : s.payload) && void 0 !== a ? a : "unknown error"}`,
                      null !== (u = b.status) && void 0 !== u
                        ? u
                        : l.Status.RSP_FAILURE_CODE,
                    );
                  return (0, g.safeJSONparse)(b.data);
                })),
              (this.open = () =>
                c(this, void 0, void 0, function* () {
                  this.device ||
                    (this.device = yield (0, y.requestKeystoneDevice)()),
                    yield (0, y.open)(this.device);
                })),
              (this.close = () =>
                c(this, void 0, void 0, function* () {
                  var t;
                  return (
                    (null === (t = this.device) || void 0 === t
                      ? void 0
                      : t.opened) && (0, y.close)(this.device)
                  );
                })),
              (this.endpoint =
                null !== (r = null == e ? void 0 : e.endpoint) && void 0 !== r
                  ? r
                  : this.endpoint),
              (this.requestTimeout =
                null !== (i = null == e ? void 0 : e.timeout) && void 0 !== i
                  ? i
                  : this.requestTimeout),
              (this.maxPacketSize =
                null !== (o = null == e ? void 0 : e.maxPacketSize) &&
                void 0 !== o
                  ? o
                  : this.maxPacketSize),
              (this.device = t);
          }
          send(t, e) {
            return c(this, void 0, void 0, function* () {
              return yield f(this, n, "m", o)
                .call(this, t, e)
                .finally(() =>
                  c(this, void 0, void 0, function* () {
                    yield (0, y.close)(this.device);
                  }),
                );
            });
          }
        }
        (e.TransportWebUSB = _),
          (i = _),
          (n = new WeakSet()),
          (o = function (t, e) {
            var r;
            return c(this, void 0, void 0, function* () {
              yield (0, y.open)(this.device),
                (null === (r = this.device) || void 0 === r
                  ? void 0
                  : r.opened) ||
                  (0, l.throwTransportError)(l.Status.ERR_DEVICE_NOT_OPENED),
                (0, g.isUint8Array)(e) ||
                  (0, g.isString)(e) ||
                  (e = (0, g.safeJSONStringify)(e));
              const n = (0, g.generateRequestID)(),
                i = (0, d.encode)(t, n, e);
              let o;
              this.maxPacketSize < i.length &&
                (0, l.throwTransportError)(l.Status.ERR_DATA_TOO_LARGE);
              const s = new Promise((t, e) => {
                  o = setTimeout(
                    () =>
                      e(
                        new l.TransportError(
                          l.ErrorInfo[l.Status.ERR_TIMEOUT],
                          l.Status.ERR_TIMEOUT,
                        ),
                      ),
                    this.requestTimeout,
                  );
                }),
                a = (() =>
                  c(this, void 0, void 0, function* () {
                    try {
                      do {
                        "ok" !==
                          (yield this.device.transferOut(this.endpoint, i[0]))
                            .status &&
                          (0, l.throwTransportError)(
                            l.Status.ERR_RESPONSE_STATUS_NOT_OK,
                          ),
                          i.shift();
                      } while (i.length > 0);
                      return yield this.receive(t, n);
                    } finally {
                      clearTimeout(o);
                    }
                  }))();
              return Promise.race([a, s]);
            });
          }),
          (_.requestPermission = () =>
            c(void 0, void 0, void 0, function* () {
              return yield (0, y.close)(yield (0, y.request)());
            })),
          (_.connect = (t) =>
            c(void 0, void 0, void 0, function* () {
              yield (0, y.isSupported)();
              const e = yield (0, y.getKeystoneDevices)();
              let r = null;
              return (
                (r =
                  e.length > 1 ? yield (0, y.requestKeystoneDevice)() : e[0]),
                (0, y.initializeDisconnectListener)(
                  r,
                  null == t ? void 0 : t.disconnectListener,
                ),
                new i(r, t)
              );
            })),
          a([m.logMethod], _.prototype, "send", null);
      },
      17202: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (t, e, r, n) {
            return new (r || (r = Promise))(function (i, o) {
              function s(t) {
                try {
                  u(n.next(t));
                } catch (t) {
                  o(t);
                }
              }
              function a(t) {
                try {
                  u(n.throw(t));
                } catch (t) {
                  o(t);
                }
              }
              function u(t) {
                var e;
                t.done
                  ? i(t.value)
                  : ((e = t.value),
                    e instanceof r
                      ? e
                      : new r(function (t) {
                          t(e);
                        })).then(s, a);
              }
              u((n = n.apply(t, e || [])).next());
            });
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.close =
            e.request =
            e.gracefullyResetDevice =
            e.isSupported =
            e.getFirstKeystoneDevice =
            e.getKeystoneDevices =
            e.open =
            e.requestKeystoneDevice =
            e.initializeDisconnectListener =
            e.keystoneUSBVendorId =
              void 0);
        const i = r(95225),
          o = r(38658),
          s = r(77839);
        e.keystoneUSBVendorId = 4617;
        const a = [{ vendorId: e.keystoneUSBVendorId }];
        function u() {
          return n(this, void 0, void 0, function* () {
            return yield navigator.usb.requestDevice({ filters: a });
          });
        }
        (e.initializeDisconnectListener = (t, r) => {
          const n = (i) => {
            t === i.device &&
              (r && r(t),
              (0, e.close)(t),
              navigator.usb.removeEventListener("disconnect", n));
          };
          navigator.usb.addEventListener("disconnect", n);
        }),
          (e.requestKeystoneDevice = u);
        function c() {
          return n(this, void 0, void 0, function* () {
            return (yield navigator.usb.getDevices()).filter(
              (t) => t.vendorId === e.keystoneUSBVendorId,
            );
          });
        }
        (e.open = (t) =>
          n(void 0, void 0, void 0, function* () {
            yield t.open(),
              yield (function (t) {
                return n(this, void 0, void 0, function* () {
                  null === t.configuration &&
                    (yield t.selectConfiguration(i.USBConfigurationValue));
                });
              })(t),
              yield f(t);
            try {
              yield t.claimInterface(i.USBInterfaceNumber);
            } catch (r) {
              throw (yield (0, e.close)(t), r);
            }
            return t;
          })),
          (e.getKeystoneDevices = c),
          (e.getFirstKeystoneDevice = function () {
            return n(this, void 0, void 0, function* () {
              const t = yield c();
              return t.length > 0 ? t[0] : u();
            });
          });
        function f(t) {
          return n(this, void 0, void 0, function* () {
            try {
              yield t.reset();
            } catch (t) {
              console.warn(t);
            }
          });
        }
        (e.isSupported = () =>
          n(void 0, void 0, void 0, function* () {
            return (
              ((null === navigator || void 0 === navigator
                ? void 0
                : navigator.usb) &&
                "function" == typeof navigator.usb.getDevices) ||
                (0, s.throwTransportError)(s.Status.ERR_NOT_SUPPORTED),
              (0, o.isEmpty)(yield c()) &&
                (0, s.throwTransportError)(s.Status.ERR_DEVICE_NOT_FOUND),
              !0
            );
          })),
          (e.gracefullyResetDevice = f);
        e.request = () =>
          n(void 0, void 0, void 0, function* () {
            const t = yield u();
            return yield (0, e.open)(t);
          });
        e.close = (t) =>
          n(void 0, void 0, void 0, function* () {
            try {
              yield t.releaseInterface(i.USBInterfaceNumber),
                yield f(t),
                yield t.close();
            } catch (t) {
              console.warn(t);
            }
          });
      },
      74469: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          o =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    i(e, t, r);
              return o(e, t), e;
            },
          a =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const u = s(r(10611)),
          c = s(r(18820)),
          f = r(92751),
          h = r(98779),
          l = r(97361),
          d = r(50168),
          p = s(r(40630)),
          y = r(65094),
          g = r(17539),
          m = r(77839),
          b = r(21359);
        var w, v;
        !(function (t) {
          (t[(t.mainnet = 0)] = "mainnet"), (t[(t.testnet = 1)] = "testnet");
        })(w || (w = {})),
          (function (t) {
            (t[(t.p2pkh = 44)] = "p2pkh"),
              (t[(t.p2sh = 49)] = "p2sh"),
              (t[(t.p2wpkh = 84)] = "p2wpkh"),
              (t[(t.p2tr = 86)] = "p2tr");
          })(v || (v = {}));
        const _ = {
          [w.mainnet]: {
            [v.p2pkh]: { private: 76066276, public: 76067358 },
            [v.p2sh]: { private: 77428856, public: 77429938 },
            [v.p2wpkh]: { private: 78791436, public: 78792518 },
            [v.p2tr]: { private: 76066276, public: 76067358 },
          },
          [w.testnet]: {
            [v.p2pkh]: { private: 70615956, public: 70617039 },
            [v.p2sh]: { private: 71978536, public: 71979618 },
            [v.p2wpkh]: { private: 73341116, public: 73342198 },
            [v.p2tr]: { private: 70615956, public: 70617039 },
          },
        };
        class E extends c.default {
          constructor(t, e) {
            super(t, e);
          }
          static createWithUSBTransport(t) {
            return a(this, void 0, void 0, function* () {
              yield f.TransportWebUSB.requestPermission();
              const e = yield f.TransportWebUSB.connect(t);
              return yield e.close(), new E(e);
            });
          }
          getExtendedPublicKey(t, e = !0) {
            return a(this, void 0, void 0, function* () {
              const e = ((t) =>
                t
                  .replace(/[m|M]\//, "")
                  .split("/")
                  .map((t) => {
                    const e = t.split("'");
                    return { pathIndex: parseInt(e[0]), hardened: !!e[1] };
                  }))(t);
              if (e.length <= 0) throw new Error("Invalid path");
              const r = e[0].pathIndex,
                n = e[1].pathIndex;
              if (44 != r && 49 != r && 84 !== r && 86 !== r && 1 !== r)
                throw new Error("Invalid coin index");
              if (0 != n && 1 != n) throw new Error("Invalid coin type");
              const i = ((t, e) => {
                  const r = 0 === e ? w.mainnet : w.testnet,
                    n =
                      {
                        [v.p2pkh]: v.p2pkh,
                        [v.p2sh]: v.p2sh,
                        [v.p2wpkh]: v.p2wpkh,
                        [v.p2tr]: v.p2tr,
                      }[t] || null;
                  if (null === n) throw new Error("Invalid purpose");
                  return _[r][n];
                })(r, n),
                o = yield this.getURAccount(
                  t,
                  h.Curve.secp256k1,
                  h.DerivationAlgorithm.slip10,
                ),
                s = o.getKeys()[0],
                a = s.getKey(),
                u = s.getChainCode(),
                c = new d.HDKey({ publicKey: a, chainCode: u, versions: i });
              return (
                (this.mfp = o.getMasterFingerprint().toString("hex")),
                c.publicExtendedKey
              );
            });
          }
          signPsbt(t) {
            return a(this, void 0, void 0, function* () {
              const e = yield this.signPsbtRaw(t);
              return p.Psbt.fromBase64(e)
                .data.inputs.map((t, e) => {
                  const r = e;
                  if (t.partialSig && t.partialSig.length > 0) {
                    const e = t.partialSig[0],
                      i = e.pubkey,
                      o = e.signature;
                    if (
                      t.tapBip32Derivation &&
                      t.tapBip32Derivation.length > 0
                    ) {
                      const e = t.tapBip32Derivation[0].leafHashes;
                      if (e.length > 0)
                        return [
                          Number(r),
                          new y.PartialSignature(
                            n.from(i),
                            n.from(o),
                            n.from(e[0]),
                          ),
                        ];
                    }
                    return [
                      Number(r),
                      new y.PartialSignature(n.from(i), n.from(o)),
                    ];
                  }
                  if (t.tapKeySig) {
                    const e = t.tapInternalKey,
                      i = t.tapKeySig;
                    return [r, new y.PartialSignature(n.from(e), n.from(i))];
                  }
                  throw new Error("No signature found for input " + r);
                })
                .filter((t) => t);
            });
          }
          signPsbtRaw(t) {
            return a(this, void 0, void 0, function* () {
              "string" == typeof t && (t = n.from(t, "base64"));
              const e = p.Psbt.fromBuffer(t),
                r = new h.CryptoPSBT(n.from(e.toBuffer())).toUR(),
                i = new g.UREncoder(r, 1 / 0).nextPart().toUpperCase(),
                o = yield this.sendToDevice(b.Actions.CMD_RESOLVE_UR, i),
                s = (0, c.parseResponoseUR)(o.payload);
              return h.CryptoPSBT.fromCBOR(s.cbor).getPSBT().toString("base64");
            });
          }
          getMasterFingerprint() {
            return a(this, void 0, void 0, function* () {
              return (yield this.getAppConfig()).mfp;
            });
          }
          setMasterFingerprint(t) {
            this.mfp = t;
          }
          signMessage(t, e) {
            return a(this, void 0, void 0, function* () {
              this.precheck();
              const r = (function (t, e, r, n) {
                  const i = u.v4(),
                    o = [r],
                    s = [e],
                    a = l.BtcSignRequest.constructBtcRequest(i, o, t, n, s),
                    c = a.toUR(),
                    f = new g.UREncoder(c, 1 / 0).nextPart().toUpperCase();
                  return f;
                })(n.from(t, "utf8"), e, this.mfp, l.DataType.message),
                i = yield this.sendToDevice(b.Actions.CMD_RESOLVE_UR, r);
              return S(i.payload);
            });
          }
        }
        const S = (t) => {
          const e = new g.URDecoder();
          e.receivePart(t),
            e.isComplete() ||
              (0, m.throwTransportError)(m.Status.ERR_UR_INCOMPLETE);
          const r = e.resultUR();
          return l.BtcSignature.fromCBOR(r.cbor)
            .getSignature()
            .toString("base64");
        };
        e.default = E;
      },
      65094: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.PartialSignature = void 0);
        e.PartialSignature = class {
          constructor(t, e, r) {
            (this.pubkey = t), (this.signature = e), (this.tapleafHash = r);
          }
        };
      },
      44413: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.throwTransportError = e.ErrorInfo = e.TransportError = void 0);
        const n = r(30799);
        class i extends Error {
          constructor(t, e, r) {
            super(`${t} (error_code: ${e})`),
              (this.name = "TransportError"),
              (this.transportErrorCode = e),
              (this.details = null != r ? r : ""),
              Object.setPrototypeOf(this, new.target.prototype);
          }
        }
        (e.TransportError = i),
          (e.ErrorInfo = {
            [n.Status.ERR_DEVICE_NOT_OPENED]:
              "The USB device cannot be connected.",
            [n.Status.ERR_DEVICE_NOT_FOUND]: "The USB device cannot be found.",
            [n.Status.ERR_RESPONSE_STATUS_NOT_OK]:
              "The response status is not ok.",
            [n.Status.ERR_TIMEOUT]: "The request timed out.",
            [n.Status.ERR_DATA_TOO_LARGE]: "The data is too large.",
            [n.Status.ERR_NOT_SUPPORTED]: "The USB device is not supported.",
            [n.Status.ERR_BUFFER_MISMATCH]: "The buffer mismatched.",
            [n.Status.ERR_RECEIVED_BABBLE]: "The USB device received babble.",
            [n.Status.ERR_INVALID_PACKET_SIZE]: "The packet size is invalid.",
            [n.Status.ERR_TRANSPORT_HAS_NOT_BEEN_SET]:
              "The transport has not been set.",
            [n.Status.ERR_UR_INCOMPLETE]: "The UR is incomplete.",
            [n.Status.ERR_UR_INVALID_TYPE]: "The UR type is invalid.",
          });
        e.throwTransportError = (t) => {
          var r;
          const n =
            null !== (r = e.ErrorInfo[t]) && void 0 !== r ? r : "Unknown error";
          throw new i(n, t);
        };
      },
      77839: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  n(e, t, r);
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          i(r(30799), e),
          i(r(44413), e);
      },
      30799: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Status = void 0),
          (function (t) {
            (t[(t.RSP_SUCCESS_CODE = 0)] = "RSP_SUCCESS_CODE"),
              (t[(t.RSP_FAILURE_CODE = 1)] = "RSP_FAILURE_CODE"),
              (t[(t.PRS_INVALID_TOTAL_PACKETS = 2)] =
                "PRS_INVALID_TOTAL_PACKETS"),
              (t[(t.PRS_INVALID_INDEX = 3)] = "PRS_INVALID_INDEX"),
              (t[(t.PRS_PARSING_REJECTED = 4)] = "PRS_PARSING_REJECTED"),
              (t[(t.PRS_PARSING_ERROR = 5)] = "PRS_PARSING_ERROR"),
              (t[(t.PRS_PARSING_DISALLOWED = 6)] = "PRS_PARSING_DISALLOWED"),
              (t[(t.PRS_PARSING_UNMATCHED = 7)] = "PRS_PARSING_UNMATCHED"),
              (t[(t.PRS_PARSING_MISMATCHED_WALLET = 8)] =
                "PRS_PARSING_MISMATCHED_WALLET"),
              (t[(t.PRS_PARSING_VERIFY_PASSWORD_ERROR = 9)] =
                "PRS_PARSING_VERIFY_PASSWORD_ERROR"),
              (t[(t.PRS_EXPORT_ADDRESS_UNSUPPORTED_CHAIN = 10)] =
                "PRS_EXPORT_ADDRESS_UNSUPPORTED_CHAIN"),
              (t[(t.PRS_EXPORT_ADDRESS_INVALID_PARAMS = 11)] =
                "PRS_EXPORT_ADDRESS_INVALID_PARAMS"),
              (t[(t.PRS_EXPORT_ADDRESS_ERROR = 12)] =
                "PRS_EXPORT_ADDRESS_ERROR"),
              (t[(t.PRS_EXPORT_ADDRESS_DISALLOWED = 13)] =
                "PRS_EXPORT_ADDRESS_DISALLOWED"),
              (t[(t.PRS_EXPORT_ADDRESS_REJECTED = 14)] =
                "PRS_EXPORT_ADDRESS_REJECTED"),
              (t[(t.PRS_EXPORT_ADDRESS_BUSY = 15)] = "PRS_EXPORT_ADDRESS_BUSY"),
              (t[(t.ERR_DEVICE_NOT_OPENED = 2684354561)] =
                "ERR_DEVICE_NOT_OPENED"),
              (t[(t.ERR_DEVICE_NOT_FOUND = 2684354562)] =
                "ERR_DEVICE_NOT_FOUND"),
              (t[(t.ERR_RESPONSE_STATUS_NOT_OK = 2684354563)] =
                "ERR_RESPONSE_STATUS_NOT_OK"),
              (t[(t.ERR_TIMEOUT = 2684354564)] = "ERR_TIMEOUT"),
              (t[(t.ERR_DATA_TOO_LARGE = 2684354565)] = "ERR_DATA_TOO_LARGE"),
              (t[(t.ERR_NOT_SUPPORTED = 2684354566)] = "ERR_NOT_SUPPORTED"),
              (t[(t.ERR_BUFFER_MISMATCH = 2684354567)] = "ERR_BUFFER_MISMATCH"),
              (t[(t.ERR_RECEIVED_BABBLE = 2684354568)] = "ERR_RECEIVED_BABBLE"),
              (t[(t.ERR_INVALID_PACKET_SIZE = 2684354569)] =
                "ERR_INVALID_PACKET_SIZE"),
              (t[(t.ERR_TRANSPORT_HAS_NOT_BEEN_SET = 2684354570)] =
                "ERR_TRANSPORT_HAS_NOT_BEEN_SET"),
              (t[(t.ERR_UR_INCOMPLETE = 2684354571)] = "ERR_UR_INCOMPLETE"),
              (t[(t.ERR_UR_INVALID_TYPE = 2684354572)] = "ERR_UR_INVALID_TYPE"),
              (t[(t.RSP_MAX_VALUE = 4294967295)] = "RSP_MAX_VALUE");
          })(r || (e.Status = r = {}));
      },
      38284: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Actions = void 0),
          (function (t) {
            (t[(t.CMD_ECHO_TEST = 1)] = "CMD_ECHO_TEST"),
              (t[(t.CMD_RESOLVE_UR = 2)] = "CMD_RESOLVE_UR"),
              (t[(t.CMD_CHECK_LOCK_STATUS = 3)] = "CMD_CHECK_LOCK_STATUS"),
              (t[(t.CMD_EXPORT_ADDRESS = 4)] = "CMD_EXPORT_ADDRESS"),
              (t[(t.CMD_GET_DEVICE_VERSION = 5)] = "CMD_GET_DEVICE_VERSION");
          })(r || (e.Actions = r = {}));
      },
      22606: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Chain = void 0),
          (function (t) {
            t[(t.ETH = 0)] = "ETH";
          })(r || (e.Chain = r = {}));
      },
      91794: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.keystoneUSBProductId =
            e.keystoneUSBVendorId =
            e.OFFSET_CDATA =
            e.OFFSET_LC =
            e.OFFSET_P2 =
            e.OFFSET_P1 =
            e.OFFSET_INS =
            e.OFFSET_CLA =
            e.USBTimeout =
            e.MAXUSBPackets =
            e.USBPackageSize =
            e.USBInterfaceNumber =
            e.USBConfigurationValue =
              void 0),
          (e.USBConfigurationValue = 1),
          (e.USBInterfaceNumber =
            "development" === "MISSING_ENV_VAR".KEYSTONE_USB_ENV ? 1 : 0),
          (e.USBPackageSize = 64),
          (e.MAXUSBPackets = 200),
          (e.USBTimeout = 15e3),
          (e.OFFSET_CLA = 0),
          (e.OFFSET_INS = 1),
          (e.OFFSET_P1 = 3),
          (e.OFFSET_P2 = 5),
          (e.OFFSET_LC = 7),
          (e.OFFSET_CDATA = 9),
          (e.keystoneUSBVendorId = 4617),
          (e.keystoneUSBProductId = 12289);
      },
      95041: function (t, e) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (t, e, r, n) {
            return new (r || (r = Promise))(function (i, o) {
              function s(t) {
                try {
                  u(n.next(t));
                } catch (t) {
                  o(t);
                }
              }
              function a(t) {
                try {
                  u(n.throw(t));
                } catch (t) {
                  o(t);
                }
              }
              function u(t) {
                var e;
                t.done
                  ? i(t.value)
                  : ((e = t.value),
                    e instanceof r
                      ? e
                      : new r(function (t) {
                          t(e);
                        })).then(s, a);
              }
              u((n = n.apply(t, e || [])).next());
            });
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.logMethod = void 0);
        const n = "development" === "MISSING_ENV_VAR".KEYSTONE_USB_ENV;
        e.logMethod = function (t, e, i) {
          const o = i.value;
          return (
            (i.value = function (...t) {
              return r(this, void 0, void 0, function* () {
                const r = t.map((t) => JSON.stringify(t)).join(),
                  i = yield o.apply(this, t);
                return (
                  n &&
                    console.log(
                      `[${new Date().toISOString()}] Call: ${e}(${r}) => ${JSON.stringify(i)}`,
                    ),
                  i
                );
              });
            }),
            i
          );
        };
      },
      15994: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = e.encode = void 0);
        const n = r(84619),
          i = r(91794),
          o = r(77839);
        e.encode = (t, e, r) => {
          if ((0, n.isString)(r) && (!r || 0 === r.length)) {
            const r = new Uint8Array(9);
            return (
              (r[i.OFFSET_CLA] = 0),
              (0, n.setUint16)(r, i.OFFSET_INS, t),
              (0, n.setUint16)(r, i.OFFSET_P1, 1),
              (0, n.setUint16)(r, i.OFFSET_P2, 0),
              (0, n.setUint16)(r, i.OFFSET_LC, e),
              [r]
            );
          }
          const o = (0, n.isString)(r) ? new TextEncoder().encode(r) : r,
            s = [],
            a = Math.ceil(o.length / 55);
          for (let r = 0; r < a; r++) {
            const u = o.slice(55 * r, 55 * (r + 1)),
              c = 9 + u.length,
              f = new Uint8Array(c);
            (f[i.OFFSET_CLA] = 0),
              (0, n.setUint16)(f, i.OFFSET_INS, t),
              (0, n.setUint16)(f, i.OFFSET_P1, a),
              (0, n.setUint16)(f, i.OFFSET_P2, r),
              (0, n.setUint16)(f, i.OFFSET_LC, e),
              f.set(u, 9),
              s.push(f);
          }
          return s;
        };
        const s = (t) => {
          t.length < 9 &&
            (0, o.throwTransportError)(o.Status.ERR_INVALID_PACKET_SIZE);
          const e = new DataView(t.buffer),
            r = e.getUint8(0),
            n = e.getUint16(i.OFFSET_INS),
            s = e.getUint16(i.OFFSET_P1),
            a = e.getUint16(i.OFFSET_P2),
            u = e.getUint16(i.OFFSET_LC),
            c = t.buffer.byteLength - 2,
            f = e.getUint16(c),
            h = c - i.OFFSET_CDATA,
            l = new Uint8Array(t.buffer, i.OFFSET_CDATA, h);
          var d;
          return {
            cla: r,
            ins: n,
            totalPackets: s,
            packetIndex: a,
            requestID: u,
            data:
              0 === (d = l).length ? null : new TextDecoder("utf-8").decode(d),
            status: f,
          };
        };
        e.decode = (t) =>
          t
            .map((t) => s(t))
            .sort(({ packetIndex: t }, { packetIndex: e }) => t - e)
            .reduce(
              (t, { data: e, status: r }) => ({ data: t.data + e, status: r }),
              { data: "" },
            );
      },
      84619: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.isString =
            e.isUint8Array =
            e.generateRequestID =
            e.isEmpty =
            e.setUint16 =
            e.safeJSONparse =
            e.safeJSONStringify =
              void 0);
        e.safeJSONStringify = (t) => {
          try {
            return JSON.stringify(t);
          } catch (t) {
            return "";
          }
        };
        e.safeJSONparse = (t) => {
          try {
            return JSON.parse(t);
          } catch (e) {
            return t;
          }
        };
        e.setUint16 = (t, e, r) => {
          (t[e] = (r >> 8) & 255), (t[e + 1] = 255 & r);
        };
        e.isEmpty = (t) =>
          Array.isArray(t)
            ? 0 === t.length
            : "object" == typeof t
              ? 0 === Object.keys(t).length
              : !t;
        e.generateRequestID = () => Math.floor(65535 * Math.random());
        e.isUint8Array = (t) => t instanceof Uint8Array;
        e.isString = (t) => "string" == typeof t;
      },
      21359: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  n(e, t, r);
            };
        this && this.__awaiter;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Chain = e.StatusCode = e.Actions = void 0);
        r(91794);
        var o = r(38284);
        Object.defineProperty(e, "Actions", {
          enumerable: !0,
          get: function () {
            return o.Actions;
          },
        });
        var s = r(77839);
        Object.defineProperty(e, "StatusCode", {
          enumerable: !0,
          get: function () {
            return s.Status;
          },
        });
        var a = r(22606);
        Object.defineProperty(e, "Chain", {
          enumerable: !0,
          get: function () {
            return a.Chain;
          },
        }),
          i(r(95041), e),
          i(r(84619), e),
          i(r(15994), e),
          i(r(91794), e),
          i(r(98948), e);
      },
      98948: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
      },
      92751: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  n(e, t, r);
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), i(r(5511), e);
      },
      5511: function (t, e, r) {
        "use strict";
        var n,
          i,
          o,
          s =
            (this && this.__decorate) ||
            function (t, e, r, n) {
              var i,
                o = arguments.length,
                s =
                  o < 3
                    ? e
                    : null === n
                      ? (n = Object.getOwnPropertyDescriptor(e, r))
                      : n;
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.decorate
              )
                s = Reflect.decorate(t, e, r, n);
              else
                for (var a = t.length - 1; a >= 0; a--)
                  (i = t[a]) &&
                    (s = (o < 3 ? i(s) : o > 3 ? i(e, r, s) : i(e, r)) || s);
              return o > 3 && s && Object.defineProperty(e, r, s), s;
            },
          a =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            },
          u =
            (this && this.__classPrivateFieldGet) ||
            function (t, e, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof e ? t !== e || !n : !e.has(t))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                  ? n.call(t)
                  : n
                    ? n.value
                    : e.get(t);
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.createKeystoneTransport = e.TransportWebUSB = void 0);
        const c = r(21359),
          f = r(21359),
          h = r(21359),
          l = r(77839),
          d = r(48287),
          p = [{ vendorId: f.keystoneUSBVendorId }];
        class y {
          static getKeystoneDevices() {
            return a(this, void 0, void 0, function* () {
              return (yield navigator.usb.getDevices()).filter(
                (t) => t.vendorId === f.keystoneUSBVendorId,
              );
            });
          }
          static getFirstKeystoneDevice() {
            return a(this, void 0, void 0, function* () {
              const t = yield this.getKeystoneDevices();
              return t.length > 0 ? t[0] : m();
            });
          }
          static isSupported() {
            return a(this, void 0, void 0, function* () {
              return (
                ((null === navigator || void 0 === navigator
                  ? void 0
                  : navigator.usb) &&
                  "function" == typeof navigator.usb.getDevices) ||
                  (0, l.throwTransportError)(l.Status.ERR_NOT_SUPPORTED),
                (0, h.isEmpty)(yield this.getKeystoneDevices()) &&
                  (0, l.throwTransportError)(l.Status.ERR_DEVICE_NOT_FOUND),
                !0
              );
            });
          }
          constructor(t, e) {
            var r, i, o;
            n.add(this),
              (this.endpoint = 3),
              (this.requestTimeout = f.USBTimeout),
              (this.maxPacketSize = f.MAXUSBPackets),
              (this.receive = (t, e) =>
                a(this, void 0, void 0, function* () {
                  var r, n, i, o, s, a, u;
                  if (
                    !(null === (r = this.device) || void 0 === r
                      ? void 0
                      : r.opened)
                  )
                    return null;
                  const p = [];
                  let y = 0,
                    g = 0,
                    m = !0;
                  do {
                    const r = yield this.device.transferIn(
                      this.endpoint,
                      f.USBPackageSize,
                    );
                    "babble" === r.status &&
                      (0, l.throwTransportError)(l.Status.ERR_RECEIVED_BABBLE);
                    const s = !!(null === (n = null == r ? void 0 : r.data) ||
                      void 0 === n
                        ? void 0
                        : n.buffer),
                      a =
                        0 ===
                        (null ===
                          (o =
                            null === (i = null == r ? void 0 : r.data) ||
                            void 0 === i
                              ? void 0
                              : i.buffer) || void 0 === o
                          ? void 0
                          : o.byteLength);
                    s &&
                    !a &&
                    new DataView(r.data.buffer).getUint16(f.OFFSET_INS) === t &&
                    new DataView(r.data.buffer).getUint16(f.OFFSET_LC) === e
                      ? ((m = !1),
                        p.push(d.Buffer.from(r.data.buffer)),
                        (g = new DataView(r.data.buffer).getUint16(
                          f.OFFSET_P1,
                        )),
                        (y += 1))
                      : yield this.open();
                  } while (y < g || m);
                  const b = (0, c.decode)(p);
                  if (b.status !== l.Status.RSP_SUCCESS_CODE)
                    throw new l.TransportError(
                      `${null !== (a = null === (s = (0, h.safeJSONparse)(b.data)) || void 0 === s ? void 0 : s.payload) && void 0 !== a ? a : "unknown error"}`,
                      null !== (u = b.status) && void 0 !== u
                        ? u
                        : l.Status.RSP_FAILURE_CODE,
                    );
                  return (0, h.safeJSONparse)(b.data);
                })),
              (this.open = () =>
                a(this, void 0, void 0, function* () {
                  this.device || (this.device = yield m()),
                    yield b(this.device);
                })),
              (this.close = () =>
                a(this, void 0, void 0, function* () {
                  var t;
                  (null === (t = this.device) || void 0 === t
                    ? void 0
                    : t.opened) && (yield _(this.device));
                })),
              (this.endpoint =
                null !== (r = null == e ? void 0 : e.endpoint) && void 0 !== r
                  ? r
                  : this.endpoint),
              (this.requestTimeout =
                null !== (i = null == e ? void 0 : e.timeout) && void 0 !== i
                  ? i
                  : this.requestTimeout),
              (this.maxPacketSize =
                null !== (o = null == e ? void 0 : e.maxPacketSize) &&
                void 0 !== o
                  ? o
                  : this.maxPacketSize),
              (this.device = t);
          }
          send(t, e) {
            return a(this, void 0, void 0, function* () {
              return yield u(this, n, "m", o)
                .call(this, t, e)
                .finally(() =>
                  a(this, void 0, void 0, function* () {
                    yield _(this.device);
                  }),
                );
            });
          }
        }
        (e.TransportWebUSB = y),
          (i = y),
          (n = new WeakSet()),
          (o = function (t, e) {
            var r;
            return a(this, void 0, void 0, function* () {
              yield b(this.device),
                (null === (r = this.device) || void 0 === r
                  ? void 0
                  : r.opened) ||
                  (0, l.throwTransportError)(l.Status.ERR_DEVICE_NOT_OPENED),
                (0, h.isUint8Array)(e) ||
                  (0, h.isString)(e) ||
                  (e = (0, h.safeJSONStringify)(e));
              const n = (0, h.generateRequestID)(),
                i = (0, c.encode)(t, n, e);
              let o;
              this.maxPacketSize < i.length &&
                (0, l.throwTransportError)(l.Status.ERR_DATA_TOO_LARGE);
              const s = new Promise((t, e) => {
                  o = setTimeout(
                    () =>
                      e(
                        new l.TransportError(
                          l.ErrorInfo[l.Status.ERR_TIMEOUT],
                          l.Status.ERR_TIMEOUT,
                        ),
                      ),
                    this.requestTimeout,
                  );
                }),
                u = (() =>
                  a(this, void 0, void 0, function* () {
                    try {
                      do {
                        "ok" !==
                          (yield this.device.transferOut(this.endpoint, i[0]))
                            .status &&
                          (0, l.throwTransportError)(
                            l.Status.ERR_RESPONSE_STATUS_NOT_OK,
                          ),
                          i.shift();
                      } while (i.length > 0);
                      return yield this.receive(t, n);
                    } finally {
                      clearTimeout(o);
                    }
                  }))();
              return Promise.race([u, s]);
            });
          }),
          (y.requestPermission = () =>
            a(void 0, void 0, void 0, function* () {
              return yield _(yield v());
            })),
          (y.connect = (t) =>
            a(void 0, void 0, void 0, function* () {
              yield i.isSupported();
              const e = yield i.getKeystoneDevices();
              let r = null;
              return (
                (r = e.length > 1 ? yield m() : e[0]),
                g(r, null == t ? void 0 : t.disconnectListener),
                new i(r, t)
              );
            })),
          s([c.logMethod], y.prototype, "send", null);
        const g = (t, e) => {
          const r = (n) => {
            t === n.device &&
              (e && e(t),
              _(t),
              navigator.usb.removeEventListener("disconnect", r));
          };
          navigator.usb.addEventListener("disconnect", r);
        };
        function m() {
          return a(this, void 0, void 0, function* () {
            return yield navigator.usb.requestDevice({ filters: p });
          });
        }
        e.createKeystoneTransport = function (t = 1e5) {
          return a(this, void 0, void 0, function* () {
            if ((yield y.getKeystoneDevices()).length <= 0)
              try {
                yield y.requestPermission();
              } catch (t) {
                throw new Error("USB_PERMISSION_NOT_AVAILABLE");
              }
            const e = yield y.connect({ timeout: t });
            return yield e.close(), e;
          });
        };
        const b = (t) =>
          a(void 0, void 0, void 0, function* () {
            yield t.open(),
              yield (function (t) {
                return a(this, void 0, void 0, function* () {
                  null === t.configuration &&
                    (yield t.selectConfiguration(f.USBConfigurationValue));
                });
              })(t),
              yield w(t);
            try {
              yield t.claimInterface(f.USBInterfaceNumber);
            } catch (e) {
              throw (yield _(t), e);
            }
            return t;
          });
        function w(t) {
          return a(this, void 0, void 0, function* () {
            try {
              yield t.reset();
            } catch (t) {
              console.warn(t);
            }
          });
        }
        const v = () =>
            a(void 0, void 0, void 0, function* () {
              const t = yield m();
              return yield b(t);
            }),
          _ = (t) =>
            a(void 0, void 0, void 0, function* () {
              try {
                yield t.releaseInterface(f.USBInterfaceNumber),
                  yield w(t),
                  yield t.close();
              } catch (t) {
                console.warn(t);
              }
            });
      },
      25300: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const o = i(r(94148)),
          s = r(11774);
        let a = [];
        var u;
        !(function (t) {
          (t.STANDARD = "standard"), (t.URI = "uri"), (t.MINIMAL = "minimal");
        })(u || (u = {}));
        const c = (t) =>
            "ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom".slice(
              4 * t,
              4 * t + 4,
            ),
          f = (t) => `${t}${s.getCRCHex(n.from(t, "hex"))}`,
          h = (t, e) => {
            const r = f(t);
            return n
              .from(r, "hex")
              .reduce((t, e) => [...t, c(e)], [])
              .join(e);
          },
          l = (t) => {
            const e = f(t);
            return n.from(e, "hex").reduce(
              (t, e) =>
                t +
                ((t) => {
                  const e = c(t);
                  return `${e[0]}${e[3]}`;
                })(e),
              "",
            );
          },
          d = (t, e, r) => {
            const i = (4 == r ? t.split(e) : s.partition(t, 2))
              .map((t) =>
                ((t, e) => {
                  o.default(
                    t.length === e,
                    "Invalid Bytewords: word.length does not match wordLength provided",
                  );
                  const r = 26;
                  if (0 === a.length) {
                    a = [...new Array(676)].map(() => -1);
                    for (let t = 0; t < 256; t++) {
                      const e = c(t);
                      let n = e[0].charCodeAt(0) - "a".charCodeAt(0),
                        i = e[3].charCodeAt(0) - "a".charCodeAt(0);
                      a[i * r + n] = t;
                    }
                  }
                  let i = t[0].toLowerCase().charCodeAt(0) - "a".charCodeAt(0),
                    s =
                      t[4 == e ? 3 : 1].toLowerCase().charCodeAt(0) -
                      "a".charCodeAt(0);
                  o.default(
                    0 <= i && i < r && 0 <= s && s < r,
                    "Invalid Bytewords: invalid word",
                  );
                  let u = a[s * r + i];
                  if (
                    (o.default(
                      -1 !== u,
                      "Invalid Bytewords: value not in lookup table",
                    ),
                    4 == e)
                  ) {
                    const e = c(u);
                    let r = t[1].toLowerCase(),
                      n = t[2].toLowerCase();
                    o.default(
                      r === e[1] && n === e[2],
                      "Invalid Bytewords: invalid middle letters of word",
                    );
                  }
                  return n.from([u]).toString("hex");
                })(t, r),
              )
              .join("");
            o.default(
              i.length >= 5,
              "Invalid Bytewords: invalid decoded string length",
            );
            const [u, f] = s.split(n.from(i, "hex"), 4),
              h = s.getCRCHex(u);
            return (
              o.default(h === f.toString("hex"), "Invalid Checksum"),
              u.toString("hex")
            );
          };
        e.default = {
          decode: (t, e = u.MINIMAL) => {
            switch (e) {
              case u.STANDARD:
                return d(t, " ", 4);
              case u.URI:
                return d(t, "-", 4);
              case u.MINIMAL:
                return d(t, "", 2);
              default:
                throw new Error(`Invalid style ${e}`);
            }
          },
          encode: (t, e = u.MINIMAL) => {
            switch (e) {
              case u.STANDARD:
                return h(t, " ");
              case u.URI:
                return h(t, "-");
              case u.MINIMAL:
                return l(t);
              default:
                throw new Error(`Invalid style ${e}`);
            }
          },
          STYLES: u,
        };
      },
      86287: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.cborDecode = e.cborEncode = void 0);
        const i = r(54362);
        e.cborEncode = (t) => i.encode(t);
        e.cborDecode = (t) => i.decode(n.isBuffer(t) ? t : n.from(t, "hex"));
      },
      20908: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.InvalidChecksumError =
            e.InvalidSequenceComponentError =
            e.InvalidTypeError =
            e.InvalidPathLengthError =
            e.InvalidSchemeError =
              void 0);
        class r extends Error {
          constructor() {
            super("Invalid Scheme"), (this.name = "InvalidSchemeError");
          }
        }
        e.InvalidSchemeError = r;
        class n extends Error {
          constructor() {
            super("Invalid Path"), (this.name = "InvalidPathLengthError");
          }
        }
        e.InvalidPathLengthError = n;
        class i extends Error {
          constructor() {
            super("Invalid Type"), (this.name = "InvalidTypeError");
          }
        }
        e.InvalidTypeError = i;
        class o extends Error {
          constructor() {
            super("Invalid Sequence Component"),
              (this.name = "InvalidSequenceComponentError");
          }
        }
        e.InvalidSequenceComponentError = o;
        class s extends Error {
          constructor() {
            super("Invalid Checksum"), (this.name = "InvalidChecksumError");
          }
        }
        e.InvalidChecksumError = s;
      },
      30571: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.FountainDecoderPart = void 0);
        const i = r(11774),
          o = r(51386),
          s = r(20908);
        class a {
          constructor(t, e) {
            (this._indexes = t), (this._fragment = e);
          }
          get indexes() {
            return this._indexes;
          }
          get fragment() {
            return this._fragment;
          }
          static fromEncoderPart(t) {
            const e = o.chooseFragments(t.seqNum, t.seqLength, t.checksum),
              r = t.fragment;
            return new a(e, r);
          }
          isSimple() {
            return 1 === this.indexes.length;
          }
        }
        e.FountainDecoderPart = a;
        class u {
          constructor() {
            (this.result = void 0),
              (this.expectedMessageLength = 0),
              (this.expectedChecksum = 0),
              (this.expectedFragmentLength = 0),
              (this.processedPartsCount = 0),
              (this.expectedPartIndexes = []),
              (this.lastPartIndexes = []),
              (this.queuedParts = []),
              (this.receivedPartIndexes = []),
              (this.mixedParts = []),
              (this.simpleParts = []);
          }
          validatePart(t) {
            if (0 === this.expectedPartIndexes.length)
              [...new Array(t.seqLength)].forEach((t, e) =>
                this.expectedPartIndexes.push(e),
              ),
                (this.expectedMessageLength = t.messageLength),
                (this.expectedChecksum = t.checksum),
                (this.expectedFragmentLength = t.fragment.length);
            else {
              if (this.expectedPartIndexes.length !== t.seqLength) return !1;
              if (this.expectedMessageLength !== t.messageLength) return !1;
              if (this.expectedChecksum !== t.checksum) return !1;
              if (this.expectedFragmentLength !== t.fragment.length) return !1;
            }
            return !0;
          }
          reducePartByPart(t, e) {
            if (i.arrayContains(t.indexes, e.indexes)) {
              const r = i.setDifference(t.indexes, e.indexes),
                n = i.bufferXOR(t.fragment, e.fragment);
              return new a(r, n);
            }
            return t;
          }
          reduceMixedBy(t) {
            const e = [];
            this.mixedParts
              .map(({ value: e }) => this.reducePartByPart(e, t))
              .forEach((t) => {
                t.isSimple()
                  ? this.queuedParts.push(t)
                  : e.push({ key: t.indexes, value: t });
              }),
              (this.mixedParts = e);
          }
          processSimplePart(t) {
            const e = t.indexes[0];
            if (!this.receivedPartIndexes.includes(e))
              if (
                (this.simpleParts.push({ key: t.indexes, value: t }),
                this.receivedPartIndexes.push(e),
                i.arraysEqual(
                  this.receivedPartIndexes,
                  this.expectedPartIndexes,
                ))
              ) {
                const t = this.simpleParts
                    .map(({ value: t }) => t)
                    .sort((t, e) => t.indexes[0] - e.indexes[0]),
                  e = u.joinFragments(
                    t.map((t) => t.fragment),
                    this.expectedMessageLength,
                  );
                i.getCRC(e) === this.expectedChecksum
                  ? (this.result = e)
                  : (this.error = new s.InvalidChecksumError());
              } else this.reduceMixedBy(t);
          }
          processMixedPart(t) {
            if (
              this.mixedParts.some(({ key: e }) => i.arraysEqual(e, t.indexes))
            )
              return;
            let e = this.simpleParts.reduce(
              (t, { value: e }) => this.reducePartByPart(t, e),
              t,
            );
            (e = this.mixedParts.reduce(
              (t, { value: e }) => this.reducePartByPart(t, e),
              e,
            )),
              e.isSimple()
                ? this.queuedParts.push(e)
                : (this.reduceMixedBy(e),
                  this.mixedParts.push({ key: e.indexes, value: e }));
          }
          processQueuedItem() {
            if (0 === this.queuedParts.length) return;
            const t = this.queuedParts.shift();
            t.isSimple() ? this.processSimplePart(t) : this.processMixedPart(t);
          }
          receivePart(t) {
            if (this.isComplete()) return !1;
            if (!this.validatePart(t)) return !1;
            const e = a.fromEncoderPart(t);
            for (
              this.lastPartIndexes = e.indexes, this.queuedParts.push(e);
              !this.isComplete() && this.queuedParts.length > 0;

            )
              this.processQueuedItem();
            return (this.processedPartsCount += 1), !0;
          }
          isComplete() {
            return Boolean(void 0 !== this.result && this.result.length > 0);
          }
          isSuccess() {
            return Boolean(void 0 === this.error && this.isComplete());
          }
          resultMessage() {
            return this.isSuccess() ? this.result : n.from([]);
          }
          isFailure() {
            return void 0 !== this.error;
          }
          resultError() {
            return this.error ? this.error.message : "";
          }
          expectedPartCount() {
            return this.expectedPartIndexes.length;
          }
          getExpectedPartIndexes() {
            return [...this.expectedPartIndexes];
          }
          getReceivedPartIndexes() {
            return [...this.receivedPartIndexes];
          }
          getLastPartIndexes() {
            return [...this.lastPartIndexes];
          }
          estimatedPercentComplete() {
            if (this.isComplete()) return 1;
            const t = this.expectedPartCount();
            return 0 === t
              ? 0
              : Math.min(0.99, this.processedPartsCount / (1.75 * t));
          }
          getProgress() {
            if (this.isComplete()) return 1;
            const t = this.expectedPartCount();
            return 0 === t ? 0 : this.receivedPartIndexes.length / t;
          }
        }
        (e.default = u), (u.joinFragments = (t, e) => n.concat(t).slice(0, e));
      },
      7075: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.FountainEncoderPart = void 0);
        const o = i(r(94148)),
          s = r(11774),
          a = r(51386),
          u = r(86287);
        class c {
          constructor(t, e, r, n, i) {
            (this._seqNum = t),
              (this._seqLength = e),
              (this._messageLength = r),
              (this._checksum = n),
              (this._fragment = i);
          }
          get messageLength() {
            return this._messageLength;
          }
          get fragment() {
            return this._fragment;
          }
          get seqNum() {
            return this._seqNum;
          }
          get seqLength() {
            return this._seqLength;
          }
          get checksum() {
            return this._checksum;
          }
          cbor() {
            const t = u.cborEncode([
              this._seqNum,
              this._seqLength,
              this._messageLength,
              this._checksum,
              this._fragment,
            ]);
            return n.from(t);
          }
          description() {
            return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString("hex")}`;
          }
          static fromCBOR(t) {
            const [e, r, i, s, a] = u.cborDecode(t);
            return (
              o.default("number" == typeof e),
              o.default("number" == typeof r),
              o.default("number" == typeof i),
              o.default("number" == typeof s),
              o.default(n.isBuffer(a) && a.length > 0),
              new c(e, r, i, s, n.from(a))
            );
          }
        }
        e.FountainEncoderPart = c;
        class f {
          constructor(t, e = 100, r = 0, n = 10) {
            const i = f.findNominalFragmentLength(t.length, n, e);
            (this._messageLength = t.length),
              (this._fragments = f.partitionMessage(t, i)),
              (this.fragmentLength = i),
              (this.seqNum = s.toUint32(r)),
              (this.checksum = s.getCRC(t));
          }
          get fragmentsLength() {
            return this._fragments.length;
          }
          get fragments() {
            return this._fragments;
          }
          get messageLength() {
            return this._messageLength;
          }
          isComplete() {
            return this.seqNum >= this._fragments.length;
          }
          isSinglePart() {
            return 1 === this._fragments.length;
          }
          seqLength() {
            return this._fragments.length;
          }
          mix(t) {
            return t.reduce(
              (t, e) => s.bufferXOR(this._fragments[e], t),
              n.alloc(this.fragmentLength, 0),
            );
          }
          nextPart() {
            this.seqNum = s.toUint32(this.seqNum + 1);
            const t = a.chooseFragments(
                this.seqNum,
                this._fragments.length,
                this.checksum,
              ),
              e = this.mix(t);
            return new c(
              this.seqNum,
              this._fragments.length,
              this._messageLength,
              this.checksum,
              e,
            );
          }
          static findNominalFragmentLength(t, e, r) {
            o.default(t > 0), o.default(e > 0), o.default(r >= e);
            const n = Math.ceil(t / e);
            let i = 0;
            for (let e = 1; e <= n && ((i = Math.ceil(t / e)), !(i <= r)); e++);
            return i;
          }
          static partitionMessage(t, e) {
            let r,
              i = n.from(t),
              o = [];
            for (; i.length > 0; )
              ([r, i] = s.split(i, -e)),
                (r = n.alloc(e, 0).fill(r, 0, r.length)),
                o.push(r);
            return o;
          }
        }
        e.default = f;
      },
      51386: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.chooseFragments = e.shuffle = e.chooseDegree = void 0);
        const o = r(11774),
          s = i(r(52801)),
          a = i(r(91284));
        e.chooseDegree = (t, e) => {
          const r = [...new Array(t)].map((t, e) => 1 / (e + 1));
          return a.default(r, void 0, e.nextDouble).next() + 1;
        };
        e.shuffle = (t, e) => {
          let r = [...t],
            n = [];
          for (; r.length > 0; ) {
            let t = e.nextInt(0, r.length - 1),
              i = r[t];
            r.splice(t, 1), n.push(i);
          }
          return n;
        };
        e.chooseFragments = (t, r, i) => {
          if (t <= r) return [t - 1];
          {
            const a = n.concat([o.intToBytes(t), o.intToBytes(i)]),
              u = new s.default(a),
              c = e.chooseDegree(r, u),
              f = [...new Array(r)].map((t, e) => e);
            return e.shuffle(f, u).slice(0, c);
          }
        };
      },
      17539: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.URDecoder = e.UREncoder = e.UR = void 0);
        const i = n(r(64908));
        e.UR = i.default;
        const o = n(r(87814));
        e.UREncoder = o.default;
        const s = n(r(78458));
        e.URDecoder = s.default;
      },
      64908: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(20908),
          o = r(11774),
          s = r(86287);
        class a {
          constructor(t, e = "bytes") {
            if (
              ((this._cborPayload = t),
              (this._type = e),
              !o.isURType(this._type))
            )
              throw new i.InvalidTypeError();
          }
          static fromBuffer(t) {
            return new a(s.cborEncode(t));
          }
          static from(t, e) {
            return a.fromBuffer(n.from(t, e));
          }
          decodeCBOR() {
            return s.cborDecode(this._cborPayload);
          }
          get type() {
            return this._type;
          }
          get cbor() {
            return this._cborPayload;
          }
          equals(t) {
            return this.type === t.type && this.cbor.equals(t.cbor);
          }
        }
        e.default = a;
      },
      78458: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const o = i(r(30571)),
          s = i(r(25300)),
          a = i(r(94148)),
          u = r(11774),
          c = r(20908),
          f = i(r(64908)),
          h = r(7075);
        class l {
          constructor(t = new o.default(), e = "bytes") {
            (this.fountainDecoder = t),
              (this.type = e),
              a.default(u.isURType(e), "Invalid UR type"),
              (this.expected_type = "");
          }
          static decodeBody(t, e) {
            const r = s.default.decode(e, s.default.STYLES.MINIMAL);
            return new f.default(n.from(r, "hex"), t);
          }
          validatePart(t) {
            return this.expected_type
              ? this.expected_type === t
              : !!u.isURType(t) && ((this.expected_type = t), !0);
          }
          static decode(t) {
            const [e, r] = this.parse(t);
            if (0 === r.length) throw new c.InvalidPathLengthError();
            const n = r[0];
            return l.decodeBody(e, n);
          }
          static parse(t) {
            const e = t.toLowerCase();
            if ("ur:" !== e.slice(0, 3)) throw new c.InvalidSchemeError();
            const r = e.slice(3).split("/"),
              n = r[0];
            if (r.length < 2) throw new c.InvalidPathLengthError();
            if (!u.isURType(n)) throw new c.InvalidTypeError();
            return [n, r.slice(1)];
          }
          static parseSequenceComponent(t) {
            const e = t.split("-");
            if (2 !== e.length) throw new c.InvalidSequenceComponentError();
            const r = u.toUint32(Number(e[0])),
              n = Number(e[1]);
            if (r < 1 || n < 1) throw new c.InvalidSequenceComponentError();
            return [r, n];
          }
          receivePart(t) {
            if (void 0 !== this.result) return !1;
            const [e, r] = l.parse(t);
            if (!this.validatePart(e)) return !1;
            if (1 === r.length)
              return (this.result = l.decodeBody(e, r[0])), !0;
            if (2 !== r.length) throw new c.InvalidPathLengthError();
            const [n, i] = r,
              [o, a] = l.parseSequenceComponent(n),
              u = s.default.decode(i, s.default.STYLES.MINIMAL),
              d = h.FountainEncoderPart.fromCBOR(u);
            return (
              o === d.seqNum &&
              a === d.seqLength &&
              !!this.fountainDecoder.receivePart(d) &&
              (this.fountainDecoder.isSuccess()
                ? (this.result = new f.default(
                    this.fountainDecoder.resultMessage(),
                    e,
                  ))
                : this.fountainDecoder.isFailure() &&
                  (this.error = new c.InvalidSchemeError()),
              !0)
            );
          }
          resultUR() {
            return this.result ? this.result : new f.default(n.from([]));
          }
          isComplete() {
            return this.result && this.result.cbor.length > 0;
          }
          isSuccess() {
            return !this.error && this.isComplete();
          }
          isError() {
            return void 0 !== this.error;
          }
          resultError() {
            return this.error ? this.error.message : "";
          }
          expectedPartCount() {
            return this.fountainDecoder.expectedPartCount();
          }
          expectedPartIndexes() {
            return this.fountainDecoder.getExpectedPartIndexes();
          }
          receivedPartIndexes() {
            return this.fountainDecoder.getReceivedPartIndexes();
          }
          lastPartIndexes() {
            return this.fountainDecoder.getLastPartIndexes();
          }
          estimatedPercentComplete() {
            return this.fountainDecoder.estimatedPercentComplete();
          }
          getProgress() {
            return this.fountainDecoder.getProgress();
          }
        }
        e.default = l;
      },
      87814: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(7075)),
          o = n(r(25300));
        class s {
          constructor(t, e, r, n) {
            (this.ur = t),
              (this.fountainEncoder = new i.default(t.cbor, e, r, n));
          }
          get fragmentsLength() {
            return this.fountainEncoder.fragmentsLength;
          }
          get fragments() {
            return this.fountainEncoder.fragments;
          }
          get messageLength() {
            return this.fountainEncoder.messageLength;
          }
          get cbor() {
            return this.ur.cbor;
          }
          encodeWhole() {
            return [...new Array(this.fragmentsLength)].map(() =>
              this.nextPart(),
            );
          }
          nextPart() {
            const t = this.fountainEncoder.nextPart();
            return this.fountainEncoder.isSinglePart()
              ? s.encodeSinglePart(this.ur)
              : s.encodePart(this.ur.type, t);
          }
          static encodeUri(t, e) {
            return [t, e.join("/")].join(":");
          }
          static encodeUR(t) {
            return s.encodeUri("ur", t);
          }
          static encodePart(t, e) {
            const r = `${e.seqNum}-${e.seqLength}`,
              n = o.default.encode(
                e.cbor().toString("hex"),
                o.default.STYLES.MINIMAL,
              );
            return s.encodeUR([t, r, n]);
          }
          static encodeSinglePart(t) {
            const e = o.default.encode(
              t.cbor.toString("hex"),
              o.default.STYLES.MINIMAL,
            );
            return s.encodeUR([t.type, e]);
          }
        }
        e.default = s;
      },
      11774: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.bufferXOR =
            e.setDifference =
            e.arrayContains =
            e.arraysEqual =
            e.hasPrefix =
            e.isURType =
            e.intToBytes =
            e.toUint32 =
            e.getCRCHex =
            e.getCRC =
            e.split =
            e.partition =
            e.sha256Hash =
              void 0);
        const o = i(r(62802)),
          s = r(70723);
        e.sha256Hash = (t) => o.default("sha256").update(t).digest();
        e.partition = (t, e) =>
          t.match(new RegExp(".{1," + e + "}", "g")) || [t];
        e.split = (t, e) => [t.slice(0, -e), t.slice(-e)];
        e.getCRC = (t) => s.crc32(t);
        e.getCRCHex = (t) => s.crc32(t).toString(16).padStart(8, "0");
        e.toUint32 = (t) => t >>> 0;
        e.intToBytes = (t) => {
          const e = new ArrayBuffer(4);
          return new DataView(e).setUint32(0, t, !1), n.from(e);
        };
        e.isURType = (t) =>
          t.split("").every((e, r) => {
            let n = t.charCodeAt(r);
            return (
              ("a".charCodeAt(0) <= n && n <= "z".charCodeAt(0)) ||
              ("0".charCodeAt(0) <= n && n <= "9".charCodeAt(0)) ||
              n === "-".charCodeAt(0)
            );
          });
        e.hasPrefix = (t, e) => 0 === t.indexOf(e);
        e.arraysEqual = (t, e) =>
          t.length === e.length && t.every((t) => e.includes(t));
        e.arrayContains = (t, e) => e.every((e) => t.includes(e));
        e.setDifference = (t, e) => t.filter((t) => e.indexOf(t) < 0);
        e.bufferXOR = (t, e) => {
          const r = Math.max(t.length, e.length),
            i = n.allocUnsafe(r);
          for (let n = 0; n < r; ++n) i[n] = t[n] ^ e[n];
          return i;
        };
      },
      52801: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(11774),
          o = n(r(61594)),
          s = n(r(75951)),
          a = (t, e) =>
            s.default.bitwiseXor(
              s.default.asUintN(
                64,
                s.default.leftShift(t, s.default.BigInt(e)),
              ),
              s.default.BigInt(
                s.default.asUintN(
                  64,
                  s.default.signedRightShift(
                    t,
                    s.default.subtract(
                      s.default.BigInt(64),
                      s.default.BigInt(e),
                    ),
                  ),
                ),
              ),
            );
        e.default = class {
          constructor(t) {
            (this.next = () => new o.default(this.roll().toString())),
              (this.nextDouble = () =>
                new o.default(this.roll().toString()).div(0x10000000000000000)),
              (this.nextInt = (t, e) =>
                Math.floor(this.nextDouble().toNumber() * (e - t + 1) + t)),
              (this.nextByte = () => this.nextInt(0, 255)),
              (this.nextData = (t) =>
                [...new Array(t)].map(() => this.nextByte()));
            const e = i.sha256Hash(t);
            (this.s = [
              s.default.BigInt(0),
              s.default.BigInt(0),
              s.default.BigInt(0),
              s.default.BigInt(0),
            ]),
              this.setS(e);
          }
          setS(t) {
            for (let e = 0; e < 4; e++) {
              let r = 8 * e,
                n = s.default.BigInt(0);
              for (let e = 0; e < 8; e++)
                (n = s.default.asUintN(
                  64,
                  s.default.leftShift(n, s.default.BigInt(8)),
                )),
                  (n = s.default.asUintN(
                    64,
                    s.default.bitwiseOr(n, s.default.BigInt(t[r + e])),
                  ));
              this.s[e] = s.default.asUintN(64, n);
            }
          }
          roll() {
            const t = s.default.asUintN(
                64,
                s.default.multiply(
                  a(
                    s.default.asUintN(
                      64,
                      s.default.multiply(this.s[1], s.default.BigInt(5)),
                    ),
                    7,
                  ),
                  s.default.BigInt(9),
                ),
              ),
              e = s.default.asUintN(
                64,
                s.default.leftShift(this.s[1], s.default.BigInt(17)),
              );
            return (
              (this.s[2] = s.default.asUintN(
                64,
                s.default.bitwiseXor(this.s[2], s.default.BigInt(this.s[0])),
              )),
              (this.s[3] = s.default.asUintN(
                64,
                s.default.bitwiseXor(this.s[3], s.default.BigInt(this.s[1])),
              )),
              (this.s[1] = s.default.asUintN(
                64,
                s.default.bitwiseXor(this.s[1], s.default.BigInt(this.s[2])),
              )),
              (this.s[0] = s.default.asUintN(
                64,
                s.default.bitwiseXor(this.s[0], s.default.BigInt(this.s[3])),
              )),
              (this.s[2] = s.default.asUintN(
                64,
                s.default.bitwiseXor(this.s[2], s.default.BigInt(e)),
              )),
              (this.s[3] = s.default.asUintN(64, a(this.s[3], 45))),
              t
            );
          }
        };
      },
      73562: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.getHash = s),
          (e.createCurve = function (t, e) {
            const r = (e) => (0, o.weierstrass)({ ...t, ...s(e) });
            return { ...r(e), create: r };
          });
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const n = r(39615),
          i = r(99175),
          o = r(91705);
        function s(t) {
          return {
            hash: t,
            hmac: (e, ...r) => (0, n.hmac)(t, e, (0, i.concatBytes)(...r)),
            randomBytes: i.randomBytes,
          };
        }
      },
      62422: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.wNAF = function (t, e) {
            return {
              constTimeNegate: a,
              hasPrecomputes: (t) => 1 !== p(t),
              unsafeLadder(e, r, n = t.ZERO) {
                let i = e;
                for (; r > o; )
                  r & s && (n = n.add(i)), (i = i.double()), (r >>= s);
                return n;
              },
              precomputeWindow(t, r) {
                const { windows: n, windowSize: i } = c(r, e),
                  o = [];
                let s = t,
                  a = s;
                for (let t = 0; t < n; t++) {
                  (a = s), o.push(a);
                  for (let t = 1; t < i; t++) (a = a.add(s)), o.push(a);
                  s = a.double();
                }
                return o;
              },
              wNAF(r, n, i) {
                const { windows: o, windowSize: u } = c(r, e);
                let f = t.ZERO,
                  h = t.BASE;
                const l = BigInt(2 ** r - 1),
                  d = 2 ** r,
                  p = BigInt(r);
                for (let t = 0; t < o; t++) {
                  const e = t * u;
                  let r = Number(i & l);
                  (i >>= p), r > u && ((r -= d), (i += s));
                  const o = e,
                    c = e + Math.abs(r) - 1,
                    y = t % 2 != 0,
                    g = r < 0;
                  0 === r ? (h = h.add(a(y, n[o]))) : (f = f.add(a(g, n[c])));
                }
                return { p: f, f: h };
              },
              wNAFUnsafe(r, n, i, a = t.ZERO) {
                const { windows: u, windowSize: f } = c(r, e),
                  h = BigInt(2 ** r - 1),
                  l = 2 ** r,
                  d = BigInt(r);
                for (let t = 0; t < u; t++) {
                  const e = t * f;
                  if (i === o) break;
                  let r = Number(i & h);
                  if (((i >>= d), r > f && ((r -= l), (i += s)), 0 === r))
                    continue;
                  let u = n[e + Math.abs(r) - 1];
                  r < 0 && (u = u.negate()), (a = a.add(u));
                }
                return a;
              },
              getPrecomputes(t, e, r) {
                let n = l.get(e);
                return (
                  n ||
                    ((n = this.precomputeWindow(e, t)),
                    1 !== t && l.set(e, r(n))),
                  n
                );
              },
              wNAFCached(t, e, r) {
                const n = p(t);
                return this.wNAF(n, this.getPrecomputes(n, t, r), e);
              },
              wNAFCachedUnsafe(t, e, r, n) {
                const i = p(t);
                return 1 === i
                  ? this.unsafeLadder(t, e, n)
                  : this.wNAFUnsafe(i, this.getPrecomputes(i, t, r), e, n);
              },
              setWindowSize(t, r) {
                u(r, e), d.set(t, r), l.delete(t);
              },
            };
          }),
          (e.pippenger = function (t, e, r, n) {
            if ((f(r, t), h(n, e), r.length !== n.length))
              throw new Error(
                "arrays of points and scalars must have equal length",
              );
            const o = t.ZERO,
              s = (0, i.bitLen)(BigInt(r.length)),
              a = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
              u = (1 << a) - 1,
              c = new Array(u + 1).fill(o),
              l = Math.floor((e.BITS - 1) / a) * a;
            let d = o;
            for (let t = l; t >= 0; t -= a) {
              c.fill(o);
              for (let e = 0; e < n.length; e++) {
                const i = n[e],
                  o = Number((i >> BigInt(t)) & BigInt(u));
                c[o] = c[o].add(r[e]);
              }
              let e = o;
              for (let t = c.length - 1, r = o; t > 0; t--)
                (r = r.add(c[t])), (e = e.add(r));
              if (((d = d.add(e)), 0 !== t))
                for (let t = 0; t < a; t++) d = d.double();
            }
            return d;
          }),
          (e.precomputeMSMUnsafe = function (t, e, r, n) {
            u(n, e.BITS), f(r, t);
            const i = t.ZERO,
              o = 2 ** n - 1,
              s = Math.ceil(e.BITS / n),
              a = BigInt((1 << n) - 1),
              c = r.map((t) => {
                const e = [];
                for (let r = 0, n = t; r < o; r++) e.push(n), (n = n.add(t));
                return e;
              });
            return (t) => {
              if ((h(t, e), t.length > r.length))
                throw new Error(
                  "array of scalars must be smaller than array of points",
                );
              let o = i;
              for (let e = 0; e < s; e++) {
                if (o !== i) for (let t = 0; t < n; t++) o = o.double();
                const r = BigInt(s * n - (e + 1) * n);
                for (let e = 0; e < t.length; e++) {
                  const n = t[e],
                    i = Number((n >> r) & a);
                  i && (o = o.add(c[e][i - 1]));
                }
              }
              return o;
            };
          }),
          (e.validateBasic = function (t) {
            return (
              (0, n.validateField)(t.Fp),
              (0, i.validateObject)(
                t,
                { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" },
              ),
              Object.freeze({
                ...(0, n.nLength)(t.n, t.nBitLength),
                ...t,
                p: t.Fp.ORDER,
              })
            );
          });
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const n = r(24967),
          i = r(91484),
          o = BigInt(0),
          s = BigInt(1);
        function a(t, e) {
          const r = e.negate();
          return t ? r : e;
        }
        function u(t, e) {
          if (!Number.isSafeInteger(t) || t <= 0 || t > e)
            throw new Error(
              "invalid window size, expected [1.." + e + "], got W=" + t,
            );
        }
        function c(t, e) {
          u(t, e);
          return { windows: Math.ceil(e / t) + 1, windowSize: 2 ** (t - 1) };
        }
        function f(t, e) {
          if (!Array.isArray(t)) throw new Error("array expected");
          t.forEach((t, r) => {
            if (!(t instanceof e))
              throw new Error("invalid point at index " + r);
          });
        }
        function h(t, e) {
          if (!Array.isArray(t)) throw new Error("array of scalars expected");
          t.forEach((t, r) => {
            if (!e.isValid(t)) throw new Error("invalid scalar at index " + r);
          });
        }
        const l = new WeakMap(),
          d = new WeakMap();
        function p(t) {
          return d.get(t) || 1;
        }
      },
      71761: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.expand_message_xmd = c),
          (e.expand_message_xof = f),
          (e.hash_to_field = h),
          (e.isogenyMap = function (t, e) {
            const r = e.map((t) => Array.from(t).reverse());
            return (e, n) => {
              const [i, o, s, a] = r.map((r) =>
                r.reduce((r, n) => t.add(t.mul(r, e), n)),
              );
              return (
                (e = t.div(i, o)), (n = t.mul(n, t.div(s, a))), { x: e, y: n }
              );
            };
          }),
          (e.createHasher = function (t, e, r) {
            if ("function" != typeof e)
              throw new Error("mapToCurve() must be defined");
            return {
              hashToCurve(n, i) {
                const o = h(n, 2, { ...r, DST: r.DST, ...i }),
                  s = t.fromAffine(e(o[0])),
                  a = t.fromAffine(e(o[1])),
                  u = s.add(a).clearCofactor();
                return u.assertValidity(), u;
              },
              encodeToCurve(n, i) {
                const o = h(n, 1, { ...r, DST: r.encodeDST, ...i }),
                  s = t.fromAffine(e(o[0])).clearCofactor();
                return s.assertValidity(), s;
              },
              mapToCurve(r) {
                if (!Array.isArray(r))
                  throw new Error("mapToCurve: expected array of bigints");
                for (const t of r)
                  if ("bigint" != typeof t)
                    throw new Error("mapToCurve: expected array of bigints");
                const n = t.fromAffine(e(r)).clearCofactor();
                return n.assertValidity(), n;
              },
            };
          });
        const n = r(24967),
          i = r(91484),
          o = i.bytesToNumberBE;
        function s(t, e) {
          if ((u(t), u(e), t < 0 || t >= 1 << (8 * e)))
            throw new Error("invalid I2OSP input: " + t);
          const r = Array.from({ length: e }).fill(0);
          for (let n = e - 1; n >= 0; n--) (r[n] = 255 & t), (t >>>= 8);
          return new Uint8Array(r);
        }
        function a(t, e) {
          const r = new Uint8Array(t.length);
          for (let n = 0; n < t.length; n++) r[n] = t[n] ^ e[n];
          return r;
        }
        function u(t) {
          if (!Number.isSafeInteger(t)) throw new Error("number expected");
        }
        function c(t, e, r, n) {
          (0, i.abytes)(t),
            (0, i.abytes)(e),
            u(r),
            e.length > 255 &&
              (e = n(
                (0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), e),
              ));
          const { outputLen: o, blockLen: c } = n,
            f = Math.ceil(r / o);
          if (r > 65535 || f > 255)
            throw new Error("expand_message_xmd: invalid lenInBytes");
          const h = (0, i.concatBytes)(e, s(e.length, 1)),
            l = s(0, c),
            d = s(r, 2),
            p = new Array(f),
            y = n((0, i.concatBytes)(l, t, d, s(0, 1), h));
          p[0] = n((0, i.concatBytes)(y, s(1, 1), h));
          for (let t = 1; t <= f; t++) {
            const e = [a(y, p[t - 1]), s(t + 1, 1), h];
            p[t] = n((0, i.concatBytes)(...e));
          }
          return (0, i.concatBytes)(...p).slice(0, r);
        }
        function f(t, e, r, n, o) {
          if (((0, i.abytes)(t), (0, i.abytes)(e), u(r), e.length > 255)) {
            const t = Math.ceil((2 * n) / 8);
            e = o
              .create({ dkLen: t })
              .update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"))
              .update(e)
              .digest();
          }
          if (r > 65535 || e.length > 255)
            throw new Error("expand_message_xof: invalid lenInBytes");
          return o
            .create({ dkLen: r })
            .update(t)
            .update(s(r, 2))
            .update(e)
            .update(s(e.length, 1))
            .digest();
        }
        function h(t, e, r) {
          (0, i.validateObject)(r, {
            DST: "stringOrUint8Array",
            p: "bigint",
            m: "isSafeInteger",
            k: "isSafeInteger",
            hash: "hash",
          });
          const { p: s, k: a, m: h, hash: l, expand: d, DST: p } = r;
          (0, i.abytes)(t), u(e);
          const y = "string" == typeof p ? (0, i.utf8ToBytes)(p) : p,
            g = s.toString(2).length,
            m = Math.ceil((g + a) / 8),
            b = e * h * m;
          let w;
          if ("xmd" === d) w = c(t, y, b, l);
          else if ("xof" === d) w = f(t, y, b, a, l);
          else {
            if ("_internal_pass" !== d)
              throw new Error('expand must be "xmd" or "xof"');
            w = t;
          }
          const v = new Array(e);
          for (let t = 0; t < e; t++) {
            const e = new Array(h);
            for (let r = 0; r < h; r++) {
              const i = m * (r + t * h),
                a = w.subarray(i, i + m);
              e[r] = (0, n.mod)(o(a), s);
            }
            v[t] = e;
          }
          return v;
        }
      },
      24967: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.isNegativeLE = void 0),
          (e.mod = h),
          (e.pow = l),
          (e.pow2 = function (t, e, r) {
            let n = t;
            for (; e-- > i; ) (n *= n), (n %= r);
            return n;
          }),
          (e.invert = d),
          (e.tonelliShanks = p),
          (e.FpSqrt = y),
          (e.validateField = function (t) {
            const e = g.reduce((t, e) => ((t[e] = "function"), t), {
              ORDER: "bigint",
              MASK: "bigint",
              BYTES: "isSafeInteger",
              BITS: "isSafeInteger",
            });
            return (0, n.validateObject)(t, e);
          }),
          (e.FpPow = m),
          (e.FpInvertBatch = b),
          (e.FpDiv = function (t, e, r) {
            return t.mul(e, "bigint" == typeof r ? d(r, t.ORDER) : t.inv(r));
          }),
          (e.FpLegendre = w),
          (e.FpIsSquare = function (t) {
            const e = w(t.ORDER);
            return (r) => {
              const n = e(t, r);
              return t.eql(n, t.ZERO) || t.eql(n, t.ONE);
            };
          }),
          (e.nLength = v),
          (e.Field = function (t, e, r = !1, s = {}) {
            if (t <= i)
              throw new Error("invalid field: expected ORDER > 0, got " + t);
            const { nBitLength: a, nByteLength: u } = v(t, e);
            if (u > 2048)
              throw new Error("invalid field: expected ORDER of <= 2048 bytes");
            let c;
            const f = Object.freeze({
              ORDER: t,
              isLE: r,
              BITS: a,
              BYTES: u,
              MASK: (0, n.bitMask)(a),
              ZERO: i,
              ONE: o,
              create: (e) => h(e, t),
              isValid: (e) => {
                if ("bigint" != typeof e)
                  throw new Error(
                    "invalid field element: expected bigint, got " + typeof e,
                  );
                return i <= e && e < t;
              },
              is0: (t) => t === i,
              isOdd: (t) => (t & o) === o,
              neg: (e) => h(-e, t),
              eql: (t, e) => t === e,
              sqr: (e) => h(e * e, t),
              add: (e, r) => h(e + r, t),
              sub: (e, r) => h(e - r, t),
              mul: (e, r) => h(e * r, t),
              pow: (t, e) => m(f, t, e),
              div: (e, r) => h(e * d(r, t), t),
              sqrN: (t) => t * t,
              addN: (t, e) => t + e,
              subN: (t, e) => t - e,
              mulN: (t, e) => t * e,
              inv: (e) => d(e, t),
              sqrt: s.sqrt || ((e) => (c || (c = y(t)), c(f, e))),
              invertBatch: (t) => b(f, t),
              cmov: (t, e, r) => (r ? e : t),
              toBytes: (t) =>
                r ? (0, n.numberToBytesLE)(t, u) : (0, n.numberToBytesBE)(t, u),
              fromBytes: (t) => {
                if (t.length !== u)
                  throw new Error(
                    "Field.fromBytes: expected " +
                      u +
                      " bytes, got " +
                      t.length,
                  );
                return r
                  ? (0, n.bytesToNumberLE)(t)
                  : (0, n.bytesToNumberBE)(t);
              },
            });
            return Object.freeze(f);
          }),
          (e.FpSqrtOdd = function (t, e) {
            if (!t.isOdd) throw new Error("Field doesn't have isOdd");
            const r = t.sqrt(e);
            return t.isOdd(r) ? r : t.neg(r);
          }),
          (e.FpSqrtEven = function (t, e) {
            if (!t.isOdd) throw new Error("Field doesn't have isOdd");
            const r = t.sqrt(e);
            return t.isOdd(r) ? t.neg(r) : r;
          }),
          (e.hashToPrivateScalar = function (t, e, r = !1) {
            const i = (t = (0, n.ensureBytes)("privateHash", t)).length,
              s = v(e).nByteLength + 8;
            if (s < 24 || i < s || i > 1024)
              throw new Error(
                "hashToPrivateScalar: expected " +
                  s +
                  "-1024 bytes of input, got " +
                  i,
              );
            return (
              h(
                r ? (0, n.bytesToNumberLE)(t) : (0, n.bytesToNumberBE)(t),
                e - o,
              ) + o
            );
          }),
          (e.getFieldBytesLength = _),
          (e.getMinHashLength = E),
          (e.mapHashToField = function (t, e, r = !1) {
            const i = t.length,
              s = _(e),
              a = E(e);
            if (i < 16 || i < a || i > 1024)
              throw new Error(
                "expected " + a + "-1024 bytes of input, got " + i,
              );
            const u =
              h(
                r ? (0, n.bytesToNumberLE)(t) : (0, n.bytesToNumberBE)(t),
                e - o,
              ) + o;
            return r
              ? (0, n.numberToBytesLE)(u, s)
              : (0, n.numberToBytesBE)(u, s);
          });
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const n = r(91484),
          i = BigInt(0),
          o = BigInt(1),
          s = BigInt(2),
          a = BigInt(3),
          u = BigInt(4),
          c = BigInt(5),
          f = BigInt(8);
        function h(t, e) {
          const r = t % e;
          return r >= i ? r : e + r;
        }
        function l(t, e, r) {
          if (e < i) throw new Error("invalid exponent, negatives unsupported");
          if (r <= i) throw new Error("invalid modulus");
          if (r === o) return i;
          let n = o;
          for (; e > i; )
            e & o && (n = (n * t) % r), (t = (t * t) % r), (e >>= o);
          return n;
        }
        function d(t, e) {
          if (t === i) throw new Error("invert: expected non-zero number");
          if (e <= i)
            throw new Error("invert: expected positive modulus, got " + e);
          let r = h(t, e),
            n = e,
            s = i,
            a = o,
            u = o,
            c = i;
          for (; r !== i; ) {
            const t = n / r,
              e = n % r,
              i = s - u * t,
              o = a - c * t;
            (n = r), (r = e), (s = u), (a = c), (u = i), (c = o);
          }
          if (n !== o) throw new Error("invert: does not exist");
          return h(s, e);
        }
        function p(t) {
          const e = (t - o) / s;
          let r, n, a;
          for (r = t - o, n = 0; r % s === i; r /= s, n++);
          for (a = s; a < t && l(a, e, t) !== t - o; a++)
            if (a > 1e3)
              throw new Error("Cannot find square root: likely non-prime P");
          if (1 === n) {
            const e = (t + o) / u;
            return function (t, r) {
              const n = t.pow(r, e);
              if (!t.eql(t.sqr(n), r))
                throw new Error("Cannot find square root");
              return n;
            };
          }
          const c = (r + o) / s;
          return function (t, i) {
            if (t.pow(i, e) === t.neg(t.ONE))
              throw new Error("Cannot find square root");
            let s = n,
              u = t.pow(t.mul(t.ONE, a), r),
              f = t.pow(i, c),
              h = t.pow(i, r);
            for (; !t.eql(h, t.ONE); ) {
              if (t.eql(h, t.ZERO)) return t.ZERO;
              let e = 1;
              for (let r = t.sqr(h); e < s && !t.eql(r, t.ONE); e++)
                r = t.sqr(r);
              const r = t.pow(u, o << BigInt(s - e - 1));
              (u = t.sqr(r)), (f = t.mul(f, r)), (h = t.mul(h, u)), (s = e);
            }
            return f;
          };
        }
        function y(t) {
          if (t % u === a) {
            const e = (t + o) / u;
            return function (t, r) {
              const n = t.pow(r, e);
              if (!t.eql(t.sqr(n), r))
                throw new Error("Cannot find square root");
              return n;
            };
          }
          if (t % f === c) {
            const e = (t - c) / f;
            return function (t, r) {
              const n = t.mul(r, s),
                i = t.pow(n, e),
                o = t.mul(r, i),
                a = t.mul(t.mul(o, s), i),
                u = t.mul(o, t.sub(a, t.ONE));
              if (!t.eql(t.sqr(u), r))
                throw new Error("Cannot find square root");
              return u;
            };
          }
          return p(t);
        }
        e.isNegativeLE = (t, e) => (h(t, e) & o) === o;
        const g = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
        function m(t, e, r) {
          if (r < i) throw new Error("invalid exponent, negatives unsupported");
          if (r === i) return t.ONE;
          if (r === o) return e;
          let n = t.ONE,
            s = e;
          for (; r > i; ) r & o && (n = t.mul(n, s)), (s = t.sqr(s)), (r >>= o);
          return n;
        }
        function b(t, e) {
          const r = new Array(e.length),
            n = e.reduce(
              (e, n, i) => (t.is0(n) ? e : ((r[i] = e), t.mul(e, n))),
              t.ONE,
            ),
            i = t.inv(n);
          return (
            e.reduceRight(
              (e, n, i) =>
                t.is0(n) ? e : ((r[i] = t.mul(e, r[i])), t.mul(e, n)),
              i,
            ),
            r
          );
        }
        function w(t) {
          const e = (t - o) / s;
          return (t, r) => t.pow(r, e);
        }
        function v(t, e) {
          const r = void 0 !== e ? e : t.toString(2).length;
          return { nBitLength: r, nByteLength: Math.ceil(r / 8) };
        }
        function _(t) {
          if ("bigint" != typeof t)
            throw new Error("field order must be bigint");
          const e = t.toString(2).length;
          return Math.ceil(e / 8);
        }
        function E(t) {
          const e = _(t);
          return e + Math.ceil(e / 2);
        }
      },
      91484: (t, e) => {
        "use strict";
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(
          e,
          "__esModule",
          { value: !0 },
        ),
          (e.notImplemented = e.bitMask = void 0),
          (e.isBytes = o),
          (e.abytes = s),
          (e.abool = function (t, e) {
            if ("boolean" != typeof e)
              throw new Error(t + " boolean expected, got " + e);
          }),
          (e.bytesToHex = u),
          (e.numberToHexUnpadded = c),
          (e.hexToNumber = f),
          (e.hexToBytes = d),
          (e.bytesToNumberBE = function (t) {
            return f(u(t));
          }),
          (e.bytesToNumberLE = function (t) {
            return s(t), f(u(Uint8Array.from(t).reverse()));
          }),
          (e.numberToBytesBE = p),
          (e.numberToBytesLE = function (t, e) {
            return p(t, e).reverse();
          }),
          (e.numberToVarBytesBE = function (t) {
            return d(c(t));
          }),
          (e.ensureBytes = function (t, e, r) {
            let n;
            if ("string" == typeof e)
              try {
                n = d(e);
              } catch (e) {
                throw new Error(
                  t + " must be hex string or Uint8Array, cause: " + e,
                );
              }
            else {
              if (!o(e))
                throw new Error(t + " must be hex string or Uint8Array");
              n = Uint8Array.from(e);
            }
            const i = n.length;
            if ("number" == typeof r && i !== r)
              throw new Error(t + " of length " + r + " expected, got " + i);
            return n;
          }),
          (e.concatBytes = y),
          (e.equalBytes = function (t, e) {
            if (t.length !== e.length) return !1;
            let r = 0;
            for (let n = 0; n < t.length; n++) r |= t[n] ^ e[n];
            return 0 === r;
          }),
          (e.utf8ToBytes = function (t) {
            if ("string" != typeof t) throw new Error("string expected");
            return new Uint8Array(new TextEncoder().encode(t));
          }),
          (e.inRange = m),
          (e.aInRange = function (t, e, r, n) {
            if (!m(e, r, n))
              throw new Error(
                "expected valid " +
                  t +
                  ": " +
                  r +
                  " <= n < " +
                  n +
                  ", got " +
                  e,
              );
          }),
          (e.bitLen = function (t) {
            let e;
            for (e = 0; t > r; t >>= n, e += 1);
            return e;
          }),
          (e.bitGet = function (t, e) {
            return (t >> BigInt(e)) & n;
          }),
          (e.bitSet = function (t, e, i) {
            return t | ((i ? n : r) << BigInt(e));
          }),
          (e.createHmacDrbg = function (t, e, r) {
            if ("number" != typeof t || t < 2)
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            if ("function" != typeof r)
              throw new Error("hmacFn must be a function");
            let n = b(t),
              i = b(t),
              o = 0;
            const s = () => {
                n.fill(1), i.fill(0), (o = 0);
              },
              a = (...t) => r(i, n, ...t),
              u = (t = b()) => {
                (i = a(w([0]), t)),
                  (n = a()),
                  0 !== t.length && ((i = a(w([1]), t)), (n = a()));
              },
              c = () => {
                if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
                let t = 0;
                const r = [];
                for (; t < e; ) {
                  n = a();
                  const e = n.slice();
                  r.push(e), (t += n.length);
                }
                return y(...r);
              };
            return (t, e) => {
              let r;
              for (s(), u(t); !(r = e(c())); ) u();
              return s(), r;
            };
          }),
          (e.validateObject = function (t, e, r = {}) {
            const n = (e, r, n) => {
              const i = v[r];
              if ("function" != typeof i)
                throw new Error("invalid validator function");
              const o = t[e];
              if (!((n && void 0 === o) || i(o, t)))
                throw new Error(
                  "param " +
                    String(e) +
                    " is invalid. Expected " +
                    r +
                    ", got " +
                    o,
                );
            };
            for (const [t, r] of Object.entries(e)) n(t, r, !1);
            for (const [t, e] of Object.entries(r)) n(t, e, !0);
            return t;
          }),
          (e.memoized = function (t) {
            const e = new WeakMap();
            return (r, ...n) => {
              const i = e.get(r);
              if (void 0 !== i) return i;
              const o = t(r, ...n);
              return e.set(r, o), o;
            };
          });
        const r = BigInt(0),
          n = BigInt(1),
          i = BigInt(2);
        function o(t) {
          return (
            t instanceof Uint8Array ||
            (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
          );
        }
        function s(t) {
          if (!o(t)) throw new Error("Uint8Array expected");
        }
        const a = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        function u(t) {
          s(t);
          let e = "";
          for (let r = 0; r < t.length; r++) e += a[t[r]];
          return e;
        }
        function c(t) {
          const e = t.toString(16);
          return 1 & e.length ? "0" + e : e;
        }
        function f(t) {
          if ("string" != typeof t)
            throw new Error("hex string expected, got " + typeof t);
          return "" === t ? r : BigInt("0x" + t);
        }
        const h = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
        function l(t) {
          return t >= h._0 && t <= h._9
            ? t - h._0
            : t >= h.A && t <= h.F
              ? t - (h.A - 10)
              : t >= h.a && t <= h.f
                ? t - (h.a - 10)
                : void 0;
        }
        function d(t) {
          if ("string" != typeof t)
            throw new Error("hex string expected, got " + typeof t);
          const e = t.length,
            r = e / 2;
          if (e % 2)
            throw new Error(
              "hex string expected, got unpadded hex of length " + e,
            );
          const n = new Uint8Array(r);
          for (let e = 0, i = 0; e < r; e++, i += 2) {
            const r = l(t.charCodeAt(i)),
              o = l(t.charCodeAt(i + 1));
            if (void 0 === r || void 0 === o) {
              const e = t[i] + t[i + 1];
              throw new Error(
                'hex string expected, got non-hex character "' +
                  e +
                  '" at index ' +
                  i,
              );
            }
            n[e] = 16 * r + o;
          }
          return n;
        }
        function p(t, e) {
          return d(t.toString(16).padStart(2 * e, "0"));
        }
        function y(...t) {
          let e = 0;
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            s(n), (e += n.length);
          }
          const r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        const g = (t) => "bigint" == typeof t && r <= t;
        function m(t, e, r) {
          return g(t) && g(e) && g(r) && e <= t && t < r;
        }
        e.bitMask = (t) => (i << BigInt(t - 1)) - n;
        const b = (t) => new Uint8Array(t),
          w = (t) => Uint8Array.from(t);
        const v = {
          bigint: (t) => "bigint" == typeof t,
          function: (t) => "function" == typeof t,
          boolean: (t) => "boolean" == typeof t,
          string: (t) => "string" == typeof t,
          stringOrUint8Array: (t) => "string" == typeof t || o(t),
          isSafeInteger: (t) => Number.isSafeInteger(t),
          array: (t) => Array.isArray(t),
          field: (t, e) => e.Fp.isValid(t),
          hash: (t) =>
            "function" == typeof t && Number.isSafeInteger(t.outputLen),
        };
        e.notImplemented = () => {
          throw new Error("not implemented");
        };
      },
      91705: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DER = e.DERErr = void 0),
          (e.weierstrassPoints = g),
          (e.weierstrass = function (t) {
            const r = (function (t) {
                const e = (0, n.validateBasic)(t);
                return (
                  o.validateObject(
                    e,
                    { hash: "hash", hmac: "function", randomBytes: "function" },
                    {
                      bits2int: "function",
                      bits2int_modN: "function",
                      lowS: "boolean",
                    },
                  ),
                  Object.freeze({ lowS: !0, ...e })
                );
              })(t),
              { Fp: u, n: c } = r,
              f = u.BYTES + 1,
              d = 2 * u.BYTES + 1;
            function p(t) {
              return (0, i.mod)(t, c);
            }
            function y(t) {
              return (0, i.invert)(t, c);
            }
            const {
                ProjectivePoint: m,
                normPrivateKeyToScalar: b,
                weierstrassEquation: w,
                isWithinCurveOrder: v,
              } = g({
                ...r,
                toBytes(t, e, r) {
                  const n = e.toAffine(),
                    i = u.toBytes(n.x),
                    a = o.concatBytes;
                  return (
                    (0, s.abool)("isCompressed", r),
                    r
                      ? a(Uint8Array.from([e.hasEvenY() ? 2 : 3]), i)
                      : a(Uint8Array.from([4]), i, u.toBytes(n.y))
                  );
                },
                fromBytes(t) {
                  const e = t.length,
                    r = t[0],
                    n = t.subarray(1);
                  if (e !== f || (2 !== r && 3 !== r)) {
                    if (e === d && 4 === r) {
                      return {
                        x: u.fromBytes(n.subarray(0, u.BYTES)),
                        y: u.fromBytes(n.subarray(u.BYTES, 2 * u.BYTES)),
                      };
                    }
                    throw new Error(
                      "invalid Point, expected length of " +
                        f +
                        ", or uncompressed " +
                        d +
                        ", got " +
                        e,
                    );
                  }
                  {
                    const t = o.bytesToNumberBE(n);
                    if (!o.inRange(t, l, u.ORDER))
                      throw new Error("Point is not on curve");
                    const e = w(t);
                    let i;
                    try {
                      i = u.sqrt(e);
                    } catch (t) {
                      const e = t instanceof Error ? ": " + t.message : "";
                      throw new Error("Point is not on curve" + e);
                    }
                    return (
                      !(1 & ~r) !== ((i & l) === l) && (i = u.neg(i)),
                      { x: t, y: i }
                    );
                  }
                },
              }),
              _ = (t) => o.bytesToHex(o.numberToBytesBE(t, r.nByteLength));
            function E(t) {
              return t > c >> l;
            }
            const S = (t, e, r) => o.bytesToNumberBE(t.slice(e, r));
            class I {
              constructor(t, e, r) {
                (this.r = t),
                  (this.s = e),
                  (this.recovery = r),
                  this.assertValidity();
              }
              static fromCompact(t) {
                const e = r.nByteLength;
                return (
                  (t = (0, s.ensureBytes)("compactSignature", t, 2 * e)),
                  new I(S(t, 0, e), S(t, e, 2 * e))
                );
              }
              static fromDER(t) {
                const { r, s: n } = e.DER.toSig((0, s.ensureBytes)("DER", t));
                return new I(r, n);
              }
              assertValidity() {
                o.aInRange("r", this.r, l, c), o.aInRange("s", this.s, l, c);
              }
              addRecoveryBit(t) {
                return new I(this.r, this.s, t);
              }
              recoverPublicKey(t) {
                const { r: e, s: n, recovery: i } = this,
                  o = k((0, s.ensureBytes)("msgHash", t));
                if (null == i || ![0, 1, 2, 3].includes(i))
                  throw new Error("recovery id invalid");
                const a = 2 === i || 3 === i ? e + r.n : e;
                if (a >= u.ORDER) throw new Error("recovery id 2 or 3 invalid");
                const c = 1 & i ? "03" : "02",
                  f = m.fromHex(c + _(a)),
                  h = y(a),
                  l = p(-o * h),
                  d = p(n * h),
                  g = m.BASE.multiplyAndAddUnsafe(f, l, d);
                if (!g) throw new Error("point at infinify");
                return g.assertValidity(), g;
              }
              hasHighS() {
                return E(this.s);
              }
              normalizeS() {
                return this.hasHighS()
                  ? new I(this.r, p(-this.s), this.recovery)
                  : this;
              }
              toDERRawBytes() {
                return o.hexToBytes(this.toDERHex());
              }
              toDERHex() {
                return e.DER.hexFromSig({ r: this.r, s: this.s });
              }
              toCompactRawBytes() {
                return o.hexToBytes(this.toCompactHex());
              }
              toCompactHex() {
                return _(this.r) + _(this.s);
              }
            }
            const M = {
              isValidPrivateKey(t) {
                try {
                  return b(t), !0;
                } catch (t) {
                  return !1;
                }
              },
              normPrivateKeyToScalar: b,
              randomPrivateKey: () => {
                const t = (0, i.getMinHashLength)(r.n);
                return (0, i.mapHashToField)(r.randomBytes(t), r.n);
              },
              precompute: (t = 8, e = m.BASE) => (
                e._setWindowSize(t), e.multiply(BigInt(3)), e
              ),
            };
            function A(t) {
              const e = o.isBytes(t),
                r = "string" == typeof t,
                n = (e || r) && t.length;
              return e
                ? n === f || n === d
                : r
                  ? n === 2 * f || n === 2 * d
                  : t instanceof m;
            }
            const T =
                r.bits2int ||
                function (t) {
                  if (t.length > 8192) throw new Error("input is too large");
                  const e = o.bytesToNumberBE(t),
                    n = 8 * t.length - r.nBitLength;
                  return n > 0 ? e >> BigInt(n) : e;
                },
              k =
                r.bits2int_modN ||
                function (t) {
                  return p(T(t));
                },
              O = o.bitMask(r.nBitLength);
            function x(t) {
              return (
                o.aInRange("num < 2^" + r.nBitLength, t, h, O),
                o.numberToBytesBE(t, r.nByteLength)
              );
            }
            function P(t, e, n = B) {
              if (["recovered", "canonical"].some((t) => t in n))
                throw new Error("sign() legacy options not supported");
              const { hash: i, randomBytes: c } = r;
              let { lowS: f, prehash: d, extraEntropy: g } = n;
              null == f && (f = !0),
                (t = (0, s.ensureBytes)("msgHash", t)),
                a(n),
                d && (t = (0, s.ensureBytes)("prehashed msgHash", i(t)));
              const w = k(t),
                _ = b(e),
                S = [x(_), x(w)];
              if (null != g && !1 !== g) {
                const t = !0 === g ? c(u.BYTES) : g;
                S.push((0, s.ensureBytes)("extraEntropy", t));
              }
              const M = o.concatBytes(...S),
                A = w;
              return {
                seed: M,
                k2sig: function (t) {
                  const e = T(t);
                  if (!v(e)) return;
                  const r = y(e),
                    n = m.BASE.multiply(e).toAffine(),
                    i = p(n.x);
                  if (i === h) return;
                  const o = p(r * p(A + i * _));
                  if (o === h) return;
                  let s = (n.x === i ? 0 : 2) | Number(n.y & l),
                    a = o;
                  return (
                    f &&
                      E(o) &&
                      ((a = (function (t) {
                        return E(t) ? p(-t) : t;
                      })(o)),
                      (s ^= 1)),
                    new I(i, a, s)
                  );
                },
              };
            }
            const B = { lowS: r.lowS, prehash: !1 },
              C = { lowS: r.lowS, prehash: !1 };
            return (
              m.BASE._setWindowSize(8),
              {
                CURVE: r,
                getPublicKey: function (t, e = !0) {
                  return m.fromPrivateKey(t).toRawBytes(e);
                },
                getSharedSecret: function (t, e, r = !0) {
                  if (A(t)) throw new Error("first arg must be private key");
                  if (!A(e)) throw new Error("second arg must be public key");
                  return m.fromHex(e).multiply(b(t)).toRawBytes(r);
                },
                sign: function (t, e, n = B) {
                  const { seed: i, k2sig: s } = P(t, e, n),
                    a = r;
                  return o.createHmacDrbg(
                    a.hash.outputLen,
                    a.nByteLength,
                    a.hmac,
                  )(i, s);
                },
                verify: function (t, n, i, u = C) {
                  const c = t;
                  (n = (0, s.ensureBytes)("msgHash", n)),
                    (i = (0, s.ensureBytes)("publicKey", i));
                  const { lowS: f, prehash: h, format: l } = u;
                  if ((a(u), "strict" in u))
                    throw new Error("options.strict was renamed to lowS");
                  if (void 0 !== l && "compact" !== l && "der" !== l)
                    throw new Error("format must be compact or der");
                  const d = "string" == typeof c || o.isBytes(c),
                    g =
                      !d &&
                      !l &&
                      "object" == typeof c &&
                      null !== c &&
                      "bigint" == typeof c.r &&
                      "bigint" == typeof c.s;
                  if (!d && !g)
                    throw new Error(
                      "invalid signature, expected Uint8Array, hex string or Signature instance",
                    );
                  let b, w;
                  try {
                    if ((g && (b = new I(c.r, c.s)), d)) {
                      try {
                        "compact" !== l && (b = I.fromDER(c));
                      } catch (t) {
                        if (!(t instanceof e.DER.Err)) throw t;
                      }
                      b || "der" === l || (b = I.fromCompact(c));
                    }
                    w = m.fromHex(i);
                  } catch (t) {
                    return !1;
                  }
                  if (!b) return !1;
                  if (f && b.hasHighS()) return !1;
                  h && (n = r.hash(n));
                  const { r: v, s: _ } = b,
                    E = k(n),
                    S = y(_),
                    M = p(E * S),
                    A = p(v * S),
                    T = m.BASE.multiplyAndAddUnsafe(w, M, A)?.toAffine();
                  if (!T) return !1;
                  return p(T.x) === v;
                },
                ProjectivePoint: m,
                Signature: I,
                utils: M,
              }
            );
          }),
          (e.SWUFpSqrtRatio = m),
          (e.mapToCurveSimpleSWU = function (t, e) {
            if (
              ((0, i.validateField)(t),
              !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z))
            )
              throw new Error("mapToCurveSimpleSWU: invalid opts");
            const r = m(t, e.Z);
            if (!t.isOdd) throw new Error("Fp.isOdd is not implemented!");
            return (n) => {
              let i, o, s, a, u, c, f, h;
              (i = t.sqr(n)),
                (i = t.mul(i, e.Z)),
                (o = t.sqr(i)),
                (o = t.add(o, i)),
                (s = t.add(o, t.ONE)),
                (s = t.mul(s, e.B)),
                (a = t.cmov(e.Z, t.neg(o), !t.eql(o, t.ZERO))),
                (a = t.mul(a, e.A)),
                (o = t.sqr(s)),
                (c = t.sqr(a)),
                (u = t.mul(c, e.A)),
                (o = t.add(o, u)),
                (o = t.mul(o, s)),
                (c = t.mul(c, a)),
                (u = t.mul(c, e.B)),
                (o = t.add(o, u)),
                (f = t.mul(i, s));
              const { isValid: l, value: d } = r(o, c);
              (h = t.mul(i, n)),
                (h = t.mul(h, d)),
                (f = t.cmov(f, s, l)),
                (h = t.cmov(h, d, l));
              const p = t.isOdd(n) === t.isOdd(h);
              return (
                (h = t.cmov(t.neg(h), h, p)), (f = t.div(f, a)), { x: f, y: h }
              );
            };
          });
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const n = r(62422),
          i = r(24967),
          o = r(91484),
          s = r(91484);
        function a(t) {
          void 0 !== t.lowS && (0, s.abool)("lowS", t.lowS),
            void 0 !== t.prehash && (0, s.abool)("prehash", t.prehash);
        }
        const { bytesToNumberBE: u, hexToBytes: c } = o;
        class f extends Error {
          constructor(t = "") {
            super(t);
          }
        }
        (e.DERErr = f),
          (e.DER = {
            Err: f,
            _tlv: {
              encode: (t, r) => {
                const { Err: n } = e.DER;
                if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
                if (1 & r.length) throw new n("tlv.encode: unpadded data");
                const i = r.length / 2,
                  s = o.numberToHexUnpadded(i);
                if ((s.length / 2) & 128)
                  throw new n("tlv.encode: long form length too big");
                const a =
                  i > 127 ? o.numberToHexUnpadded((s.length / 2) | 128) : "";
                return o.numberToHexUnpadded(t) + a + s + r;
              },
              decode(t, r) {
                const { Err: n } = e.DER;
                let i = 0;
                if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
                if (r.length < 2 || r[i++] !== t)
                  throw new n("tlv.decode: wrong tlv");
                const o = r[i++];
                let s = 0;
                if (!!(128 & o)) {
                  const t = 127 & o;
                  if (!t)
                    throw new n(
                      "tlv.decode(long): indefinite length not supported",
                    );
                  if (t > 4)
                    throw new n("tlv.decode(long): byte length is too big");
                  const e = r.subarray(i, i + t);
                  if (e.length !== t)
                    throw new n("tlv.decode: length bytes not complete");
                  if (0 === e[0])
                    throw new n("tlv.decode(long): zero leftmost byte");
                  for (const t of e) s = (s << 8) | t;
                  if (((i += t), s < 128))
                    throw new n("tlv.decode(long): not minimal encoding");
                } else s = o;
                const a = r.subarray(i, i + s);
                if (a.length !== s)
                  throw new n("tlv.decode: wrong value length");
                return { v: a, l: r.subarray(i + s) };
              },
            },
            _int: {
              encode(t) {
                const { Err: r } = e.DER;
                if (t < h)
                  throw new r("integer: negative integers are not allowed");
                let n = o.numberToHexUnpadded(t);
                if (
                  (8 & Number.parseInt(n[0], 16) && (n = "00" + n),
                  1 & n.length)
                )
                  throw new r("unexpected DER parsing assertion: unpadded hex");
                return n;
              },
              decode(t) {
                const { Err: r } = e.DER;
                if (128 & t[0])
                  throw new r("invalid signature integer: negative");
                if (0 === t[0] && !(128 & t[1]))
                  throw new r(
                    "invalid signature integer: unnecessary leading zero",
                  );
                return u(t);
              },
            },
            toSig(t) {
              const { Err: r, _int: n, _tlv: i } = e.DER,
                s = "string" == typeof t ? c(t) : t;
              o.abytes(s);
              const { v: a, l: u } = i.decode(48, s);
              if (u.length)
                throw new r("invalid signature: left bytes after parsing");
              const { v: f, l: h } = i.decode(2, a),
                { v: l, l: d } = i.decode(2, h);
              if (d.length)
                throw new r("invalid signature: left bytes after parsing");
              return { r: n.decode(f), s: n.decode(l) };
            },
            hexFromSig(t) {
              const { _tlv: r, _int: n } = e.DER,
                i = r.encode(2, n.encode(t.r)) + r.encode(2, n.encode(t.s));
              return r.encode(48, i);
            },
          });
        const h = BigInt(0),
          l = BigInt(1),
          d = BigInt(2),
          p = BigInt(3),
          y = BigInt(4);
        function g(t) {
          const e = (function (t) {
              const e = (0, n.validateBasic)(t);
              o.validateObject(
                e,
                { a: "field", b: "field" },
                {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                  fromBytes: "function",
                  toBytes: "function",
                },
              );
              const { endo: r, Fp: i, a: s } = e;
              if (r) {
                if (!i.eql(s, i.ZERO))
                  throw new Error(
                    "invalid endomorphism, can only be defined for Koblitz curves that have a=0",
                  );
                if (
                  "object" != typeof r ||
                  "bigint" != typeof r.beta ||
                  "function" != typeof r.splitScalar
                )
                  throw new Error(
                    "invalid endomorphism, expected beta: bigint and splitScalar: function",
                  );
              }
              return Object.freeze({ ...e });
            })(t),
            { Fp: r } = e,
            a = (0, i.Field)(e.n, e.nBitLength),
            u =
              e.toBytes ||
              ((t, e, n) => {
                const i = e.toAffine();
                return o.concatBytes(
                  Uint8Array.from([4]),
                  r.toBytes(i.x),
                  r.toBytes(i.y),
                );
              }),
            c =
              e.fromBytes ||
              ((t) => {
                const e = t.subarray(1);
                return {
                  x: r.fromBytes(e.subarray(0, r.BYTES)),
                  y: r.fromBytes(e.subarray(r.BYTES, 2 * r.BYTES)),
                };
              });
          function f(t) {
            const { a: n, b: i } = e,
              o = r.sqr(t),
              s = r.mul(o, t);
            return r.add(r.add(s, r.mul(t, n)), i);
          }
          if (!r.eql(r.sqr(e.Gy), f(e.Gx)))
            throw new Error("bad generator point: equation left != right");
          function d(t) {
            const {
              allowedPrivateKeyLengths: r,
              nByteLength: n,
              wrapPrivateKey: a,
              n: u,
            } = e;
            if (r && "bigint" != typeof t) {
              if (
                (o.isBytes(t) && (t = o.bytesToHex(t)),
                "string" != typeof t || !r.includes(t.length))
              )
                throw new Error("invalid private key");
              t = t.padStart(2 * n, "0");
            }
            let c;
            try {
              c =
                "bigint" == typeof t
                  ? t
                  : o.bytesToNumberBE((0, s.ensureBytes)("private key", t, n));
            } catch (e) {
              throw new Error(
                "invalid private key, expected hex or " +
                  n +
                  " bytes, got " +
                  typeof t,
              );
            }
            return (
              a && (c = (0, i.mod)(c, u)), o.aInRange("private key", c, l, u), c
            );
          }
          function y(t) {
            if (!(t instanceof b)) throw new Error("ProjectivePoint expected");
          }
          const g = (0, s.memoized)((t, e) => {
              const { px: n, py: i, pz: o } = t;
              if (r.eql(o, r.ONE)) return { x: n, y: i };
              const s = t.is0();
              null == e && (e = s ? r.ONE : r.inv(o));
              const a = r.mul(n, e),
                u = r.mul(i, e),
                c = r.mul(o, e);
              if (s) return { x: r.ZERO, y: r.ZERO };
              if (!r.eql(c, r.ONE)) throw new Error("invZ was invalid");
              return { x: a, y: u };
            }),
            m = (0, s.memoized)((t) => {
              if (t.is0()) {
                if (e.allowInfinityPoint && !r.is0(t.py)) return;
                throw new Error("bad point: ZERO");
              }
              const { x: n, y: i } = t.toAffine();
              if (!r.isValid(n) || !r.isValid(i))
                throw new Error("bad point: x or y not FE");
              const o = r.sqr(i),
                s = f(n);
              if (!r.eql(o, s))
                throw new Error("bad point: equation left != right");
              if (!t.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup");
              return !0;
            });
          class b {
            constructor(t, e, n) {
              if (
                ((this.px = t),
                (this.py = e),
                (this.pz = n),
                null == t || !r.isValid(t))
              )
                throw new Error("x required");
              if (null == e || !r.isValid(e)) throw new Error("y required");
              if (null == n || !r.isValid(n)) throw new Error("z required");
              Object.freeze(this);
            }
            static fromAffine(t) {
              const { x: e, y: n } = t || {};
              if (!t || !r.isValid(e) || !r.isValid(n))
                throw new Error("invalid affine point");
              if (t instanceof b)
                throw new Error("projective point not allowed");
              const i = (t) => r.eql(t, r.ZERO);
              return i(e) && i(n) ? b.ZERO : new b(e, n, r.ONE);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static normalizeZ(t) {
              const e = r.invertBatch(t.map((t) => t.pz));
              return t.map((t, r) => t.toAffine(e[r])).map(b.fromAffine);
            }
            static fromHex(t) {
              const e = b.fromAffine(c((0, s.ensureBytes)("pointHex", t)));
              return e.assertValidity(), e;
            }
            static fromPrivateKey(t) {
              return b.BASE.multiply(d(t));
            }
            static msm(t, e) {
              return (0, n.pippenger)(b, a, t, e);
            }
            _setWindowSize(t) {
              v.setWindowSize(this, t);
            }
            assertValidity() {
              m(this);
            }
            hasEvenY() {
              const { y: t } = this.toAffine();
              if (r.isOdd) return !r.isOdd(t);
              throw new Error("Field doesn't support isOdd");
            }
            equals(t) {
              y(t);
              const { px: e, py: n, pz: i } = this,
                { px: o, py: s, pz: a } = t,
                u = r.eql(r.mul(e, a), r.mul(o, i)),
                c = r.eql(r.mul(n, a), r.mul(s, i));
              return u && c;
            }
            negate() {
              return new b(this.px, r.neg(this.py), this.pz);
            }
            double() {
              const { a: t, b: n } = e,
                i = r.mul(n, p),
                { px: o, py: s, pz: a } = this;
              let u = r.ZERO,
                c = r.ZERO,
                f = r.ZERO,
                h = r.mul(o, o),
                l = r.mul(s, s),
                d = r.mul(a, a),
                y = r.mul(o, s);
              return (
                (y = r.add(y, y)),
                (f = r.mul(o, a)),
                (f = r.add(f, f)),
                (u = r.mul(t, f)),
                (c = r.mul(i, d)),
                (c = r.add(u, c)),
                (u = r.sub(l, c)),
                (c = r.add(l, c)),
                (c = r.mul(u, c)),
                (u = r.mul(y, u)),
                (f = r.mul(i, f)),
                (d = r.mul(t, d)),
                (y = r.sub(h, d)),
                (y = r.mul(t, y)),
                (y = r.add(y, f)),
                (f = r.add(h, h)),
                (h = r.add(f, h)),
                (h = r.add(h, d)),
                (h = r.mul(h, y)),
                (c = r.add(c, h)),
                (d = r.mul(s, a)),
                (d = r.add(d, d)),
                (h = r.mul(d, y)),
                (u = r.sub(u, h)),
                (f = r.mul(d, l)),
                (f = r.add(f, f)),
                (f = r.add(f, f)),
                new b(u, c, f)
              );
            }
            add(t) {
              y(t);
              const { px: n, py: i, pz: o } = this,
                { px: s, py: a, pz: u } = t;
              let c = r.ZERO,
                f = r.ZERO,
                h = r.ZERO;
              const l = e.a,
                d = r.mul(e.b, p);
              let g = r.mul(n, s),
                m = r.mul(i, a),
                w = r.mul(o, u),
                v = r.add(n, i),
                _ = r.add(s, a);
              (v = r.mul(v, _)),
                (_ = r.add(g, m)),
                (v = r.sub(v, _)),
                (_ = r.add(n, o));
              let E = r.add(s, u);
              return (
                (_ = r.mul(_, E)),
                (E = r.add(g, w)),
                (_ = r.sub(_, E)),
                (E = r.add(i, o)),
                (c = r.add(a, u)),
                (E = r.mul(E, c)),
                (c = r.add(m, w)),
                (E = r.sub(E, c)),
                (h = r.mul(l, _)),
                (c = r.mul(d, w)),
                (h = r.add(c, h)),
                (c = r.sub(m, h)),
                (h = r.add(m, h)),
                (f = r.mul(c, h)),
                (m = r.add(g, g)),
                (m = r.add(m, g)),
                (w = r.mul(l, w)),
                (_ = r.mul(d, _)),
                (m = r.add(m, w)),
                (w = r.sub(g, w)),
                (w = r.mul(l, w)),
                (_ = r.add(_, w)),
                (g = r.mul(m, _)),
                (f = r.add(f, g)),
                (g = r.mul(E, _)),
                (c = r.mul(v, c)),
                (c = r.sub(c, g)),
                (g = r.mul(v, m)),
                (h = r.mul(E, h)),
                (h = r.add(h, g)),
                new b(c, f, h)
              );
            }
            subtract(t) {
              return this.add(t.negate());
            }
            is0() {
              return this.equals(b.ZERO);
            }
            wNAF(t) {
              return v.wNAFCached(this, t, b.normalizeZ);
            }
            multiplyUnsafe(t) {
              const { endo: n, n: i } = e;
              o.aInRange("scalar", t, h, i);
              const s = b.ZERO;
              if (t === h) return s;
              if (this.is0() || t === l) return this;
              if (!n || v.hasPrecomputes(this))
                return v.wNAFCachedUnsafe(this, t, b.normalizeZ);
              let { k1neg: a, k1: u, k2neg: c, k2: f } = n.splitScalar(t),
                d = s,
                p = s,
                y = this;
              for (; u > h || f > h; )
                u & l && (d = d.add(y)),
                  f & l && (p = p.add(y)),
                  (y = y.double()),
                  (u >>= l),
                  (f >>= l);
              return (
                a && (d = d.negate()),
                c && (p = p.negate()),
                (p = new b(r.mul(p.px, n.beta), p.py, p.pz)),
                d.add(p)
              );
            }
            multiply(t) {
              const { endo: n, n: i } = e;
              let s, a;
              if ((o.aInRange("scalar", t, l, i), n)) {
                const { k1neg: e, k1: i, k2neg: o, k2: u } = n.splitScalar(t);
                let { p: c, f } = this.wNAF(i),
                  { p: h, f: l } = this.wNAF(u);
                (c = v.constTimeNegate(e, c)),
                  (h = v.constTimeNegate(o, h)),
                  (h = new b(r.mul(h.px, n.beta), h.py, h.pz)),
                  (s = c.add(h)),
                  (a = f.add(l));
              } else {
                const { p: e, f: r } = this.wNAF(t);
                (s = e), (a = r);
              }
              return b.normalizeZ([s, a])[0];
            }
            multiplyAndAddUnsafe(t, e, r) {
              const n = b.BASE,
                i = (t, e) =>
                  e !== h && e !== l && t.equals(n)
                    ? t.multiply(e)
                    : t.multiplyUnsafe(e),
                o = i(this, e).add(i(t, r));
              return o.is0() ? void 0 : o;
            }
            toAffine(t) {
              return g(this, t);
            }
            isTorsionFree() {
              const { h: t, isTorsionFree: r } = e;
              if (t === l) return !0;
              if (r) return r(b, this);
              throw new Error(
                "isTorsionFree() has not been declared for the elliptic curve",
              );
            }
            clearCofactor() {
              const { h: t, clearCofactor: r } = e;
              return t === l ? this : r ? r(b, this) : this.multiplyUnsafe(e.h);
            }
            toRawBytes(t = !0) {
              return (
                (0, s.abool)("isCompressed", t),
                this.assertValidity(),
                u(b, this, t)
              );
            }
            toHex(t = !0) {
              return (
                (0, s.abool)("isCompressed", t),
                o.bytesToHex(this.toRawBytes(t))
              );
            }
          }
          (b.BASE = new b(e.Gx, e.Gy, r.ONE)),
            (b.ZERO = new b(r.ZERO, r.ONE, r.ZERO));
          const w = e.nBitLength,
            v = (0, n.wNAF)(b, e.endo ? Math.ceil(w / 2) : w);
          return {
            CURVE: e,
            ProjectivePoint: b,
            normPrivateKeyToScalar: d,
            weierstrassEquation: f,
            isWithinCurveOrder: function (t) {
              return o.inRange(t, l, e.n);
            },
          };
        }
        function m(t, e) {
          const r = t.ORDER;
          let n = h;
          for (let t = r - l; t % d === h; t /= d) n += l;
          const i = n,
            o = d << (i - l - l),
            s = o * d,
            a = (r - l) / s,
            u = (a - l) / d,
            c = s - l,
            f = o,
            g = t.pow(e, a),
            m = t.pow(e, (a + l) / d);
          let b = (e, r) => {
            let n = g,
              o = t.pow(r, c),
              s = t.sqr(o);
            s = t.mul(s, r);
            let a = t.mul(e, s);
            (a = t.pow(a, u)),
              (a = t.mul(a, o)),
              (o = t.mul(a, r)),
              (s = t.mul(a, e));
            let h = t.mul(s, o);
            a = t.pow(h, f);
            let p = t.eql(a, t.ONE);
            (o = t.mul(s, m)),
              (a = t.mul(h, n)),
              (s = t.cmov(o, s, p)),
              (h = t.cmov(a, h, p));
            for (let e = i; e > l; e--) {
              let r = e - d;
              r = d << (r - l);
              let i = t.pow(h, r);
              const a = t.eql(i, t.ONE);
              (o = t.mul(s, n)),
                (n = t.mul(n, n)),
                (i = t.mul(h, n)),
                (s = t.cmov(o, s, a)),
                (h = t.cmov(i, h, a));
            }
            return { isValid: p, value: s };
          };
          if (t.ORDER % y === p) {
            const r = (t.ORDER - p) / y,
              n = t.sqrt(t.neg(e));
            b = (e, i) => {
              let o = t.sqr(i);
              const s = t.mul(e, i);
              o = t.mul(o, s);
              let a = t.pow(o, r);
              a = t.mul(a, s);
              const u = t.mul(a, n),
                c = t.mul(t.sqr(a), i),
                f = t.eql(c, e);
              return { isValid: f, value: t.cmov(u, a, f) };
            };
          }
          return b;
        }
      },
      8510: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0);
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const n = r(22623),
          i = r(99175),
          o = r(73562),
          s = r(71761),
          a = r(24967),
          u = r(91484),
          c = r(91705),
          f = BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
          ),
          h = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
          ),
          l = BigInt(1),
          d = BigInt(2),
          p = (t, e) => (t + e / d) / e;
        function y(t) {
          const e = f,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            u = BigInt(44),
            c = BigInt(88),
            h = (t * t * t) % e,
            l = (h * h * t) % e,
            p = ((0, a.pow2)(l, r, e) * l) % e,
            y = ((0, a.pow2)(p, r, e) * l) % e,
            m = ((0, a.pow2)(y, d, e) * h) % e,
            b = ((0, a.pow2)(m, i, e) * m) % e,
            w = ((0, a.pow2)(b, o, e) * b) % e,
            v = ((0, a.pow2)(w, u, e) * w) % e,
            _ = ((0, a.pow2)(v, c, e) * v) % e,
            E = ((0, a.pow2)(_, u, e) * w) % e,
            S = ((0, a.pow2)(E, r, e) * l) % e,
            I = ((0, a.pow2)(S, s, e) * b) % e,
            M = ((0, a.pow2)(I, n, e) * h) % e,
            A = (0, a.pow2)(M, d, e);
          if (!g.eql(g.sqr(A), t)) throw new Error("Cannot find square root");
          return A;
        }
        const g = (0, a.Field)(f, void 0, void 0, { sqrt: y });
        e.secp256k1 = (0, o.createCurve)(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: g,
            n: h,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240",
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424",
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
              ),
              splitScalar: (t) => {
                const e = h,
                  r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  n = -l * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  o = r,
                  s = BigInt("0x100000000000000000000000000000000"),
                  u = p(o * t, e),
                  c = p(-n * t, e);
                let f = (0, a.mod)(t - u * r - c * i, e),
                  d = (0, a.mod)(-u * n - c * o, e);
                const y = f > s,
                  g = d > s;
                if ((y && (f = e - f), g && (d = e - d), f > s || d > s))
                  throw new Error("splitScalar: Endomorphism failed, k=" + t);
                return { k1neg: y, k1: f, k2neg: g, k2: d };
              },
            },
          },
          n.sha256,
        );
        const m = BigInt(0),
          b = {};
        function w(t, ...e) {
          let r = b[t];
          if (void 0 === r) {
            const e = (0, n.sha256)(Uint8Array.from(t, (t) => t.charCodeAt(0)));
            (r = (0, u.concatBytes)(e, e)), (b[t] = r);
          }
          return (0, n.sha256)((0, u.concatBytes)(r, ...e));
        }
        const v = (t) => t.toRawBytes(!0).slice(1),
          _ = (t) => (0, u.numberToBytesBE)(t, 32),
          E = (t) => (0, a.mod)(t, f),
          S = (t) => (0, a.mod)(t, h),
          I = e.secp256k1.ProjectivePoint;
        function M(t) {
          let r = e.secp256k1.utils.normPrivateKeyToScalar(t),
            n = I.fromPrivateKey(r);
          return { scalar: n.hasEvenY() ? r : S(-r), bytes: v(n) };
        }
        function A(t) {
          (0, u.aInRange)("x", t, l, f);
          const e = E(t * t);
          let r = y(E(e * t + BigInt(7)));
          r % d !== m && (r = E(-r));
          const n = new I(t, r, l);
          return n.assertValidity(), n;
        }
        const T = u.bytesToNumberBE;
        function k(...t) {
          return S(T(w("BIP0340/challenge", ...t)));
        }
        function O(t) {
          return M(t).bytes;
        }
        function x(t, e, r = (0, i.randomBytes)(32)) {
          const n = (0, u.ensureBytes)("message", t),
            { bytes: o, scalar: s } = M(e),
            a = (0, u.ensureBytes)("auxRand", r, 32),
            c = _(s ^ T(w("BIP0340/aux", a))),
            f = w("BIP0340/nonce", c, o, n),
            h = S(T(f));
          if (h === m) throw new Error("sign failed: k is zero");
          const { bytes: l, scalar: d } = M(h),
            p = k(l, o, n),
            y = new Uint8Array(64);
          if ((y.set(l, 0), y.set(_(S(d + p * s)), 32), !P(y, n, o)))
            throw new Error("sign: Invalid signature produced");
          return y;
        }
        function P(t, e, r) {
          const n = (0, u.ensureBytes)("signature", t, 64),
            i = (0, u.ensureBytes)("message", e),
            o = (0, u.ensureBytes)("publicKey", r, 32);
          try {
            const t = A(T(o)),
              e = T(n.subarray(0, 32));
            if (!(0, u.inRange)(e, l, f)) return !1;
            const r = T(n.subarray(32, 64));
            if (!(0, u.inRange)(r, l, h)) return !1;
            const d = k(_(e), v(t), i),
              p =
                ((s = t),
                (a = r),
                (c = S(-d)),
                I.BASE.multiplyAndAddUnsafe(s, a, c));
            return !(!p || !p.hasEvenY() || p.toAffine().x !== e);
          } catch (t) {
            return !1;
          }
          var s, a, c;
        }
        e.schnorr = {
          getPublicKey: O,
          sign: x,
          verify: P,
          utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: A,
            pointToBytes: v,
            numberToBytesBE: u.numberToBytesBE,
            bytesToNumberBE: u.bytesToNumberBE,
            taggedHash: w,
            mod: a.mod,
          },
        };
        const B = (() =>
            (0, s.isogenyMap)(
              g,
              [
                [
                  "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
                  "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
                  "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
                  "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
                ],
                [
                  "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
                  "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
                  "0x0000000000000000000000000000000000000000000000000000000000000001",
                ],
                [
                  "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
                  "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
                  "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
                  "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
                ],
                [
                  "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
                  "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
                  "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
                  "0x0000000000000000000000000000000000000000000000000000000000000001",
                ],
              ].map((t) => t.map((t) => BigInt(t))),
            ))(),
          C = (() =>
            (0, c.mapToCurveSimpleSWU)(g, {
              A: BigInt(
                "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533",
              ),
              B: BigInt("1771"),
              Z: g.create(BigInt("-11")),
            }))(),
          R = (() =>
            (0, s.createHasher)(
              e.secp256k1.ProjectivePoint,
              (t) => {
                const { x: e, y: r } = C(g.create(t[0]));
                return B(e, r);
              },
              {
                DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
                encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
                p: g.ORDER,
                m: 1,
                k: 128,
                expand: "xmd",
                hash: n.sha256,
              },
            ))();
        (e.hashToCurve = R.hashToCurve), (e.encodeToCurve = R.encodeToCurve);
      },
      67557: (t, e) => {
        "use strict";
        function r(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error("positive integer expected, got " + t);
        }
        function n(t, ...e) {
          if (
            !(
              (r = t) instanceof Uint8Array ||
              (ArrayBuffer.isView(r) && "Uint8Array" === r.constructor.name)
            )
          )
            throw new Error("Uint8Array expected");
          var r;
          if (e.length > 0 && !e.includes(t.length))
            throw new Error(
              "Uint8Array expected of length " + e + ", got length=" + t.length,
            );
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.anumber = r),
          (e.abytes = n),
          (e.ahash = function (t) {
            if ("function" != typeof t || "function" != typeof t.create)
              throw new Error(
                "Hash should be wrapped by utils.wrapConstructor",
              );
            r(t.outputLen), r(t.blockLen);
          }),
          (e.aexists = function (t, e = !0) {
            if (t.destroyed)
              throw new Error("Hash instance has been destroyed");
            if (e && t.finished)
              throw new Error("Hash#digest() has already been called");
          }),
          (e.aoutput = function (t, e) {
            n(t);
            const r = e.outputLen;
            if (t.length < r)
              throw new Error(
                "digestInto() expects output buffer of length at least " + r,
              );
          });
      },
      37202: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.HashMD = void 0),
          (e.setBigUint64 = o),
          (e.Chi = function (t, e, r) {
            return (t & e) ^ (~t & r);
          }),
          (e.Maj = function (t, e, r) {
            return (t & e) ^ (t & r) ^ (e & r);
          });
        const n = r(67557),
          i = r(99175);
        function o(t, e, r, n) {
          if ("function" == typeof t.setBigUint64)
            return t.setBigUint64(e, r, n);
          const i = BigInt(32),
            o = BigInt(4294967295),
            s = Number((r >> i) & o),
            a = Number(r & o),
            u = n ? 4 : 0,
            c = n ? 0 : 4;
          t.setUint32(e + u, s, n), t.setUint32(e + c, a, n);
        }
        class s extends i.Hash {
          constructor(t, e, r, n) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = r),
              (this.isLE = n),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = (0, i.createView)(this.buffer));
          }
          update(t) {
            (0, n.aexists)(this);
            const { view: e, buffer: r, blockLen: o } = this,
              s = (t = (0, i.toBytes)(t)).length;
            for (let n = 0; n < s; ) {
              const a = Math.min(o - this.pos, s - n);
              if (a !== o)
                r.set(t.subarray(n, n + a), this.pos),
                  (this.pos += a),
                  (n += a),
                  this.pos === o && (this.process(e, 0), (this.pos = 0));
              else {
                const e = (0, i.createView)(t);
                for (; o <= s - n; n += o) this.process(e, n);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            (0, n.aexists)(this), (0, n.aoutput)(t, this), (this.finished = !0);
            const { buffer: e, view: r, blockLen: s, isLE: a } = this;
            let { pos: u } = this;
            (e[u++] = 128),
              this.buffer.subarray(u).fill(0),
              this.padOffset > s - u && (this.process(r, 0), (u = 0));
            for (let t = u; t < s; t++) e[t] = 0;
            o(r, s - 8, BigInt(8 * this.length), a), this.process(r, 0);
            const c = (0, i.createView)(t),
              f = this.outputLen;
            if (f % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const h = f / 4,
              l = this.get();
            if (h > l.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let t = 0; t < h; t++) c.setUint32(4 * t, l[t], a);
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const r = t.slice(0, e);
            return this.destroy(), r;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: r,
              length: n,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (t.length = n),
              (t.pos = s),
              (t.finished = i),
              (t.destroyed = o),
              n % e && t.buffer.set(r),
              t
            );
          }
        }
        e.HashMD = s;
      },
      22318: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.add5L =
            e.add5H =
            e.add4H =
            e.add4L =
            e.add3H =
            e.add3L =
            e.rotlBL =
            e.rotlBH =
            e.rotlSL =
            e.rotlSH =
            e.rotr32L =
            e.rotr32H =
            e.rotrBL =
            e.rotrBH =
            e.rotrSL =
            e.rotrSH =
            e.shrSL =
            e.shrSH =
            e.toBig =
              void 0),
          (e.fromBig = i),
          (e.split = o),
          (e.add = w);
        const r = BigInt(2 ** 32 - 1),
          n = BigInt(32);
        function i(t, e = !1) {
          return e
            ? { h: Number(t & r), l: Number((t >> n) & r) }
            : { h: 0 | Number((t >> n) & r), l: 0 | Number(t & r) };
        }
        function o(t, e = !1) {
          let r = new Uint32Array(t.length),
            n = new Uint32Array(t.length);
          for (let o = 0; o < t.length; o++) {
            const { h: s, l: a } = i(t[o], e);
            [r[o], n[o]] = [s, a];
          }
          return [r, n];
        }
        const s = (t, e) => (BigInt(t >>> 0) << n) | BigInt(e >>> 0);
        e.toBig = s;
        const a = (t, e, r) => t >>> r;
        e.shrSH = a;
        const u = (t, e, r) => (t << (32 - r)) | (e >>> r);
        e.shrSL = u;
        const c = (t, e, r) => (t >>> r) | (e << (32 - r));
        e.rotrSH = c;
        const f = (t, e, r) => (t << (32 - r)) | (e >>> r);
        e.rotrSL = f;
        const h = (t, e, r) => (t << (64 - r)) | (e >>> (r - 32));
        e.rotrBH = h;
        const l = (t, e, r) => (t >>> (r - 32)) | (e << (64 - r));
        e.rotrBL = l;
        const d = (t, e) => e;
        e.rotr32H = d;
        const p = (t, e) => t;
        e.rotr32L = p;
        const y = (t, e, r) => (t << r) | (e >>> (32 - r));
        e.rotlSH = y;
        const g = (t, e, r) => (e << r) | (t >>> (32 - r));
        e.rotlSL = g;
        const m = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r));
        e.rotlBH = m;
        const b = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r));
        function w(t, e, r, n) {
          const i = (e >>> 0) + (n >>> 0);
          return { h: (t + r + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
        }
        e.rotlBL = b;
        const v = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0);
        e.add3L = v;
        const _ = (t, e, r, n) => (e + r + n + ((t / 2 ** 32) | 0)) | 0;
        e.add3H = _;
        const E = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0);
        e.add4L = E;
        const S = (t, e, r, n, i) => (e + r + n + i + ((t / 2 ** 32) | 0)) | 0;
        e.add4H = S;
        const I = (t, e, r, n, i) =>
          (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
        e.add5L = I;
        const M = (t, e, r, n, i, o) =>
          (e + r + n + i + o + ((t / 2 ** 32) | 0)) | 0;
        e.add5H = M;
        const A = {
          fromBig: i,
          split: o,
          toBig: s,
          shrSH: a,
          shrSL: u,
          rotrSH: c,
          rotrSL: f,
          rotrBH: h,
          rotrBL: l,
          rotr32H: d,
          rotr32L: p,
          rotlSH: y,
          rotlSL: g,
          rotlBH: m,
          rotlBL: b,
          add: w,
          add3L: v,
          add3H: _,
          add4L: E,
          add4H: S,
          add5H: M,
          add5L: I,
        };
        e.default = A;
      },
      25145: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.crypto = void 0),
          (e.crypto =
            "object" == typeof globalThis && "crypto" in globalThis
              ? globalThis.crypto
              : void 0);
      },
      39615: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.hmac = e.HMAC = void 0);
        const n = r(67557),
          i = r(99175);
        class o extends i.Hash {
          constructor(t, e) {
            super(),
              (this.finished = !1),
              (this.destroyed = !1),
              (0, n.ahash)(t);
            const r = (0, i.toBytes)(e);
            if (
              ((this.iHash = t.create()),
              "function" != typeof this.iHash.update)
            )
              throw new Error(
                "Expected instance of class which extends utils.Hash",
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const o = this.blockLen,
              s = new Uint8Array(o);
            s.set(r.length > o ? t.create().update(r).digest() : r);
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return (0, n.aexists)(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            (0, n.aexists)(this),
              (0, n.abytes)(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: r,
              finished: n,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (t.finished = n),
              (t.destroyed = i),
              (t.blockLen = o),
              (t.outputLen = s),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = r._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        e.HMAC = o;
        (e.hmac = (t, e, r) => new o(t, e).update(r).digest()),
          (e.hmac.create = (t, e) => new o(t, e));
      },
      93238: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ripemd160 = e.RIPEMD160 = void 0);
        const n = r(37202),
          i = r(99175),
          o = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          s = new Uint8Array(new Array(16).fill(0).map((t, e) => e));
        let a = [s],
          u = [s.map((t) => (9 * t + 5) % 16)];
        for (let t = 0; t < 4; t++)
          for (let e of [a, u]) e.push(e[t].map((t) => o[t]));
        const c = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((t) => new Uint8Array(t)),
          f = a.map((t, e) => t.map((t) => c[e][t])),
          h = u.map((t, e) => t.map((t) => c[e][t])),
          l = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          d = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]);
        function p(t, e, r, n) {
          return 0 === t
            ? e ^ r ^ n
            : 1 === t
              ? (e & r) | (~e & n)
              : 2 === t
                ? (e | ~r) ^ n
                : 3 === t
                  ? (e & n) | (r & ~n)
                  : e ^ (r | ~n);
        }
        const y = new Uint32Array(16);
        class g extends n.HashMD {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: t, h1: e, h2: r, h3: n, h4: i } = this;
            return [t, e, r, n, i];
          }
          set(t, e, r, n, i) {
            (this.h0 = 0 | t),
              (this.h1 = 0 | e),
              (this.h2 = 0 | r),
              (this.h3 = 0 | n),
              (this.h4 = 0 | i);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4) y[r] = t.getUint32(e, !0);
            let r = 0 | this.h0,
              n = r,
              o = 0 | this.h1,
              s = o,
              c = 0 | this.h2,
              g = c,
              m = 0 | this.h3,
              b = m,
              w = 0 | this.h4,
              v = w;
            for (let t = 0; t < 5; t++) {
              const e = 4 - t,
                _ = l[t],
                E = d[t],
                S = a[t],
                I = u[t],
                M = f[t],
                A = h[t];
              for (let e = 0; e < 16; e++) {
                const n =
                  ((0, i.rotl)(r + p(t, o, c, m) + y[S[e]] + _, M[e]) + w) | 0;
                (r = w),
                  (w = m),
                  (m = 0 | (0, i.rotl)(c, 10)),
                  (c = o),
                  (o = n);
              }
              for (let t = 0; t < 16; t++) {
                const r =
                  ((0, i.rotl)(n + p(e, s, g, b) + y[I[t]] + E, A[t]) + v) | 0;
                (n = v),
                  (v = b),
                  (b = 0 | (0, i.rotl)(g, 10)),
                  (g = s),
                  (s = r);
              }
            }
            this.set(
              (this.h1 + c + b) | 0,
              (this.h2 + m + v) | 0,
              (this.h3 + w + n) | 0,
              (this.h4 + r + s) | 0,
              (this.h0 + o + g) | 0,
            );
          }
          roundClean() {
            y.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        (e.RIPEMD160 = g),
          (e.ripemd160 = (0, i.wrapConstructor)(() => new g()));
      },
      31549: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.sha1 = e.SHA1 = void 0);
        const n = r(37202),
          i = r(99175),
          o = new Uint32Array([
            1732584193, 4023233417, 2562383102, 271733878, 3285377520,
          ]),
          s = new Uint32Array(80);
        class a extends n.HashMD {
          constructor() {
            super(64, 20, 8, !1),
              (this.A = 0 | o[0]),
              (this.B = 0 | o[1]),
              (this.C = 0 | o[2]),
              (this.D = 0 | o[3]),
              (this.E = 0 | o[4]);
          }
          get() {
            const { A: t, B: e, C: r, D: n, E: i } = this;
            return [t, e, r, n, i];
          }
          set(t, e, r, n, i) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | r),
              (this.D = 0 | n),
              (this.E = 0 | i);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4) s[r] = t.getUint32(e, !1);
            for (let t = 16; t < 80; t++)
              s[t] = (0, i.rotl)(
                s[t - 3] ^ s[t - 8] ^ s[t - 14] ^ s[t - 16],
                1,
              );
            let { A: r, B: o, C: a, D: u, E: c } = this;
            for (let t = 0; t < 80; t++) {
              let e, f;
              t < 20
                ? ((e = (0, n.Chi)(o, a, u)), (f = 1518500249))
                : t < 40
                  ? ((e = o ^ a ^ u), (f = 1859775393))
                  : t < 60
                    ? ((e = (0, n.Maj)(o, a, u)), (f = 2400959708))
                    : ((e = o ^ a ^ u), (f = 3395469782));
              const h = ((0, i.rotl)(r, 5) + e + c + f + s[t]) | 0;
              (c = u), (u = a), (a = (0, i.rotl)(o, 30)), (o = r), (r = h);
            }
            (r = (r + this.A) | 0),
              (o = (o + this.B) | 0),
              (a = (a + this.C) | 0),
              (u = (u + this.D) | 0),
              (c = (c + this.E) | 0),
              this.set(r, o, a, u, c);
          }
          roundClean() {
            s.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        (e.SHA1 = a), (e.sha1 = (0, i.wrapConstructor)(() => new a()));
      },
      22623: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.sha224 = e.sha256 = e.SHA256 = void 0);
        const n = r(37202),
          i = r(99175),
          o = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          s = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          a = new Uint32Array(64);
        class u extends n.HashMD {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | s[0]),
              (this.B = 0 | s[1]),
              (this.C = 0 | s[2]),
              (this.D = 0 | s[3]),
              (this.E = 0 | s[4]),
              (this.F = 0 | s[5]),
              (this.G = 0 | s[6]),
              (this.H = 0 | s[7]);
          }
          get() {
            const { A: t, B: e, C: r, D: n, E: i, F: o, G: s, H: a } = this;
            return [t, e, r, n, i, o, s, a];
          }
          set(t, e, r, n, i, o, s, a) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | r),
              (this.D = 0 | n),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4) a[r] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = a[t - 15],
                r = a[t - 2],
                n = (0, i.rotr)(e, 7) ^ (0, i.rotr)(e, 18) ^ (e >>> 3),
                o = (0, i.rotr)(r, 17) ^ (0, i.rotr)(r, 19) ^ (r >>> 10);
              a[t] = (o + a[t - 7] + n + a[t - 16]) | 0;
            }
            let { A: r, B: s, C: u, D: c, E: f, F: h, G: l, H: d } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (d +
                    ((0, i.rotr)(f, 6) ^
                      (0, i.rotr)(f, 11) ^
                      (0, i.rotr)(f, 25)) +
                    (0, n.Chi)(f, h, l) +
                    o[t] +
                    a[t]) |
                  0,
                p =
                  (((0, i.rotr)(r, 2) ^
                    (0, i.rotr)(r, 13) ^
                    (0, i.rotr)(r, 22)) +
                    (0, n.Maj)(r, s, u)) |
                  0;
              (d = l),
                (l = h),
                (h = f),
                (f = (c + e) | 0),
                (c = u),
                (u = s),
                (s = r),
                (r = (e + p) | 0);
            }
            (r = (r + this.A) | 0),
              (s = (s + this.B) | 0),
              (u = (u + this.C) | 0),
              (c = (c + this.D) | 0),
              (f = (f + this.E) | 0),
              (h = (h + this.F) | 0),
              (l = (l + this.G) | 0),
              (d = (d + this.H) | 0),
              this.set(r, s, u, c, f, h, l, d);
          }
          roundClean() {
            a.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        e.SHA256 = u;
        class c extends u {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        (e.sha256 = (0, i.wrapConstructor)(() => new u())),
          (e.sha224 = (0, i.wrapConstructor)(() => new c()));
      },
      30102: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.sha384 =
            e.sha512_256 =
            e.sha512_224 =
            e.sha512 =
            e.SHA384 =
            e.SHA512_256 =
            e.SHA512_224 =
            e.SHA512 =
              void 0);
        const n = r(37202),
          i = r(22318),
          o = r(99175),
          [s, a] = (() =>
            i.default.split(
              [
                "0x428a2f98d728ae22",
                "0x7137449123ef65cd",
                "0xb5c0fbcfec4d3b2f",
                "0xe9b5dba58189dbbc",
                "0x3956c25bf348b538",
                "0x59f111f1b605d019",
                "0x923f82a4af194f9b",
                "0xab1c5ed5da6d8118",
                "0xd807aa98a3030242",
                "0x12835b0145706fbe",
                "0x243185be4ee4b28c",
                "0x550c7dc3d5ffb4e2",
                "0x72be5d74f27b896f",
                "0x80deb1fe3b1696b1",
                "0x9bdc06a725c71235",
                "0xc19bf174cf692694",
                "0xe49b69c19ef14ad2",
                "0xefbe4786384f25e3",
                "0x0fc19dc68b8cd5b5",
                "0x240ca1cc77ac9c65",
                "0x2de92c6f592b0275",
                "0x4a7484aa6ea6e483",
                "0x5cb0a9dcbd41fbd4",
                "0x76f988da831153b5",
                "0x983e5152ee66dfab",
                "0xa831c66d2db43210",
                "0xb00327c898fb213f",
                "0xbf597fc7beef0ee4",
                "0xc6e00bf33da88fc2",
                "0xd5a79147930aa725",
                "0x06ca6351e003826f",
                "0x142929670a0e6e70",
                "0x27b70a8546d22ffc",
                "0x2e1b21385c26c926",
                "0x4d2c6dfc5ac42aed",
                "0x53380d139d95b3df",
                "0x650a73548baf63de",
                "0x766a0abb3c77b2a8",
                "0x81c2c92e47edaee6",
                "0x92722c851482353b",
                "0xa2bfe8a14cf10364",
                "0xa81a664bbc423001",
                "0xc24b8b70d0f89791",
                "0xc76c51a30654be30",
                "0xd192e819d6ef5218",
                "0xd69906245565a910",
                "0xf40e35855771202a",
                "0x106aa07032bbd1b8",
                "0x19a4c116b8d2d0c8",
                "0x1e376c085141ab53",
                "0x2748774cdf8eeb99",
                "0x34b0bcb5e19b48a8",
                "0x391c0cb3c5c95a63",
                "0x4ed8aa4ae3418acb",
                "0x5b9cca4f7763e373",
                "0x682e6ff3d6b2b8a3",
                "0x748f82ee5defb2fc",
                "0x78a5636f43172f60",
                "0x84c87814a1f0ab72",
                "0x8cc702081a6439ec",
                "0x90befffa23631e28",
                "0xa4506cebde82bde9",
                "0xbef9a3f7b2c67915",
                "0xc67178f2e372532b",
                "0xca273eceea26619c",
                "0xd186b8c721c0c207",
                "0xeada7dd6cde0eb1e",
                "0xf57d4f7fee6ed178",
                "0x06f067aa72176fba",
                "0x0a637dc5a2c898a6",
                "0x113f9804bef90dae",
                "0x1b710b35131c471b",
                "0x28db77f523047d84",
                "0x32caab7b40c72493",
                "0x3c9ebe0a15c9bebc",
                "0x431d67c49c100d4c",
                "0x4cc5d4becb3e42b6",
                "0x597f299cfc657e2a",
                "0x5fcb6fab3ad6faec",
                "0x6c44198c4a475817",
              ].map((t) => BigInt(t)),
            ))(),
          u = new Uint32Array(80),
          c = new Uint32Array(80);
        class f extends n.HashMD {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: r,
              Bl: n,
              Ch: i,
              Cl: o,
              Dh: s,
              Dl: a,
              Eh: u,
              El: c,
              Fh: f,
              Fl: h,
              Gh: l,
              Gl: d,
              Hh: p,
              Hl: y,
            } = this;
            return [t, e, r, n, i, o, s, a, u, c, f, h, l, d, p, y];
          }
          set(t, e, r, n, i, o, s, a, u, c, f, h, l, d, p, y) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | r),
              (this.Bl = 0 | n),
              (this.Ch = 0 | i),
              (this.Cl = 0 | o),
              (this.Dh = 0 | s),
              (this.Dl = 0 | a),
              (this.Eh = 0 | u),
              (this.El = 0 | c),
              (this.Fh = 0 | f),
              (this.Fl = 0 | h),
              (this.Gh = 0 | l),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | y);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4)
              (u[r] = t.getUint32(e)), (c[r] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | u[t - 15],
                r = 0 | c[t - 15],
                n =
                  i.default.rotrSH(e, r, 1) ^
                  i.default.rotrSH(e, r, 8) ^
                  i.default.shrSH(e, r, 7),
                o =
                  i.default.rotrSL(e, r, 1) ^
                  i.default.rotrSL(e, r, 8) ^
                  i.default.shrSL(e, r, 7),
                s = 0 | u[t - 2],
                a = 0 | c[t - 2],
                f =
                  i.default.rotrSH(s, a, 19) ^
                  i.default.rotrBH(s, a, 61) ^
                  i.default.shrSH(s, a, 6),
                h =
                  i.default.rotrSL(s, a, 19) ^
                  i.default.rotrBL(s, a, 61) ^
                  i.default.shrSL(s, a, 6),
                l = i.default.add4L(o, h, c[t - 7], c[t - 16]),
                d = i.default.add4H(l, n, f, u[t - 7], u[t - 16]);
              (u[t] = 0 | d), (c[t] = 0 | l);
            }
            let {
              Ah: r,
              Al: n,
              Bh: o,
              Bl: f,
              Ch: h,
              Cl: l,
              Dh: d,
              Dl: p,
              Eh: y,
              El: g,
              Fh: m,
              Fl: b,
              Gh: w,
              Gl: v,
              Hh: _,
              Hl: E,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  i.default.rotrSH(y, g, 14) ^
                  i.default.rotrSH(y, g, 18) ^
                  i.default.rotrBH(y, g, 41),
                S =
                  i.default.rotrSL(y, g, 14) ^
                  i.default.rotrSL(y, g, 18) ^
                  i.default.rotrBL(y, g, 41),
                I = (y & m) ^ (~y & w),
                M = (g & b) ^ (~g & v),
                A = i.default.add5L(E, S, M, a[t], c[t]),
                T = i.default.add5H(A, _, e, I, s[t], u[t]),
                k = 0 | A,
                O =
                  i.default.rotrSH(r, n, 28) ^
                  i.default.rotrBH(r, n, 34) ^
                  i.default.rotrBH(r, n, 39),
                x =
                  i.default.rotrSL(r, n, 28) ^
                  i.default.rotrBL(r, n, 34) ^
                  i.default.rotrBL(r, n, 39),
                P = (r & o) ^ (r & h) ^ (o & h),
                B = (n & f) ^ (n & l) ^ (f & l);
              (_ = 0 | w),
                (E = 0 | v),
                (w = 0 | m),
                (v = 0 | b),
                (m = 0 | y),
                (b = 0 | g),
                ({ h: y, l: g } = i.default.add(0 | d, 0 | p, 0 | T, 0 | k)),
                (d = 0 | h),
                (p = 0 | l),
                (h = 0 | o),
                (l = 0 | f),
                (o = 0 | r),
                (f = 0 | n);
              const C = i.default.add3L(k, x, B);
              (r = i.default.add3H(C, T, O, P)), (n = 0 | C);
            }
            ({ h: r, l: n } = i.default.add(
              0 | this.Ah,
              0 | this.Al,
              0 | r,
              0 | n,
            )),
              ({ h: o, l: f } = i.default.add(
                0 | this.Bh,
                0 | this.Bl,
                0 | o,
                0 | f,
              )),
              ({ h, l } = i.default.add(
                0 | this.Ch,
                0 | this.Cl,
                0 | h,
                0 | l,
              )),
              ({ h: d, l: p } = i.default.add(
                0 | this.Dh,
                0 | this.Dl,
                0 | d,
                0 | p,
              )),
              ({ h: y, l: g } = i.default.add(
                0 | this.Eh,
                0 | this.El,
                0 | y,
                0 | g,
              )),
              ({ h: m, l: b } = i.default.add(
                0 | this.Fh,
                0 | this.Fl,
                0 | m,
                0 | b,
              )),
              ({ h: w, l: v } = i.default.add(
                0 | this.Gh,
                0 | this.Gl,
                0 | w,
                0 | v,
              )),
              ({ h: _, l: E } = i.default.add(
                0 | this.Hh,
                0 | this.Hl,
                0 | _,
                0 | E,
              )),
              this.set(r, n, o, f, h, l, d, p, y, g, m, b, w, v, _, E);
          }
          roundClean() {
            u.fill(0), c.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        e.SHA512 = f;
        class h extends f {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        e.SHA512_224 = h;
        class l extends f {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        e.SHA512_256 = l;
        class d extends f {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        (e.SHA384 = d),
          (e.sha512 = (0, o.wrapConstructor)(() => new f())),
          (e.sha512_224 = (0, o.wrapConstructor)(() => new h())),
          (e.sha512_256 = (0, o.wrapConstructor)(() => new l())),
          (e.sha384 = (0, o.wrapConstructor)(() => new d()));
      },
      99175: (t, e, r) => {
        "use strict";
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(
          e,
          "__esModule",
          { value: !0 },
        ),
          (e.Hash = e.nextTick = e.byteSwapIfBE = e.isLE = void 0),
          (e.isBytes = function (t) {
            return (
              t instanceof Uint8Array ||
              (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
            );
          }),
          (e.u8 = function (t) {
            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
          }),
          (e.u32 = function (t) {
            return new Uint32Array(
              t.buffer,
              t.byteOffset,
              Math.floor(t.byteLength / 4),
            );
          }),
          (e.createView = function (t) {
            return new DataView(t.buffer, t.byteOffset, t.byteLength);
          }),
          (e.rotr = function (t, e) {
            return (t << (32 - e)) | (t >>> e);
          }),
          (e.rotl = function (t, e) {
            return (t << e) | ((t >>> (32 - e)) >>> 0);
          }),
          (e.byteSwap = o),
          (e.byteSwap32 = function (t) {
            for (let e = 0; e < t.length; e++) t[e] = o(t[e]);
          }),
          (e.bytesToHex = function (t) {
            (0, i.abytes)(t);
            let e = "";
            for (let r = 0; r < t.length; r++) e += s[t[r]];
            return e;
          }),
          (e.hexToBytes = function (t) {
            if ("string" != typeof t)
              throw new Error("hex string expected, got " + typeof t);
            const e = t.length,
              r = e / 2;
            if (e % 2)
              throw new Error(
                "hex string expected, got unpadded hex of length " + e,
              );
            const n = new Uint8Array(r);
            for (let e = 0, i = 0; e < r; e++, i += 2) {
              const r = u(t.charCodeAt(i)),
                o = u(t.charCodeAt(i + 1));
              if (void 0 === r || void 0 === o) {
                const e = t[i] + t[i + 1];
                throw new Error(
                  'hex string expected, got non-hex character "' +
                    e +
                    '" at index ' +
                    i,
                );
              }
              n[e] = 16 * r + o;
            }
            return n;
          }),
          (e.asyncLoop = async function (t, r, n) {
            let i = Date.now();
            for (let o = 0; o < t; o++) {
              n(o);
              const t = Date.now() - i;
              (t >= 0 && t < r) || (await (0, e.nextTick)(), (i += t));
            }
          }),
          (e.utf8ToBytes = c),
          (e.toBytes = f),
          (e.concatBytes = function (...t) {
            let e = 0;
            for (let r = 0; r < t.length; r++) {
              const n = t[r];
              (0, i.abytes)(n), (e += n.length);
            }
            const r = new Uint8Array(e);
            for (let e = 0, n = 0; e < t.length; e++) {
              const i = t[e];
              r.set(i, n), (n += i.length);
            }
            return r;
          }),
          (e.checkOpts = function (t, e) {
            if (void 0 !== e && "[object Object]" !== {}.toString.call(e))
              throw new Error("Options should be object or undefined");
            return Object.assign(t, e);
          }),
          (e.wrapConstructor = function (t) {
            const e = (e) => t().update(f(e)).digest(),
              r = t();
            return (
              (e.outputLen = r.outputLen),
              (e.blockLen = r.blockLen),
              (e.create = () => t()),
              e
            );
          }),
          (e.wrapConstructorWithOpts = function (t) {
            const e = (e, r) => t(r).update(f(e)).digest(),
              r = t({});
            return (
              (e.outputLen = r.outputLen),
              (e.blockLen = r.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          }),
          (e.wrapXOFConstructorWithOpts = function (t) {
            const e = (e, r) => t(r).update(f(e)).digest(),
              r = t({});
            return (
              (e.outputLen = r.outputLen),
              (e.blockLen = r.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          }),
          (e.randomBytes = function (t = 32) {
            if (n.crypto && "function" == typeof n.crypto.getRandomValues)
              return n.crypto.getRandomValues(new Uint8Array(t));
            if (n.crypto && "function" == typeof n.crypto.randomBytes)
              return n.crypto.randomBytes(t);
            throw new Error("crypto.getRandomValues must be defined");
          });
        const n = r(25145),
          i = r(67557);
        function o(t) {
          return (
            ((t << 24) & 4278190080) |
            ((t << 8) & 16711680) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255)
          );
        }
        (e.isLE =
          68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]),
          (e.byteSwapIfBE = e.isLE ? (t) => t : (t) => o(t));
        const s = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        const a = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
        function u(t) {
          return t >= a._0 && t <= a._9
            ? t - a._0
            : t >= a.A && t <= a.F
              ? t - (a.A - 10)
              : t >= a.a && t <= a.f
                ? t - (a.a - 10)
                : void 0;
        }
        function c(t) {
          if ("string" != typeof t)
            throw new Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array(new TextEncoder().encode(t));
        }
        function f(t) {
          return "string" == typeof t && (t = c(t)), (0, i.abytes)(t), t;
        }
        e.nextTick = async () => {};
        e.Hash = class {
          clone() {
            return this._cloneInto();
          }
        };
      },
      9598: (t, e, r) => {
        "use strict";
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ Object.defineProperty(
          e,
          "__esModule",
          { value: !0 },
        ),
          (e.utils =
            e.schnorr =
            e.verify =
            e.signSync =
            e.sign =
            e.getSharedSecret =
            e.recoverPublicKey =
            e.getPublicKey =
            e.Signature =
            e.Point =
            e.CURVE =
              void 0);
        const n = r(14923),
          i = BigInt(0),
          o = BigInt(1),
          s = BigInt(2),
          a = BigInt(3),
          u = BigInt(8),
          c = Object.freeze({
            a: i,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
            ),
            h: o,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240",
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424",
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            ),
          });
        e.CURVE = c;
        const f = (t, e) => (t + e / s) / e,
          h = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            ),
            splitScalar(t) {
              const { n: e } = c,
                r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                n = -o * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                s = r,
                a = BigInt("0x100000000000000000000000000000000"),
                u = f(s * t, e),
                h = f(-n * t, e);
              let l = D(t - u * r - h * i, e),
                d = D(-u * n - h * s, e);
              const p = l > a,
                y = d > a;
              if ((p && (l = e - l), y && (d = e - d), l > a || d > a))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: p, k1: l, k2neg: y, k2: d };
            },
          },
          l = 32,
          d = 32;
        function p(t) {
          const { a: e, b: r } = c,
            n = D(t * t),
            i = D(n * t);
          return D(i + e * t + r);
        }
        const y = c.a === i;
        class g extends Error {
          constructor(t) {
            super(t);
          }
        }
        function m(t) {
          if (!(t instanceof b)) throw new TypeError("JacobianPoint expected");
        }
        class b {
          constructor(t, e, r) {
            (this.x = t), (this.y = e), (this.z = r);
          }
          static fromAffine(t) {
            if (!(t instanceof _))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(_.ZERO) ? b.ZERO : new b(t.x, t.y, o);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = c.P) {
              const r = new Array(t.length),
                n = j(
                  t.reduce(
                    (t, n, o) => (n === i ? t : ((r[o] = t), D(t * n, e))),
                    o,
                  ),
                  e,
                );
              return (
                t.reduceRight(
                  (t, n, o) =>
                    n === i ? t : ((r[o] = D(t * r[o], e)), D(t * n, e)),
                  n,
                ),
                r
              );
            })(t.map((t) => t.z));
            return t.map((t, r) => t.toAffine(e[r]));
          }
          static normalizeZ(t) {
            return b.toAffineBatch(t).map(b.fromAffine);
          }
          equals(t) {
            m(t);
            const { x: e, y: r, z: n } = this,
              { x: i, y: o, z: s } = t,
              a = D(n * n),
              u = D(s * s),
              c = D(e * u),
              f = D(i * a),
              h = D(D(r * s) * u),
              l = D(D(o * n) * a);
            return c === f && h === l;
          }
          negate() {
            return new b(this.x, D(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: r } = this,
              n = D(t * t),
              i = D(e * e),
              o = D(i * i),
              c = t + i,
              f = D(s * (D(c * c) - n - o)),
              h = D(a * n),
              l = D(h * h),
              d = D(l - s * f),
              p = D(h * (f - d) - u * o),
              y = D(s * e * r);
            return new b(d, p, y);
          }
          add(t) {
            m(t);
            const { x: e, y: r, z: n } = this,
              { x: o, y: a, z: u } = t;
            if (o === i || a === i) return this;
            if (e === i || r === i) return t;
            const c = D(n * n),
              f = D(u * u),
              h = D(e * f),
              l = D(o * c),
              d = D(D(r * u) * f),
              p = D(D(a * n) * c),
              y = D(l - h),
              g = D(p - d);
            if (y === i) return g === i ? this.double() : b.ZERO;
            const w = D(y * y),
              v = D(y * w),
              _ = D(h * w),
              E = D(g * g - v - s * _),
              S = D(g * (_ - E) - d * v),
              I = D(n * u * y);
            return new b(E, S, I);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = b.ZERO;
            if ("bigint" == typeof t && t === i) return e;
            let r = U(t);
            if (r === o) return this;
            if (!y) {
              let t = e,
                n = this;
              for (; r > i; )
                r & o && (t = t.add(n)), (n = n.double()), (r >>= o);
              return t;
            }
            let { k1neg: n, k1: s, k2neg: a, k2: u } = h.splitScalar(r),
              c = e,
              f = e,
              l = this;
            for (; s > i || u > i; )
              s & o && (c = c.add(l)),
                u & o && (f = f.add(l)),
                (l = l.double()),
                (s >>= o),
                (u >>= o);
            return (
              n && (c = c.negate()),
              a && (f = f.negate()),
              (f = new b(D(f.x * h.beta), f.y, f.z)),
              c.add(f)
            );
          }
          precomputeWindow(t) {
            const e = y ? 128 / t + 1 : 256 / t + 1,
              r = [];
            let n = this,
              i = n;
            for (let o = 0; o < e; o++) {
              (i = n), r.push(i);
              for (let e = 1; e < 2 ** (t - 1); e++) (i = i.add(n)), r.push(i);
              n = i.double();
            }
            return r;
          }
          wNAF(t, e) {
            !e && this.equals(b.BASE) && (e = _.BASE);
            const r = (e && e._WINDOW_SIZE) || 1;
            if (256 % r)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2",
              );
            let n = e && v.get(e);
            n ||
              ((n = this.precomputeWindow(r)),
              e && 1 !== r && ((n = b.normalizeZ(n)), v.set(e, n)));
            let i = b.ZERO,
              s = b.BASE;
            const a = 1 + (y ? 128 / r : 256 / r),
              u = 2 ** (r - 1),
              c = BigInt(2 ** r - 1),
              f = 2 ** r,
              h = BigInt(r);
            for (let e = 0; e < a; e++) {
              const r = e * u;
              let a = Number(t & c);
              (t >>= h), a > u && ((a -= f), (t += o));
              const l = r,
                d = r + Math.abs(a) - 1,
                p = e % 2 != 0,
                y = a < 0;
              0 === a ? (s = s.add(w(p, n[l]))) : (i = i.add(w(y, n[d])));
            }
            return { p: i, f: s };
          }
          multiply(t, e) {
            let r,
              n,
              i = U(t);
            if (y) {
              const { k1neg: t, k1: o, k2neg: s, k2: a } = h.splitScalar(i);
              let { p: u, f: c } = this.wNAF(o, e),
                { p: f, f: l } = this.wNAF(a, e);
              (u = w(t, u)),
                (f = w(s, f)),
                (f = new b(D(f.x * h.beta), f.y, f.z)),
                (r = u.add(f)),
                (n = c.add(l));
            } else {
              const { p: t, f: o } = this.wNAF(i, e);
              (r = t), (n = o);
            }
            return b.normalizeZ([r, n])[0];
          }
          toAffine(t) {
            const { x: e, y: r, z: n } = this,
              i = this.equals(b.ZERO);
            null == t && (t = i ? u : j(n));
            const s = t,
              a = D(s * s),
              c = D(a * s),
              f = D(e * a),
              h = D(r * c),
              l = D(n * s);
            if (i) return _.ZERO;
            if (l !== o) throw new Error("invZ was invalid");
            return new _(f, h);
          }
        }
        function w(t, e) {
          const r = e.negate();
          return t ? r : e;
        }
        (b.BASE = new b(c.Gx, c.Gy, o)), (b.ZERO = new b(i, o, i));
        const v = new WeakMap();
        class _ {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), v.delete(this);
          }
          hasEvenY() {
            return this.y % s === i;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              r = R(e ? t : t.subarray(1));
            if (!z(r)) throw new Error("Point is not on curve");
            let n = (function (t) {
              const { P: e } = c,
                r = BigInt(6),
                n = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                u = BigInt(44),
                f = BigInt(88),
                h = (t * t * t) % e,
                l = (h * h * t) % e,
                d = (L(l, a) * l) % e,
                p = (L(d, a) * l) % e,
                y = (L(p, s) * h) % e,
                g = (L(y, n) * y) % e,
                m = (L(g, i) * g) % e,
                b = (L(m, u) * m) % e,
                w = (L(b, f) * b) % e,
                v = (L(w, u) * m) % e,
                _ = (L(v, a) * l) % e,
                E = (L(_, o) * g) % e,
                S = (L(E, r) * h) % e,
                I = L(S, s);
              if ((I * I) % e !== t) throw new Error("Cannot find square root");
              return I;
            })(p(r));
            const i = (n & o) === o;
            if (e) i && (n = D(-n));
            else {
              !(1 & ~t[0]) !== i && (n = D(-n));
            }
            const u = new _(r, n);
            return u.assertValidity(), u;
          }
          static fromUncompressedHex(t) {
            const e = R(t.subarray(1, 33)),
              r = R(t.subarray(33, 65)),
              n = new _(e, r);
            return n.assertValidity(), n;
          }
          static fromHex(t) {
            const e = N(t),
              r = e.length,
              n = e[0];
            if (r === l) return this.fromCompressedHex(e);
            if (33 === r && (2 === n || 3 === n))
              return this.fromCompressedHex(e);
            if (65 === r && 4 === n) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`,
            );
          }
          static fromPrivateKey(t) {
            return _.BASE.multiply(G(t));
          }
          static fromSignature(t, e, r) {
            const { r: n, s: i } = Y(e);
            if (![0, 1, 2, 3].includes(r))
              throw new Error("Cannot recover: invalid recovery bit");
            const o = F(N(t)),
              { n: s } = c,
              a = 2 === r || 3 === r ? n + s : n,
              u = j(a, s),
              f = D(-o * u, s),
              h = D(i * u, s),
              l = 1 & r ? "03" : "02",
              d = _.fromHex(l + O(a)),
              p = _.BASE.multiplyAndAddUnsafe(d, f, h);
            if (!p)
              throw new Error("Cannot recover signature: point at infinify");
            return p.assertValidity(), p;
          }
          toRawBytes(t = !1) {
            return C(this.toHex(t));
          }
          toHex(t = !1) {
            const e = O(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${O(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: r } = this;
            if (!z(e) || !z(r)) throw new Error(t);
            const n = D(r * r);
            if (D(n - p(e)) !== i) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new _(this.x, D(-this.y));
          }
          double() {
            return b.fromAffine(this).double().toAffine();
          }
          add(t) {
            return b.fromAffine(this).add(b.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return b.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, r) {
            const n = b.fromAffine(this),
              s =
                e === i || e === o || this !== _.BASE
                  ? n.multiplyUnsafe(e)
                  : n.multiply(e),
              a = b.fromAffine(t).multiplyUnsafe(r),
              u = s.add(a);
            return u.equals(b.ZERO) ? void 0 : u.toAffine();
          }
        }
        function E(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function S(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${T(t)}`);
          const e = t[1],
            r = t.subarray(2, e + 2);
          if (!e || r.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === r[0] && r[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: R(r), left: t.subarray(e + 2) };
        }
        (e.Point = _), (_.BASE = new _(c.Gx, c.Gy)), (_.ZERO = new _(i, i));
        class I {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(t) {
            const e = t instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof t && !e)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const n = e ? T(t) : t;
            if (128 !== n.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new I(B(n.slice(0, 64)), B(n.slice(64, 128)));
          }
          static fromDER(t) {
            const e = t instanceof Uint8Array;
            if ("string" != typeof t && !e)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array",
              );
            const { r, s: n } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${T(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: r } = S(t.subarray(2)),
                { data: n, left: i } = S(r);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${T(i)}`,
                );
              return { r: e, s: n };
            })(e ? t : C(t));
            return new I(r, n);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!q(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!q(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = c.n >> o;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new I(this.r, D(-this.s, c.n)) : this;
          }
          toDERRawBytes() {
            return C(this.toDERHex());
          }
          toDERHex() {
            const t = E(P(this.s)),
              e = E(P(this.r)),
              r = t.length / 2,
              n = e.length / 2,
              i = P(r),
              o = P(n);
            return `30${P(n + r + 4)}02${o}${e}02${i}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return C(this.toCompactHex());
          }
          toCompactHex() {
            return O(this.r) + O(this.s);
          }
        }
        function M(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        e.Signature = I;
        const A = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        function T(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let r = 0; r < t.length; r++) e += A[t[r]];
          return e;
        }
        const k = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000",
        );
        function O(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(i <= t && t < k))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function x(t) {
          const e = C(O(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function P(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function B(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t,
            );
          return BigInt(`0x${t}`);
        }
        function C(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length,
            );
          const e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            const n = 2 * r,
              i = t.slice(n, n + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            e[r] = o;
          }
          return e;
        }
        function R(t) {
          return B(T(t));
        }
        function N(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : C(t);
        }
        function U(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && q(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n",
          );
        }
        function D(t, e = c.P) {
          const r = t % e;
          return r >= i ? r : e + r;
        }
        function L(t, e) {
          const { P: r } = c;
          let n = t;
          for (; e-- > i; ) (n *= n), (n %= r);
          return n;
        }
        function j(t, e = c.P) {
          if (t === i || e <= i)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`,
            );
          let r = D(t, e),
            n = e,
            s = i,
            a = o,
            u = o,
            f = i;
          for (; r !== i; ) {
            const t = n / r,
              e = n % r,
              i = s - u * t,
              o = a - f * t;
            (n = r), (r = e), (s = u), (a = f), (u = i), (f = o);
          }
          if (n !== o) throw new Error("invert: does not exist");
          return D(s, e);
        }
        function F(t, e = !1) {
          const r = (function (t) {
            const e = 8 * t.length - 256,
              r = R(t);
            return e > 0 ? r >> BigInt(e) : r;
          })(t);
          if (e) return r;
          const { n } = c;
          return r >= n ? r - n : r;
        }
        let H, K;
        class V {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return e.utils.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return K(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof K)
              throw new g("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid",
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const r = this.v.slice();
              e.push(r), (t += this.v.length);
            }
            return M(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const r = this.v.slice();
              e.push(r), (t += this.v.length);
            }
            return M(...e);
          }
        }
        function q(t) {
          return i < t && t < c.n;
        }
        function z(t) {
          return i < t && t < c.P;
        }
        function $(t, e, r, n = !0) {
          const { n: s } = c,
            a = F(t, !0);
          if (!q(a)) return;
          const u = j(a, s),
            f = _.BASE.multiply(a),
            h = D(f.x, s);
          if (h === i) return;
          const l = D(u * D(e + r * h, s), s);
          if (l === i) return;
          let d = new I(h, l),
            p = (f.x === d.r ? 0 : 2) | Number(f.y & o);
          return (
            n && d.hasHighS() && ((d = d.normalizeS()), (p ^= 1)),
            { sig: d, recovery: p }
          );
        }
        function G(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (64 !== t.length)
              throw new Error("Expected 32 bytes of private key");
            e = B(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== d)
              throw new Error("Expected 32 bytes of private key");
            e = R(t);
          }
          if (!q(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function W(t) {
          return t instanceof _ ? (t.assertValidity(), t) : _.fromHex(t);
        }
        function Y(t) {
          if (t instanceof I) return t.assertValidity(), t;
          try {
            return I.fromDER(t);
          } catch (e) {
            return I.fromCompact(t);
          }
        }
        function X(t) {
          const e = t instanceof Uint8Array,
            r = "string" == typeof t,
            n = (e || r) && t.length;
          return e
            ? 33 === n || 65 === n
            : r
              ? 66 === n || 130 === n
              : t instanceof _;
        }
        function Z(t) {
          return R(t.length > l ? t.slice(0, l) : t);
        }
        function J(t) {
          const e = Z(t),
            r = D(e, c.n);
          return Q(r < i ? e : r);
        }
        function Q(t) {
          return x(t);
        }
        function tt(t, r, n) {
          if (null == t)
            throw new Error(`sign: expected valid message hash, not "${t}"`);
          const i = N(t),
            o = G(r),
            s = [Q(o), J(i)];
          if (null != n) {
            !0 === n && (n = e.utils.randomBytes(l));
            const t = N(n);
            if (t.length !== l)
              throw new Error("sign: Expected 32 bytes of extra data");
            s.push(t);
          }
          return { seed: M(...s), m: Z(i), d: o };
        }
        function et(t, e) {
          const { sig: r, recovery: n } = t,
            { der: i, recovered: o } = Object.assign(
              { canonical: !0, der: !0 },
              e,
            ),
            s = i ? r.toDERRawBytes() : r.toCompactRawBytes();
          return o ? [s, n] : s;
        }
        (e.getPublicKey = function (t, e = !1) {
          return _.fromPrivateKey(t).toRawBytes(e);
        }),
          (e.recoverPublicKey = function (t, e, r, n = !1) {
            return _.fromSignature(t, e, r).toRawBytes(n);
          }),
          (e.getSharedSecret = function (t, e, r = !1) {
            if (X(t))
              throw new TypeError(
                "getSharedSecret: first arg must be private key",
              );
            if (!X(e))
              throw new TypeError(
                "getSharedSecret: second arg must be public key",
              );
            const n = W(e);
            return n.assertValidity(), n.multiply(G(t)).toRawBytes(r);
          }),
          (e.sign = async function (t, e, r = {}) {
            const { seed: n, m: i, d: o } = tt(t, e, r.extraEntropy),
              s = new V(32, d);
            let a;
            for (
              await s.reseed(n);
              !(a = $(await s.generate(), i, o, r.canonical));

            )
              await s.reseed();
            return et(a, r);
          }),
          (e.signSync = function (t, e, r = {}) {
            const { seed: n, m: i, d: o } = tt(t, e, r.extraEntropy),
              s = new V(32, d);
            let a;
            for (
              s.reseedSync(n);
              !(a = $(s.generateSync(), i, o, r.canonical));

            )
              s.reseedSync();
            return et(a, r);
          });
        const rt = { strict: !0 };
        function nt(t) {
          return D(R(t), c.n);
        }
        e.verify = function (t, e, r, n = rt) {
          let i;
          try {
            (i = Y(t)), (e = N(e));
          } catch (t) {
            return !1;
          }
          const { r: o, s } = i;
          if (n.strict && i.hasHighS()) return !1;
          const a = F(e);
          let u;
          try {
            u = W(r);
          } catch (t) {
            return !1;
          }
          const { n: f } = c,
            h = j(s, f),
            l = D(a * h, f),
            d = D(o * h, f),
            p = _.BASE.multiplyAndAddUnsafe(u, l, d);
          return !!p && D(p.x, f) === o;
        };
        class it {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromHex(t) {
            const e = N(t);
            if (64 !== e.length)
              throw new TypeError(
                `SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`,
              );
            const r = R(e.subarray(0, 32)),
              n = R(e.subarray(32, 64));
            return new it(r, n);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!z(t) || !q(e)) throw new Error("Invalid signature");
          }
          toHex() {
            return O(this.r) + O(this.s);
          }
          toRawBytes() {
            return C(this.toHex());
          }
        }
        class ot {
          constructor(t, r, n = e.utils.randomBytes()) {
            if (null == t)
              throw new TypeError(`sign: Expected valid message, not "${t}"`);
            this.m = N(t);
            const { x: i, scalar: o } = this.getScalar(G(r));
            if (
              ((this.px = i),
              (this.d = o),
              (this.rand = N(n)),
              32 !== this.rand.length)
            )
              throw new TypeError("sign: Expected 32 bytes of aux randomness");
          }
          getScalar(t) {
            const e = _.fromPrivateKey(t),
              r = e.hasEvenY() ? t : c.n - t;
            return { point: e, scalar: r, x: e.toRawX() };
          }
          initNonce(t, e) {
            return x(t ^ R(e));
          }
          finalizeNonce(t) {
            const e = D(R(t), c.n);
            if (e === i)
              throw new Error("sign: Creation of signature failed. k is zero");
            const { point: r, x: n, scalar: o } = this.getScalar(e);
            return { R: r, rx: n, k: o };
          }
          finalizeSig(t, e, r, n) {
            return new it(t.x, D(e + r * n, c.n)).toRawBytes();
          }
          error() {
            throw new Error("sign: Invalid signature produced");
          }
          async calc() {
            const { m: t, d: r, px: n, rand: i } = this,
              o = e.utils.taggedHash,
              s = this.initNonce(r, await o(ht.aux, i)),
              {
                R: a,
                rx: u,
                k: c,
              } = this.finalizeNonce(await o(ht.nonce, s, n, t)),
              f = nt(await o(ht.challenge, u, n, t)),
              h = this.finalizeSig(a, c, f, r);
            return (await ut(h, t, n)) || this.error(), h;
          }
          calcSync() {
            const { m: t, d: r, px: n, rand: i } = this,
              o = e.utils.taggedHashSync,
              s = this.initNonce(r, o(ht.aux, i)),
              { R: a, rx: u, k: c } = this.finalizeNonce(o(ht.nonce, s, n, t)),
              f = nt(o(ht.challenge, u, n, t)),
              h = this.finalizeSig(a, c, f, r);
            return ct(h, t, n) || this.error(), h;
          }
        }
        function st(t, e, r) {
          const n = t instanceof it,
            i = n ? t : it.fromHex(t);
          return n && i.assertValidity(), { ...i, m: N(e), P: W(r) };
        }
        function at(t, e, r, n) {
          const i = _.BASE.multiplyAndAddUnsafe(e, G(r), D(-n, c.n));
          return !(!i || !i.hasEvenY() || i.x !== t);
        }
        async function ut(t, r, n) {
          try {
            const { r: i, s: o, m: s, P: a } = st(t, r, n),
              u = nt(
                await e.utils.taggedHash(ht.challenge, x(i), a.toRawX(), s),
              );
            return at(i, a, o, u);
          } catch (t) {
            return !1;
          }
        }
        function ct(t, r, n) {
          try {
            const { r: i, s: o, m: s, P: a } = st(t, r, n),
              u = nt(e.utils.taggedHashSync(ht.challenge, x(i), a.toRawX(), s));
            return at(i, a, o, u);
          } catch (t) {
            if (t instanceof g) throw t;
            return !1;
          }
        }
        (e.schnorr = {
          Signature: it,
          getPublicKey: function (t) {
            return _.fromPrivateKey(t).toRawX();
          },
          sign: async function (t, e, r) {
            return new ot(t, e, r).calc();
          },
          verify: ut,
          signSync: function (t, e, r) {
            return new ot(t, e, r).calcSync();
          },
          verifySync: ct,
        }),
          _.BASE._setWindowSize(8);
        const ft = {
            node: n,
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          ht = {
            challenge: "BIP0340/challenge",
            aux: "BIP0340/aux",
            nonce: "BIP0340/nonce",
          },
          lt = {};
        (e.utils = {
          bytesToHex: T,
          hexToBytes: C,
          concatBytes: M,
          mod: D,
          invert: j,
          isValidPrivateKey(t) {
            try {
              return G(t), !0;
            } catch (t) {
              return !1;
            }
          },
          _bigintTo32Bytes: x,
          _normalizePrivateKey: G,
          hashToPrivateKey: (t) => {
            if ((t = N(t)).length < 40 || t.length > 1024)
              throw new Error(
                "Expected valid bytes of private key as per FIPS 186",
              );
            return x(D(R(t), c.n - o) + o);
          },
          randomBytes: (t = 32) => {
            if (ft.web) return ft.web.getRandomValues(new Uint8Array(t));
            if (ft.node) {
              const { randomBytes: e } = ft.node;
              return Uint8Array.from(e(t));
            }
            throw new Error(
              "The environment doesn't have randomBytes function",
            );
          },
          randomPrivateKey: () =>
            e.utils.hashToPrivateKey(e.utils.randomBytes(40)),
          precompute(t = 8, e = _.BASE) {
            const r = e === _.BASE ? e : new _(e.x, e.y);
            return r._setWindowSize(t), r.multiply(a), r;
          },
          sha256: async (...t) => {
            if (ft.web) {
              const e = await ft.web.subtle.digest("SHA-256", M(...t));
              return new Uint8Array(e);
            }
            if (ft.node) {
              const { createHash: e } = ft.node,
                r = e("sha256");
              return t.forEach((t) => r.update(t)), Uint8Array.from(r.digest());
            }
            throw new Error("The environment doesn't have sha256 function");
          },
          hmacSha256: async (t, ...e) => {
            if (ft.web) {
              const r = await ft.web.subtle.importKey(
                  "raw",
                  t,
                  { name: "HMAC", hash: { name: "SHA-256" } },
                  !1,
                  ["sign"],
                ),
                n = M(...e),
                i = await ft.web.subtle.sign("HMAC", r, n);
              return new Uint8Array(i);
            }
            if (ft.node) {
              const { createHmac: r } = ft.node,
                n = r("sha256", t);
              return e.forEach((t) => n.update(t)), Uint8Array.from(n.digest());
            }
            throw new Error(
              "The environment doesn't have hmac-sha256 function",
            );
          },
          sha256Sync: void 0,
          hmacSha256Sync: void 0,
          taggedHash: async (t, ...r) => {
            let n = lt[t];
            if (void 0 === n) {
              const r = await e.utils.sha256(
                Uint8Array.from(t, (t) => t.charCodeAt(0)),
              );
              (n = M(r, r)), (lt[t] = n);
            }
            return e.utils.sha256(n, ...r);
          },
          taggedHashSync: (t, ...e) => {
            if ("function" != typeof H)
              throw new g("sha256Sync is undefined, you need to set it");
            let r = lt[t];
            if (void 0 === r) {
              const e = H(Uint8Array.from(t, (t) => t.charCodeAt(0)));
              (r = M(e, e)), (lt[t] = r);
            }
            return H(r, ...e);
          },
          _JacobianPoint: b,
        }),
          Object.defineProperties(e.utils, {
            sha256Sync: {
              configurable: !1,
              get: () => H,
              set(t) {
                H || (H = t);
              },
            },
            hmacSha256Sync: {
              configurable: !1,
              get: () => K,
              set(t) {
                K || (K = t);
              },
            },
          });
      },
      63203: (t, e) => {
        "use strict";
        /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function r(
          t,
        ) {
          return (
            t instanceof Uint8Array ||
            (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
          );
        }
        function n(t, e) {
          return (
            !!Array.isArray(e) &&
            (0 === e.length ||
              (t
                ? e.every((t) => "string" == typeof t)
                : e.every((t) => Number.isSafeInteger(t))))
          );
        }
        function i(t) {
          if ("function" != typeof t) throw new Error("function expected");
          return !0;
        }
        function o(t, e) {
          if ("string" != typeof e) throw new Error(`${t}: string expected`);
          return !0;
        }
        function s(t) {
          if (!Number.isSafeInteger(t))
            throw new Error(`invalid integer: ${t}`);
        }
        function a(t) {
          if (!Array.isArray(t)) throw new Error("array expected");
        }
        function u(t, e) {
          if (!n(!0, e)) throw new Error(`${t}: array of strings expected`);
        }
        function c(t, e) {
          if (!n(!1, e)) throw new Error(`${t}: array of numbers expected`);
        }
        function f(...t) {
          const e = (t) => t,
            r = (t, e) => (r) => t(e(r));
          return {
            encode: t.map((t) => t.encode).reduceRight(r, e),
            decode: t.map((t) => t.decode).reduce(r, e),
          };
        }
        function h(t) {
          const e = "string" == typeof t ? t.split("") : t,
            r = e.length;
          u("alphabet", e);
          const n = new Map(e.map((t, e) => [t, e]));
          return {
            encode: (n) => (
              a(n),
              n.map((n) => {
                if (!Number.isSafeInteger(n) || n < 0 || n >= r)
                  throw new Error(
                    `alphabet.encode: digit index outside alphabet "${n}". Allowed: ${t}`,
                  );
                return e[n];
              })
            ),
            decode: (e) => (
              a(e),
              e.map((e) => {
                o("alphabet.decode", e);
                const r = n.get(e);
                if (void 0 === r)
                  throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);
                return r;
              })
            ),
          };
        }
        function l(t = "") {
          return (
            o("join", t),
            {
              encode: (e) => (u("join.decode", e), e.join(t)),
              decode: (e) => (o("join.decode", e), e.split(t)),
            }
          );
        }
        function d(t, e = "=") {
          return (
            s(t),
            o("padding", e),
            {
              encode(r) {
                for (u("padding.encode", r); (r.length * t) % 8; ) r.push(e);
                return r;
              },
              decode(r) {
                u("padding.decode", r);
                let n = r.length;
                if ((n * t) % 8)
                  throw new Error(
                    "padding: invalid, string should have whole number of bytes",
                  );
                for (; n > 0 && r[n - 1] === e; n--) {
                  if (((n - 1) * t) % 8 == 0)
                    throw new Error(
                      "padding: invalid, string has too much padding",
                    );
                }
                return r.slice(0, n);
              },
            }
          );
        }
        function p(t) {
          return i(t), { encode: (t) => t, decode: (e) => t(e) };
        }
        function y(t, e, r) {
          if (e < 2)
            throw new Error(
              `convertRadix: invalid from=${e}, base cannot be less than 2`,
            );
          if (r < 2)
            throw new Error(
              `convertRadix: invalid to=${r}, base cannot be less than 2`,
            );
          if ((a(t), !t.length)) return [];
          let n = 0;
          const i = [],
            o = Array.from(t, (t) => {
              if ((s(t), t < 0 || t >= e))
                throw new Error(`invalid integer: ${t}`);
              return t;
            }),
            u = o.length;
          for (;;) {
            let t = 0,
              s = !0;
            for (let i = n; i < u; i++) {
              const a = o[i],
                u = e * t,
                c = u + a;
              if (!Number.isSafeInteger(c) || u / e !== t || c - a !== u)
                throw new Error("convertRadix: carry overflow");
              const f = c / r;
              t = c % r;
              const h = Math.floor(f);
              if (((o[i] = h), !Number.isSafeInteger(h) || h * r + t !== c))
                throw new Error("convertRadix: carry overflow");
              s && (h ? (s = !1) : (n = i));
            }
            if ((i.push(t), s)) break;
          }
          for (let e = 0; e < t.length - 1 && 0 === t[e]; e++) i.push(0);
          return i.reverse();
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.bytes =
            e.stringToBytes =
            e.str =
            e.bytesToString =
            e.hex =
            e.utf8 =
            e.bech32m =
            e.bech32 =
            e.base58check =
            e.createBase58check =
            e.base58xmr =
            e.base58xrp =
            e.base58flickr =
            e.base58 =
            e.base64urlnopad =
            e.base64url =
            e.base64nopad =
            e.base64 =
            e.base32crockford =
            e.base32hexnopad =
            e.base32hex =
            e.base32nopad =
            e.base32 =
            e.base16 =
            e.utils =
            e.assertNumber =
              void 0),
          (e.assertNumber = s);
        const g = (t, e) => (0 === e ? t : g(e, t % e)),
          m = (t, e) => t + (e - g(t, e)),
          b = (() => {
            let t = [];
            for (let e = 0; e < 40; e++) t.push(2 ** e);
            return t;
          })();
        function w(t, e, r, n) {
          if ((a(t), e <= 0 || e > 32))
            throw new Error(`convertRadix2: wrong from=${e}`);
          if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
          if (m(e, r) > 32)
            throw new Error(
              `convertRadix2: carry overflow from=${e} to=${r} carryBits=${m(e, r)}`,
            );
          let i = 0,
            o = 0;
          const u = b[e],
            c = b[r] - 1,
            f = [];
          for (const n of t) {
            if ((s(n), n >= u))
              throw new Error(
                `convertRadix2: invalid data word=${n} from=${e}`,
              );
            if (((i = (i << e) | n), o + e > 32))
              throw new Error(
                `convertRadix2: carry overflow pos=${o} from=${e}`,
              );
            for (o += e; o >= r; o -= r) f.push(((i >> (o - r)) & c) >>> 0);
            const t = b[o];
            if (void 0 === t) throw new Error("invalid carry");
            i &= t - 1;
          }
          if (((i = (i << (r - o)) & c), !n && o >= e))
            throw new Error("Excess padding");
          if (!n && i > 0) throw new Error(`Non-zero padding: ${i}`);
          return n && o > 0 && f.push(i >>> 0), f;
        }
        function v(t) {
          s(t);
          return {
            encode: (e) => {
              if (!r(e))
                throw new Error("radix.encode input should be Uint8Array");
              return y(Array.from(e), 256, t);
            },
            decode: (e) => (
              c("radix.decode", e), Uint8Array.from(y(e, t, 256))
            ),
          };
        }
        function _(t, e = !1) {
          if ((s(t), t <= 0 || t > 32))
            throw new Error("radix2: bits should be in (0..32]");
          if (m(8, t) > 32 || m(t, 8) > 32)
            throw new Error("radix2: carry overflow");
          return {
            encode: (n) => {
              if (!r(n))
                throw new Error("radix2.encode input should be Uint8Array");
              return w(Array.from(n), 8, t, !e);
            },
            decode: (r) => (
              c("radix2.decode", r), Uint8Array.from(w(r, t, 8, e))
            ),
          };
        }
        function E(t) {
          return (
            i(t),
            function (...e) {
              try {
                return t.apply(null, e);
              } catch (t) {}
            }
          );
        }
        function S(t, e) {
          return (
            s(t),
            i(e),
            {
              encode(n) {
                if (!r(n))
                  throw new Error(
                    "checksum.encode: input should be Uint8Array",
                  );
                const i = e(n).slice(0, t),
                  o = new Uint8Array(n.length + t);
                return o.set(n), o.set(i, n.length), o;
              },
              decode(n) {
                if (!r(n))
                  throw new Error(
                    "checksum.decode: input should be Uint8Array",
                  );
                const i = n.slice(0, -t),
                  o = n.slice(-t),
                  s = e(i).slice(0, t);
                for (let e = 0; e < t; e++)
                  if (s[e] !== o[e]) throw new Error("Invalid checksum");
                return i;
              },
            }
          );
        }
        (e.utils = {
          alphabet: h,
          chain: f,
          checksum: S,
          convertRadix: y,
          convertRadix2: w,
          radix: v,
          radix2: _,
          join: l,
          padding: d,
        }),
          (e.base16 = f(_(4), h("0123456789ABCDEF"), l(""))),
          (e.base32 = f(
            _(5),
            h("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),
            d(5),
            l(""),
          )),
          (e.base32nopad = f(
            _(5),
            h("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),
            l(""),
          )),
          (e.base32hex = f(
            _(5),
            h("0123456789ABCDEFGHIJKLMNOPQRSTUV"),
            d(5),
            l(""),
          )),
          (e.base32hexnopad = f(
            _(5),
            h("0123456789ABCDEFGHIJKLMNOPQRSTUV"),
            l(""),
          )),
          (e.base32crockford = f(
            _(5),
            h("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),
            l(""),
            p((t) => t.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")),
          )),
          (e.base64 = f(
            _(6),
            h(
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            ),
            d(6),
            l(""),
          )),
          (e.base64nopad = f(
            _(6),
            h(
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            ),
            l(""),
          )),
          (e.base64url = f(
            _(6),
            h(
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            ),
            d(6),
            l(""),
          )),
          (e.base64urlnopad = f(
            _(6),
            h(
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            ),
            l(""),
          ));
        const I = (t) => f(v(58), h(t), l(""));
        (e.base58 = I(
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        )),
          (e.base58flickr = I(
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          )),
          (e.base58xrp = I(
            "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz",
          ));
        const M = [0, 2, 3, 5, 6, 7, 9, 10, 11];
        e.base58xmr = {
          encode(t) {
            let r = "";
            for (let n = 0; n < t.length; n += 8) {
              const i = t.subarray(n, n + 8);
              r += e.base58.encode(i).padStart(M[i.length], "1");
            }
            return r;
          },
          decode(t) {
            let r = [];
            for (let n = 0; n < t.length; n += 11) {
              const i = t.slice(n, n + 11),
                o = M.indexOf(i.length),
                s = e.base58.decode(i);
              for (let t = 0; t < s.length - o; t++)
                if (0 !== s[t]) throw new Error("base58xmr: wrong padding");
              r = r.concat(Array.from(s.slice(s.length - o)));
            }
            return Uint8Array.from(r);
          },
        };
        (e.createBase58check = (t) =>
          f(
            S(4, (e) => t(t(e))),
            e.base58,
          )),
          (e.base58check = e.createBase58check);
        const A = f(h("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), l("")),
          T = [996825010, 642813549, 513874426, 1027748829, 705979059];
        function k(t) {
          const e = t >> 25;
          let r = (33554431 & t) << 5;
          for (let t = 0; t < T.length; t++) 1 == ((e >> t) & 1) && (r ^= T[t]);
          return r;
        }
        function O(t, e, r = 1) {
          const n = t.length;
          let i = 1;
          for (let e = 0; e < n; e++) {
            const r = t.charCodeAt(e);
            if (r < 33 || r > 126) throw new Error(`Invalid prefix (${t})`);
            i = k(i) ^ (r >> 5);
          }
          i = k(i);
          for (let e = 0; e < n; e++) i = k(i) ^ (31 & t.charCodeAt(e));
          for (let t of e) i = k(i) ^ t;
          for (let t = 0; t < 6; t++) i = k(i);
          return (i ^= r), A.encode(w([i % b[30]], 30, 5, !1));
        }
        function x(t) {
          const e = "bech32" === t ? 1 : 734539939,
            n = _(5),
            i = n.decode,
            s = n.encode,
            a = E(i);
          function u(t, n, i = 90) {
            o("bech32.encode prefix", t),
              r(n) && (n = Array.from(n)),
              c("bech32.encode", n);
            const s = t.length;
            if (0 === s) throw new TypeError(`Invalid prefix length ${s}`);
            const a = s + 7 + n.length;
            if (!1 !== i && a > i)
              throw new TypeError(`Length ${a} exceeds limit ${i}`);
            const u = t.toLowerCase(),
              f = O(u, n, e);
            return `${u}1${A.encode(n)}${f}`;
          }
          function f(t, r = 90) {
            o("bech32.decode input", t);
            const n = t.length;
            if (n < 8 || (!1 !== r && n > r))
              throw new TypeError(
                `invalid string length: ${n} (${t}). Expected (8..${r})`,
              );
            const i = t.toLowerCase();
            if (t !== i && t !== t.toUpperCase())
              throw new Error("String must be lowercase or uppercase");
            const s = i.lastIndexOf("1");
            if (0 === s || -1 === s)
              throw new Error(
                'Letter "1" must be present between prefix and data only',
              );
            const a = i.slice(0, s),
              u = i.slice(s + 1);
            if (u.length < 6)
              throw new Error("Data must be at least 6 characters long");
            const c = A.decode(u).slice(0, -6),
              f = O(a, c, e);
            if (!u.endsWith(f))
              throw new Error(`Invalid checksum in ${t}: expected "${f}"`);
            return { prefix: a, words: c };
          }
          return {
            encode: u,
            decode: f,
            encodeFromBytes: function (t, e) {
              return u(t, s(e));
            },
            decodeToBytes: function (t) {
              const { prefix: e, words: r } = f(t, !1);
              return { prefix: e, words: r, bytes: i(r) };
            },
            decodeUnsafe: E(f),
            fromWords: i,
            fromWordsUnsafe: a,
            toWords: s,
          };
        }
        (e.bech32 = x("bech32")),
          (e.bech32m = x("bech32m")),
          (e.utf8 = {
            encode: (t) => new TextDecoder().decode(t),
            decode: (t) => new TextEncoder().encode(t),
          }),
          (e.hex = f(
            _(4),
            h("0123456789abcdef"),
            l(""),
            p((t) => {
              if ("string" != typeof t || t.length % 2 != 0)
                throw new TypeError(
                  `hex.decode: expected string, got ${typeof t} with length ${t.length}`,
                );
              return t.toLowerCase();
            }),
          ));
        const P = {
            utf8: e.utf8,
            hex: e.hex,
            base16: e.base16,
            base32: e.base32,
            base64: e.base64,
            base64url: e.base64url,
            base58: e.base58,
            base58xmr: e.base58xmr,
          },
          B =
            "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
        (e.bytesToString = (t, e) => {
          if ("string" != typeof t || !P.hasOwnProperty(t))
            throw new TypeError(B);
          if (!r(e)) throw new TypeError("bytesToString() expects Uint8Array");
          return P[t].encode(e);
        }),
          (e.str = e.bytesToString);
        (e.stringToBytes = (t, e) => {
          if (!P.hasOwnProperty(t)) throw new TypeError(B);
          if ("string" != typeof e)
            throw new TypeError("stringToBytes() expects string");
          return P[t].decode(e);
        }),
          (e.bytes = e.stringToBytes);
      },
      50168: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.HDKey = e.HARDENED_OFFSET = void 0);
        /*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
        const n = r(39615),
          i = r(93238),
          o = r(22623),
          s = r(30102),
          a = r(67557),
          u = r(99175),
          c = r(8510),
          f = r(24967),
          h = r(63203),
          l = c.secp256k1.ProjectivePoint,
          d = (0, h.createBase58check)(o.sha256);
        function p(t) {
          (0, a.abytes)(t);
          const e = 0 === t.length ? "0" : (0, u.bytesToHex)(t);
          return BigInt("0x" + e);
        }
        const y = (0, u.utf8ToBytes)("Bitcoin seed"),
          g = { private: 76066276, public: 76067358 };
        e.HARDENED_OFFSET = 2147483648;
        const m = (t) => {
          if (!Number.isSafeInteger(t) || t < 0 || t > 2 ** 32 - 1)
            throw new Error(
              "invalid number, should be from 0 to 2**32-1, got " + t,
            );
          const e = new Uint8Array(4);
          return (0, u.createView)(e).setUint32(0, t, !1), e;
        };
        class b {
          get fingerprint() {
            if (!this.pubHash) throw new Error("No publicKey set!");
            return (t = this.pubHash), (0, u.createView)(t).getUint32(0, !1);
            var t;
          }
          get identifier() {
            return this.pubHash;
          }
          get pubKeyHash() {
            return this.pubHash;
          }
          get privateKey() {
            return this.privKeyBytes || null;
          }
          get publicKey() {
            return this.pubKey || null;
          }
          get privateExtendedKey() {
            const t = this.privateKey;
            if (!t) throw new Error("No private key");
            return d.encode(
              this.serialize(
                this.versions.private,
                (0, u.concatBytes)(new Uint8Array([0]), t),
              ),
            );
          }
          get publicExtendedKey() {
            if (!this.pubKey) throw new Error("No public key");
            return d.encode(this.serialize(this.versions.public, this.pubKey));
          }
          static fromMasterSeed(t, e = g) {
            if (((0, a.abytes)(t), 8 * t.length < 128 || 8 * t.length > 512))
              throw new Error(
                "HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " +
                  t.length,
              );
            const r = (0, n.hmac)(s.sha512, y, t);
            return new b({
              versions: e,
              chainCode: r.slice(32),
              privateKey: r.slice(0, 32),
            });
          }
          static fromExtendedKey(t, e = g) {
            const r = d.decode(t),
              n = (0, u.createView)(r),
              i = n.getUint32(0, !1),
              o = {
                versions: e,
                depth: r[4],
                parentFingerprint: n.getUint32(5, !1),
                index: n.getUint32(9, !1),
                chainCode: r.slice(13, 45),
              },
              s = r.slice(45),
              a = 0 === s[0];
            if (i !== e[a ? "private" : "public"])
              throw new Error("Version mismatch");
            return new b(
              a ? { ...o, privateKey: s.slice(1) } : { ...o, publicKey: s },
            );
          }
          static fromJSON(t) {
            return b.fromExtendedKey(t.xpriv);
          }
          constructor(t) {
            if (
              ((this.depth = 0),
              (this.index = 0),
              (this.chainCode = null),
              (this.parentFingerprint = 0),
              !t || "object" != typeof t)
            )
              throw new Error("HDKey.constructor must not be called directly");
            if (
              ((this.versions = t.versions || g),
              (this.depth = t.depth || 0),
              (this.chainCode = t.chainCode || null),
              (this.index = t.index || 0),
              (this.parentFingerprint = t.parentFingerprint || 0),
              !this.depth && (this.parentFingerprint || this.index))
            )
              throw new Error(
                "HDKey: zero depth with non-zero index/parent fingerprint",
              );
            if (t.publicKey && t.privateKey)
              throw new Error("HDKey: publicKey and privateKey at same time.");
            if (t.privateKey) {
              if (!c.secp256k1.utils.isValidPrivateKey(t.privateKey))
                throw new Error("Invalid private key");
              (this.privKey =
                "bigint" == typeof t.privateKey
                  ? t.privateKey
                  : p(t.privateKey)),
                (this.privKeyBytes = (function (t) {
                  if ("bigint" != typeof t) throw new Error("bigint expected");
                  return (0, u.hexToBytes)(t.toString(16).padStart(64, "0"));
                })(this.privKey)),
                (this.pubKey = c.secp256k1.getPublicKey(t.privateKey, !0));
            } else {
              if (!t.publicKey)
                throw new Error("HDKey: no public or private key provided");
              this.pubKey = l.fromHex(t.publicKey).toRawBytes(!0);
            }
            var e;
            this.pubHash =
              ((e = this.pubKey), (0, i.ripemd160)((0, o.sha256)(e)));
          }
          derive(t) {
            if (!/^[mM]'?/.test(t))
              throw new Error('Path must start with "m" or "M"');
            if (/^[mM]'?$/.test(t)) return this;
            const r = t.replace(/^[mM]'?\//, "").split("/");
            let n = this;
            for (const t of r) {
              const r = /^(\d+)('?)$/.exec(t),
                i = r && r[1];
              if (!r || 3 !== r.length || "string" != typeof i)
                throw new Error("invalid child index: " + t);
              let o = +i;
              if (!Number.isSafeInteger(o) || o >= e.HARDENED_OFFSET)
                throw new Error("Invalid index");
              "'" === r[2] && (o += e.HARDENED_OFFSET), (n = n.deriveChild(o));
            }
            return n;
          }
          deriveChild(t) {
            if (!this.pubKey || !this.chainCode)
              throw new Error("No publicKey or chainCode set");
            let r = m(t);
            if (t >= e.HARDENED_OFFSET) {
              const t = this.privateKey;
              if (!t) throw new Error("Could not derive hardened child key");
              r = (0, u.concatBytes)(new Uint8Array([0]), t, r);
            } else r = (0, u.concatBytes)(this.pubKey, r);
            const i = (0, n.hmac)(s.sha512, this.chainCode, r),
              o = p(i.slice(0, 32)),
              a = i.slice(32);
            if (!c.secp256k1.utils.isValidPrivateKey(o))
              throw new Error("Tweak bigger than curve order");
            const h = {
              versions: this.versions,
              chainCode: a,
              depth: this.depth + 1,
              parentFingerprint: this.fingerprint,
              index: t,
            };
            try {
              if (this.privateKey) {
                const t = (0, f.mod)(this.privKey + o, c.secp256k1.CURVE.n);
                if (!c.secp256k1.utils.isValidPrivateKey(t))
                  throw new Error(
                    "The tweak was out of range or the resulted private key is invalid",
                  );
                h.privateKey = t;
              } else {
                const t = l.fromHex(this.pubKey).add(l.fromPrivateKey(o));
                if (t.equals(l.ZERO))
                  throw new Error(
                    "The tweak was equal to negative P, which made the result key invalid",
                  );
                h.publicKey = t.toRawBytes(!0);
              }
              return new b(h);
            } catch (e) {
              return this.deriveChild(t + 1);
            }
          }
          sign(t) {
            if (!this.privateKey) throw new Error("No privateKey set!");
            return (
              (0, a.abytes)(t, 32),
              c.secp256k1.sign(t, this.privKey).toCompactRawBytes()
            );
          }
          verify(t, e) {
            if (((0, a.abytes)(t, 32), (0, a.abytes)(e, 64), !this.publicKey))
              throw new Error("No publicKey set!");
            let r;
            try {
              r = c.secp256k1.Signature.fromCompact(e);
            } catch (t) {
              return !1;
            }
            return c.secp256k1.verify(r, t, this.publicKey);
          }
          wipePrivateData() {
            return (
              (this.privKey = void 0),
              this.privKeyBytes &&
                (this.privKeyBytes.fill(0), (this.privKeyBytes = void 0)),
              this
            );
          }
          toJSON() {
            return {
              xpriv: this.privateExtendedKey,
              xpub: this.publicExtendedKey,
            };
          }
          serialize(t, e) {
            if (!this.chainCode) throw new Error("No chainCode set");
            return (
              (0, a.abytes)(e, 33),
              (0, u.concatBytes)(
                m(t),
                new Uint8Array([this.depth]),
                m(this.parentFingerprint),
                m(this.index),
                this.chainCode,
                e,
              )
            );
          }
        }
        e.HDKey = b;
      },
      15257: (t, e, r) => {
        "use strict";
        function n(t, e) {
          return ((t[e + 0] << 8) | t[e + 1]) >>> 0;
        }
        function i(t, e, r = 0) {
          return (t[r + 0] = e >>> 8), (t[r + 1] = e >>> 0), t;
        }
        function o(t, e) {
          return t[e];
        }
        function s(t, e, r = 0) {
          return (t[r] = e), t;
        }
        function a(t, e) {
          return t[e] * 2 ** 24 + 65536 * t[e + 1] + 256 * t[e + 2] + t[e + 3];
        }
        function u(t, e, r = 0) {
          return (
            (t[r + 3] = e),
            (e >>>= 8),
            (t[r + 2] = e),
            (e >>>= 8),
            (t[r + 1] = e),
            (e >>>= 8),
            (t[r] = e),
            t
          );
        }
        r.d(e, {
          Gs: () => s,
          Sw: () => u,
          bb: () => a,
          bc: () => n,
          ml: () => i,
          pJ: () => o,
        });
      },
      43330: (t, e, r) => {
        "use strict";
        r.d(e, { Ze: () => o, dT: () => i, o3: () => n, uc: () => s });
        const n = "https://api.mainnet.hiro.so",
          i = "https://api.testnet.hiro.so",
          o = "http://localhost:3999",
          s = 33;
      },
      4563: (t, e, r) => {
        "use strict";
        r.d(e, { Hq: () => o });
        const n = {
          referrerPolicy: "origin",
          headers: { "x-hiro-product": "stacksjs" },
        };
        async function i(t, e) {
          const r = {};
          Object.assign(r, n, e);
          return await fetch(t, r);
        }
        function o(...t) {
          const { fetchLib: e, middlewares: r } = (function (t) {
            let e = i,
              r = [];
            return (
              t.length > 0 && "function" == typeof t[0] && (e = t.shift()),
              t.length > 0 && (r = t),
              { fetchLib: e, middlewares: r }
            );
          })(t);
          return async (t, n) => {
            let i = { url: t, init: n ?? {} };
            for (const t of r)
              if ("function" == typeof t.pre) {
                i = (await Promise.resolve(t.pre({ fetch: e, ...i }))) ?? i;
              }
            let o = await e(i.url, i.init);
            for (const t of r)
              if ("function" == typeof t.post) {
                const r = await Promise.resolve(
                  t.post({
                    fetch: e,
                    url: i.url,
                    init: i.init,
                    response: o?.clone() ?? o,
                  }),
                );
                o = r ?? o;
              }
            return o;
          };
        }
      },
      27367: (t, e, r) => {
        "use strict";
        r.d(e, { x: () => i });
        var n = r(39834);
        function i(t) {
          const e = "string" == typeof t ? (0, n.aT)(t) : t;
          if (32 != e.length && 33 != e.length)
            throw new Error(
              `Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${e.length}`,
            );
          if (33 == e.length && 1 !== e[32])
            throw new Error(
              "Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01",
            );
          return e;
        }
      },
      39834: (t, e, r) => {
        "use strict";
        r.d(e, {
          AE: () => m,
          AI: () => g,
          CZ: () => f,
          EL: () => M,
          Id: () => E,
          JJ: () => h,
          Mh: () => b,
          My: () => p,
          Qs: () => I,
          VI: () => l,
          WI: () => i,
          aT: () => y,
          fz: () => o,
          m5: () => n,
          od: () => c,
          qu: () => w,
          uU: () => a,
          y6: () => u,
          yB: () => S,
        });
        function n(t, e) {
          return f(i(t), e);
        }
        function i(t) {
          if ("bigint" == typeof t) return t;
          if ("string" == typeof t) return BigInt(t);
          if ("number" == typeof t) {
            if (!Number.isInteger(t))
              throw new RangeError(
                "Invalid value. Values of type 'number' must be an integer.",
              );
            if (t > Number.MAX_SAFE_INTEGER)
              throw new RangeError(
                `Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`,
              );
            return BigInt(t);
          }
          if (I(t, Uint8Array)) return BigInt(`0x${p(t)}`);
          throw new TypeError(
            "intToBigInt: Invalid value type. Must be a number, bigint, BigInt-compatible string, or Uint8Array.",
          );
        }
        function o(t) {
          return /^0x/i.test(t) ? t : `0x${t}`;
        }
        function s(t) {
          return /^0x/i.test(t) ? t.slice(2) : t;
        }
        function a(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToBigInt: expected string, got " + typeof t,
            );
          return BigInt(`0x${t}`);
        }
        function u(t, e = 8) {
          return ("bigint" == typeof t ? t : i(t))
            .toString(16)
            .padStart(2 * e, "0");
        }
        function c(t) {
          return parseInt(t, 16);
        }
        function f(t, e = 16) {
          return y(u(t, e));
        }
        function h(t, e) {
          if (
            t < -(BigInt(1) << (e - BigInt(1))) ||
            (BigInt(1) << (e - BigInt(1))) - BigInt(1) < t
          )
            throw `Unable to represent integer in width: ${e}`;
          return t >= BigInt(0) ? BigInt(t) : t + (BigInt(1) << e);
        }
        function l(t) {
          return (function (t, e) {
            if (
              (function (t, e) {
                return t & (BigInt(1) << e);
              })(t, e - BigInt(1))
            )
              return t - (BigInt(1) << e);
            return t;
          })(BigInt(`0x${p(t)}`), BigInt(8 * t.byteLength));
        }
        const d = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        function p(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let e = "";
          for (const r of t) e += d[r];
          return e;
        }
        function y(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          t = (t = s(t)).length % 2 ? `0${t}` : t;
          const e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            const n = 2 * r,
              i = t.slice(n, n + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            e[r] = o;
          }
          return e;
        }
        function g(t) {
          return new TextEncoder().encode(t);
        }
        function m(t) {
          return new TextDecoder().decode(t);
        }
        function b(t) {
          const e = [];
          for (let r = 0; r < t.length; r++) e.push(255 & t.charCodeAt(r));
          return new Uint8Array(e);
        }
        function w(t) {
          return String.fromCharCode.apply(null, t);
        }
        function v(t) {
          return !Number.isInteger(t) || t < 0 || t > 255;
        }
        function _(t) {
          if (t.some(v)) throw new Error("Some values are invalid bytes.");
          return new Uint8Array(t);
        }
        function E(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        function S(t) {
          return E(
            ...t.map((t) =>
              "number" == typeof t ? _([t]) : t instanceof Array ? _(t) : t,
            ),
          );
        }
        function I(t, e) {
          return (
            t instanceof e || t?.constructor?.name?.toLowerCase() === e.name
          );
        }
        function M(t) {
          return 64 === (t = s(t)).length && /^[0-9a-fA-F]+$/.test(t);
        }
      },
      29325: (t, e, r) => {
        "use strict";
        var n, i;
        r.d(e, {
          BY: () => s,
          J_: () => o,
          Qp: () => i,
          nU: () => n,
          tS: () => a,
        }),
          (function (t) {
            (t[(t.Mainnet = 1)] = "Mainnet"),
              (t[(t.Testnet = 2147483648)] = "Testnet");
          })(n || (n = {})),
          (function (t) {
            (t[(t.Mainnet = 385875968)] = "Mainnet"),
              (t[(t.Testnet = 4278190080)] = "Testnet");
          })(i || (i = {}));
        n.Mainnet;
        var o, s;
        !(function (t) {
          (t[(t.Mainnet = 0)] = "Mainnet"), (t[(t.Testnet = 128)] = "Testnet");
        })(o || (o = {})),
          (function (t) {
            (t[(t.MainnetSingleSig = 22)] = "MainnetSingleSig"),
              (t[(t.MainnetMultiSig = 20)] = "MainnetMultiSig"),
              (t[(t.TestnetSingleSig = 26)] = "TestnetSingleSig"),
              (t[(t.TestnetMultiSig = 21)] = "TestnetMultiSig");
          })(s || (s = {}));
        o.Mainnet;
        function a(t) {
          return (e) => e[t];
        }
      },
      33598: (t, e, r) => {
        "use strict";
        r.d(e, { SS: () => a, Up: () => h, hu: () => f, nG: () => s });
        var n = r(43330),
          i = r(4563),
          o = r(29325);
        const s = {
            chainId: o.nU.Mainnet,
            transactionVersion: o.J_.Mainnet,
            peerNetworkId: o.Qp.Mainnet,
            magicBytes: "X2",
            bootAddress: "SP000000000000000000002Q6VF78",
            addressVersion: {
              singleSig: o.BY.MainnetSingleSig,
              multiSig: o.BY.MainnetMultiSig,
            },
            client: { baseUrl: n.o3 },
          },
          a = {
            chainId: o.nU.Testnet,
            transactionVersion: o.J_.Testnet,
            peerNetworkId: o.Qp.Testnet,
            magicBytes: "T2",
            bootAddress: "ST000000000000000000002AMW42H",
            addressVersion: {
              singleSig: o.BY.TestnetSingleSig,
              multiSig: o.BY.TestnetMultiSig,
            },
            client: { baseUrl: n.dT },
          },
          u = {
            ...a,
            addressVersion: { ...a.addressVersion },
            magicBytes: "id",
            client: { baseUrl: n.Ze },
          },
          c = {
            ...u,
            addressVersion: { ...u.addressVersion },
            client: { ...u.client },
          };
        function f(t) {
          return "string" == typeof t
            ? (function (t) {
                switch (t) {
                  case "mainnet":
                    return s;
                  case "testnet":
                    return a;
                  case "devnet":
                    return u;
                  case "mocknet":
                    return c;
                  default:
                    throw new Error(`Unknown network name: ${t}`);
                }
              })(t)
            : t;
        }
        function h(t) {
          return t.client.fetch
            ? t.client
            : { ...t.client, fetch: (0, i.Hq)() };
        }
      },
      51047: (t, e, r) => {
        "use strict";
        r.d(e, { H: () => a });
        var n = r(39834),
          i = r(15257);
        const o = new Map();
        function s(t, e) {
          const r = o.get(t);
          if (void 0 !== r) return r(e);
          const n = (function (t) {
            const e = Object.values(t).filter((t) => "number" == typeof t),
              r = new Set(e);
            return (t) => r.has(t);
          })(t);
          return o.set(t, n), s(t, e);
        }
        class a {
          constructor(t) {
            (this.consumed = 0),
              (this.source = "string" == typeof t ? (0, n.aT)(t) : t);
          }
          readBytes(t) {
            const e = this.source.subarray(this.consumed, this.consumed + t);
            return (this.consumed += t), e;
          }
          readUInt32BE() {
            return (0, i.bb)(this.readBytes(4), 0);
          }
          readUInt8() {
            return (0, i.pJ)(this.readBytes(1), 0);
          }
          readUInt16BE() {
            return (0, i.bc)(this.readBytes(2), 0);
          }
          readBigUIntLE(t) {
            const e = this.readBytes(t).slice().reverse(),
              r = (0, n.My)(e);
            return BigInt(`0x${r}`);
          }
          readBigUIntBE(t) {
            const e = this.readBytes(t),
              r = (0, n.My)(e);
            return BigInt(`0x${r}`);
          }
          get readOffset() {
            return this.consumed;
          }
          set readOffset(t) {
            this.consumed = t;
          }
          get internalBytes() {
            return this.source;
          }
          readUInt8Enum(t, e) {
            const r = this.readUInt8();
            if (s(t, r)) return r;
            throw e(r);
          }
        }
      },
      74139: (t, e, r) => {
        "use strict";
        r.d(e, { f: () => s });
        var n = r(33598),
          i = r(29325),
          o = r(45842);
        function s(t, e) {
          switch (((e = (0, n.hu)(e ?? n.nG)), t)) {
            case o.ct.P2PKH:
              switch (e.transactionVersion) {
                case i.J_.Mainnet:
                  return i.BY.MainnetSingleSig;
                case i.J_.Testnet:
                  return i.BY.TestnetSingleSig;
                default:
                  throw new Error(
                    `Unexpected transactionVersion ${e.transactionVersion} for hashMode ${t}`,
                  );
              }
            case o.ct.P2SH:
            case o.ct.P2SHNonSequential:
            case o.ct.P2WPKH:
            case o.ct.P2WSH:
            case o.ct.P2WSHNonSequential:
              switch (e.transactionVersion) {
                case i.J_.Mainnet:
                  return i.BY.MainnetMultiSig;
                case i.J_.Testnet:
                  return i.BY.TestnetMultiSig;
                default:
                  throw new Error(
                    `Unexpected transactionVersion ${e.transactionVersion} for hashMode ${t}`,
                  );
              }
            default:
              throw new Error(`Unexpected hashMode ${t}`);
          }
        }
      },
      32814: (t, e, r) => {
        "use strict";
        r.d(e, {
          A6: () => B,
          AT: () => D,
          Ag: () => M,
          H7: () => z,
          I4: () => m,
          IE: () => K,
          Ir: () => b,
          Jl: () => A,
          Jr: () => C,
          Kz: () => N,
          MG: () => H,
          N7: () => I,
          NC: () => d,
          S1: () => L,
          V5: () => _,
          Xf: () => F,
          Y: () => p,
          _7: () => E,
          _o: () => S,
          _p: () => x,
          d8: () => k,
          gq: () => q,
          h2: () => $,
          k_: () => T,
          km: () => U,
          o5: () => g,
          pi: () => w,
          rT: () => O,
          tj: () => V,
          v_: () => y,
          x6: () => j,
        });
        var n = r(39834),
          i = r(15257),
          o = r(45842),
          s = r(4696),
          a = r(1755),
          u = r(48299),
          c = r(60752),
          f = r(17436),
          h = r(67449),
          l = r(89977);
        function d() {
          return {
            type: c.$.MessageSignature,
            data: (0, n.My)(new Uint8Array(o.tL)),
          };
        }
        function p(t) {
          return "publicKey" in t
            ? y(o.ct.P2PKH, t.publicKey, t.nonce, t.fee)
            : g(o.ct.P2SH, t.numSignatures, t.publicKeys, t.nonce, t.fee);
        }
        function y(t, e, r, i) {
          const s = (0, f.Uw)(0, t, 1, [(0, a.uC)(e)]).hash160,
            u = (0, a.AC)(e) ? o.G5.Compressed : o.G5.Uncompressed;
          return {
            hashMode: t,
            signer: s,
            nonce: (0, n.WI)(r),
            fee: (0, n.WI)(i),
            keyEncoding: u,
            signature: d(),
          };
        }
        function g(t, e, r, i, o) {
          const s = r.map(a.uC);
          return {
            hashMode: t,
            signer: (0, f.Uw)(0, t, e, s).hash160,
            nonce: (0, n.WI)(i),
            fee: (0, n.WI)(o),
            fields: [],
            signaturesRequired: e,
          };
        }
        function m(t) {
          return "signature" in t;
        }
        function b(t) {
          return t === o.ct.P2SH || t === o.ct.P2WSH;
        }
        function w(t) {
          return t === o.ct.P2SHNonSequential || t === o.ct.P2WSHNonSequential;
        }
        function v(t) {
          const e = (0, u.mg)(t);
          return (
            (e.nonce = 0),
            (e.fee = 0),
            m(e) ? (e.signature = d()) : (e.fields = []),
            { ...e, nonce: BigInt(0), fee: BigInt(0) }
          );
        }
        function _(t) {
          return (0, n.My)(E(t));
        }
        function E(t) {
          const e = [
            t.hashMode,
            (0, n.aT)(t.signer),
            (0, n.m5)(t.nonce, 8),
            (0, n.m5)(t.fee, 8),
            t.keyEncoding,
            (0, h.Zq)(t.signature),
          ];
          return (0, n.yB)(e);
        }
        function S(t) {
          return (0, n.My)(I(t));
        }
        function I(t) {
          const e = [
              t.hashMode,
              (0, n.aT)(t.signer),
              (0, n.m5)(t.nonce, 8),
              (0, n.m5)(t.fee, 8),
            ],
            r = (0, l.lU)(t.fields);
          e.push((0, h.SY)(r));
          const o = new Uint8Array(2);
          return (0, i.ml)(o, t.signaturesRequired, 0), e.push(o), (0, n.yB)(e);
        }
        function M(t, e) {
          const r = (0, n.My)(e.readBytes(20)),
            i = BigInt(`0x${(0, n.My)(e.readBytes(8))}`),
            a = BigInt(`0x${(0, n.My)(e.readBytes(8))}`),
            u = e.readUInt8Enum(o.G5, (t) => {
              throw new s.MJ(`Could not parse ${t} as PubKeyEncoding`);
            });
          if (t === o.ct.P2WPKH && u != o.G5.Compressed)
            throw new s.MJ(
              "Failed to parse singlesig spending condition: incomaptible hash mode and key encoding",
            );
          return {
            hashMode: t,
            signer: r,
            nonce: i,
            fee: a,
            keyEncoding: u,
            signature: (0, h.X)(e),
          };
        }
        function A(t, e) {
          const r = (0, n.My)(e.readBytes(20)),
            i = BigInt("0x" + (0, n.My)(e.readBytes(8))),
            u = BigInt("0x" + (0, n.My)(e.readBytes(8))),
            f = (0, h.em)(e, c.$.TransactionAuthField).values;
          let l = !1,
            d = 0;
          for (const t of f)
            switch (t.contents.type) {
              case c.$.PublicKey:
                (0, a.AC)(t.contents.data) || (l = !0);
                break;
              case c.$.MessageSignature:
                if (
                  (t.pubKeyEncoding === o.G5.Uncompressed && (l = !0),
                  (d += 1),
                  65536 === d)
                )
                  throw new s.mk(
                    "Failed to parse multisig spending condition: too many signatures",
                  );
            }
          const p = e.readUInt16BE();
          if (l && (t === o.ct.P2WSH || t === o.ct.P2WSHNonSequential))
            throw new s.mk(
              "Uncompressed keys are not allowed in this hash mode",
            );
          return {
            hashMode: t,
            signer: r,
            nonce: i,
            fee: u,
            fields: f,
            signaturesRequired: p,
          };
        }
        function T(t) {
          return (0, n.My)(k(t));
        }
        function k(t) {
          return m(t) ? E(t) : I(t);
        }
        function O(t) {
          const e = t.readUInt8Enum(o.ct, (t) => {
            throw new s.MJ(`Could not parse ${t} as AddressHashMode`);
          });
          return e === o.ct.P2PKH || e === o.ct.P2WPKH ? M(e, t) : A(e, t);
        }
        function x(t, e, r, i) {
          const o =
            t +
            (0, n.My)(new Uint8Array([e])) +
            (0, n.My)((0, n.m5)(r, 8)) +
            (0, n.My)((0, n.m5)(i, 8));
          if (49 !== (0, n.aT)(o).byteLength)
            throw Error("Invalid signature hash length");
          return (0, u.U1)((0, n.aT)(o));
        }
        function P(t, e, r) {
          const i = 33 + o.tL,
            s = (0, a.AC)(e.data) ? o.G5.Compressed : o.G5.Uncompressed,
            c = t + (0, u.EW)(s.toString(16)) + r,
            f = (0, n.aT)(c);
          if (f.byteLength > i) throw Error("Invalid signature hash length");
          return (0, u.U1)(f);
        }
        function B(t, e, r, n, i) {
          const o = x(t, e, r, n),
            s = (0, a.Ft)(i, o);
          return { nextSig: s, nextSigHash: P(o, (0, a.uC)((0, a.Ti)(i)), s) };
        }
        function C(t, e, r, n, i, o) {
          const s = x(t, e, r, n),
            u = (0, a.uC)((0, a.El)(s, o, i));
          return { pubKey: u, nextSigHash: P(s, u, o) };
        }
        function R(t, e, r) {
          return m(t)
            ? (function (t, e, r) {
                const { pubKey: n, nextSigHash: i } = C(
                    e,
                    r,
                    t.fee,
                    t.nonce,
                    t.keyEncoding,
                    t.signature.data,
                  ),
                  o = (0, f.Uw)(0, t.hashMode, 1, [n]).hash160;
                if (o !== t.signer)
                  throw new s.mk(
                    `Signer hash does not equal hash of public key(s): ${o} != ${t.signer}`,
                  );
                return i;
              })(t, e, r)
            : (function (t, e, r) {
                const n = [];
                let i = e,
                  u = !1,
                  h = 0;
                for (const e of t.fields)
                  switch (e.contents.type) {
                    case c.$.PublicKey:
                      (0, a.AC)(e.contents.data) || (u = !0),
                        n.push(e.contents);
                      break;
                    case c.$.MessageSignature:
                      e.pubKeyEncoding === o.G5.Uncompressed && (u = !0);
                      const { pubKey: f, nextSigHash: l } = C(
                        i,
                        r,
                        t.fee,
                        t.nonce,
                        e.pubKeyEncoding,
                        e.contents.data,
                      );
                      if (
                        (b(t.hashMode) && (i = l),
                        n.push(f),
                        (h += 1),
                        65536 === h)
                      )
                        throw new s.mk("Too many signatures");
                  }
                if (
                  (b(t.hashMode) && h !== t.signaturesRequired) ||
                  (w(t.hashMode) && h < t.signaturesRequired)
                )
                  throw new s.mk("Incorrect number of signatures");
                if (
                  u &&
                  (t.hashMode === o.ct.P2WSH ||
                    t.hashMode === o.ct.P2WSHNonSequential)
                )
                  throw new s.mk(
                    "Uncompressed keys are not allowed in this hash mode",
                  );
                const l = (0, f.Uw)(
                  0,
                  t.hashMode,
                  t.signaturesRequired,
                  n,
                ).hash160;
                if (l !== t.signer)
                  throw new s.mk(
                    `Signer hash does not equal hash of public key(s): ${l} != ${t.signer}`,
                  );
                return i;
              })(t, e, r);
        }
        function N(t) {
          return { authType: o.hT.Standard, spendingCondition: t };
        }
        function U(t, e) {
          return {
            authType: o.hT.Sponsored,
            spendingCondition: t,
            sponsorSpendingCondition: e || y(o.ct.P2PKH, "0".repeat(66), 0, 0),
          };
        }
        function D(t) {
          if (t.spendingCondition)
            switch (t.authType) {
              case o.hT.Standard:
                return N(v(t.spendingCondition));
              case o.hT.Sponsored:
                return U(
                  v(t.spendingCondition),
                  (function () {
                    const t = y(o.ct.P2PKH, "", 0, 0);
                    return (
                      (t.signer = (0, l._b)().hash160),
                      (t.keyEncoding = o.G5.Compressed),
                      (t.signature = d()),
                      t
                    );
                  })(),
                );
              default:
                throw new s.uJ("Unexpected authorization type for signing");
            }
          throw new Error("Authorization missing SpendingCondition");
        }
        function L(t, e) {
          switch (t.authType) {
            case o.hT.Standard:
            case o.hT.Sponsored:
              return R(t.spendingCondition, e, o.hT.Standard);
            default:
              throw new s.uJ("Invalid origin auth type");
          }
        }
        function j(t, e) {
          switch (t.authType) {
            case o.hT.Standard:
              const r = { ...t.spendingCondition, fee: (0, n.WI)(e) };
              return { ...t, spendingCondition: r };
            case o.hT.Sponsored:
              const i = { ...t.sponsorSpendingCondition, fee: (0, n.WI)(e) };
              return { ...t, sponsorSpendingCondition: i };
          }
        }
        function F(t) {
          switch (t.authType) {
            case o.hT.Standard:
              return t.spendingCondition.fee;
            case o.hT.Sponsored:
              return t.sponsorSpendingCondition.fee;
          }
        }
        function H(t, e) {
          const r = { ...t.spendingCondition, nonce: (0, n.WI)(e) };
          return { ...t, spendingCondition: r };
        }
        function K(t, e) {
          const r = { ...t.sponsorSpendingCondition, nonce: (0, n.WI)(e) };
          return { ...t, sponsorSpendingCondition: r };
        }
        function V(t, e) {
          return {
            ...t,
            sponsorSpendingCondition: {
              ...e,
              nonce: (0, n.WI)(e.nonce),
              fee: (0, n.WI)(e.fee),
            },
          };
        }
        function q(t) {
          return (0, n.My)(z(t));
        }
        function z(t) {
          const e = [];
          switch ((e.push(t.authType), t.authType)) {
            case o.hT.Standard:
              e.push(k(t.spendingCondition));
              break;
            case o.hT.Sponsored:
              e.push(k(t.spendingCondition)),
                e.push(k(t.sponsorSpendingCondition));
          }
          return (0, n.yB)(e);
        }
        function $(t) {
          let e;
          switch (
            t.readUInt8Enum(o.hT, (t) => {
              throw new s.MJ(`Could not parse ${t} as AuthType`);
            })
          ) {
            case o.hT.Standard:
              return (e = O(t)), N(e);
            case o.hT.Sponsored:
              e = O(t);
              return U(e, O(t));
          }
        }
      },
      12799: (t, e, r) => {
        "use strict";
        r.d(e, {
          Pt: () => w,
          XV: () => g,
          ok: () => v,
          uj: () => m,
          y9: () => b,
          zI: () => E,
          zL: () => _,
        });
        var n = r(33598),
          i = r(7581),
          o = r(32814),
          s = r(45842),
          a = r(34534),
          u = r(96227),
          c = r(1755),
          f = r(86664),
          h = r(63001),
          l = r(41011),
          d = r(48299),
          p = r(89977),
          y = r(17436);
        async function g(t) {
          const e = {
              fee: BigInt(0),
              nonce: BigInt(0),
              network: n.nG,
              memo: "",
              sponsored: !1,
            },
            r = Object.assign(e, t);
          (r.network = (0, n.hu)(r.network)),
            (r.client = Object.assign({}, (0, n.Up)(r.network), t.client));
          const a = (0, p.zh)(r.recipient, r.amount, r.memo);
          let f = null;
          if ("publicKey" in r)
            f = (0, o.v_)(s.ct.P2PKH, r.publicKey, r.nonce, r.fee);
          else {
            const t = r.useNonSequentialMultiSig
                ? s.ct.P2SHNonSequential
                : s.ct.P2SH,
              e = r.address
                ? I(
                    r.publicKeys.map(c.ru),
                    r.numSignatures,
                    t,
                    (0, p.FR)(r.address).hash160,
                  )
                : r.publicKeys.map(c.ru);
            f = (0, o.o5)(t, r.numSignatures, e, r.nonce, r.fee);
          }
          const h = r.sponsored ? (0, o.km)(f) : (0, o.Kz)(f),
            d = new l.$f({
              transactionVersion: r.network.transactionVersion,
              chainId: r.network.chainId,
              auth: h,
              payload: a,
            });
          if (null == t.fee) {
            const t = await (0, u.tL)({ transaction: d, ...r });
            d.setFee(t);
          }
          if (null == t.nonce) {
            const t = r.network.addressVersion.singleSig,
              e = (0, i.bJ)(t, d.auth.spendingCondition.signer),
              n = await (0, u.QQ)({ address: e, ...r });
            d.setNonce(n);
          }
          return d;
        }
        async function m(t) {
          if ("senderKey" in t) {
            const e = (0, c.Ti)(t.senderKey),
              r = (0, d.cJ)(t, "senderKey"),
              n = await g({ publicKey: e, ...r }),
              i = t.senderKey;
            return new h.p(n).signOrigin(i), n;
          }
          {
            const e = (0, d.cJ)(t, "signerKeys"),
              r = await g(e);
            return (
              S(
                r,
                t.publicKeys.map(c.ru).slice(),
                t.signerKeys.map(c.xr),
                t.address,
              ),
              r
            );
          }
        }
        async function b(t) {
          if ("senderKey" in t) {
            const e = (0, c.Ti)(t.senderKey),
              r = (0, d.cJ)(t, "senderKey"),
              n = await w({ publicKey: e, ...r }),
              i = t.senderKey;
            return new h.p(n).signOrigin(i), n;
          }
          {
            const e = (0, d.cJ)(t, "signerKeys"),
              r = await w(e);
            return (
              S(
                r,
                t.publicKeys.map(c.ru).slice(),
                t.signerKeys.map(c.xr),
                t.address,
              ),
              r
            );
          }
        }
        async function w(t) {
          const e = {
              fee: BigInt(0),
              nonce: BigInt(0),
              network: n.nG,
              postConditionMode: s.FN.Deny,
              sponsored: !1,
              clarityVersion: s.nX.Clarity3,
            },
            r = Object.assign(e, t);
          (r.network = (0, n.hu)(r.network)),
            (r.client = Object.assign({}, (0, n.Up)(r.network), t.client)),
            (r.postConditionMode = (0, f.HI)(r.postConditionMode));
          const a = (0, p.Ox)(r.contractName, r.codeBody, r.clarityVersion);
          let h = null;
          if ("publicKey" in r)
            h = (0, o.v_)(s.ct.P2PKH, r.publicKey, r.nonce, r.fee);
          else {
            const t = r.useNonSequentialMultiSig
                ? s.ct.P2SHNonSequential
                : s.ct.P2SH,
              e = r.address
                ? I(
                    r.publicKeys.map(c.ru),
                    r.numSignatures,
                    t,
                    (0, p.FR)(r.address).hash160,
                  )
                : r.publicKeys.map(c.ru);
            h = (0, o.o5)(t, r.numSignatures, e, r.nonce, r.fee);
          }
          const d = r.sponsored ? (0, o.km)(h) : (0, o.Kz)(h),
            y = (r.postConditions ?? []).map((t) =>
              "string" == typeof t.type ? (0, f._)(t) : t,
            ),
            g = (0, p.lU)(y),
            m = new l.$f({
              transactionVersion: r.network.transactionVersion,
              chainId: r.network.chainId,
              auth: d,
              payload: a,
              postConditions: g,
              postConditionMode: r.postConditionMode,
            });
          if (void 0 === t.fee || null === t.fee) {
            const t = await (0, u.tL)({ transaction: m, ...r });
            m.setFee(t);
          }
          if (void 0 === t.nonce || null === t.nonce) {
            const t = r.network.addressVersion.singleSig,
              e = (0, i.bJ)(t, m.auth.spendingCondition.signer),
              n = await (0, u.QQ)({ address: e, ...r });
            m.setNonce(n);
          }
          return m;
        }
        async function v(t) {
          const e = {
              fee: BigInt(0),
              nonce: BigInt(0),
              network: n.nG,
              postConditionMode: s.FN.Deny,
              sponsored: !1,
            },
            r = Object.assign(e, t);
          (r.network = (0, n.hu)(r.network)),
            (r.client = Object.assign({}, (0, n.Up)(r.network), r.client)),
            (r.postConditionMode = (0, f.HI)(r.postConditionMode));
          const h = (0, p.tT)(
            r.contractAddress,
            r.contractName,
            r.functionName,
            r.functionArgs,
          );
          if (r?.validateWithAbi) {
            let t;
            if ("boolean" == typeof r.validateWithAbi) {
              if (!r?.network)
                throw new Error(
                  "Network option must be provided in order to validate with ABI",
                );
              t = await (0, u.dN)({ ...r });
            } else t = r.validateWithAbi;
            (0, a.d8)(h, t);
          }
          let d = null;
          if ("publicKey" in r)
            d = (0, o.v_)(s.ct.P2PKH, r.publicKey, r.nonce, r.fee);
          else {
            const t = r.useNonSequentialMultiSig
                ? s.ct.P2SHNonSequential
                : s.ct.P2SH,
              e = r.address
                ? I(
                    r.publicKeys.map(c.ru),
                    r.numSignatures,
                    t,
                    (0, p.FR)(r.address).hash160,
                  )
                : r.publicKeys.map(c.ru);
            d = (0, o.o5)(t, r.numSignatures, e, r.nonce, r.fee);
          }
          const y = r.sponsored ? (0, o.km)(d) : (0, o.Kz)(d),
            g = (r.postConditions ?? []).map((t) =>
              "string" == typeof t.type ? (0, f._)(t) : t,
            ),
            m = (0, p.lU)(g),
            b = new l.$f({
              transactionVersion: r.network.transactionVersion,
              chainId: r.network.chainId,
              auth: y,
              payload: h,
              postConditions: m,
              postConditionMode: r.postConditionMode,
            });
          if (void 0 === t.fee || null === t.fee) {
            const t = await (0, u.tL)({ transaction: b, ...r });
            b.setFee(t);
          }
          if (void 0 === t.nonce || null === t.nonce) {
            const t = r.network.addressVersion.singleSig,
              e = (0, i.bJ)(t, b.auth.spendingCondition.signer),
              n = await (0, u.QQ)({ address: e, ...r });
            b.setNonce(n);
          }
          return b;
        }
        async function _(t) {
          if ("senderKey" in t) {
            const e = (0, c.Ti)(t.senderKey),
              r = (0, d.cJ)(t, "senderKey"),
              n = await v({ publicKey: e, ...r }),
              i = t.senderKey;
            return new h.p(n).signOrigin(i), n;
          }
          {
            const e = (0, d.cJ)(t, "signerKeys"),
              r = await v(e);
            return (
              S(
                r,
                t.publicKeys.map(c.ru).slice(),
                t.signerKeys.map(c.xr),
                t.address,
              ),
              r
            );
          }
        }
        async function E(t) {
          const e = {
              fee: 0,
              sponsorNonce: 0,
              sponsorAddressHashmode: s.ct.P2PKH,
              network: (0, l.OC)(t.transaction),
            },
            r = Object.assign(e, t);
          (r.network = (0, n.hu)(r.network)),
            (r.client = Object.assign({}, (0, n.Up)(r.network), r.client));
          const i = (0, c.Ti)(r.sponsorPrivateKey);
          if (null == t.fee) {
            let t = 0;
            switch (r.transaction.payload.payloadType) {
              case s.d2.TokenTransfer:
              case s.d2.SmartContract:
              case s.d2.VersionedSmartContract:
              case s.d2.ContractCall:
                t = BigInt(await (0, u.tL)({ ...r }));
                break;
              default:
                throw new Error(
                  `Sponsored transactions not supported for transaction type ${s.d2[r.transaction.payload.payloadType]}`,
                );
            }
            r.transaction.setFee(t), (r.fee = t);
          }
          if (null == t.sponsorNonce) {
            const t = r.network.addressVersion.singleSig,
              e = (0, c.M)(t, i),
              n = await (0, u.QQ)({ address: e, ...r });
            r.sponsorNonce = n;
          }
          const a = (0, o.v_)(
            r.sponsorAddressHashmode,
            i,
            r.sponsorNonce,
            r.fee,
          );
          r.transaction.setSponsor(a);
          const f = r.sponsorPrivateKey,
            d = h.p.createSponsorSigner(r.transaction, a);
          return d.signSponsor(f), d.transaction;
        }
        function S(t, e, r, n) {
          if ((0, o.I4)(t.auth.spendingCondition))
            throw new Error("Transaction is not a multi-sig transaction");
          const i = new h.p(t),
            s = n
              ? I(
                  e,
                  t.auth.spendingCondition.signaturesRequired,
                  t.auth.spendingCondition.hashMode,
                  (0, p.FR)(n).hash160,
                )
              : e;
          for (const t of s) {
            const e = r.find((e) => (0, c.Ti)(e) === t);
            e ? i.signOrigin(e) : i.appendOrigin(t);
          }
        }
        function I(t, e, r, n) {
          if ((0, y.Uw)(0, r, e, t.map(c.uC)).hash160 === n) return t;
          const i = t.slice().sort();
          if ((0, y.Uw)(0, r, e, i.map(c.uC)).hash160 === n) return i;
          throw new Error(
            "Failed to find matching multi-sig address given public-keys.",
          );
        }
      },
      19419: (t, e, r) => {
        "use strict";
        r.d(e, {
          E4: () => s,
          JP: () => a,
          P2: () => u,
          Ss: () => o,
          f: () => c,
        });
        var n = r(38389),
          i = r(39834);
        function o(t, e = "hex") {
          switch (t.type) {
            case n.dl.BoolTrue:
              return "true";
            case n.dl.BoolFalse:
              return "false";
            case n.dl.Int:
              return t.value.toString();
            case n.dl.UInt:
              return `u${t.value.toString()}`;
            case n.dl.Buffer:
              if ("tryAscii" === e) {
                const e = (0, i.qu)((0, i.aT)(t.value));
                if (/[ -~]/.test(e)) return JSON.stringify(e);
              }
              return `0x${t.value}`;
            case n.dl.OptionalNone:
              return "none";
            case n.dl.OptionalSome:
              return `(some ${o(t.value, e)})`;
            case n.dl.ResponseErr:
              return `(err ${o(t.value, e)})`;
            case n.dl.ResponseOk:
              return `(ok ${o(t.value, e)})`;
            case n.dl.PrincipalStandard:
            case n.dl.PrincipalContract:
              return t.value;
            case n.dl.List:
              return `(list ${t.value.map((t) => o(t, e)).join(" ")})`;
            case n.dl.Tuple:
              return `(tuple ${Object.keys(t.value)
                .map((r) => `(${r} ${o(t.value[r], e)})`)
                .join(" ")})`;
            case n.dl.StringASCII:
              return `"${t.value}"`;
            case n.dl.StringUTF8:
              return `u"${t.value}"`;
          }
        }
        function s(t, e = !1) {
          switch (t.type) {
            case n.dl.BoolTrue:
              return !0;
            case n.dl.BoolFalse:
              return !1;
            case n.dl.Int:
            case n.dl.UInt:
              return e ? t.value.toString() : t.value;
            case n.dl.Buffer:
              return `0x${t.value}`;
            case n.dl.OptionalNone:
              return null;
            case n.dl.OptionalSome:
            case n.dl.ResponseErr:
            case n.dl.ResponseOk:
              return a(t.value);
            case n.dl.PrincipalStandard:
            case n.dl.PrincipalContract:
              return t.value;
            case n.dl.List:
              return t.value.map((t) => a(t));
            case n.dl.Tuple:
              const r = {};
              return (
                Object.keys(t.value).forEach((e) => {
                  r[e] = a(t.value[e]);
                }),
                r
              );
            case n.dl.StringASCII:
            case n.dl.StringUTF8:
              return t.value;
          }
        }
        function a(t) {
          switch (t.type) {
            case n.dl.ResponseErr:
              return { type: u(t), value: s(t, !0), success: !1 };
            case n.dl.ResponseOk:
              return { type: u(t), value: s(t, !0), success: !0 };
            default:
              return { type: u(t), value: s(t, !0) };
          }
        }
        function u(t) {
          switch (t.type) {
            case n.dl.BoolTrue:
            case n.dl.BoolFalse:
              return "bool";
            case n.dl.Int:
              return "int";
            case n.dl.UInt:
              return "uint";
            case n.dl.Buffer:
              return `(buff ${Math.ceil(t.value.length / 2)})`;
            case n.dl.OptionalNone:
              return "(optional none)";
            case n.dl.OptionalSome:
              return `(optional ${u(t.value)})`;
            case n.dl.ResponseErr:
              return `(response UnknownType ${u(t.value)})`;
            case n.dl.ResponseOk:
              return `(response ${u(t.value)} UnknownType)`;
            case n.dl.PrincipalStandard:
            case n.dl.PrincipalContract:
              return "principal";
            case n.dl.List:
              return `(list ${t.value.length} ${t.value.length ? u(t.value[0]) : "UnknownType"})`;
            case n.dl.Tuple:
              return `(tuple ${Object.keys(t.value)
                .map((e) => `(${e} ${u(t.value[e])})`)
                .join(" ")})`;
            case n.dl.StringASCII:
              return `(string-ascii ${(0, i.Mh)(t.value).length})`;
            case n.dl.StringUTF8:
              return `(string-utf8 ${(0, i.AI)(t.value).length})`;
          }
        }
        function c(t, e) {
          return t.type === e;
        }
      },
      38389: (t, e, r) => {
        "use strict";
        var n, i;
        function o(t) {
          return i[t];
        }
        function s(t) {
          return i[t];
        }
        r.d(e, { Gk: () => s, dl: () => n, qz: () => i, ug: () => o }),
          (function (t) {
            (t.Int = "int"),
              (t.UInt = "uint"),
              (t.Buffer = "buffer"),
              (t.BoolTrue = "true"),
              (t.BoolFalse = "false"),
              (t.PrincipalStandard = "address"),
              (t.PrincipalContract = "contract"),
              (t.ResponseOk = "ok"),
              (t.ResponseErr = "err"),
              (t.OptionalNone = "none"),
              (t.OptionalSome = "some"),
              (t.List = "list"),
              (t.Tuple = "tuple"),
              (t.StringASCII = "ascii"),
              (t.StringUTF8 = "utf8");
          })(n || (n = {})),
          (function (t) {
            (t[(t.int = 0)] = "int"),
              (t[(t.uint = 1)] = "uint"),
              (t[(t.buffer = 2)] = "buffer"),
              (t[(t.true = 3)] = "true"),
              (t[(t.false = 4)] = "false"),
              (t[(t.address = 5)] = "address"),
              (t[(t.contract = 6)] = "contract"),
              (t[(t.ok = 7)] = "ok"),
              (t[(t.err = 8)] = "err"),
              (t[(t.none = 9)] = "none"),
              (t[(t.some = 10)] = "some"),
              (t[(t.list = 11)] = "list"),
              (t[(t.tuple = 12)] = "tuple"),
              (t[(t.ascii = 13)] = "ascii"),
              (t[(t.utf8 = 14)] = "utf8");
          })(i || (i = {}));
      },
      90687: (t, e, r) => {
        "use strict";
        r.d(e, { b: () => m });
        var n = r(39834),
          i = r(38389),
          o = r(11171),
          s = r(29048),
          a = r(91438),
          u = r(18480),
          c = r(8501),
          f = r(21086),
          h = r(88906),
          l = r(79796),
          d = r(45547),
          p = r(51047),
          y = r(4696),
          g = r(67449);
        function m(t) {
          let e;
          if ("string" == typeof t) {
            const r = "0x" === t.slice(0, 2).toLowerCase();
            e = new p.H((0, n.aT)(r ? t.slice(2) : t));
          } else e = t instanceof Uint8Array ? new p.H(t) : t;
          switch (
            e.readUInt8Enum(i.qz, (t) => {
              throw new y.MJ(`Cannot recognize Clarity Type: ${t}`);
            })
          ) {
            case i.qz.int:
              return (0, o.p)((0, n.VI)(e.readBytes(16)));
            case i.qz.uint:
              return (0, o.u)(e.readBytes(16));
            case i.qz.buffer:
              const t = e.readUInt32BE();
              return (0, s.I)(e.readBytes(t));
            case i.qz.true:
              return (0, a.WM)();
            case i.qz.false:
              return (0, a.PH)();
            case i.qz.address:
              const r = (0, g.AP)(e);
              return (0, u.Hh)(r);
            case i.qz.contract:
              const p = (0, g.AP)(e),
                b = (0, g.Dp)(e);
              return (0, u.a5)(p, b);
            case i.qz.ok:
              return (0, c.B)(m(e));
            case i.qz.err:
              return (0, c.v)(m(e));
            case i.qz.none:
              return (0, f.gu)();
            case i.qz.some:
              return (0, f.gp)(m(e));
            case i.qz.list:
              const w = e.readUInt32BE(),
                v = [];
              for (let t = 0; t < w; t++) v.push(m(e));
              return (0, h.y)(v);
            case i.qz.tuple:
              const _ = e.readUInt32BE(),
                E = {};
              for (let t = 0; t < _; t++) {
                const t = (0, g.Dp)(e).content;
                if (void 0 === t) throw new y.MJ('"content" is undefined');
                E[t] = m(e);
              }
              return (0, l.M)(E);
            case i.qz.ascii:
              const S = e.readUInt32BE(),
                I = (0, n.qu)(e.readBytes(S));
              return (0, d.IE)(I);
            case i.qz.utf8:
              const M = e.readUInt32BE(),
                A = (0, n.AE)(e.readBytes(M));
              return (0, d.y3)(A);
            default:
              throw new y.MJ(
                "Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.",
              );
          }
        }
      },
      61994: (t, e, r) => {
        "use strict";
        r.d(e, { G: () => d, n: () => p });
        var n = r(39834),
          i = r(15257),
          o = r(45842),
          s = r(4696),
          a = r(48299),
          u = r(67449),
          c = r(89977),
          f = r(38389);
        function h(t, e) {
          return (0, n.yB)([(0, f.ug)(t), e]);
        }
        function l(t, e) {
          const r = [],
            o = "ascii" == e ? (0, n.Mh)(t.value) : (0, n.AI)(t.value),
            s = new Uint8Array(4);
          return (
            (0, i.Sw)(s, o.length, 0),
            r.push(s),
            r.push(o),
            h(t.type, (0, n.yB)(r))
          );
        }
        function d(t) {
          return (0, n.My)(p(t));
        }
        function p(t) {
          switch (t.type) {
            case f.dl.BoolTrue:
            case f.dl.BoolFalse:
              return (function (t) {
                return new Uint8Array([(0, f.ug)(t.type)]);
              })(t);
            case f.dl.OptionalNone:
            case f.dl.OptionalSome:
              return (e = t).type === f.dl.OptionalNone
                ? new Uint8Array([(0, f.ug)(e.type)])
                : h(e.type, p(e.value));
            case f.dl.Buffer:
              return (function (t) {
                const e = new Uint8Array(4);
                return (
                  (0, i.Sw)(e, Math.ceil(t.value.length / 2), 0),
                  h(t.type, (0, n.Id)(e, (0, n.aT)(t.value)))
                );
              })(t);
            case f.dl.UInt:
              return (function (t) {
                const e = (0, n.CZ)(BigInt(t.value), o.gb);
                return h(t.type, e);
              })(t);
            case f.dl.Int:
              return (function (t) {
                const e = (0, n.CZ)(
                  (0, n.JJ)(BigInt(t.value), BigInt(o.H0)),
                  o.gb,
                );
                return h(t.type, e);
              })(t);
            case f.dl.PrincipalStandard:
              return (function (t) {
                return h(t.type, (0, u.ij)((0, c.FR)(t.value)));
              })(t);
            case f.dl.PrincipalContract:
              return (function (t) {
                const [e, r] = (0, a.zi)(t.value);
                return h(
                  t.type,
                  (0, n.Id)((0, u.ij)((0, c.FR)(e)), (0, u.Xe)((0, c.o1)(r))),
                );
              })(t);
            case f.dl.ResponseOk:
            case f.dl.ResponseErr:
              return (function (t) {
                return h(t.type, p(t.value));
              })(t);
            case f.dl.List:
              return (function (t) {
                const e = [],
                  r = new Uint8Array(4);
                (0, i.Sw)(r, t.value.length, 0), e.push(r);
                for (const r of t.value) {
                  const t = p(r);
                  e.push(t);
                }
                return h(t.type, (0, n.yB)(e));
              })(t);
            case f.dl.Tuple:
              return (function (t) {
                const e = [],
                  r = new Uint8Array(4);
                (0, i.Sw)(r, Object.keys(t.value).length, 0), e.push(r);
                const o = Object.keys(t.value).sort((t, e) =>
                  t.localeCompare(e),
                );
                for (const r of o) {
                  const n = (0, c.o1)(r);
                  e.push((0, u.Xe)(n));
                  const i = p(t.value[r]);
                  e.push(i);
                }
                return h(t.type, (0, n.yB)(e));
              })(t);
            case f.dl.StringASCII:
              return (function (t) {
                return l(t, "ascii");
              })(t);
            case f.dl.StringUTF8:
              return (function (t) {
                return l(t, "utf8");
              })(t);
            default:
              throw new s.Fn("Unable to serialize. Invalid Clarity Value.");
          }
          var e;
        }
      },
      91438: (t, e, r) => {
        "use strict";
        r.d(e, { PH: () => o, WM: () => i, yw: () => s });
        var n = r(38389);
        const i = () => ({ type: n.dl.BoolTrue }),
          o = () => ({ type: n.dl.BoolFalse }),
          s = (t) => (t ? i() : o());
      },
      29048: (t, e, r) => {
        "use strict";
        r.d(e, { I: () => o, L: () => s });
        var n = r(39834),
          i = r(38389);
        const o = (t) => {
            if (t.byteLength > 1048576)
              throw new Error(
                "Cannot construct clarity buffer that is greater than 1MB",
              );
            return { type: i.dl.Buffer, value: (0, n.My)(t) };
          },
          s = (t) => o((0, n.AI)(t));
      },
      11171: (t, e, r) => {
        "use strict";
        r.d(e, { p: () => c, u: () => f });
        var n = r(39834),
          i = r(38389);
        const o = BigInt("0xffffffffffffffffffffffffffffffff"),
          s = BigInt(0),
          a = BigInt("0x7fffffffffffffffffffffffffffffff"),
          u = BigInt("-170141183460469231731687303715884105728"),
          c = (t) => {
            "string" == typeof t &&
              t.toLowerCase().startsWith("0x") &&
              (t = (0, n.VI)((0, n.aT)(t))),
              (0, n.Qs)(t, Uint8Array) && (t = (0, n.VI)(t));
            const e = (0, n.WI)(t);
            if (e > a)
              throw new RangeError(
                `Cannot construct clarity integer from value greater than ${a}`,
              );
            if (e < u)
              throw new RangeError(
                `Cannot construct clarity integer form value less than ${u}`,
              );
            return { type: i.dl.Int, value: e };
          },
          f = (t) => {
            const e = (0, n.WI)(t);
            if (e < s)
              throw new RangeError(
                "Cannot construct unsigned clarity integer from negative value",
              );
            if (e > o)
              throw new RangeError(
                `Cannot construct unsigned clarity integer greater than ${o}`,
              );
            return { type: i.dl.UInt, value: e };
          };
      },
      88906: (t, e, r) => {
        "use strict";
        r.d(e, { y: () => i });
        var n = r(38389);
        function i(t) {
          return { type: n.dl.List, value: t };
        }
      },
      21086: (t, e, r) => {
        "use strict";
        r.d(e, { gp: () => o, gu: () => i, hg: () => s });
        var n = r(38389);
        function i() {
          return { type: n.dl.OptionalNone };
        }
        function o(t) {
          return { type: n.dl.OptionalSome, value: t };
        }
        function s(t) {
          return t ? o(t) : i();
        }
      },
      18480: (t, e, r) => {
        "use strict";
        r.d(e, {
          Hh: () => c,
          a5: () => h,
          f: () => u,
          g7: () => a,
          iZ: () => f,
          jS: () => l,
        });
        var n = r(39834),
          i = r(89977),
          o = r(17436),
          s = r(38389);
        function a(t) {
          if (t.includes(".")) {
            const [e, r] = t.split(".");
            return f(e, r);
          }
          return u(t);
        }
        function u(t) {
          const e = (0, i.FR)(t);
          return { type: s.dl.PrincipalStandard, value: (0, o.pD)(e) };
        }
        function c(t) {
          return { type: s.dl.PrincipalStandard, value: (0, o.pD)(t) };
        }
        function f(t, e) {
          return h((0, i.FR)(t), (0, i.o1)(e));
        }
        function h(t, e) {
          if ((0, n.AI)(e.content).byteLength >= 128)
            throw new Error("Contract name must be less than 128 bytes");
          return {
            type: s.dl.PrincipalContract,
            value: `${(0, o.pD)(t)}.${e.content}`,
          };
        }
        function l(t, e) {
          return { type: s.dl.PrincipalContract, value: `${t.value}.${e}` };
        }
      },
      8501: (t, e, r) => {
        "use strict";
        r.d(e, { B: () => o, v: () => i });
        var n = r(38389);
        function i(t) {
          return { type: n.dl.ResponseErr, value: t };
        }
        function o(t) {
          return { type: n.dl.ResponseOk, value: t };
        }
      },
      45547: (t, e, r) => {
        "use strict";
        r.d(e, { IE: () => i, rv: () => s, y3: () => o });
        var n = r(38389);
        const i = (t) => ({ type: n.dl.StringASCII, value: t }),
          o = (t) => ({ type: n.dl.StringUTF8, value: t }),
          s = (t, e) => {
            switch (e) {
              case "ascii":
                return i(t);
              case "utf8":
                return o(t);
            }
          };
      },
      79796: (t, e, r) => {
        "use strict";
        r.d(e, { M: () => o });
        var n = r(38389),
          i = r(48299);
        function o(t) {
          for (const e in t)
            if (!(0, i.qw)(e))
              throw new Error(`"${e}" is not a valid Clarity name`);
          return { type: n.dl.Tuple, value: t };
        }
      },
      45842: (t, e, r) => {
        "use strict";
        r.d(e, {
          $8: () => P,
          BY: () => n.BY,
          Dv: () => x,
          Dx: () => M,
          Ej: () => o,
          FN: () => v,
          Fj: () => g,
          G5: () => I,
          H0: () => s,
          Ld: () => O,
          PW: () => k,
          V9: () => T,
          ct: () => S,
          d2: () => p,
          gb: () => a,
          hT: () => E,
          j4: () => d,
          jz: () => m,
          mw: () => h,
          nU: () => w,
          nX: () => y,
          q$: () => A,
          qu: () => _,
          tL: () => f,
          vX: () => c,
          xV: () => l,
          yZ: () => u,
          zB: () => i,
        });
        var n = r(29325);
        const i = "https://hub.blockstack.org",
          o = 128,
          s = 128,
          a = 16,
          u = 32,
          c = 80,
          f = 65,
          h = 32,
          l = 64,
          d = 34;
        var p, y, g;
        !(function (t) {
          (t[(t.TokenTransfer = 0)] = "TokenTransfer"),
            (t[(t.SmartContract = 1)] = "SmartContract"),
            (t[(t.VersionedSmartContract = 6)] = "VersionedSmartContract"),
            (t[(t.ContractCall = 2)] = "ContractCall"),
            (t[(t.PoisonMicroblock = 3)] = "PoisonMicroblock"),
            (t[(t.Coinbase = 4)] = "Coinbase"),
            (t[(t.CoinbaseToAltRecipient = 5)] = "CoinbaseToAltRecipient"),
            (t[(t.TenureChange = 7)] = "TenureChange"),
            (t[(t.NakamotoCoinbase = 8)] = "NakamotoCoinbase");
        })(p || (p = {})),
          (function (t) {
            (t[(t.Clarity1 = 1)] = "Clarity1"),
              (t[(t.Clarity2 = 2)] = "Clarity2"),
              (t[(t.Clarity3 = 3)] = "Clarity3");
          })(y || (y = {})),
          (function (t) {
            (t[(t.OnChainOnly = 1)] = "OnChainOnly"),
              (t[(t.OffChainOnly = 2)] = "OffChainOnly"),
              (t[(t.Any = 3)] = "Any");
          })(g || (g = {}));
        const m = ["onChainOnly", "offChainOnly", "any"],
          b = {
            [m[0]]: g.OnChainOnly,
            [m[1]]: g.OffChainOnly,
            [m[2]]: g.Any,
            [g.OnChainOnly]: g.OnChainOnly,
            [g.OffChainOnly]: g.OffChainOnly,
            [g.Any]: g.Any,
          };
        function w(t) {
          if (t in b) return b[t];
          throw new Error(
            `Invalid anchor mode "${t}", must be one of: ${m.join(", ")}`,
          );
        }
        var v, _, E, S, I, M, A, T, k, O, x, P;
        !(function (t) {
          (t[(t.Allow = 1)] = "Allow"), (t[(t.Deny = 2)] = "Deny");
        })(v || (v = {})),
          (function (t) {
            (t[(t.STX = 0)] = "STX"),
              (t[(t.Fungible = 1)] = "Fungible"),
              (t[(t.NonFungible = 2)] = "NonFungible");
          })(_ || (_ = {})),
          (function (t) {
            (t[(t.Standard = 4)] = "Standard"),
              (t[(t.Sponsored = 5)] = "Sponsored");
          })(E || (E = {})),
          (function (t) {
            (t[(t.P2PKH = 0)] = "P2PKH"),
              (t[(t.P2SH = 1)] = "P2SH"),
              (t[(t.P2WPKH = 2)] = "P2WPKH"),
              (t[(t.P2WSH = 3)] = "P2WSH"),
              (t[(t.P2SHNonSequential = 5)] = "P2SHNonSequential"),
              (t[(t.P2WSHNonSequential = 7)] = "P2WSHNonSequential");
          })(S || (S = {})),
          (function (t) {
            (t[(t.Compressed = 0)] = "Compressed"),
              (t[(t.Uncompressed = 1)] = "Uncompressed");
          })(I || (I = {})),
          (function (t) {
            (t[(t.Equal = 1)] = "Equal"),
              (t[(t.Greater = 2)] = "Greater"),
              (t[(t.GreaterEqual = 3)] = "GreaterEqual"),
              (t[(t.Less = 4)] = "Less"),
              (t[(t.LessEqual = 5)] = "LessEqual");
          })(M || (M = {})),
          (function (t) {
            (t[(t.Sends = 16)] = "Sends"),
              (t[(t.DoesNotSend = 17)] = "DoesNotSend");
          })(A || (A = {})),
          (function (t) {
            (t[(t.Origin = 1)] = "Origin"),
              (t[(t.Standard = 2)] = "Standard"),
              (t[(t.Contract = 3)] = "Contract");
          })(T || (T = {})),
          (function (t) {
            (t[(t.STX = 0)] = "STX"),
              (t[(t.Fungible = 1)] = "Fungible"),
              (t[(t.NonFungible = 2)] = "NonFungible");
          })(k || (k = {})),
          (function (t) {
            (t[(t.BlockFound = 0)] = "BlockFound"),
              (t[(t.Extended = 1)] = "Extended");
          })(O || (O = {})),
          (function (t) {
            (t[(t.PublicKeyCompressed = 0)] = "PublicKeyCompressed"),
              (t[(t.PublicKeyUncompressed = 1)] = "PublicKeyUncompressed"),
              (t[(t.SignatureCompressed = 2)] = "SignatureCompressed"),
              (t[(t.SignatureUncompressed = 3)] = "SignatureUncompressed");
          })(x || (x = {})),
          (function (t) {
            (t.Serialization = "Serialization"),
              (t.Deserialization = "Deserialization"),
              (t.SignatureValidation = "SignatureValidation"),
              (t.FeeTooLow = "FeeTooLow"),
              (t.BadNonce = "BadNonce"),
              (t.NotEnoughFunds = "NotEnoughFunds"),
              (t.NoSuchContract = "NoSuchContract"),
              (t.NoSuchPublicFunction = "NoSuchPublicFunction"),
              (t.BadFunctionArgument = "BadFunctionArgument"),
              (t.ContractAlreadyExists = "ContractAlreadyExists"),
              (t.PoisonMicroblocksDoNotConflict =
                "PoisonMicroblocksDoNotConflict"),
              (t.PoisonMicroblockHasUnknownPubKeyHash =
                "PoisonMicroblockHasUnknownPubKeyHash"),
              (t.PoisonMicroblockIsInvalid = "PoisonMicroblockIsInvalid"),
              (t.BadAddressVersionByte = "BadAddressVersionByte"),
              (t.NoCoinbaseViaMempool = "NoCoinbaseViaMempool"),
              (t.ServerFailureNoSuchChainTip = "ServerFailureNoSuchChainTip"),
              (t.ServerFailureDatabase = "ServerFailureDatabase"),
              (t.ServerFailureOther = "ServerFailureOther");
          })(P || (P = {}));
      },
      34534: (t, e, r) => {
        "use strict";
        r.d(e, {
          AM: () => A,
          Ah: () => x,
          DH: () => b,
          H: () => E,
          QH: () => w,
          So: () => y,
          VQ: () => g,
          YS: () => I,
          YY: () => M,
          cG: () => n,
          d8: () => O,
          lw: () => m,
          p0: () => T,
          p3: () => _,
          pF: () => v,
          uv: () => S,
        });
        var n,
          i = r(39834),
          o = r(11171),
          s = r(91438),
          a = r(18480),
          u = r(21086),
          c = r(29048),
          f = r(45547),
          h = r(38389),
          l = r(19419),
          d = r(4696),
          p = r(48299);
        !(function (t) {
          (t[(t.ClarityAbiTypeUInt128 = 1)] = "ClarityAbiTypeUInt128"),
            (t[(t.ClarityAbiTypeInt128 = 2)] = "ClarityAbiTypeInt128"),
            (t[(t.ClarityAbiTypeBool = 3)] = "ClarityAbiTypeBool"),
            (t[(t.ClarityAbiTypePrincipal = 4)] = "ClarityAbiTypePrincipal"),
            (t[(t.ClarityAbiTypeNone = 5)] = "ClarityAbiTypeNone"),
            (t[(t.ClarityAbiTypeBuffer = 6)] = "ClarityAbiTypeBuffer"),
            (t[(t.ClarityAbiTypeResponse = 7)] = "ClarityAbiTypeResponse"),
            (t[(t.ClarityAbiTypeOptional = 8)] = "ClarityAbiTypeOptional"),
            (t[(t.ClarityAbiTypeTuple = 9)] = "ClarityAbiTypeTuple"),
            (t[(t.ClarityAbiTypeList = 10)] = "ClarityAbiTypeList"),
            (t[(t.ClarityAbiTypeStringAscii = 11)] =
              "ClarityAbiTypeStringAscii"),
            (t[(t.ClarityAbiTypeStringUtf8 = 12)] = "ClarityAbiTypeStringUtf8"),
            (t[(t.ClarityAbiTypeTraitReference = 13)] =
              "ClarityAbiTypeTraitReference");
        })(n || (n = {}));
        const y = (t) => "string" == typeof t,
          g = (t) => void 0 !== t.buffer,
          m = (t) => void 0 !== t["string-ascii"],
          b = (t) => void 0 !== t["string-utf8"],
          w = (t) => void 0 !== t.response,
          v = (t) => void 0 !== t.optional,
          _ = (t) => void 0 !== t.tuple,
          E = (t) => void 0 !== t.list;
        function S(t) {
          if (y(t)) {
            if ("uint128" === t)
              return { id: n.ClarityAbiTypeUInt128, type: t };
            if ("int128" === t) return { id: n.ClarityAbiTypeInt128, type: t };
            if ("bool" === t) return { id: n.ClarityAbiTypeBool, type: t };
            if ("principal" === t)
              return { id: n.ClarityAbiTypePrincipal, type: t };
            if ("trait_reference" === t)
              return { id: n.ClarityAbiTypeTraitReference, type: t };
            if ("none" === t) return { id: n.ClarityAbiTypeNone, type: t };
            throw new Error(
              `Unexpected Clarity ABI type primitive: ${JSON.stringify(t)}`,
            );
          }
          if (g(t)) return { id: n.ClarityAbiTypeBuffer, type: t };
          if (w(t)) return { id: n.ClarityAbiTypeResponse, type: t };
          if (v(t)) return { id: n.ClarityAbiTypeOptional, type: t };
          if (_(t)) return { id: n.ClarityAbiTypeTuple, type: t };
          if (E(t)) return { id: n.ClarityAbiTypeList, type: t };
          if (m(t)) return { id: n.ClarityAbiTypeStringAscii, type: t };
          if (b(t)) return { id: n.ClarityAbiTypeStringUtf8, type: t };
          throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(t)}`);
        }
        function I(t, e) {
          const r = e.id ? e : S(e);
          switch (r.id) {
            case n.ClarityAbiTypeUInt128:
              return (0, o.u)(t);
            case n.ClarityAbiTypeInt128:
              return (0, o.p)(t);
            case n.ClarityAbiTypeBool:
              if ("false" === t || "0" === t) return (0, s.PH)();
              if ("true" === t || "1" === t) return (0, s.WM)();
              throw new Error(
                `Unexpected Clarity bool value: ${JSON.stringify(t)}`,
              );
            case n.ClarityAbiTypePrincipal:
              if (t.includes(".")) {
                const [e, r] = t.split(".");
                return (0, a.iZ)(e, r);
              }
              return (0, a.f)(t);
            case n.ClarityAbiTypeTraitReference:
              const [e, h] = t.split(".");
              return (0, a.iZ)(e, h);
            case n.ClarityAbiTypeNone:
              return (0, u.gu)();
            case n.ClarityAbiTypeBuffer:
              return (0, c.I)((0, i.aT)(t));
            case n.ClarityAbiTypeStringAscii:
              return (0, f.IE)(t);
            case n.ClarityAbiTypeStringUtf8:
              return (0, f.y3)(t);
            case n.ClarityAbiTypeOptional:
              return (0, u.gp)(I(t, r.type.optional));
            case n.ClarityAbiTypeResponse:
            case n.ClarityAbiTypeTuple:
            case n.ClarityAbiTypeList:
              throw new d.EH(`Unsupported encoding for Clarity type: ${r.id}`);
            default:
              throw new Error(
                `Unexpected Clarity type ID: ${JSON.stringify(r)}`,
              );
          }
        }
        function M(t, e) {
          const r = t.id ? t : S(t);
          return r.id === n.ClarityAbiTypeBuffer
            ? (0, c.I)((0, i.AI)(e))
            : I(e, r);
        }
        function A(t) {
          if (y(t))
            return "int128" === t ? "int" : "uint128" === t ? "uint" : t;
          if (g(t)) return `(buff ${t.buffer.length})`;
          if (m(t)) return `(string-ascii ${t["string-ascii"].length})`;
          if (b(t)) return `(string-utf8 ${t["string-utf8"].length})`;
          if (w(t))
            return `(response ${A(t.response.ok)} ${A(t.response.error)})`;
          if (v(t)) return `(optional ${A(t.optional)})`;
          if (_(t))
            return `(tuple ${t.tuple.map((t) => `(${t.name} ${A(t.type)})`).join(" ")})`;
          if (E(t)) return `(list ${t.list.length} ${A(t.list.type)})`;
          throw new Error(
            `Type string unsupported for Clarity type: ${JSON.stringify(t)}`,
          );
        }
        function T(t) {
          return `(define-${"read_only" === t.access ? "read-only" : t.access} (${t.name} ${t.args.map((t) => `(${t.name} ${A(t.type)})`).join(" ")}))`;
        }
        function k(t, e) {
          const r = S(e);
          switch (t.type) {
            case h.dl.BoolTrue:
            case h.dl.BoolFalse:
              return r.id === n.ClarityAbiTypeBool;
            case h.dl.Int:
              return r.id === n.ClarityAbiTypeInt128;
            case h.dl.UInt:
              return r.id === n.ClarityAbiTypeUInt128;
            case h.dl.Buffer:
              return (
                r.id === n.ClarityAbiTypeBuffer &&
                r.type.buffer.length >= Math.ceil(t.value.length / 2)
              );
            case h.dl.StringASCII:
              return (
                r.id === n.ClarityAbiTypeStringAscii &&
                r.type["string-ascii"].length >= t.value.length
              );
            case h.dl.StringUTF8:
              return (
                r.id === n.ClarityAbiTypeStringUtf8 &&
                r.type["string-utf8"].length >= t.value.length
              );
            case h.dl.OptionalNone:
              return (
                r.id === n.ClarityAbiTypeNone ||
                r.id === n.ClarityAbiTypeOptional
              );
            case h.dl.OptionalSome:
              return (
                r.id === n.ClarityAbiTypeOptional && k(t.value, r.type.optional)
              );
            case h.dl.ResponseErr:
              return (
                r.id === n.ClarityAbiTypeResponse &&
                k(t.value, r.type.response.error)
              );
            case h.dl.ResponseOk:
              return (
                r.id === n.ClarityAbiTypeResponse &&
                k(t.value, r.type.response.ok)
              );
            case h.dl.PrincipalContract:
              return (
                r.id === n.ClarityAbiTypePrincipal ||
                r.id === n.ClarityAbiTypeTraitReference
              );
            case h.dl.PrincipalStandard:
              return r.id === n.ClarityAbiTypePrincipal;
            case h.dl.List:
              return (
                r.id == n.ClarityAbiTypeList &&
                r.type.list.length >= t.value.length &&
                t.value.every((t) => k(t, r.type.list.type))
              );
            case h.dl.Tuple:
              if (r.id == n.ClarityAbiTypeTuple) {
                const e = (0, p.mg)(t.value);
                for (let t = 0; t < r.type.tuple.length; t++) {
                  const n = r.type.tuple[t],
                    i = n.name,
                    o = e[i];
                  if (!o) return !1;
                  if (!k(o, n.type)) return !1;
                  delete e[i];
                }
                return !0;
              }
              return !1;
            default:
              return !1;
          }
        }
        function O(t, e) {
          const r = e.functions.filter(
            (e) => e.name === t.functionName.content,
          );
          if (1 === r.length) {
            const e = r[0].args;
            if (t.functionArgs.length !== e.length)
              throw new Error(
                `Clarity function expects ${e.length} argument(s) but received ${t.functionArgs.length}`,
              );
            for (let r = 0; r < t.functionArgs.length; r++) {
              const n = t.functionArgs[r],
                i = e[r];
              if (!k(n, i.type)) {
                const e = r + 1;
                throw new Error(
                  `Clarity function \`${t.functionName.content}\` expects argument ${e} to be of type ${A(i.type)}, not ${(0, l.P2)(n)}`,
                );
              }
            }
            return !0;
          }
          throw 0 === r.length
            ? new Error(
                `ABI doesn't contain a function with the name ${t.functionName.content}`,
              )
            : new Error(
                `Malformed ABI. Contains multiple functions with the name ${t.functionName.content}`,
              );
        }
        function x(t, e) {
          const r = A(e);
          if (y(e)) {
            if ("uint128" === e) return (0, o.u)(t);
            if ("int128" === e) return (0, o.p)(t);
            if ("bool" === e) {
              if ("true" === t.toLowerCase()) return (0, s.WM)();
              if ("false" === t.toLowerCase()) return (0, s.PH)();
              throw new Error(`Invalid bool value: ${t}`);
            }
            if ("principal" === e) {
              if (t.includes(".")) {
                const [e, r] = t.split(".");
                return (0, a.iZ)(e, r);
              }
              return (0, a.f)(t);
            }
            throw new Error(
              `Contract function contains unsupported Clarity ABI type: ${r}`,
            );
          }
          if (g(e)) {
            if ((0, i.AI)(t).byteLength > e.buffer.length)
              throw new Error(
                `Input exceeds specified buffer length limit of ${e.buffer.length}`,
              );
            return (0, c.L)(t);
          }
          throw (
            (w(e) || v(e) || _(e) || E(e),
            new Error(
              `Contract function contains unsupported Clarity ABI type: ${r}`,
            ))
          );
        }
      },
      4696: (t, e, r) => {
        "use strict";
        r.d(e, {
          EH: () => a,
          Fn: () => i,
          MJ: () => o,
          bw: () => s,
          mk: () => c,
          uJ: () => u,
        });
        class n extends Error {
          constructor(t) {
            super(t),
              (this.message = t),
              (this.name = this.constructor.name),
              Error.captureStackTrace &&
                Error.captureStackTrace(this, this.constructor);
          }
        }
        class i extends n {
          constructor(t) {
            super(t);
          }
        }
        class o extends n {
          constructor(t) {
            super(t);
          }
        }
        class s extends n {
          constructor(t) {
            super(t);
          }
        }
        class a extends n {
          constructor(t) {
            super(t);
          }
        }
        class u extends n {
          constructor(t) {
            super(t);
          }
        }
        class c extends n {
          constructor(t) {
            super(t);
          }
        }
      },
      96227: (t, e, r) => {
        "use strict";
        r.d(e, {
          AQ: () => p,
          FC: () => I,
          QQ: () => w,
          Vu: () => _,
          dN: () => S,
          gp: () => v,
          iv: () => l,
          iz: () => h,
          jK: () => d,
          jd: () => g,
          sP: () => y,
          tL: () => E,
          uI: () => m,
          ui: () => b,
          x1: () => M,
        });
        var n = r(39834),
          i = r(33598),
          o = r(61994),
          s = r(90687),
          a = r(4696),
          u = r(41011),
          c = r(48299),
          f = r(67449);
        const h = "/v2/transactions",
          l = "/v2/fees/transfer",
          d = "/v2/fees/transaction",
          p = "/v2/accounts",
          y = "/v2/contracts/interface",
          g = "/v2/contracts/call-read",
          m = "/v2/map_entry";
        async function b({
          transaction: t,
          attachment: e,
          network: r,
          client: o,
        }) {
          const s = t.serialize(),
            a = e ? ("string" == typeof e ? e : (0, n.My)(e)) : void 0,
            c = e ? { tx: s, attachment: a } : { tx: s },
            f = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(c),
            },
            l = r ?? (0, u.OC)(t),
            d = Object.assign({}, (0, i.Up)((0, i.hu)(l)), o),
            p = `${d.baseUrl}${h}`,
            y = await d.fetch(p, f);
          if (!y.ok)
            try {
              return await y.json();
            } catch (t) {
              throw Error(
                "Failed to broadcast transaction (unable to parse node response).",
                { cause: t },
              );
            }
          const g = await y.text(),
            m = g.replace(/["]+/g, "");
          if (!(0, n.EL)(m)) throw new Error(g);
          return { txid: m };
        }
        async function w(t) {
          try {
            return await (async function ({
              address: t,
              network: e = "mainnet",
              client: r,
            }) {
              const n = Object.assign({}, (0, i.Up)((0, i.hu)(e)), r),
                o = `${n.baseUrl}/extended/v1/address/${t}/nonces`,
                s = await n.fetch(o),
                a = await s.json();
              return BigInt(a.possible_next_nonce);
            })(t);
          } catch (t) {}
          const e = (0, i.hu)(t.network ?? "mainnet"),
            r = Object.assign({}, (0, i.Up)(e), t.client),
            n = `${r.baseUrl}${p}/${t.address}?proof=0`,
            o = await r.fetch(n);
          if (!o.ok) {
            const t = await o.text().catch(() => "");
            throw new Error(
              `Error fetching nonce. Response ${o.status}: ${o.statusText}. Attempted to fetch ${n} and failed with the message: "${t}"`,
            );
          }
          const s = await o.json();
          return BigInt(s.nonce);
        }
        async function v({ transaction: t, network: e, client: r }) {
          const n = e ?? (0, u.OC)(t),
            o = Object.assign({}, (0, i.Up)((0, i.hu)(n)), r),
            s = `${o.baseUrl}${l}`,
            a = await o.fetch(s, { headers: { Accept: "application/text" } });
          if (!a.ok) {
            const t = await a.text().catch(() => "");
            throw new Error(
              `Error estimating transfer fee. Response ${a.status}: ${a.statusText}. Attempted to fetch ${s} and failed with the message: "${t}"`,
            );
          }
          const c = await a.text(),
            f = BigInt(Math.ceil(t.serializeBytes().byteLength));
          return BigInt(c) * f;
        }
        async function _({
          payload: t,
          estimatedLength: e,
          network: r = "mainnet",
          client: n,
        }) {
          const o = { transaction_payload: t, estimated_len: e },
            s = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(o),
            },
            u = Object.assign({}, (0, i.Up)((0, i.hu)(r)), n),
            c = `${u.baseUrl}${d}`,
            f = await u.fetch(c, s);
          if (!f.ok) {
            const t = await f.json().catch(() => ({}));
            if ("NoEstimateAvailable" === t?.reason)
              throw new a.bw(t?.reason_data?.message ?? "");
            throw new Error(
              `Error estimating transaction fee. Response ${f.status}: ${f.statusText}. Attempted to fetch ${c} and failed with the message: "${t}"`,
            );
          }
          return (await f.json()).estimations;
        }
        async function E({ transaction: t, network: e, client: r }) {
          const o = e ?? (0, u.OC)(t),
            s = Object.assign({}, (0, i.Up)((0, i.hu)(o)), r);
          try {
            const e = (0, u.Z9)(t);
            return (
              await _({
                payload: (0, n.My)((0, f.o3)(t.payload)),
                estimatedLength: e,
                network: o,
                client: s,
              })
            )[1].fee;
          } catch (e) {
            if (!(e instanceof a.bw)) throw e;
            return await v({ transaction: t, network: o });
          }
        }
        async function S({
          contractAddress: t,
          contractName: e,
          network: r = "mainnet",
          client: n,
        }) {
          const o = Object.assign({}, (0, i.Up)((0, i.hu)(r)), n),
            s = `${o.baseUrl}${y}/${t}/${e}`,
            a = await o.fetch(s);
          if (!a.ok) {
            const r = await a.text().catch(() => "");
            throw new Error(
              `Error fetching contract ABI for contract "${e}" at address ${t}. Response ${a.status}: ${a.statusText}. Attempted to fetch ${s} and failed with the message: "${r}"`,
            );
          }
          return JSON.parse(await a.text());
        }
        async function I({
          contractName: t,
          contractAddress: e,
          functionName: r,
          functionArgs: n,
          senderAddress: o,
          network: s = "mainnet",
          client: a,
        }) {
          const u = { sender: o, arguments: n.map((t) => (0, c.yX)(t)) },
            f = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(u),
            },
            h = encodeURIComponent(r),
            l = Object.assign({}, (0, i.Up)((0, i.hu)(s)), a),
            d = `${l.baseUrl}${g}/${e}/${t}/${h}`,
            p = await l.fetch(d, f);
          if (!p.ok) {
            const t = await p.text().catch(() => "");
            throw new Error(
              `Error calling read-only function. Response ${p.status}: ${p.statusText}. Attempted to fetch ${d} and failed with the message: "${t}"`,
            );
          }
          return await p.json().then(c.vx);
        }
        async function M({
          contractAddress: t,
          contractName: e,
          mapName: r,
          mapKey: a,
          network: u = "mainnet",
          client: c,
        }) {
          const f = (0, n.fz)((0, o.G)(a)),
            h = {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
              body: JSON.stringify(f),
            },
            l = Object.assign({}, (0, i.Up)((0, i.hu)(u)), c),
            d = `${l.baseUrl}${m}/${t}/${e}/${r}?proof=0`,
            p = await l.fetch(d, h);
          if (!p.ok) {
            const n = await p.text().catch(() => "");
            throw new Error(
              `Error fetching map entry for map "${r}" in contract "${e}" at address ${t}, using map key "${f}". Response ${p.status}: ${p.statusText}. Attempted to fetch ${d} and failed with the message: "${n}"`,
            );
          }
          const y = await p.json();
          if (!y.data)
            throw new Error(
              `Error fetching map entry for map "${r}" in contract "${e}" at address ${t}, using map key "${f}". Response ${p.status}: ${p.statusText}. Attempted to fetch ${l.baseUrl} and failed with the response: "${JSON.stringify(y)}"`,
            );
          try {
            return (0, s.b)(y.data);
          } catch (t) {
            throw new Error(
              `Error deserializing Clarity value "${y.data}": ${t}`,
            );
          }
        }
      },
      86582: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            ACCOUNT_PATH: () => E.AQ,
            Address: () => R,
            AddressHashMode: () => v.ct,
            AddressVersion: () => v.BY,
            AnchorMode: () => v.Fj,
            AnchorModeNames: () => v.jz,
            AssetType: () => v.PW,
            AuthFieldType: () => v.Dv,
            AuthType: () => v.hT,
            BLOCKSTACK_DEFAULT_GAIA_HUB_URL: () => v.zB,
            BROADCAST_PATH: () => E.iz,
            BytesReader: () => i.H,
            CLARITY_INT_BYTE_SIZE: () => v.gb,
            CLARITY_INT_SIZE: () => v.H0,
            COINBASE_BYTES_LENGTH: () => v.yZ,
            COMPRESSED_PUBKEY_LENGTH_BYTES: () => v.mw,
            CONTRACT_ABI_PATH: () => E.sP,
            Cl: () => n,
            ClarityAbiTypeId: () => _.cG,
            ClarityType: () => u.dl,
            ClarityVersion: () => v.nX,
            ClarityWireType: () => u.qz,
            FungibleConditionCode: () => v.Dx,
            MAP_ENTRY_PATH: () => E.uI,
            MAX_STRING_LENGTH_BYTES: () => v.Ej,
            MEMO_MAX_LENGTH_BYTES: () => v.j4,
            NonFungibleConditionCode: () => v.q$,
            PayloadType: () => v.d2,
            Pc: () => Rt,
            PostConditionMode: () => v.FN,
            PostConditionPrincipalId: () => v.V9,
            PostConditionType: () => v.qu,
            PubKeyEncoding: () => v.G5,
            READONLY_FUNCTION_CALL_PATH: () => E.jd,
            RECOVERABLE_ECDSA_SIG_LENGTH_BYTES: () => v.tL,
            STRUCTURED_DATA_PREFIX: () => A._c,
            StacksTransactionWire: () => T.$f,
            StacksWireType: () => C.$,
            TRANSACTION_FEE_ESTIMATE_PATH: () => E.jK,
            TRANSFER_FEE_ESTIMATE_PATH: () => E.iv,
            TenureChangeCause: () => v.Ld,
            TransactionSigner: () => M.p,
            TxRejectedReason: () => v.$8,
            UNCOMPRESSED_PUBKEY_LENGTH_BYTES: () => v.xV,
            VRF_PROOF_BYTES_LENGTH: () => v.vX,
            abiFunctionToString: () => _.p0,
            addressFromPublicKeys: () => P.Uw,
            addressFromVersionHash: () => P.lY,
            addressHashModeToVersion: () => O.f,
            addressToString: () => P.pD,
            anchorModeFrom: () => v.nU,
            boolCV: () => c.yw,
            broadcastTransaction: () => E.ui,
            bufferCV: () => f.I,
            bufferCVFromString: () => f.L,
            clarityByteToType: () => u.Gk,
            clarityTypeToByte: () => u.ug,
            cloneDeep: () => k.mg,
            codeBodyString: () => x.Dv,
            compressPrivateKey: () => S.z,
            compressPublicKey: () => S.xf,
            contractPrincipalCV: () => p.iZ,
            contractPrincipalCVFromAddress: () => p.a5,
            contractPrincipalCVFromStandard: () => p.jS,
            createAddress: () => x.FR,
            createAsset: () => x.$o,
            createCoinbasePayload: () => x.Tj,
            createContractCallPayload: () => x.tT,
            createContractPrincipal: () => x.Ti,
            createEmptyAddress: () => x._b,
            createLPList: () => x.lU,
            createLPString: () => x.o1,
            createMemoString: () => x.iB,
            createMessageSignature: () => x.EM,
            createMultiSigSpendingCondition: () => o.o5,
            createNakamotoCoinbasePayload: () => x.JA,
            createPoisonPayload: () => x.nT,
            createSingleSigSpendingCondition: () => o.v_,
            createSmartContractPayload: () => x.Ox,
            createSpendingCondition: () => o.Y,
            createSponsoredAuth: () => o.km,
            createStacksPublicKey: () => S.uC,
            createStandardAuth: () => o.Kz,
            createStandardPrincipal: () => x.qX,
            createTenureChangePayload: () => x.iw,
            createTokenTransferPayload: () => x.zh,
            createTransactionAuthField: () => x.Jt,
            cvToHex: () => k.yX,
            cvToJSON: () => a.JP,
            cvToString: () => a.Ss,
            cvToValue: () => a.E4,
            decodeStructuredDataSignature: () => A.ar,
            decodeStructuredDataSignatureBytes: () => A.bt,
            deriveNetworkFromTx: () => T.OC,
            deserializeAddress: () => B.AP,
            deserializeAsset: () => B.oJ,
            deserializeAuthorization: () => o.h2,
            deserializeCV: () => b.b,
            deserializeLPList: () => B.em,
            deserializeLPString: () => B.Dp,
            deserializeMemoString: () => B.pF,
            deserializeMessageSignature: () => B.X,
            deserializeMultiSigSpendingCondition: () => o.Jl,
            deserializePayload: () => B.ur,
            deserializePostConditionWire: () => B.I_,
            deserializePrincipal: () => B.qb,
            deserializePublicKey: () => B.QT,
            deserializeSingleSigSpendingCondition: () => o.Ag,
            deserializeSpendingCondition: () => o.rT,
            deserializeStacksWire: () => B.SG,
            deserializeTransaction: () => T.qu,
            deserializeTransactionAuthField: () => B.wW,
            emptyMessageSignature: () => o.NC,
            encodeAbiClarityValue: () => _.YS,
            encodeClarityValue: () => _.YY,
            encodeStructuredData: () => A.AH,
            encodeStructuredDataBytes: () => A.Nx,
            estimateTransactionByteLength: () => T.Z9,
            exceedsMaxLengthBytes: () => k.vI,
            falseCV: () => c.PH,
            fetchAbi: () => E.dN,
            fetchCallReadOnlyFunction: () => E.FC,
            fetchContractMapEntry: () => E.x1,
            fetchFeeEstimate: () => E.tL,
            fetchFeeEstimateTransaction: () => E.Vu,
            fetchFeeEstimateTransfer: () => E.gp,
            fetchNonce: () => E.QQ,
            getAddressFromPrivateKey: () => S.FJ,
            getAddressFromPublicKey: () => S.Tq,
            getCVTypeString: () => a.P2,
            getFee: () => o.Xf,
            getTypeString: () => _.AM,
            getTypeUnion: () => _.uv,
            hash160: () => k.A0,
            hashP2PKH: () => k.G9,
            hashP2SH: () => k.wZ,
            hashP2WPKH: () => k.rY,
            hashP2WSH: () => k.x5,
            hashStructuredData: () => A.Yw,
            hashStructuredDataBytes: () => A.Fw,
            hexToCV: () => k.ev,
            intCV: () => h.p,
            intoInitialSighashAuth: () => o.AT,
            isClarityAbiBuffer: () => _.VQ,
            isClarityAbiList: () => _.H,
            isClarityAbiOptional: () => _.pF,
            isClarityAbiPrimitive: () => _.So,
            isClarityAbiResponse: () => _.QH,
            isClarityAbiStringAscii: () => _.lw,
            isClarityAbiStringUtf8: () => _.DH,
            isClarityAbiTuple: () => _.p3,
            isClarityName: () => k.qw,
            isClarityType: () => a.f,
            isCoinbasePayload: () => P.X3,
            isContractCallPayload: () => P.Zj,
            isNonSequentialMultiSig: () => o.pi,
            isPoisonPayload: () => P.xk,
            isPrivateKeyCompressed: () => S.kO,
            isPublicKeyCompressed: () => S.yH,
            isSequentialMultiSig: () => o.Ir,
            isSingleSig: () => o.I4,
            isSmartContractPayload: () => P.EY,
            isTokenTransferPayload: () => P.dm,
            leftPadHex: () => k.EW,
            leftPadHexToLength: () => k.PM,
            listCV: () => l.y,
            makeContractCall: () => s.zL,
            makeContractDeploy: () => s.y9,
            makeRandomPrivKey: () => S.G0,
            makeSTXTokenTransfer: () => s.uj,
            makeUnsignedContractCall: () => s.ok,
            makeUnsignedContractDeploy: () => s.Pt,
            makeUnsignedSTXTokenTransfer: () => s.XV,
            nextSignature: () => o.A6,
            nextVerification: () => o.Jr,
            noneCV: () => d.gu,
            omit: () => k.cJ,
            optionalCVOf: () => d.hg,
            parseAssetString: () => P.v3,
            parseContractId: () => k.zi,
            parsePrincipalString: () => P.bM,
            parseReadOnlyResponse: () => k.vx,
            parseToCV: () => _.Ah,
            postConditionModeFrom: () => I.HI,
            postConditionToHex: () => I.Us,
            postConditionToWire: () => I._,
            principalCV: () => p.g7,
            privateKeyIsCompressed: () => S.E,
            privateKeyToAddress: () => S.uX,
            privateKeyToHex: () => S.xr,
            privateKeyToPublic: () => S.Ti,
            publicKeyFromSignatureRsv: () => S.ef,
            publicKeyFromSignatureVrs: () => S.El,
            publicKeyIsCompressed: () => S.AC,
            publicKeyToAddress: () => S.M,
            publicKeyToAddressSingleSig: () => S.vU,
            publicKeyToHex: () => S.ru,
            randomBytes: () => k.po,
            randomPrivateKey: () => S.oN,
            responseErrorCV: () => y.v,
            responseOkCV: () => y.B,
            rightPadHexToLength: () => k.Wf,
            serializeAddress: () => B.vS,
            serializeAddressBytes: () => B.ij,
            serializeAsset: () => B.Dq,
            serializeAssetBytes: () => B.Ei,
            serializeAuthorization: () => o.gq,
            serializeAuthorizationBytes: () => o.H7,
            serializeCV: () => w.G,
            serializeCVBytes: () => w.n,
            serializeLPList: () => B.bJ,
            serializeLPListBytes: () => B.SY,
            serializeLPString: () => B.ug,
            serializeLPStringBytes: () => B.Xe,
            serializeMemoString: () => B.GT,
            serializeMemoStringBytes: () => B.lW,
            serializeMessageSignature: () => B.YU,
            serializeMessageSignatureBytes: () => B.Zq,
            serializeMultiSigSpendingCondition: () => o._o,
            serializeMultiSigSpendingConditionBytes: () => o.N7,
            serializePayload: () => B.hs,
            serializePayloadBytes: () => B.o3,
            serializePostConditionWire: () => B.Vk,
            serializePostConditionWireBytes: () => B.kH,
            serializePrincipal: () => B.L7,
            serializePrincipalBytes: () => B._i,
            serializePublicKey: () => B.Jn,
            serializePublicKeyBytes: () => B.U6,
            serializeSingleSigSpendingCondition: () => o.V5,
            serializeSingleSigSpendingConditionBytes: () => o._7,
            serializeSpendingCondition: () => o.k_,
            serializeSpendingConditionBytes: () => o.d8,
            serializeStacksWire: () => B.JE,
            serializeStacksWireBytes: () => B.IJ,
            serializeTransaction: () => T.bQ,
            serializeTransactionAuthField: () => B.D6,
            serializeTransactionAuthFieldBytes: () => B.Yi,
            serializeTransactionBytes: () => T.q9,
            setFee: () => o.x6,
            setNonce: () => o.MG,
            setSponsor: () => o.tj,
            setSponsorNonce: () => o.IE,
            sigHashPreSign: () => o._p,
            signMessageHashRsv: () => S.ed,
            signStructuredData: () => A.tV,
            signWithKey: () => S.Ft,
            someCV: () => d.gp,
            sponsorTransaction: () => s.zI,
            standardPrincipalCV: () => p.f,
            standardPrincipalCVFromAddress: () => p.Hh,
            stringAsciiCV: () => g.IE,
            stringCV: () => g.rv,
            stringUtf8CV: () => g.y3,
            transactionToHex: () => T.vO,
            trueCV: () => c.WM,
            tupleCV: () => m.M,
            txidFromBytes: () => k.p1,
            txidFromData: () => k.U1,
            uintCV: () => h.u,
            uncompressPublicKey: () => S.sA,
            validateContractCall: () => _.d8,
            validateStacksAddress: () => k.cU,
            verifyOrigin: () => o.S1,
            verifySignature: () => k.Od,
            whenWireType: () => C.q,
          });
        var n = {};
        r.r(n),
          r.d(n, {
            address: () => mt,
            bool: () => dt,
            buffer: () => St,
            bufferFromAscii: () => Mt,
            bufferFromHex: () => It,
            bufferFromUtf8: () => At,
            contractPrincipal: () => bt,
            deserialize: () => Ct,
            error: () => xt,
            int: () => pt,
            list: () => vt,
            none: () => Tt,
            ok: () => Ot,
            parse: () => lt,
            prettyPrint: () => j,
            principal: () => gt,
            serialize: () => Bt,
            some: () => kt,
            standardPrincipal: () => wt,
            stringAscii: () => _t,
            stringUtf8: () => Et,
            stringify: () => L,
            tuple: () => Pt,
            uint: () => yt,
          });
        var i = r(51047),
          o = r(32814),
          s = r(12799),
          a = r(19419),
          u = r(38389),
          c = r(91438),
          f = r(29048),
          h = r(11171),
          l = r(88906),
          d = r(21086),
          p = r(18480),
          y = r(8501),
          g = r(45547),
          m = r(79796),
          b = r(90687),
          w = r(61994),
          v = r(45842),
          _ = r(34534),
          E = r(96227),
          S = r(1755),
          I = r(86664),
          M = r(63001),
          A = r(46200),
          T = r(41011),
          k = r(48299),
          O = r(74139),
          x = r(89977),
          P = r(17436),
          B = r(67449),
          C = r(60752),
          R = r(72904),
          N = r(39834);
        function U(t, e, r = !1) {
          return t ? `\n${" ".repeat(t * (e - (r ? 1 : 0)))}` : " ";
        }
        function D(t, e = 0, r) {
          return t.type === u.dl.BoolFalse
            ? "false"
            : t.type === u.dl.BoolTrue
              ? "true"
              : t.type === u.dl.Int
                ? t.value.toString()
                : t.type === u.dl.UInt
                  ? `u${t.value.toString()}`
                  : t.type === u.dl.StringASCII
                    ? `"${t.value}"`
                    : t.type === u.dl.StringUTF8
                      ? `u"${t.value}"`
                      : t.type === u.dl.PrincipalContract ||
                          t.type === u.dl.PrincipalStandard
                        ? `'${t.value}`
                        : t.type === u.dl.Buffer
                          ? `0x${t.value}`
                          : t.type === u.dl.OptionalNone
                            ? "none"
                            : t.type === u.dl.OptionalSome
                              ? `(some ${D(t.value, e, r)})`
                              : t.type === u.dl.ResponseOk
                                ? `(ok ${D(t.value, e, r)})`
                                : t.type === u.dl.ResponseErr
                                  ? `(err ${D(t.value, e, r)})`
                                  : t.type === u.dl.List
                                    ? (function (t, e, r = 1) {
                                        if (0 === t.value.length)
                                          return "(list)";
                                        const n = U(e, r, !1),
                                          i = e ? U(e, r, !0) : "";
                                        return `(list${n}${t.value.map((t) => D(t, e, r)).join(n)}${i})`;
                                      })(t, e, r + 1)
                                    : t.type === u.dl.Tuple
                                      ? (function (t, e, r = 1) {
                                          if (0 === Object.keys(t.value).length)
                                            return "{}";
                                          const n = [];
                                          for (const [i, o] of Object.entries(
                                            t.value,
                                          ))
                                            n.push(`${i}: ${D(o, e, r)}`);
                                          const i = U(e, r, !1),
                                            o = U(e, r, !0);
                                          return `{${i}${n.sort().join(`,${i}`)}${o}}`;
                                        })(t, e, r + 1)
                                      : void (function (t) {
                                          throw new Error(
                                            `invalid clarity value type: ${t}`,
                                          );
                                        })(t);
        }
        function L(t, e = 0) {
          return D(t, e, 0);
        }
        const j = L;
        function F(t, e) {
          return (r) => {
            const n = r.match(t);
            return n && 0 === n.index
              ? {
                  success: !0,
                  value: n[0],
                  rest: r.substring(n[0].length),
                  capture: e ? e(n[0]) : void 0,
                }
              : { success: !1 };
          };
        }
        function H() {
          return F(/\s+/);
        }
        function K(t) {
          return (e) => t()(e);
        }
        function V(t) {
          return (e) => {
            for (const r of t) {
              const t = r(e);
              if (t.success) return t;
            }
            return { success: !1 };
          };
        }
        function q(t) {
          return (e) => {
            const r = t(e);
            return !r.success || r.rest ? { success: !1 } : r;
          };
        }
        function z(t) {
          return (e) => {
            const r = t(e);
            return r.success ? r : { success: !0, value: "", rest: e };
          };
        }
        function $(t, e = (t) => t[0]) {
          return (r) => {
            let n = r,
              i = "";
            const o = [];
            for (const e of t) {
              const t = e(n);
              if (!t.success) return { success: !1 };
              (n = t.rest), (i += t.value), t.capture && o.push(t.capture);
            }
            return { success: !0, value: i, rest: n, capture: e(o) };
          };
        }
        function G(t, e = (t) => t[0]) {
          return $(
            t.flatMap((t, e) => (0 === e ? [t] : [z(H()), t])),
            e,
          );
        }
        function W(t) {
          return G([F(/\(/), t, F(/\)/)]);
        }
        function Y(t, e, r = (t) => t[t.length - 1], n) {
          return (i) => {
            let o = i,
              s = "";
            const a = [];
            let u;
            for (u = 0; ; u++) {
              const t = e(o);
              if (!t.success) break;
              if (
                ((o = t.rest),
                (s += t.value),
                t.capture && a.push(t.capture),
                n)
              ) {
                const t = n(o);
                if (!t.success) {
                  u++;
                  break;
                }
                (o = t.rest), (s += t.value);
              }
            }
            return u < t
              ? { success: !1 }
              : { success: !0, value: s, rest: o, capture: r(a) };
          };
        }
        function X(t, e) {
          return (r) => {
            const n = t(r);
            return n.success
              ? {
                  success: !0,
                  value: n.value,
                  rest: n.rest,
                  capture: e ? e(n.value) : n.value,
                }
              : { success: !1 };
          };
        }
        function Z() {
          return X(F(/\-?[0-9]+/), (t) => pt(parseInt(t)));
        }
        function J() {
          return $([F(/u/), X(F(/[0-9]+/), (t) => yt(parseInt(t)))]);
        }
        function Q() {
          return X(F(/true|false/), (t) => dt("true" === t));
        }
        function tt() {
          return $([
            F(/\'/),
            X($([F(/[A-Z0-9]+/), z($([F(/\./), F(/[a-zA-Z0-9\-]+/)]))]), mt),
          ]);
        }
        function et() {
          return $([F(/0x/), X(F(/[0-9a-fA-F]+/), It)]);
        }
        function rt(t) {
          return t.replace(/\\\\/g, "\\").replace(/\\(.)/g, "$1");
        }
        function nt() {
          return $([F(/"/), X(F(/(\\.|[^"])*/), (t) => _t(rt(t))), F(/"/)]);
        }
        function it() {
          return $([F(/u"/), X(F(/(\\.|[^"])*/), (t) => Et(rt(t))), F(/"/)]);
        }
        function ot() {
          return W($([F(/list/), Y(0, $([H(), ht()]), (t) => vt(t))]));
        }
        function st() {
          return V([
            G([
              F(/\{/),
              Y(
                1,
                $(
                  [X(F(/[a-zA-Z][a-zA-Z0-9_]*/)), F(/\s*\:/), H(), ht()],
                  ([t, e]) => Pt({ [t]: e }),
                ),
                (t) => Pt(Object.assign({}, ...t.map((t) => t.value))),
                F(/\s*\,\s*/),
              ),
              F(/\}/),
            ]),
            W(
              $([
                z(H()),
                F(/tuple/),
                H(),
                Y(
                  1,
                  W(
                    $(
                      [
                        z(H()),
                        X(F(/[a-zA-Z][a-zA-Z0-9_]*/)),
                        H(),
                        ht(),
                        z(H()),
                      ],
                      ([t, e]) => Pt({ [t]: e }),
                    ),
                  ),
                  (t) => Pt(Object.assign({}, ...t.map((t) => t.value))),
                  H(),
                ),
              ]),
            ),
          ]);
        }
        function at() {
          return X(F(/none/), Tt);
        }
        function ut() {
          return W($([F(/some/), H(), ht()], (t) => kt(t[0])));
        }
        function ct() {
          return W($([F(/ok/), H(), ht()], (t) => Ot(t[0])));
        }
        function ft() {
          return W($([F(/err/), H(), ht()], (t) => xt(t[0])));
        }
        function ht(t = (t) => t) {
          return V(
            [et, nt, it, Z, J, Q, tt, ot, st, at, ut, ct, ft].map(K).map(t),
          );
        }
        function lt(t) {
          const e = ht(q)(t);
          if (!e.success || !e.capture) throw "Parse error";
          return e.capture;
        }
        const dt = c.yw,
          pt = h.p,
          yt = h.u;
        function gt(t) {
          const [e, r] = t.split(".");
          return r ? (0, p.iZ)(e, r) : (0, p.f)(e);
        }
        const mt = gt,
          bt = p.iZ,
          wt = p.f,
          vt = l.y,
          _t = g.IE,
          Et = g.y3,
          St = f.I,
          It = (t) => (0, f.I)((0, N.aT)(t)),
          Mt = (t) => (0, f.I)((0, N.Mh)(t)),
          At = (t) => (0, f.I)((0, N.AI)(t)),
          Tt = d.gu,
          kt = d.gp,
          Ot = y.B,
          xt = y.v,
          Pt = m.M,
          Bt = w.G,
          Ct = b.b;
        var Rt = r(94926);
      },
      1755: (t, e, r) => {
        "use strict";
        r.d(e, {
          z: () => L,
          xf: () => B,
          uC: () => E,
          FJ: () => v,
          Tq: () => _,
          kO: () => T,
          yH: () => O,
          G0: () => R,
          E: () => k,
          uX: () => j,
          xr: () => M,
          Ti: () => P,
          ef: () => I,
          El: () => S,
          AC: () => x,
          M: () => F,
          vU: () => H,
          ru: () => A,
          oN: () => N,
          ed: () => D,
          Ft: () => U,
          sA: () => C,
        });
        var n = r(30539),
          i = r(17816);
        class o extends i.Vw {
          constructor(t, e) {
            super(), (this.finished = !1), (this.destroyed = !1), n.Ay.hash(t);
            const r = (0, i.ZJ)(e);
            if (
              ((this.iHash = t.create()),
              "function" != typeof this.iHash.update)
            )
              throw new TypeError(
                "Expected instance of class which extends utils.Hash",
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const o = this.blockLen,
              s = new Uint8Array(o);
            s.set(r.length > o ? t.create().update(r).digest() : r);
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return n.Ay.exists(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            n.Ay.exists(this),
              n.Ay.bytes(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: r,
              finished: n,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (t.finished = n),
              (t.destroyed = i),
              (t.blockLen = o),
              (t.outputLen = s),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = r._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const s = (t, e, r) => new o(t, e).update(r).digest();
        s.create = (t, e) => new o(t, e);
        var a = r(35021),
          u = r(97883),
          c = r(39834);
        const f = 32;
        var h = r(43330),
          l = r(27367),
          d = r(33598),
          p = r(7581),
          y = r(74139),
          g = r(45842),
          m = r(48299),
          b = r(17436),
          w = r(60752);
        function v(t, e = "mainnet") {
          e = (0, d.hu)(e);
          return _(P(t), e);
        }
        function _(t, e = "mainnet") {
          (e = (0, d.hu)(e)), (t = "string" == typeof t ? (0, c.aT)(t) : t);
          const r = (0, y.f)(g.ct.P2PKH, e),
            n = (0, b.lY)(r, (0, m.G9)(t));
          return (0, b.pD)(n);
        }
        function E(t) {
          return (
            (t = "string" == typeof t ? (0, c.aT)(t) : t),
            { type: w.$.PublicKey, data: t }
          );
        }
        function S(t, e, r = g.G5.Compressed) {
          const n = (function (t) {
              if (t.length < 2 * f * 2 + 1)
                throw new Error("Invalid signature");
              const e = t.slice(0, 2),
                r = t.slice(2, 2 + 2 * f),
                n = t.slice(2 + 2 * f);
              return { recoveryId: (0, c.od)(e), r, s: n };
            })(e),
            i = new u.to((0, c.uU)(n.r), (0, c.uU)(n.s)),
            o = u.bR.fromSignature(t, i, n.recoveryId),
            s = r === g.G5.Compressed;
          return o.toHex(s);
        }
        function I(t, e, r = g.G5.Compressed) {
          return S(t, (n = e).slice(-2) + n.slice(0, -2), r);
          var n;
        }
        function M(t) {
          return "string" == typeof t ? t : (0, c.My)(t);
        }
        u.Wp.hmacSha256Sync = (t, ...e) => {
          const r = s.create(a.s, t);
          return e.forEach((t) => r.update(t)), r.digest();
        };
        const A = M,
          T = k;
        function k(t) {
          return ("string" == typeof t ? t.length / 2 : t.byteLength) === h.uc;
        }
        const O = x;
        function x(t) {
          return !A(t).startsWith("04");
        }
        function P(t) {
          const e = k((t = (0, l.x)(t)));
          return (0, c.My)((0, u.lG)(t.slice(0, 32), e));
        }
        function B(t) {
          return u.bR.fromHex(A(t)).toHex(!0);
        }
        function C(t) {
          return u.bR.fromHex(A(t)).toHex(!1);
        }
        const R = N;
        function N() {
          return L(u.Wp.randomPrivateKey());
        }
        function U(t, e) {
          t = (0, l.x)(t);
          const [r, n] = (0, u.HU)(e, t.slice(0, 32), {
            canonical: !0,
            recovered: !0,
          });
          if (null == n) throw new Error("No signature recoveryId received");
          return (0, c.y6)(n, 1) + u.to.fromHex(r).toCompactHex();
        }
        function D({ messageHash: t, privateKey: e }) {
          return (r = U(e, t)).slice(2) + r.slice(0, 2);
          var r;
        }
        function L(t) {
          return (t = M(t)).length == 2 * h.uc ? t : `${t}01`;
        }
        function j(t, e) {
          return H(P(t), e);
        }
        function F(...t) {
          return "number" == typeof t[0]
            ? (function (t, e) {
                return (
                  (e = "string" == typeof e ? (0, c.aT)(e) : e),
                  (0, p.bJ)(t, (0, c.My)((0, m.A0)(e)))
                );
              })(...t)
            : H(...t);
        }
        function H(t, e) {
          return (
            (e = e ? (0, d.hu)(e) : d.nG),
            (t = "string" == typeof t ? (0, c.aT)(t) : t),
            (0, p.bJ)(e.addressVersion.singleSig, (0, c.My)((0, m.A0)(t)))
          );
        }
      },
      72904: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            fromPrivateKey: () => u,
            fromPublicKey: () => c,
            parse: () => s,
            stringify: () => a,
          });
        var n = r(7581),
          i = r(1755);
        const o = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
        function s(t) {
          const [e, r] = t.split("."),
            i = (0, n.ns)(e);
          return {
            version: i[0],
            versionChar: o[i[0]],
            hash160: i[1],
            contractName: r,
          };
        }
        function a(t) {
          const e =
              "version" in t
                ? t.version
                : o.indexOf(t.versionChar.toUpperCase()),
            r = (0, n.bJ)(e, t.hash160);
          return t.contractName ? `${r}.${t.contractName}` : r;
        }
        const u = i.uX,
          c = i.vU;
      },
      94926: (t, e, r) => {
        "use strict";
        r.r(e), r.d(e, { origin: () => s, principal: () => o });
        var n = r(39834),
          i = r(48299);
        function o(t) {
          const [e, r] = t.split(".");
          if (!e || !(0, i.cU)(e) || ("string" == typeof r && !r))
            throw new Error(`Invalid contract id: ${t}`);
          return new a(t);
        }
        function s() {
          return new a("origin");
        }
        class a {
          constructor(t) {
            this.address = t;
          }
          willSendEq(t) {
            return new u(this.address, t, "eq");
          }
          willSendLte(t) {
            return new u(this.address, t, "lte");
          }
          willSendLt(t) {
            return new u(this.address, t, "lt");
          }
          willSendGte(t) {
            return new u(this.address, t, "gte");
          }
          willSendGt(t) {
            return new u(this.address, t, "gt");
          }
          willSendAsset() {
            return new c(this.address, "sent");
          }
          willNotSendAsset() {
            return new c(this.address, "not-sent");
          }
        }
        class u {
          constructor(t, e, r) {
            (this.address = t), (this.amount = e), (this.code = r);
          }
          ustx() {
            return {
              type: "stx-postcondition",
              address: this.address,
              condition: this.code,
              amount: (0, n.WI)(this.amount).toString(),
            };
          }
          ft(t, e) {
            const [r, o] = t.split(".");
            if (!r || !(0, i.cU)(r) || ("string" == typeof o && !o))
              throw new Error(`Invalid contract id: ${t}`);
            return {
              type: "ft-postcondition",
              address: this.address,
              condition: this.code,
              amount: (0, n.WI)(this.amount).toString(),
              asset: `${t}::${e}`,
            };
          }
        }
        class c {
          constructor(t, e) {
            (this.address = t), (this.code = e);
          }
          nft(...t) {
            const {
              contractAddress: e,
              contractName: r,
              tokenName: n,
              assetId: o,
            } = (function (...t) {
              if (2 === t.length) {
                const [e, r] = t;
                return { ...f(e), assetId: r };
              }
              const [e, r, n] = t,
                [o, s] = (0, i.zi)(e);
              return {
                contractAddress: o,
                contractName: s,
                tokenName: r,
                assetId: n,
              };
            })(...t);
            if (!(0, i.cU)(e)) throw new Error(`Invalid contract id: ${e}`);
            return {
              type: "nft-postcondition",
              address: this.address,
              condition: this.code,
              asset: `${e}.${r}::${n}`,
              assetId: o,
            };
          }
        }
        function f(t) {
          const [e, r] = t.split("::");
          if (!e || !r)
            throw new Error(`Invalid fully-qualified nft asset name: ${t}`);
          const [n, o] = (0, i.zi)(e);
          return { contractAddress: n, contractName: o, tokenName: r };
        }
      },
      86664: (t, e, r) => {
        "use strict";
        r.d(e, { HI: () => h, Us: () => f, _: () => c });
        var n = r(45842),
          i = r(60752),
          o = r(17436),
          s = r(67449);
        const a = {
            eq: n.Dx.Equal,
            gt: n.Dx.Greater,
            lt: n.Dx.Less,
            gte: n.Dx.GreaterEqual,
            lte: n.Dx.LessEqual,
          },
          u = { sent: n.q$.Sends, "not-sent": n.q$.DoesNotSend };
        function c(t) {
          switch (t.type) {
            case "stx-postcondition":
              return {
                type: i.$.PostCondition,
                conditionType: n.qu.STX,
                principal:
                  "origin" === t.address
                    ? { type: i.$.Principal, prefix: n.V9.Origin }
                    : (0, o.bM)(t.address),
                conditionCode: a[t.condition],
                amount: BigInt(t.amount),
              };
            case "ft-postcondition":
              return {
                type: i.$.PostCondition,
                conditionType: n.qu.Fungible,
                principal:
                  "origin" === t.address
                    ? { type: i.$.Principal, prefix: n.V9.Origin }
                    : (0, o.bM)(t.address),
                conditionCode: a[t.condition],
                amount: BigInt(t.amount),
                asset: (0, o.v3)(t.asset),
              };
            case "nft-postcondition":
              return {
                type: i.$.PostCondition,
                conditionType: n.qu.NonFungible,
                principal:
                  "origin" === t.address
                    ? { type: i.$.Principal, prefix: n.V9.Origin }
                    : (0, o.bM)(t.address),
                conditionCode: u[t.condition],
                asset: (0, o.v3)(t.asset),
                assetName: t.assetId,
              };
            default:
              throw new Error("Invalid post condition type");
          }
        }
        function f(t) {
          const e = c(t);
          return (0, s.Vk)(e);
        }
        function h(t) {
          if ("number" == typeof t) return t;
          if ("allow" === t) return n.FN.Allow;
          if ("deny" === t) return n.FN.Deny;
          throw new Error(`Invalid post condition mode: ${t}`);
        }
      },
      63001: (t, e, r) => {
        "use strict";
        r.d(e, { p: () => c });
        var n = r(32814),
          i = r(45842),
          o = r(4696),
          s = r(48299),
          a = r(60752),
          u = r(1755);
        class c {
          constructor(t) {
            (this.transaction = t),
              (this.sigHash = t.signBegin()),
              (this.originDone = !1),
              (this.checkOversign = !0),
              (this.checkOverlap = !0);
            const e = t.auth.spendingCondition;
            if (e && !(0, n.I4)(e)) {
              if (
                e.fields.filter((t) => t.contents.type === a.$.MessageSignature)
                  .length >= e.signaturesRequired
              )
                throw new Error(
                  "SpendingCondition has more signatures than are expected",
                );
              e.fields.forEach((r) => {
                if (r.contents.type !== a.$.MessageSignature) return;
                const o = r.contents,
                  s = (0, n.Jr)(
                    this.sigHash,
                    t.auth.authType,
                    e.fee,
                    e.nonce,
                    i.G5.Compressed,
                    o.data,
                  );
                (0, n.pi)(e.hashMode) || (this.sigHash = s.nextSigHash);
              });
            }
          }
          static createSponsorSigner(t, e) {
            if (t.auth.authType != i.hT.Sponsored)
              throw new o.uJ("Cannot add sponsor to non-sponsored transaction");
            const r = (0, s.mg)(t);
            r.setSponsor(e);
            const n = r.verifyOrigin(),
              a = new this(r);
            return (
              (a.originDone = !0),
              (a.sigHash = n),
              (a.checkOversign = !0),
              (a.checkOverlap = !0),
              a
            );
          }
          signOrigin(t) {
            if (this.checkOverlap && this.originDone)
              throw new o.uJ("Cannot sign origin after sponsor key");
            if (void 0 === this.transaction.auth)
              throw new o.uJ('"transaction.auth" is undefined');
            if (void 0 === this.transaction.auth.spendingCondition)
              throw new o.uJ(
                '"transaction.auth.spendingCondition" is undefined',
              );
            const e = this.transaction.auth.spendingCondition;
            if (
              (e.hashMode === i.ct.P2SH || e.hashMode === i.ct.P2WSH) &&
              this.checkOversign &&
              e.fields.filter((t) => t.contents.type === a.$.MessageSignature)
                .length >= e.signaturesRequired
            )
              throw new Error("Origin would have too many signatures");
            const r = this.transaction.signNextOrigin(this.sigHash, t);
            ((0, n.I4)(this.transaction.auth.spendingCondition) ||
              (0, n.Ir)(this.transaction.auth.spendingCondition.hashMode)) &&
              (this.sigHash = r);
          }
          appendOrigin(t) {
            const e = "object" == typeof t && "type" in t ? t : (0, u.uC)(t);
            if (this.checkOverlap && this.originDone)
              throw Error(
                "Cannot append public key to origin after sponsor key",
              );
            if (void 0 === this.transaction.auth)
              throw new Error('"transaction.auth" is undefined');
            if (void 0 === this.transaction.auth.spendingCondition)
              throw new Error(
                '"transaction.auth.spendingCondition" is undefined',
              );
            this.transaction.appendPubkey(e);
          }
          signSponsor(t) {
            if (void 0 === this.transaction.auth)
              throw new o.uJ('"transaction.auth" is undefined');
            if (this.transaction.auth.authType !== i.hT.Sponsored)
              throw new o.uJ(
                '"transaction.auth.authType" is not AuthType.Sponsored',
              );
            const e = this.transaction.signNextSponsor(this.sigHash, t);
            (this.sigHash = e), (this.originDone = !0);
          }
          getTxInComplete() {
            return (0, s.mg)(this.transaction);
          }
          resume(t) {
            (this.transaction = (0, s.mg)(t)), (this.sigHash = t.signBegin());
          }
        }
      },
      46200: (t, e, r) => {
        "use strict";
        r.d(e, {
          AH: () => l,
          Fw: () => f,
          Nx: () => d,
          Yw: () => c,
          _c: () => u,
          ar: () => p,
          bt: () => y,
          tV: () => g,
        });
        var n = r(35021),
          i = r(39834),
          o = r(61994),
          s = r(38389),
          a = r(1755);
        const u = new Uint8Array([83, 73, 80, 48, 49, 56]);
        function c(t) {
          return (0, i.My)((0, n.s)((0, o.n)(t)));
        }
        function f(t) {
          return (0, n.s)((0, o.n)(t));
        }
        const h = 32;
        function l(t) {
          const e = d(t);
          return (0, i.My)(e);
        }
        function d({ message: t, domain: e }) {
          const r = f(t);
          if (
            (n = e).type !== s.dl.Tuple ||
            !["name", "version", "chain-id"].every((t) => t in n.value) ||
            !["name", "version"].every(
              (t) => n.value[t].type === s.dl.StringASCII,
            ) ||
            n.value["chain-id"].type !== s.dl.UInt
          )
            throw new Error(
              "domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt",
            );
          var n;
          const o = f(e);
          return (0, i.Id)(u, o, r);
        }
        function p(t) {
          const e = y(t);
          return {
            domainHash: (0, i.My)(e.domainHash),
            messageHash: (0, i.My)(e.messageHash),
          };
        }
        function y(t) {
          const e = "string" == typeof t ? (0, i.aT)(t) : t;
          return {
            domainHash: e.slice(u.length, u.length + h),
            messageHash: e.slice(u.length + h),
          };
        }
        function g({ message: t, domain: e, privateKey: r }) {
          const o = (0, i.My)((0, n.s)(d({ message: t, domain: e })));
          return (0, a.ed)({ messageHash: o, privateKey: r });
        }
      },
      41011: (t, e, r) => {
        "use strict";
        r.d(e, {
          $f: () => g,
          OC: () => b,
          Z9: () => w,
          bQ: () => v,
          q9: () => _,
          qu: () => m,
          vO: () => E,
        });
        var n = r(39834),
          i = r(15257),
          o = r(33598),
          s = r(29325),
          a = r(67449),
          u = r(51047),
          c = r(32814),
          f = r(45842),
          h = r(4696),
          l = r(1755),
          d = r(48299),
          p = r(89977),
          y = r(60752);
        class g {
          constructor({
            auth: t,
            payload: e,
            postConditions: r = (0, p.lU)([]),
            postConditionMode: i = f.FN.Deny,
            transactionVersion: s,
            chainId: a,
            network: u = "mainnet",
          }) {
            (u = (0, o.hu)(u)),
              (this.transactionVersion = s ?? u.transactionVersion),
              (this.chainId = a ?? u.chainId),
              (this.auth = t),
              (this.payload =
                "amount" in e ? { ...e, amount: (0, n.WI)(e.amount) } : e),
              (this.postConditionMode = i),
              (this.postConditions = r),
              (this.anchorMode = f.Fj.Any);
          }
          signBegin() {
            const t = (0, d.mg)(this);
            return (t.auth = (0, c.AT)(t.auth)), t.txid();
          }
          verifyBegin() {
            const t = (0, d.mg)(this);
            return (t.auth = (0, c.AT)(t.auth)), t.txid();
          }
          verifyOrigin() {
            return (0, c.S1)(this.auth, this.verifyBegin());
          }
          signNextOrigin(t, e) {
            if (void 0 === this.auth.spendingCondition)
              throw new Error('"auth.spendingCondition" is undefined');
            if (void 0 === this.auth.authType)
              throw new Error('"auth.authType" is undefined');
            return this.signAndAppend(
              this.auth.spendingCondition,
              t,
              f.hT.Standard,
              e,
            );
          }
          signNextSponsor(t, e) {
            if (this.auth.authType === f.hT.Sponsored)
              return this.signAndAppend(
                this.auth.sponsorSpendingCondition,
                t,
                f.hT.Sponsored,
                e,
              );
            throw new Error('"auth.sponsorSpendingCondition" is undefined');
          }
          appendPubkey(t) {
            const e = "object" == typeof t && "type" in t ? t : (0, l.uC)(t),
              r = this.auth.spendingCondition;
            if (!r || (0, c.I4)(r))
              throw new Error(
                "Can't append public key to a singlesig condition",
              );
            {
              const t = (0, l.AC)(e.data);
              r.fields.push(
                (0, p.Jt)(t ? f.G5.Compressed : f.G5.Uncompressed, e),
              );
            }
          }
          signAndAppend(t, e, r, n) {
            const { nextSig: i, nextSigHash: o } = (0, c.A6)(
              e,
              r,
              t.fee,
              t.nonce,
              n,
            );
            if ((0, c.I4)(t)) t.signature = (0, p.EM)(i);
            else {
              const e = (0, l.E)(n);
              t.fields.push(
                (0, p.Jt)(
                  e ? f.G5.Compressed : f.G5.Uncompressed,
                  (0, p.EM)(i),
                ),
              );
            }
            return o;
          }
          txid() {
            const t = this.serializeBytes();
            return (0, d.U1)(t);
          }
          setSponsor(t) {
            if (this.auth.authType != f.hT.Sponsored)
              throw new h.uJ("Cannot sponsor sign a non-sponsored transaction");
            this.auth = (0, c.tj)(this.auth, t);
          }
          setFee(t) {
            this.auth = (0, c.x6)(this.auth, t);
          }
          setNonce(t) {
            this.auth = (0, c.MG)(this.auth, t);
          }
          setSponsorNonce(t) {
            if (this.auth.authType != f.hT.Sponsored)
              throw new h.uJ("Cannot sponsor sign a non-sponsored transaction");
            this.auth = (0, c.IE)(this.auth, t);
          }
          serialize() {
            return (0, n.My)(this.serializeBytes());
          }
          serializeBytes() {
            if (void 0 === this.transactionVersion)
              throw new h.Fn('"transactionVersion" is undefined');
            if (void 0 === this.chainId)
              throw new h.Fn('"chainId" is undefined');
            if (void 0 === this.auth) throw new h.Fn('"auth" is undefined');
            if (void 0 === this.payload)
              throw new h.Fn('"payload" is undefined');
            const t = [];
            t.push(this.transactionVersion);
            const e = new Uint8Array(4);
            return (
              (0, i.Sw)(e, this.chainId, 0),
              t.push(e),
              t.push((0, c.H7)(this.auth)),
              t.push(this.anchorMode),
              t.push(this.postConditionMode),
              t.push((0, a.SY)(this.postConditions)),
              t.push((0, a.o3)(this.payload)),
              (0, n.yB)(t)
            );
          }
        }
        function m(t) {
          const e = (0, n.Qs)(t, u.H) ? t : new u.H(t),
            r = e.readUInt8Enum(s.J_, (t) => {
              throw new Error(`Could not parse ${t} as TransactionVersion`);
            }),
            i = e.readUInt32BE(),
            o = (0, c.h2)(e),
            h = e.readUInt8Enum(f.Fj, (t) => {
              throw new Error(`Could not parse ${t} as AnchorMode`);
            }),
            l = e.readUInt8Enum(f.FN, (t) => {
              throw new Error(`Could not parse ${t} as PostConditionMode`);
            }),
            d = (0, a.em)(e, y.$.PostCondition),
            p = (0, a.ur)(e),
            m = new g({
              transactionVersion: r,
              chainId: i,
              auth: o,
              payload: p,
              postConditions: d,
              postConditionMode: l,
            });
          return (m.anchorMode = h), m;
        }
        function b(t) {
          return (0, s.tS)(t.transactionVersion)({
            [s.J_.Mainnet]: o.nG,
            [s.J_.Testnet]: o.SS,
          });
        }
        function w(t) {
          const e = t.auth.spendingCondition.hashMode;
          if ([f.ct.P2SH, f.ct.P2WSH].includes(e)) {
            const e = t.auth.spendingCondition,
              r = e.fields.filter(
                (t) => t.contents.type === y.$.MessageSignature,
              ).length,
              n = (e.signaturesRequired - r) * (f.tL + 1);
            return t.serializeBytes().byteLength + n;
          }
          return t.serializeBytes().byteLength;
        }
        function v(t) {
          return t.serialize();
        }
        function _(t) {
          return t.serializeBytes();
        }
        function E(t) {
          return t.serialize();
        }
      },
      48299: (t, e, r) => {
        "use strict";
        r.d(e, {
          mg: () => $,
          yX: () => rt,
          vI: () => z,
          A0: () => W,
          G9: () => Z,
          wZ: () => Q,
          rY: () => J,
          x5: () => tt,
          ev: () => nt,
          qw: () => et,
          EW: () => K,
          PM: () => V,
          cJ: () => G,
          zi: () => st,
          vx: () => it,
          po: () => H,
          Wf: () => q,
          p1: () => X,
          U1: () => Y,
          cU: () => ot,
          Od: () => R.MX,
        });
        var n = r(66421),
          i = r(17816);
        const o = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          s = Uint8Array.from({ length: 16 }, (t, e) => e),
          a = s.map((t) => (9 * t + 5) % 16);
        let u = [s],
          c = [a];
        for (let t = 0; t < 4; t++)
          for (let e of [u, c]) e.push(e[t].map((t) => o[t]));
        const f = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((t) => new Uint8Array(t)),
          h = u.map((t, e) => t.map((t) => f[e][t])),
          l = c.map((t, e) => t.map((t) => f[e][t])),
          d = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          p = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          y = (t, e) => (t << e) | (t >>> (32 - e));
        function g(t, e, r, n) {
          return 0 === t
            ? e ^ r ^ n
            : 1 === t
              ? (e & r) | (~e & n)
              : 2 === t
                ? (e | ~r) ^ n
                : 3 === t
                  ? (e & n) | (r & ~n)
                  : e ^ (r | ~n);
        }
        const m = new Uint32Array(16);
        class b extends n.D {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: t, h1: e, h2: r, h3: n, h4: i } = this;
            return [t, e, r, n, i];
          }
          set(t, e, r, n, i) {
            (this.h0 = 0 | t),
              (this.h1 = 0 | e),
              (this.h2 = 0 | r),
              (this.h3 = 0 | n),
              (this.h4 = 0 | i);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4) m[r] = t.getUint32(e, !0);
            let r = 0 | this.h0,
              n = r,
              i = 0 | this.h1,
              o = i,
              s = 0 | this.h2,
              a = s,
              f = 0 | this.h3,
              b = f,
              w = 0 | this.h4,
              v = w;
            for (let t = 0; t < 5; t++) {
              const e = 4 - t,
                _ = d[t],
                E = p[t],
                S = u[t],
                I = c[t],
                M = h[t],
                A = l[t];
              for (let e = 0; e < 16; e++) {
                const n = (y(r + g(t, i, s, f) + m[S[e]] + _, M[e]) + w) | 0;
                (r = w), (w = f), (f = 0 | y(s, 10)), (s = i), (i = n);
              }
              for (let t = 0; t < 16; t++) {
                const r = (y(n + g(e, o, a, b) + m[I[t]] + E, A[t]) + v) | 0;
                (n = v), (v = b), (b = 0 | y(a, 10)), (a = o), (o = r);
              }
            }
            this.set(
              (this.h1 + s + b) | 0,
              (this.h2 + f + v) | 0,
              (this.h3 + w + n) | 0,
              (this.h4 + r + o) | 0,
              (this.h0 + i + a) | 0,
            );
          }
          roundClean() {
            m.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        const w = (0, i.ld)(() => new b());
        var v = r(35021);
        const _ = BigInt(2 ** 32 - 1),
          E = BigInt(32);
        function S(t, e = !1) {
          return e
            ? { h: Number(t & _), l: Number((t >> E) & _) }
            : { h: 0 | Number((t >> E) & _), l: 0 | Number(t & _) };
        }
        const I = {
            fromBig: S,
            split: function (t, e = !1) {
              let r = new Uint32Array(t.length),
                n = new Uint32Array(t.length);
              for (let i = 0; i < t.length; i++) {
                const { h: o, l: s } = S(t[i], e);
                [r[i], n[i]] = [o, s];
              }
              return [r, n];
            },
            toBig: (t, e) => (BigInt(t >>> 0) << E) | BigInt(e >>> 0),
            shrSH: (t, e, r) => t >>> r,
            shrSL: (t, e, r) => (t << (32 - r)) | (e >>> r),
            rotrSH: (t, e, r) => (t >>> r) | (e << (32 - r)),
            rotrSL: (t, e, r) => (t << (32 - r)) | (e >>> r),
            rotrBH: (t, e, r) => (t << (64 - r)) | (e >>> (r - 32)),
            rotrBL: (t, e, r) => (t >>> (r - 32)) | (e << (64 - r)),
            rotr32H: (t, e) => e,
            rotr32L: (t, e) => t,
            rotlSH: (t, e, r) => (t << r) | (e >>> (32 - r)),
            rotlSL: (t, e, r) => (e << r) | (t >>> (32 - r)),
            rotlBH: (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
            rotlBL: (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
            add: function (t, e, r, n) {
              const i = (e >>> 0) + (n >>> 0);
              return { h: (t + r + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
            },
            add3L: (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
            add3H: (t, e, r, n) => (e + r + n + ((t / 2 ** 32) | 0)) | 0,
            add4L: (t, e, r, n) =>
              (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
            add4H: (t, e, r, n, i) => (e + r + n + i + ((t / 2 ** 32) | 0)) | 0,
            add5H: (t, e, r, n, i, o) =>
              (e + r + n + i + o + ((t / 2 ** 32) | 0)) | 0,
            add5L: (t, e, r, n, i) =>
              (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
          },
          [M, A] = I.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t)),
          ),
          T = new Uint32Array(80),
          k = new Uint32Array(80);
        class O extends n.D {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: r,
              Bl: n,
              Ch: i,
              Cl: o,
              Dh: s,
              Dl: a,
              Eh: u,
              El: c,
              Fh: f,
              Fl: h,
              Gh: l,
              Gl: d,
              Hh: p,
              Hl: y,
            } = this;
            return [t, e, r, n, i, o, s, a, u, c, f, h, l, d, p, y];
          }
          set(t, e, r, n, i, o, s, a, u, c, f, h, l, d, p, y) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | r),
              (this.Bl = 0 | n),
              (this.Ch = 0 | i),
              (this.Cl = 0 | o),
              (this.Dh = 0 | s),
              (this.Dl = 0 | a),
              (this.Eh = 0 | u),
              (this.El = 0 | c),
              (this.Fh = 0 | f),
              (this.Fl = 0 | h),
              (this.Gh = 0 | l),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | y);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4)
              (T[r] = t.getUint32(e)), (k[r] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | T[t - 15],
                r = 0 | k[t - 15],
                n = I.rotrSH(e, r, 1) ^ I.rotrSH(e, r, 8) ^ I.shrSH(e, r, 7),
                i = I.rotrSL(e, r, 1) ^ I.rotrSL(e, r, 8) ^ I.shrSL(e, r, 7),
                o = 0 | T[t - 2],
                s = 0 | k[t - 2],
                a = I.rotrSH(o, s, 19) ^ I.rotrBH(o, s, 61) ^ I.shrSH(o, s, 6),
                u = I.rotrSL(o, s, 19) ^ I.rotrBL(o, s, 61) ^ I.shrSL(o, s, 6),
                c = I.add4L(i, u, k[t - 7], k[t - 16]),
                f = I.add4H(c, n, a, T[t - 7], T[t - 16]);
              (T[t] = 0 | f), (k[t] = 0 | c);
            }
            let {
              Ah: r,
              Al: n,
              Bh: i,
              Bl: o,
              Ch: s,
              Cl: a,
              Dh: u,
              Dl: c,
              Eh: f,
              El: h,
              Fh: l,
              Fl: d,
              Gh: p,
              Gl: y,
              Hh: g,
              Hl: m,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  I.rotrSH(f, h, 14) ^ I.rotrSH(f, h, 18) ^ I.rotrBH(f, h, 41),
                b =
                  I.rotrSL(f, h, 14) ^ I.rotrSL(f, h, 18) ^ I.rotrBL(f, h, 41),
                w = (f & l) ^ (~f & p),
                v = (h & d) ^ (~h & y),
                _ = I.add5L(m, b, v, A[t], k[t]),
                E = I.add5H(_, g, e, w, M[t], T[t]),
                S = 0 | _,
                O =
                  I.rotrSH(r, n, 28) ^ I.rotrBH(r, n, 34) ^ I.rotrBH(r, n, 39),
                x =
                  I.rotrSL(r, n, 28) ^ I.rotrBL(r, n, 34) ^ I.rotrBL(r, n, 39),
                P = (r & i) ^ (r & s) ^ (i & s),
                B = (n & o) ^ (n & a) ^ (o & a);
              (g = 0 | p),
                (m = 0 | y),
                (p = 0 | l),
                (y = 0 | d),
                (l = 0 | f),
                (d = 0 | h),
                ({ h: f, l: h } = I.add(0 | u, 0 | c, 0 | E, 0 | S)),
                (u = 0 | s),
                (c = 0 | a),
                (s = 0 | i),
                (a = 0 | o),
                (i = 0 | r),
                (o = 0 | n);
              const C = I.add3L(S, x, B);
              (r = I.add3H(C, E, O, P)), (n = 0 | C);
            }
            ({ h: r, l: n } = I.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)),
              ({ h: i, l: o } = I.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)),
              ({ h: s, l: a } = I.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
              ({ h: u, l: c } = I.add(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)),
              ({ h: f, l: h } = I.add(0 | this.Eh, 0 | this.El, 0 | f, 0 | h)),
              ({ h: l, l: d } = I.add(0 | this.Fh, 0 | this.Fl, 0 | l, 0 | d)),
              ({ h: p, l: y } = I.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | y)),
              ({ h: g, l: m } = I.add(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | m)),
              this.set(r, n, i, o, s, a, u, c, f, h, l, d, p, y, g, m);
          }
          roundClean() {
            T.fill(0), k.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class x extends O {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        class P extends O {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class B extends O {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        (0, i.ld)(() => new O()), (0, i.ld)(() => new x());
        const C = (0, i.ld)(() => new P());
        (0, i.ld)(() => new B());
        var R = r(97883),
          N = r(39834),
          U = r(7581),
          D = r(67193),
          L = r.n(D),
          j = r(61994),
          F = r(90687);
        const H = (t) => R.Wp.randomBytes(t),
          K = (t) => (t.length % 2 ? `0${t}` : t),
          V = (t, e) => t.padStart(e, "0"),
          q = (t, e) => t.padEnd(e, "0"),
          z = (t, e) => !!t && (0, N.AI)(t).length > e;
        function $(t) {
          return L()(t);
        }
        function G(t, e) {
          const r = $(t);
          return delete r[e], r;
        }
        const W = (t) => w((0, v.s)(t)),
          Y = (t) => (0, N.My)(C(t)),
          X = Y,
          Z = (t) => (0, N.My)(W(t)),
          J = (t) => {
            const e = W(t),
              r = (0, N.Id)(new Uint8Array([0]), new Uint8Array([e.length]), e),
              n = W(r);
            return (0, N.My)(n);
          },
          Q = (t, e) => {
            if (t > 15 || e.length > 15)
              throw Error(
                "P2SH multisig address can only contain up to 15 public keys",
              );
            const r = [];
            r.push(80 + t),
              e.forEach((t) => {
                r.push(t.length), r.push(t);
              }),
              r.push(80 + e.length),
              r.push(174);
            const n = (0, N.yB)(r),
              i = W(n);
            return (0, N.My)(i);
          },
          tt = (t, e) => {
            if (t > 15 || e.length > 15)
              throw Error(
                "P2WSH multisig address can only contain up to 15 public keys",
              );
            const r = [];
            r.push(80 + t),
              e.forEach((t) => {
                r.push(t.length), r.push(t);
              }),
              r.push(80 + e.length),
              r.push(174);
            const n = (0, N.yB)(r),
              i = (0, v.s)(n),
              o = [];
            o.push(0), o.push(i.length), o.push(i);
            const s = (0, N.yB)(o),
              a = W(s);
            return (0, N.My)(a);
          };
        function et(t) {
          return (
            /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/.test(
              t,
            ) && t.length < 128
          );
        }
        function rt(t) {
          return `0x${(0, j.G)(t)}`;
        }
        function nt(t) {
          return (0, F.b)(t);
        }
        const it = (t) => {
            if (t.okay) return nt(t.result);
            throw new Error(t.cause);
          },
          ot = (t) => {
            try {
              return (0, U.ns)(t), !0;
            } catch (t) {
              return !1;
            }
          };
        function st(t) {
          const [e, r] = t.split(".");
          if (!e || !r) throw new Error(`Invalid contract identifier: ${t}`);
          return [e, r];
        }
      },
      89977: (t, e, r) => {
        "use strict";
        r.d(e, {
          $o: () => I,
          Dv: () => m,
          EM: () => p,
          FR: () => M,
          JA: () => _,
          Jt: () => k,
          Ox: () => b,
          Ti: () => A,
          Tj: () => v,
          _b: () => h,
          iB: () => l,
          iw: () => E,
          lU: () => d,
          nT: () => w,
          o1: () => S,
          qX: () => T,
          tT: () => g,
          zh: () => y,
        });
        var n = r(39834),
          i = r(7581),
          o = r(18480),
          s = r(38389),
          a = r(29325),
          u = r(45842),
          c = r(48299),
          f = r(60752);
        function h() {
          return {
            type: f.$.Address,
            version: a.BY.MainnetSingleSig,
            hash160: "0".repeat(40),
          };
        }
        function l(t) {
          if (t && (0, c.vI)(t, u.j4))
            throw new Error(`Memo exceeds maximum length of ${u.j4} bytes`);
          return { type: f.$.MemoString, content: t };
        }
        function d(t, e) {
          return {
            type: f.$.LengthPrefixedList,
            lengthPrefixBytes: e || 4,
            values: t,
          };
        }
        function p(t) {
          if ((0, n.aT)(t).byteLength != u.tL) throw Error("Invalid signature");
          return { type: f.$.MessageSignature, data: t };
        }
        function y(t, e, r) {
          return (
            "string" == typeof t && (t = (0, o.g7)(t)),
            "string" == typeof r && (r = l(r)),
            {
              type: f.$.Payload,
              payloadType: u.d2.TokenTransfer,
              recipient: t,
              amount: (0, n.WI)(e),
              memo: r ?? l(""),
            }
          );
        }
        function g(t, e, r, n) {
          return (
            "string" == typeof e && (e = S(e)),
            "string" == typeof r && (r = S(r)),
            {
              type: f.$.Payload,
              payloadType: u.d2.ContractCall,
              contractAddress: "string" == typeof t ? M(t) : t,
              contractName: e,
              functionName: r,
              functionArgs: n,
            }
          );
        }
        function m(t) {
          return S(t, 4, 1e5);
        }
        function b(t, e, r) {
          return (
            "string" == typeof t && (t = S(t)),
            "string" == typeof e && (e = m(e)),
            "number" == typeof r
              ? {
                  type: f.$.Payload,
                  payloadType: u.d2.VersionedSmartContract,
                  clarityVersion: r,
                  contractName: t,
                  codeBody: e,
                }
              : {
                  type: f.$.Payload,
                  payloadType: u.d2.SmartContract,
                  contractName: t,
                  codeBody: e,
                }
          );
        }
        function w() {
          return { type: f.$.Payload, payloadType: u.d2.PoisonMicroblock };
        }
        function v(t, e) {
          if (t.byteLength != u.yZ)
            throw Error(`Coinbase buffer size must be ${u.yZ} bytes`);
          return null != e
            ? {
                type: f.$.Payload,
                payloadType: u.d2.CoinbaseToAltRecipient,
                coinbaseBytes: t,
                recipient: e,
              }
            : {
                type: f.$.Payload,
                payloadType: u.d2.Coinbase,
                coinbaseBytes: t,
              };
        }
        function _(t, e, r) {
          if (t.byteLength != u.yZ)
            throw Error(`Coinbase buffer size must be ${u.yZ} bytes`);
          if (r.byteLength != u.vX)
            throw Error(`VRF proof buffer size must be ${u.vX} bytes`);
          return {
            type: f.$.Payload,
            payloadType: u.d2.NakamotoCoinbase,
            coinbaseBytes: t,
            recipient: e.type === s.dl.OptionalSome ? e.value : void 0,
            vrfProof: r,
          };
        }
        function E(t, e, r, n, i, o, s) {
          return {
            type: f.$.Payload,
            payloadType: u.d2.TenureChange,
            tenureHash: t,
            previousTenureHash: e,
            burnViewHash: r,
            previousTenureEnd: n,
            previousTenureBlocks: i,
            cause: o,
            publicKeyHash: s,
          };
        }
        function S(t, e, r) {
          const n = e || 1,
            i = r || u.Ej;
          if ((0, c.vI)(t, i))
            throw new Error(`String length exceeds maximum bytes ${i}`);
          return {
            type: f.$.LengthPrefixedString,
            content: t,
            lengthPrefixBytes: n,
            maxLengthBytes: i,
          };
        }
        function I(t, e, r) {
          return {
            type: f.$.Asset,
            address: M(t),
            contractName: S(e),
            assetName: S(r),
          };
        }
        function M(t) {
          const e = (0, i.ns)(t);
          return { type: f.$.Address, version: e[0], hash160: e[1] };
        }
        function A(t, e) {
          const r = M(t),
            n = S(e);
          return {
            type: f.$.Principal,
            prefix: u.V9.Contract,
            address: r,
            contractName: n,
          };
        }
        function T(t) {
          const e = M(t);
          return { type: f.$.Principal, prefix: u.V9.Standard, address: e };
        }
        function k(t, e) {
          return {
            pubKeyEncoding: t,
            type: f.$.TransactionAuthField,
            contents: e,
          };
        }
      },
      17436: (t, e, r) => {
        "use strict";
        r.d(e, {
          EY: () => y,
          Uw: () => f,
          X3: () => m,
          Zj: () => p,
          bM: () => w,
          dm: () => d,
          lY: () => h,
          pD: () => l,
          v3: () => b,
          xk: () => g,
        });
        var n = r(7581),
          i = r(45842),
          o = r(1755),
          s = r(48299),
          a = r(89977),
          u = r(67449),
          c = r(60752);
        function f(t, e, r, n) {
          if (0 === n.length) throw Error("Invalid number of public keys");
          if (
            !(
              (e !== i.ct.P2PKH && e !== i.ct.P2WPKH) ||
              (1 === n.length && 1 === r)
            )
          )
            throw Error("Invalid number of public keys or signatures");
          if (
            (e === i.ct.P2WPKH ||
              e === i.ct.P2WSH ||
              e === i.ct.P2WSHNonSequential) &&
            !n.map((t) => t.data).every(o.AC)
          )
            throw Error("Public keys must be compressed for segwit");
          switch (e) {
            case i.ct.P2PKH:
              return h(t, (0, s.G9)(n[0].data));
            case i.ct.P2WPKH:
              return h(t, (0, s.rY)(n[0].data));
            case i.ct.P2SH:
            case i.ct.P2SHNonSequential:
              return h(t, (0, s.wZ)(r, n.map(u.U6)));
            case i.ct.P2WSH:
            case i.ct.P2WSHNonSequential:
              return h(t, (0, s.x5)(r, n.map(u.U6)));
          }
        }
        function h(t, e) {
          return { type: c.$.Address, version: t, hash160: e };
        }
        function l(t) {
          return (0, n.bJ)(t.version, t.hash160);
        }
        function d(t) {
          return t.payloadType === i.d2.TokenTransfer;
        }
        function p(t) {
          return t.payloadType === i.d2.ContractCall;
        }
        function y(t) {
          return t.payloadType === i.d2.SmartContract;
        }
        function g(t) {
          return t.payloadType === i.d2.PoisonMicroblock;
        }
        function m(t) {
          return t.payloadType === i.d2.Coinbase;
        }
        function b(t) {
          const [e, r, n] = t.split(/\.|::/);
          return (0, a.$o)(e, r, n);
        }
        function w(t) {
          if (t.includes(".")) {
            const [e, r] = t.split(".");
            return (0, a.Ti)(e, r);
          }
          return (0, a.qX)(t);
        }
      },
      67449: (t, e, r) => {
        "use strict";
        r.d(e, {
          AP: () => v,
          D6: () => $,
          Dp: () => A,
          Dq: () => x,
          Ei: () => P,
          GT: () => T,
          IJ: () => g,
          I_: () => L,
          JE: () => y,
          Jn: () => W,
          L7: () => _,
          QT: () => X,
          SG: () => m,
          SY: () => R,
          U6: () => Y,
          Vk: () => U,
          X: () => K,
          Xe: () => M,
          YU: () => q,
          Yi: () => G,
          Zq: () => z,
          _i: () => E,
          bJ: () => C,
          em: () => N,
          hs: () => j,
          ij: () => w,
          kH: () => D,
          lW: () => k,
          o3: () => F,
          oJ: () => B,
          pF: () => O,
          qb: () => S,
          ug: () => I,
          ur: () => H,
          vS: () => b,
          wW: () => V,
        });
        var n = r(39834),
          i = r(15257),
          o = r(51047),
          s = r(61994),
          a = r(90687),
          u = r(21086),
          c = r(45842),
          f = r(4696),
          h = r(1755),
          l = r(48299),
          d = r(89977),
          p = r(60752);
        function y(t) {
          return (0, n.My)(g(t));
        }
        function g(t) {
          switch (t.type) {
            case p.$.Address:
              return w(t);
            case p.$.Principal:
              return E(t);
            case p.$.LengthPrefixedString:
              return M(t);
            case p.$.MemoString:
              return k(t);
            case p.$.Asset:
              return P(t);
            case p.$.PostCondition:
              return D(t);
            case p.$.PublicKey:
              return Y(t);
            case p.$.LengthPrefixedList:
              return R(t);
            case p.$.Payload:
              return F(t);
            case p.$.TransactionAuthField:
              return G(t);
            case p.$.MessageSignature:
              return z(t);
          }
        }
        function m(t, e, r) {
          switch (e) {
            case p.$.Address:
              return v(t);
            case p.$.Principal:
              return S(t);
            case p.$.LengthPrefixedString:
              return A(t);
            case p.$.MemoString:
              return O(t);
            case p.$.Asset:
              return B(t);
            case p.$.PostCondition:
              return L(t);
            case p.$.PublicKey:
              return X(t);
            case p.$.Payload:
              return H(t);
            case p.$.LengthPrefixedList:
              if (!r) throw new f.MJ("No list type specified");
              return N(t, r);
            case p.$.MessageSignature:
              return K(t);
            default:
              throw new Error("Could not recognize StacksWireType");
          }
        }
        function b(t) {
          return (0, n.My)(w(t));
        }
        function w(t) {
          const e = [];
          return (
            e.push((0, n.aT)((0, n.y6)(t.version, 1))),
            e.push((0, n.aT)(t.hash160)),
            (0, n.yB)(e)
          );
        }
        function v(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            r = (0, n.od)((0, n.My)(e.readBytes(1))),
            i = (0, n.My)(e.readBytes(20));
          return { type: p.$.Address, version: r, hash160: i };
        }
        function _(t) {
          return (0, n.My)(E(t));
        }
        function E(t) {
          const e = [];
          return (
            e.push(t.prefix),
            (t.prefix !== c.V9.Standard && t.prefix !== c.V9.Contract) ||
              e.push(w(t.address)),
            t.prefix === c.V9.Contract && e.push(M(t.contractName)),
            (0, n.yB)(e)
          );
        }
        function S(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            r = e.readUInt8Enum(c.V9, (t) => {
              throw new f.MJ(`Unexpected Principal payload type: ${t}`);
            });
          if (r === c.V9.Origin) return { type: p.$.Principal, prefix: r };
          const i = v(e);
          if (r === c.V9.Standard)
            return { type: p.$.Principal, prefix: r, address: i };
          const s = A(e);
          return {
            type: p.$.Principal,
            prefix: r,
            address: i,
            contractName: s,
          };
        }
        function I(t) {
          return (0, n.My)(M(t));
        }
        function M(t) {
          const e = [],
            r = (0, n.AI)(t.content),
            i = r.byteLength;
          return (
            e.push((0, n.aT)((0, n.y6)(i, t.lengthPrefixBytes))),
            e.push(r),
            (0, n.yB)(e)
          );
        }
        function A(t, e, r) {
          e = e || 1;
          const i = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            s = (0, n.od)((0, n.My)(i.readBytes(e))),
            a = (0, n.AE)(i.readBytes(s));
          return (0, d.o1)(a, e, r ?? 128);
        }
        function T(t) {
          return (0, n.My)(k(t));
        }
        function k(t) {
          const e = [],
            r = (0, n.AI)(t.content),
            i = (0, l.Wf)((0, n.My)(r), 2 * c.j4);
          return e.push((0, n.aT)(i)), (0, n.yB)(e);
        }
        function O(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t);
          let r = (0, n.AE)(e.readBytes(c.j4));
          return (
            (r = r.replace(/\u0000*$/, "")),
            { type: p.$.MemoString, content: r }
          );
        }
        function x(t) {
          return (0, n.My)(P(t));
        }
        function P(t) {
          const e = [];
          return (
            e.push(w(t.address)),
            e.push(M(t.contractName)),
            e.push(M(t.assetName)),
            (0, n.yB)(e)
          );
        }
        function B(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t);
          return {
            type: p.$.Asset,
            address: v(e),
            contractName: A(e),
            assetName: A(e),
          };
        }
        function C(t) {
          return (0, n.My)(R(t));
        }
        function R(t) {
          const e = t.values,
            r = [];
          r.push((0, n.aT)((0, n.y6)(e.length, t.lengthPrefixBytes)));
          for (const t of e) r.push(g(t));
          return (0, n.yB)(r);
        }
        function N(t, e, r) {
          const i = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            s = (0, n.od)((0, n.My)(i.readBytes(r || 4))),
            a = [];
          for (let t = 0; t < s; t++)
            switch (e) {
              case p.$.Address:
                a.push(v(i));
                break;
              case p.$.LengthPrefixedString:
                a.push(A(i));
                break;
              case p.$.MemoString:
                a.push(O(i));
                break;
              case p.$.Asset:
                a.push(B(i));
                break;
              case p.$.PostCondition:
                a.push(L(i));
                break;
              case p.$.PublicKey:
                a.push(X(i));
                break;
              case p.$.TransactionAuthField:
                a.push(V(i));
            }
          return (0, d.lU)(a, r);
        }
        function U(t) {
          return (0, n.My)(D(t));
        }
        function D(t) {
          const e = [];
          if (
            (e.push(t.conditionType),
            e.push(E(t.principal)),
            (t.conditionType !== c.qu.Fungible &&
              t.conditionType !== c.qu.NonFungible) ||
              e.push(P(t.asset)),
            t.conditionType === c.qu.NonFungible &&
              e.push((0, s.n)(t.assetName)),
            e.push(t.conditionCode),
            t.conditionType === c.qu.STX || t.conditionType === c.qu.Fungible)
          ) {
            if (t.amount > BigInt("0xffffffffffffffff"))
              throw new f.Fn(
                "The post-condition amount may not be larger than 8 bytes",
              );
            e.push((0, n.m5)(t.amount, 8));
          }
          return (0, n.yB)(e);
        }
        function L(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            r = e.readUInt8Enum(c.qu, (t) => {
              throw new f.MJ(`Could not read ${t} as PostConditionType`);
            }),
            i = S(e);
          let s, u, h;
          switch (r) {
            case c.qu.STX:
              return (
                (s = e.readUInt8Enum(c.Dx, (t) => {
                  throw new f.MJ(
                    `Could not read ${t} as FungibleConditionCode`,
                  );
                })),
                (h = BigInt(`0x${(0, n.My)(e.readBytes(8))}`)),
                {
                  type: p.$.PostCondition,
                  conditionType: c.qu.STX,
                  principal: i,
                  conditionCode: s,
                  amount: h,
                }
              );
            case c.qu.Fungible:
              return (
                (u = B(e)),
                (s = e.readUInt8Enum(c.Dx, (t) => {
                  throw new f.MJ(
                    `Could not read ${t} as FungibleConditionCode`,
                  );
                })),
                (h = BigInt(`0x${(0, n.My)(e.readBytes(8))}`)),
                {
                  type: p.$.PostCondition,
                  conditionType: c.qu.Fungible,
                  principal: i,
                  conditionCode: s,
                  amount: h,
                  asset: u,
                }
              );
            case c.qu.NonFungible:
              u = B(e);
              const t = (0, a.b)(e);
              return (
                (s = e.readUInt8Enum(c.q$, (t) => {
                  throw new f.MJ(
                    `Could not read ${t} as FungibleConditionCode`,
                  );
                })),
                {
                  type: p.$.PostCondition,
                  conditionType: c.qu.NonFungible,
                  principal: i,
                  conditionCode: s,
                  asset: u,
                  assetName: t,
                }
              );
          }
        }
        function j(t) {
          return (0, n.My)(F(t));
        }
        function F(t) {
          const e = [];
          switch ((e.push(t.payloadType), t.payloadType)) {
            case c.d2.TokenTransfer:
              e.push((0, s.n)(t.recipient)),
                e.push((0, n.m5)(t.amount, 8)),
                e.push(g(t.memo));
              break;
            case c.d2.ContractCall:
              e.push(g(t.contractAddress)),
                e.push(g(t.contractName)),
                e.push(g(t.functionName));
              const r = new Uint8Array(4);
              (0, i.Sw)(r, t.functionArgs.length, 0),
                e.push(r),
                t.functionArgs.forEach((t) => {
                  e.push((0, s.n)(t));
                });
              break;
            case c.d2.SmartContract:
              e.push(g(t.contractName)), e.push(g(t.codeBody));
              break;
            case c.d2.VersionedSmartContract:
              e.push(t.clarityVersion),
                e.push(g(t.contractName)),
                e.push(g(t.codeBody));
              break;
            case c.d2.PoisonMicroblock:
              break;
            case c.d2.Coinbase:
              e.push(t.coinbaseBytes);
              break;
            case c.d2.CoinbaseToAltRecipient:
              e.push(t.coinbaseBytes), e.push((0, s.n)(t.recipient));
              break;
            case c.d2.NakamotoCoinbase:
              e.push(t.coinbaseBytes),
                e.push(
                  (0, s.n)(t.recipient ? (0, u.gp)(t.recipient) : (0, u.gu)()),
                ),
                e.push(t.vrfProof);
              break;
            case c.d2.TenureChange:
              e.push((0, n.aT)(t.tenureHash)),
                e.push((0, n.aT)(t.previousTenureHash)),
                e.push((0, n.aT)(t.burnViewHash)),
                e.push((0, n.aT)(t.previousTenureEnd)),
                e.push((0, i.Sw)(new Uint8Array(4), t.previousTenureBlocks)),
                e.push((0, i.Gs)(new Uint8Array(1), t.cause)),
                e.push((0, n.aT)(t.publicKeyHash));
          }
          return (0, n.yB)(e);
        }
        function H(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t);
          switch (
            e.readUInt8Enum(c.d2, (t) => {
              throw new Error(`Cannot recognize PayloadType: ${t}`);
            })
          ) {
            case c.d2.TokenTransfer:
              const t = (0, a.b)(e),
                r = (0, n.WI)(e.readBytes(8)),
                i = O(e);
              return (0, d.zh)(t, r, i);
            case c.d2.ContractCall:
              const o = v(e),
                s = A(e),
                u = A(e),
                f = [],
                h = e.readUInt32BE();
              for (let t = 0; t < h; t++) {
                const t = (0, a.b)(e);
                f.push(t);
              }
              return (0, d.tT)(o, s, u, f);
            case c.d2.SmartContract:
              const l = A(e),
                p = A(e, 4, 1e5);
              return (0, d.Ox)(l, p);
            case c.d2.VersionedSmartContract: {
              const t = e.readUInt8Enum(c.nX, (t) => {
                  throw new Error(`Cannot recognize ClarityVersion: ${t}`);
                }),
                r = A(e),
                n = A(e, 4, 1e5);
              return (0, d.Ox)(r, n, t);
            }
            case c.d2.PoisonMicroblock:
              return (0, d.nT)();
            case c.d2.Coinbase: {
              const t = e.readBytes(c.yZ);
              return (0, d.Tj)(t);
            }
            case c.d2.CoinbaseToAltRecipient: {
              const t = e.readBytes(c.yZ),
                r = (0, a.b)(e);
              return (0, d.Tj)(t, r);
            }
            case c.d2.NakamotoCoinbase: {
              const t = e.readBytes(c.yZ),
                r = (0, a.b)(e),
                n = e.readBytes(c.vX);
              return (0, d.JA)(t, r, n);
            }
            case c.d2.TenureChange:
              const y = (0, n.My)(e.readBytes(20)),
                g = (0, n.My)(e.readBytes(20)),
                m = (0, n.My)(e.readBytes(20)),
                b = (0, n.My)(e.readBytes(32)),
                w = e.readUInt32BE(),
                _ = e.readUInt8Enum(c.Ld, (t) => {
                  throw new Error(`Cannot recognize TenureChangeCause: ${t}`);
                }),
                E = (0, n.My)(e.readBytes(20));
              return (0, d.iw)(y, g, m, b, w, _, E);
          }
        }
        function K(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t);
          return (0, d.EM)((0, n.My)(e.readBytes(c.tL)));
        }
        function V(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            r = e.readUInt8Enum(c.Dv, (t) => {
              throw new f.MJ(`Could not read ${t} as AuthFieldType`);
            });
          switch (r) {
            case c.Dv.PublicKeyCompressed:
              return (0, d.Jt)(c.G5.Compressed, X(e));
            case c.Dv.PublicKeyUncompressed:
              return (0, d.Jt)(
                c.G5.Uncompressed,
                (0, h.uC)((0, h.sA)(X(e).data)),
              );
            case c.Dv.SignatureCompressed:
              return (0, d.Jt)(c.G5.Compressed, K(e));
            case c.Dv.SignatureUncompressed:
              return (0, d.Jt)(c.G5.Uncompressed, K(e));
            default:
              throw new Error(`Unknown auth field type: ${JSON.stringify(r)}`);
          }
        }
        function q(t) {
          return (0, n.My)(z(t));
        }
        function z(t) {
          return (0, n.aT)(t.data);
        }
        function $(t) {
          return (0, n.My)(G(t));
        }
        function G(t) {
          const e = [];
          switch (t.contents.type) {
            case p.$.PublicKey:
              e.push(
                t.pubKeyEncoding === c.G5.Compressed
                  ? c.Dv.PublicKeyCompressed
                  : c.Dv.PublicKeyUncompressed,
              ),
                e.push((0, n.aT)((0, h.xf)(t.contents.data)));
              break;
            case p.$.MessageSignature:
              e.push(
                t.pubKeyEncoding === c.G5.Compressed
                  ? c.Dv.SignatureCompressed
                  : c.Dv.SignatureUncompressed,
              ),
                e.push(z(t.contents));
          }
          return (0, n.yB)(e);
        }
        function W(t) {
          return (0, n.My)(Y(t));
        }
        function Y(t) {
          return t.data.slice();
        }
        function X(t) {
          const e = (0, n.Qs)(t, o.H) ? t : new o.H(t),
            r = e.readUInt8(),
            i = 4 === r ? c.xV : c.mw;
          return (0, h.uC)((0, n.yB)([r, e.readBytes(i)]));
        }
      },
      60752: (t, e, r) => {
        "use strict";
        var n;
        function i(t) {
          return (e) => e[t];
        }
        r.d(e, { $: () => n, q: () => i }),
          (function (t) {
            (t[(t.Address = 0)] = "Address"),
              (t[(t.Principal = 1)] = "Principal"),
              (t[(t.LengthPrefixedString = 2)] = "LengthPrefixedString"),
              (t[(t.MemoString = 3)] = "MemoString"),
              (t[(t.Asset = 4)] = "Asset"),
              (t[(t.PostCondition = 5)] = "PostCondition"),
              (t[(t.PublicKey = 6)] = "PublicKey"),
              (t[(t.LengthPrefixedList = 7)] = "LengthPrefixedList"),
              (t[(t.Payload = 8)] = "Payload"),
              (t[(t.MessageSignature = 9)] = "MessageSignature"),
              (t[(t.StructuredDataSignature = 10)] = "StructuredDataSignature"),
              (t[(t.TransactionAuthField = 11)] = "TransactionAuthField");
          })(n || (n = {}));
      },
      44541: function (t, e) {
        "use strict";
        var r,
          n,
          i =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            },
          o =
            (this && this.__generator) ||
            function (t, e) {
              var r,
                n,
                i,
                o,
                s = {
                  label: 0,
                  sent: function () {
                    if (1 & i[0]) throw i[1];
                    return i[1];
                  },
                  trys: [],
                  ops: [],
                };
              return (
                (o = { next: a(0), throw: a(1), return: a(2) }),
                "function" == typeof Symbol &&
                  (o[Symbol.iterator] = function () {
                    return this;
                  }),
                o
              );
              function a(a) {
                return function (u) {
                  return (function (a) {
                    if (r)
                      throw new TypeError("Generator is already executing.");
                    for (; o && ((o = 0), a[0] && (s = 0)), s; )
                      try {
                        if (
                          ((r = 1),
                          n &&
                            (i =
                              2 & a[0]
                                ? n.return
                                : a[0]
                                  ? n.throw || ((i = n.return) && i.call(n), 0)
                                  : n.next) &&
                            !(i = i.call(n, a[1])).done)
                        )
                          return i;
                        switch (
                          ((n = 0), i && (a = [2 & a[0], i.value]), a[0])
                        ) {
                          case 0:
                          case 1:
                            i = a;
                            break;
                          case 4:
                            return s.label++, { value: a[1], done: !1 };
                          case 5:
                            s.label++, (n = a[1]), (a = [0]);
                            continue;
                          case 7:
                            (a = s.ops.pop()), s.trys.pop();
                            continue;
                          default:
                            if (
                              !((i = s.trys),
                              (i = i.length > 0 && i[i.length - 1]) ||
                                (6 !== a[0] && 2 !== a[0]))
                            ) {
                              s = 0;
                              continue;
                            }
                            if (
                              3 === a[0] &&
                              (!i || (a[1] > i[0] && a[1] < i[3]))
                            ) {
                              s.label = a[1];
                              break;
                            }
                            if (6 === a[0] && s.label < i[1]) {
                              (s.label = i[1]), (i = a);
                              break;
                            }
                            if (i && s.label < i[2]) {
                              (s.label = i[2]), s.ops.push(a);
                              break;
                            }
                            i[2] && s.ops.pop(), s.trys.pop();
                            continue;
                        }
                        a = e.call(t, s);
                      } catch (t) {
                        (a = [6, t]), (n = 0);
                      } finally {
                        r = i = 0;
                      }
                    if (5 & a[0]) throw a[1];
                    return { value: a[0] ? a[1] : void 0, done: !0 };
                  })([a, u]);
                };
              }
            };
        function s(t) {
          return t in e.ERROR_DESCRIPTION
            ? e.ERROR_DESCRIPTION[t]
            : "Unknown Status Code: ".concat(t);
        }
        function a(t) {
          if (t) {
            if (
              (function (t) {
                return !(
                  "object" != typeof t ||
                  null === t ||
                  t instanceof Array ||
                  t instanceof Date
                );
              })(t)
            ) {
              if (Object.prototype.hasOwnProperty.call(t, "statusCode"))
                return {
                  returnCode: t.statusCode,
                  errorMessage: s(t.statusCode),
                };
              if (
                Object.prototype.hasOwnProperty.call(t, "returnCode") &&
                Object.prototype.hasOwnProperty.call(t, "errorMessage")
              )
                return t;
            }
            return { returnCode: 65535, errorMessage: t.toString() };
          }
          return { returnCode: 65535, errorMessage: t.toString() };
        }
        (e.__esModule = !0),
          (e.getVersion =
            e.processErrorResponse =
            e.errorCodeToString =
            e.ERROR_DESCRIPTION =
            e.LedgerError =
            e.PKLEN =
            e.P1_VALUES =
            e.PAYLOAD_TYPE =
            e.INS =
            e.APP_KEY =
            e.CHUNK_SIZE =
            e.CLA =
              void 0),
          (e.CLA = 9),
          (e.CHUNK_SIZE = 250),
          (e.APP_KEY = "STX"),
          (e.INS = {
            GET_VERSION: 0,
            GET_ADDR_SECP256K1: 1,
            SIGN_SECP256K1: 2,
            GET_AUTH_PUBKEY: 3,
            SIGN_JWT_SECP256K1: 4,
            SIGN_STRUCTURED_MSG: 5,
          }),
          (e.PAYLOAD_TYPE = { INIT: 0, ADD: 1, LAST: 2 }),
          (e.P1_VALUES = { ONLY_RETRIEVE: 0, SHOW_ADDRESS_IN_DEVICE: 1 }),
          (e.PKLEN = 33),
          (function (t) {
            (t[(t.U2FUnknown = 1)] = "U2FUnknown"),
              (t[(t.U2FBadRequest = 2)] = "U2FBadRequest"),
              (t[(t.U2FConfigurationUnsupported = 3)] =
                "U2FConfigurationUnsupported"),
              (t[(t.U2FDeviceIneligible = 4)] = "U2FDeviceIneligible"),
              (t[(t.U2FTimeout = 5)] = "U2FTimeout"),
              (t[(t.Timeout = 14)] = "Timeout"),
              (t[(t.NoErrors = 36864)] = "NoErrors"),
              (t[(t.DeviceIsBusy = 36865)] = "DeviceIsBusy"),
              (t[(t.ErrorDerivingKeys = 26626)] = "ErrorDerivingKeys"),
              (t[(t.ExecutionError = 25600)] = "ExecutionError"),
              (t[(t.WrongLength = 26368)] = "WrongLength"),
              (t[(t.EmptyBuffer = 27010)] = "EmptyBuffer"),
              (t[(t.OutputBufferTooSmall = 27011)] = "OutputBufferTooSmall"),
              (t[(t.DataIsInvalid = 27012)] = "DataIsInvalid"),
              (t[(t.ConditionsNotSatisfied = 27013)] =
                "ConditionsNotSatisfied"),
              (t[(t.TransactionRejected = 27014)] = "TransactionRejected"),
              (t[(t.BadKeyHandle = 27264)] = "BadKeyHandle"),
              (t[(t.InvalidP1P2 = 27392)] = "InvalidP1P2"),
              (t[(t.InstructionNotSupported = 27904)] =
                "InstructionNotSupported"),
              (t[(t.AppDoesNotSeemToBeOpen = 28161)] =
                "AppDoesNotSeemToBeOpen"),
              (t[(t.UnknownError = 28416)] = "UnknownError"),
              (t[(t.SignVerifyError = 28417)] = "SignVerifyError");
          })((n = e.LedgerError || (e.LedgerError = {}))),
          (e.ERROR_DESCRIPTION =
            (((r = {})[n.U2FUnknown] = "U2F: Unknown"),
            (r[n.U2FBadRequest] = "U2F: Bad request"),
            (r[n.U2FConfigurationUnsupported] =
              "U2F: Configuration unsupported"),
            (r[n.U2FDeviceIneligible] = "U2F: Device Ineligible"),
            (r[n.U2FTimeout] = "U2F: Timeout"),
            (r[n.Timeout] = "Timeout"),
            (r[n.NoErrors] = "No errors"),
            (r[n.DeviceIsBusy] = "Device is busy"),
            (r[n.ErrorDerivingKeys] = "Error deriving keys"),
            (r[n.ExecutionError] = "Execution Error"),
            (r[n.WrongLength] = "Wrong Length"),
            (r[n.EmptyBuffer] = "Empty Buffer"),
            (r[n.OutputBufferTooSmall] = "Output buffer too small"),
            (r[n.DataIsInvalid] = "Data is invalid"),
            (r[n.ConditionsNotSatisfied] = "Conditions not satisfied"),
            (r[n.TransactionRejected] = "Transaction rejected"),
            (r[n.BadKeyHandle] = "Bad key handle"),
            (r[n.InvalidP1P2] = "Invalid P1/P2"),
            (r[n.InstructionNotSupported] = "Instruction not supported"),
            (r[n.AppDoesNotSeemToBeOpen] = "App does not seem to be open"),
            (r[n.UnknownError] = "Unknown error"),
            (r[n.SignVerifyError] = "Sign/verify error"),
            r)),
          (e.errorCodeToString = s),
          (e.processErrorResponse = a),
          (e.getVersion = function (t) {
            return i(this, void 0, void 0, function () {
              return o(this, function (r) {
                return [
                  2,
                  t.send(e.CLA, e.INS.GET_VERSION, 0, 0).then(function (t) {
                    var e = t.slice(-2),
                      r = 256 * e[0] + e[1],
                      n = 0;
                    return (
                      t.length >= 9 &&
                        (n =
                          (t[5] << 24) +
                          (t[6] << 16) +
                          (t[7] << 8) +
                          (t[8] | 0)),
                      {
                        returnCode: r,
                        errorMessage: s(r),
                        testMode: 0 !== t[0],
                        major: t[1],
                        minor: t[2],
                        patch: t[3],
                        deviceLocked: 1 === t[4],
                        targetId: n.toString(16),
                      }
                    );
                  }, a),
                ];
              });
            });
          });
      },
      12572: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        (e.__esModule = !0), (e.serializePath = void 0);
        var i = 2147483648;
        e.serializePath = function (t) {
          if (!t.startsWith("m"))
            throw new Error(
              'Path should start with "m" (e.g "m/44\'/5757\'/5\'/0/3")',
            );
          var e = t.split("/"),
            r = 0;
          if (6 !== e.length && 4 !== e.length)
            throw new Error(
              "Invalid path. (e.g \"m/44'/5757'/5'/0/3\" or \"m/888'/0'/<account>\")",
            );
          r = 4 * (e.length - 1);
          for (var o = n.alloc(r), s = 1; s < e.length; s += 1) {
            var a = 0,
              u = e[s];
            u.endsWith("'") && ((a += i), (u = u.slice(0, -1)));
            var c = Number(u);
            if (Number.isNaN(c))
              throw new Error(
                "Invalid path : ".concat(
                  u,
                  " is not a number. (e.g \"m/44'/461'/5'/0/3\")",
                ),
              );
            if (c >= i)
              throw new Error(
                "Incorrect child value (bigger or equal to 0x80000000)",
              );
            (a += c), o.writeUInt32LE(a, 4 * (s - 1));
          }
          return o;
        };
      },
      18322: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          o =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  i(e, t, r);
            },
          s =
            (this && this.__awaiter) ||
            function (t, e, r, n) {
              return new (r || (r = Promise))(function (i, o) {
                function s(t) {
                  try {
                    u(n.next(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function a(t) {
                  try {
                    u(n.throw(t));
                  } catch (t) {
                    o(t);
                  }
                }
                function u(t) {
                  var e;
                  t.done
                    ? i(t.value)
                    : ((e = t.value),
                      e instanceof r
                        ? e
                        : new r(function (t) {
                            t(e);
                          })).then(s, a);
                }
                u((n = n.apply(t, e || [])).next());
              });
            },
          a =
            (this && this.__generator) ||
            function (t, e) {
              var r,
                n,
                i,
                o,
                s = {
                  label: 0,
                  sent: function () {
                    if (1 & i[0]) throw i[1];
                    return i[1];
                  },
                  trys: [],
                  ops: [],
                };
              return (
                (o = { next: a(0), throw: a(1), return: a(2) }),
                "function" == typeof Symbol &&
                  (o[Symbol.iterator] = function () {
                    return this;
                  }),
                o
              );
              function a(a) {
                return function (u) {
                  return (function (a) {
                    if (r)
                      throw new TypeError("Generator is already executing.");
                    for (; o && ((o = 0), a[0] && (s = 0)), s; )
                      try {
                        if (
                          ((r = 1),
                          n &&
                            (i =
                              2 & a[0]
                                ? n.return
                                : a[0]
                                  ? n.throw || ((i = n.return) && i.call(n), 0)
                                  : n.next) &&
                            !(i = i.call(n, a[1])).done)
                        )
                          return i;
                        switch (
                          ((n = 0), i && (a = [2 & a[0], i.value]), a[0])
                        ) {
                          case 0:
                          case 1:
                            i = a;
                            break;
                          case 4:
                            return s.label++, { value: a[1], done: !1 };
                          case 5:
                            s.label++, (n = a[1]), (a = [0]);
                            continue;
                          case 7:
                            (a = s.ops.pop()), s.trys.pop();
                            continue;
                          default:
                            if (
                              !((i = s.trys),
                              (i = i.length > 0 && i[i.length - 1]) ||
                                (6 !== a[0] && 2 !== a[0]))
                            ) {
                              s = 0;
                              continue;
                            }
                            if (
                              3 === a[0] &&
                              (!i || (a[1] > i[0] && a[1] < i[3]))
                            ) {
                              s.label = a[1];
                              break;
                            }
                            if (6 === a[0] && s.label < i[1]) {
                              (s.label = i[1]), (i = a);
                              break;
                            }
                            if (i && s.label < i[2]) {
                              (s.label = i[2]), s.ops.push(a);
                              break;
                            }
                            i[2] && s.ops.pop(), s.trys.pop();
                            continue;
                        }
                        a = e.call(t, s);
                      } catch (t) {
                        (a = [6, t]), (n = 0);
                      } finally {
                        r = i = 0;
                      }
                    if (5 & a[0]) throw a[1];
                    return { value: a[0] ? a[1] : void 0, done: !0 };
                  })([a, u]);
                };
              }
            };
        (e.__esModule = !0), (e.LedgerError = void 0);
        var u = r(12572),
          c = r(44541);
        e.LedgerError = c.LedgerError;
        var f = r(68469);
        function h(t) {
          var e = t,
            r = e.slice(-2),
            i = 256 * r[0] + r[1],
            o = n.from(e.slice(0, c.PKLEN));
          return (
            (e = e.slice(c.PKLEN)),
            {
              publicKey: o,
              address: n.from(e.slice(0, -2)).toString(),
              returnCode: i,
              errorMessage: (0, c.errorCodeToString)(i),
            }
          );
        }
        o(r(98447), e);
        var l = (function () {
          function t(t) {
            if (((this.transport = t), !t))
              throw new Error("Transport has not been defined");
          }
          return (
            (t.prepareChunks = function (t, e) {
              var r = [];
              r.push(t);
              for (
                var i = n.from(e), o = n.concat([i]), s = 0;
                s < o.length;
                s += c.CHUNK_SIZE
              ) {
                var a = s + c.CHUNK_SIZE;
                s > o.length && (a = o.length), r.push(o.slice(s, a));
              }
              return r;
            }),
            (t.prototype.signGetChunks = function (e, r) {
              return s(this, void 0, void 0, function () {
                return a(this, function (n) {
                  return [2, t.prepareChunks((0, u.serializePath)(e), r)];
                });
              });
            }),
            (t.prototype.getVersion = function () {
              return s(this, void 0, void 0, function () {
                return a(this, function (t) {
                  return [
                    2,
                    (0, c.getVersion)(this.transport).catch(function (t) {
                      return (0, c.processErrorResponse)(t);
                    }),
                  ];
                });
              });
            }),
            (t.prototype.getAppInfo = function () {
              return s(this, void 0, void 0, function () {
                return a(this, function (t) {
                  return [
                    2,
                    this.transport.send(176, 1, 0, 0).then(function (t) {
                      var e = t.slice(-2),
                        r = 256 * e[0] + e[1],
                        n = {},
                        i = "err",
                        o = "err",
                        s = 0,
                        a = 0;
                      if (1 !== t[0])
                        (n.errorMessage = "response format ID not recognized"),
                          (n.returnCode = c.LedgerError.DeviceIsBusy);
                      else {
                        var u = t[1];
                        i = t.slice(2, 2 + u).toString("ascii");
                        var f = 2 + u,
                          h = t[f];
                        (f += 1),
                          (o = t.slice(f, f + h).toString("ascii")),
                          (s = t[(f += h)]),
                          (a = t[(f += 1)]);
                      }
                      return {
                        returnCode: r,
                        errorMessage: (0, c.errorCodeToString)(r),
                        appName: i,
                        appVersion: o,
                        flagLen: s,
                        flagsValue: a,
                        flagRecovery: !!(1 & a),
                        flagSignedMcuCode: !!(2 & a),
                        flagOnboarded: !!(4 & a),
                        flagPINValidated: !!(128 & a),
                      };
                    }, c.processErrorResponse),
                  ];
                });
              });
            }),
            (t.prototype.getAddressAndPubKey = function (t, e) {
              return s(this, void 0, void 0, function () {
                var r;
                return a(this, function (n) {
                  return (
                    (r = (0, u.serializePath)(t)),
                    [
                      2,
                      this.transport
                        .send(
                          c.CLA,
                          c.INS.GET_ADDR_SECP256K1,
                          c.P1_VALUES.ONLY_RETRIEVE,
                          e,
                          r,
                          [36864],
                        )
                        .then(h, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.getIdentityPubKey = function (t) {
              return s(this, void 0, void 0, function () {
                var e;
                return a(this, function (r) {
                  return (
                    (e = (0, u.serializePath)(t)),
                    [
                      2,
                      this.transport
                        .send(
                          c.CLA,
                          c.INS.GET_AUTH_PUBKEY,
                          c.P1_VALUES.ONLY_RETRIEVE,
                          0,
                          e,
                          [36864],
                        )
                        .then(h, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.showAddressAndPubKey = function (t, e) {
              return s(this, void 0, void 0, function () {
                var r;
                return a(this, function (n) {
                  return (
                    (r = (0, u.serializePath)(t)),
                    [
                      2,
                      this.transport
                        .send(
                          c.CLA,
                          c.INS.GET_ADDR_SECP256K1,
                          c.P1_VALUES.SHOW_ADDRESS_IN_DEVICE,
                          e,
                          r,
                          [c.LedgerError.NoErrors],
                        )
                        .then(h, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.signSendChunk = function (t, e, r, i) {
              return s(this, void 0, void 0, function () {
                var o;
                return a(this, function (s) {
                  return (
                    (o = c.PAYLOAD_TYPE.ADD),
                    1 === t && (o = c.PAYLOAD_TYPE.INIT),
                    t === e && (o = c.PAYLOAD_TYPE.LAST),
                    [
                      2,
                      this.transport
                        .send(c.CLA, i, o, 0, r, [
                          c.LedgerError.NoErrors,
                          c.LedgerError.DataIsInvalid,
                          c.LedgerError.BadKeyHandle,
                          c.LedgerError.SignVerifyError,
                        ])
                        .then(function (t) {
                          var e = t.slice(-2),
                            r = 256 * e[0] + e[1],
                            i = (0, c.errorCodeToString)(r),
                            o = n.alloc(0),
                            s = n.alloc(0),
                            a = n.alloc(0);
                          n.alloc(0);
                          return (
                            (r !== c.LedgerError.BadKeyHandle &&
                              r !== c.LedgerError.DataIsInvalid &&
                              r !== c.LedgerError.SignVerifyError) ||
                              (i = ""
                                .concat(i, " : ")
                                .concat(
                                  t.slice(0, t.length - 2).toString("ascii"),
                                )),
                            r === c.LedgerError.NoErrors && t.length > 2
                              ? ((o = t.slice(0, 32)),
                                (s = t.slice(32, 97)),
                                ((a = n.alloc(65))[0] = s[s.length - 1]),
                                n.from(s).copy(a, 1, 0, 64),
                                {
                                  postSignHash: o,
                                  signatureCompact: s,
                                  signatureVRS: a,
                                  signatureDER: t.slice(97, t.length - 2),
                                  returnCode: r,
                                  errorMessage: i,
                                })
                              : { returnCode: r, errorMessage: i }
                          );
                        }, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.sign = function (t, e) {
              return s(this, void 0, void 0, function () {
                var r = this;
                return a(this, function (n) {
                  return [
                    2,
                    this.signGetChunks(t, e).then(function (t) {
                      return r
                        .signSendChunk(1, t.length, t[0], c.INS.SIGN_SECP256K1)
                        .then(function (e) {
                          return s(r, void 0, void 0, function () {
                            var r, n;
                            return a(this, function (i) {
                              switch (i.label) {
                                case 0:
                                  (r = {
                                    returnCode: e.returnCode,
                                    errorMessage: e.errorMessage,
                                    postSignHash: null,
                                    signatureCompact: null,
                                    signatureDER: null,
                                  }),
                                    (n = 1),
                                    (i.label = 1);
                                case 1:
                                  return n < t.length
                                    ? [
                                        4,
                                        this.signSendChunk(
                                          1 + n,
                                          t.length,
                                          t[n],
                                          c.INS.SIGN_SECP256K1,
                                        ),
                                      ]
                                    : [3, 4];
                                case 2:
                                  if (
                                    (r = i.sent()).returnCode !==
                                    c.LedgerError.NoErrors
                                  )
                                    return [3, 4];
                                  i.label = 3;
                                case 3:
                                  return (n += 1), [3, 1];
                                case 4:
                                  return [2, r];
                              }
                            });
                          });
                        }, c.processErrorResponse);
                    }, c.processErrorResponse),
                  ];
                });
              });
            }),
            (t.prototype.sign_msg = function (t, e) {
              return s(this, void 0, void 0, function () {
                var r,
                  i,
                  o,
                  u = this;
                return a(this, function (h) {
                  return (
                    (r = (0, f.encode)(e.length)),
                    (i = n.concat([
                      n.from("Stacks Signed Message:\n"),
                      r,
                      n.from(e),
                    ])),
                    (o = c.INS.SIGN_SECP256K1),
                    [
                      2,
                      this.signGetChunks(t, i).then(function (t) {
                        return u
                          .signSendChunk(1, t.length, t[0], o)
                          .then(function (e) {
                            return s(u, void 0, void 0, function () {
                              var r, n;
                              return a(this, function (i) {
                                switch (i.label) {
                                  case 0:
                                    (r = {
                                      returnCode: e.returnCode,
                                      errorMessage: e.errorMessage,
                                      postSignHash: null,
                                      signatureCompact: null,
                                      signatureDER: null,
                                    }),
                                      (n = 1),
                                      (i.label = 1);
                                  case 1:
                                    return n < t.length
                                      ? [
                                          4,
                                          this.signSendChunk(
                                            1 + n,
                                            t.length,
                                            t[n],
                                            o,
                                          ),
                                        ]
                                      : [3, 4];
                                  case 2:
                                    if (
                                      (r = i.sent()).returnCode !==
                                      c.LedgerError.NoErrors
                                    )
                                      return [3, 4];
                                    i.label = 3;
                                  case 3:
                                    return (n += 1), [3, 1];
                                  case 4:
                                    return [2, r];
                                }
                              });
                            });
                          }, c.processErrorResponse);
                      }, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.sign_jwt = function (t, e) {
              return s(this, void 0, void 0, function () {
                var r,
                  i,
                  o = this;
                return a(this, function (u) {
                  return (
                    e.length,
                    (r = n.from(e)),
                    (i = c.INS.SIGN_JWT_SECP256K1),
                    [
                      2,
                      this.signGetChunks(t, r).then(function (t) {
                        return o
                          .signSendChunk(1, t.length, t[0], i)
                          .then(function (e) {
                            return s(o, void 0, void 0, function () {
                              var r, n;
                              return a(this, function (o) {
                                switch (o.label) {
                                  case 0:
                                    (r = {
                                      returnCode: e.returnCode,
                                      errorMessage: e.errorMessage,
                                      postSignHash: null,
                                      signatureCompact: null,
                                      signatureDER: null,
                                    }),
                                      (n = 1),
                                      (o.label = 1);
                                  case 1:
                                    return n < t.length
                                      ? [
                                          4,
                                          this.signSendChunk(
                                            1 + n,
                                            t.length,
                                            t[n],
                                            i,
                                          ),
                                        ]
                                      : [3, 4];
                                  case 2:
                                    if (
                                      (r = o.sent()).returnCode !==
                                      c.LedgerError.NoErrors
                                    )
                                      return [3, 4];
                                    o.label = 3;
                                  case 3:
                                    return (n += 1), [3, 1];
                                  case 4:
                                    return [2, r];
                                }
                              });
                            });
                          }, c.processErrorResponse);
                      }, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            (t.prototype.sign_structured_msg = function (t, e, r) {
              return s(this, void 0, void 0, function () {
                var i,
                  o,
                  u = this;
                return a(this, function (h) {
                  return (
                    (0, f.encode)(r.length),
                    (i = n.concat([
                      n.from("SIP018"),
                      n.from(e, "hex"),
                      n.from(r, "hex"),
                    ])),
                    (o = c.INS.SIGN_SECP256K1),
                    [
                      2,
                      this.signGetChunks(t, i).then(function (t) {
                        return u
                          .signSendChunk(1, t.length, t[0], o)
                          .then(function (e) {
                            return s(u, void 0, void 0, function () {
                              var r, n;
                              return a(this, function (i) {
                                switch (i.label) {
                                  case 0:
                                    (r = {
                                      returnCode: e.returnCode,
                                      errorMessage: e.errorMessage,
                                      postSignHash: null,
                                      signatureCompact: null,
                                      signatureDER: null,
                                    }),
                                      (n = 1),
                                      (i.label = 1);
                                  case 1:
                                    return n < t.length
                                      ? [
                                          4,
                                          this.signSendChunk(
                                            1 + n,
                                            t.length,
                                            t[n],
                                            o,
                                          ),
                                        ]
                                      : [3, 4];
                                  case 2:
                                    if (
                                      (r = i.sent()).returnCode !==
                                      c.LedgerError.NoErrors
                                    )
                                      return [3, 4];
                                    i.label = 3;
                                  case 3:
                                    return (n += 1), [3, 1];
                                  case 4:
                                    return [2, r];
                                }
                              });
                            });
                          }, c.processErrorResponse);
                      }, c.processErrorResponse),
                    ]
                  );
                });
              });
            }),
            t
          );
        })();
        e.default = l;
      },
      98447: (t, e) => {
        "use strict";
        e.__esModule = !0;
      },
      87568: (t, e, r) => {
        "use strict";
        const n = e;
        (n.bignum = r(72344)),
          (n.define = r(47363).define),
          (n.base = r(9673)),
          (n.constants = r(22153)),
          (n.decoders = r(22853)),
          (n.encoders = r(24669));
      },
      47363: (t, e, r) => {
        "use strict";
        const n = r(24669),
          i = r(22853),
          o = r(56698);
        function s(t, e) {
          (this.name = t),
            (this.body = e),
            (this.decoders = {}),
            (this.encoders = {});
        }
        (e.define = function (t, e) {
          return new s(t, e);
        }),
          (s.prototype._createNamed = function (t) {
            const e = this.name;
            function r(t) {
              this._initNamed(t, e);
            }
            return (
              o(r, t),
              (r.prototype._initNamed = function (e, r) {
                t.call(this, e, r);
              }),
              new r(this)
            );
          }),
          (s.prototype._getDecoder = function (t) {
            return (
              (t = t || "der"),
              this.decoders.hasOwnProperty(t) ||
                (this.decoders[t] = this._createNamed(i[t])),
              this.decoders[t]
            );
          }),
          (s.prototype.decode = function (t, e, r) {
            return this._getDecoder(e).decode(t, r);
          }),
          (s.prototype._getEncoder = function (t) {
            return (
              (t = t || "der"),
              this.encoders.hasOwnProperty(t) ||
                (this.encoders[t] = this._createNamed(n[t])),
              this.encoders[t]
            );
          }),
          (s.prototype.encode = function (t, e, r) {
            return this._getEncoder(e).encode(t, r);
          });
      },
      47227: (t, e, r) => {
        "use strict";
        const n = r(56698),
          i = r(89220).a,
          o = r(54774).Buffer;
        function s(t, e) {
          i.call(this, e),
            o.isBuffer(t)
              ? ((this.base = t), (this.offset = 0), (this.length = t.length))
              : this.error("Input not Buffer");
        }
        function a(t, e) {
          if (Array.isArray(t))
            (this.length = 0),
              (this.value = t.map(function (t) {
                return (
                  a.isEncoderBuffer(t) || (t = new a(t, e)),
                  (this.length += t.length),
                  t
                );
              }, this));
          else if ("number" == typeof t) {
            if (!(0 <= t && t <= 255))
              return e.error("non-byte EncoderBuffer value");
            (this.value = t), (this.length = 1);
          } else if ("string" == typeof t)
            (this.value = t), (this.length = o.byteLength(t));
          else {
            if (!o.isBuffer(t)) return e.error("Unsupported type: " + typeof t);
            (this.value = t), (this.length = t.length);
          }
        }
        n(s, i),
          (e.t = s),
          (s.isDecoderBuffer = function (t) {
            if (t instanceof s) return !0;
            return (
              "object" == typeof t &&
              o.isBuffer(t.base) &&
              "DecoderBuffer" === t.constructor.name &&
              "number" == typeof t.offset &&
              "number" == typeof t.length &&
              "function" == typeof t.save &&
              "function" == typeof t.restore &&
              "function" == typeof t.isEmpty &&
              "function" == typeof t.readUInt8 &&
              "function" == typeof t.skip &&
              "function" == typeof t.raw
            );
          }),
          (s.prototype.save = function () {
            return {
              offset: this.offset,
              reporter: i.prototype.save.call(this),
            };
          }),
          (s.prototype.restore = function (t) {
            const e = new s(this.base);
            return (
              (e.offset = t.offset),
              (e.length = this.offset),
              (this.offset = t.offset),
              i.prototype.restore.call(this, t.reporter),
              e
            );
          }),
          (s.prototype.isEmpty = function () {
            return this.offset === this.length;
          }),
          (s.prototype.readUInt8 = function (t) {
            return this.offset + 1 <= this.length
              ? this.base.readUInt8(this.offset++, !0)
              : this.error(t || "DecoderBuffer overrun");
          }),
          (s.prototype.skip = function (t, e) {
            if (!(this.offset + t <= this.length))
              return this.error(e || "DecoderBuffer overrun");
            const r = new s(this.base);
            return (
              (r._reporterState = this._reporterState),
              (r.offset = this.offset),
              (r.length = this.offset + t),
              (this.offset += t),
              r
            );
          }),
          (s.prototype.raw = function (t) {
            return this.base.slice(t ? t.offset : this.offset, this.length);
          }),
          (e.d = a),
          (a.isEncoderBuffer = function (t) {
            if (t instanceof a) return !0;
            return (
              "object" == typeof t &&
              "EncoderBuffer" === t.constructor.name &&
              "number" == typeof t.length &&
              "function" == typeof t.join
            );
          }),
          (a.prototype.join = function (t, e) {
            return (
              t || (t = o.alloc(this.length)),
              e || (e = 0),
              0 === this.length ||
                (Array.isArray(this.value)
                  ? this.value.forEach(function (r) {
                      r.join(t, e), (e += r.length);
                    })
                  : ("number" == typeof this.value
                      ? (t[e] = this.value)
                      : "string" == typeof this.value
                        ? t.write(this.value, e)
                        : o.isBuffer(this.value) && this.value.copy(t, e),
                    (e += this.length))),
              t
            );
          });
      },
      9673: (t, e, r) => {
        "use strict";
        const n = e;
        (n.Reporter = r(89220).a),
          (n.DecoderBuffer = r(47227).t),
          (n.EncoderBuffer = r(47227).d),
          (n.Node = r(90993));
      },
      90993: (t, e, r) => {
        "use strict";
        const n = r(89220).a,
          i = r(47227).d,
          o = r(47227).t,
          s = r(43349),
          a = [
            "seq",
            "seqof",
            "set",
            "setof",
            "objid",
            "bool",
            "gentime",
            "utctime",
            "null_",
            "enum",
            "int",
            "objDesc",
            "bitstr",
            "bmpstr",
            "charstr",
            "genstr",
            "graphstr",
            "ia5str",
            "iso646str",
            "numstr",
            "octstr",
            "printstr",
            "t61str",
            "unistr",
            "utf8str",
            "videostr",
          ],
          u = [
            "key",
            "obj",
            "use",
            "optional",
            "explicit",
            "implicit",
            "def",
            "choice",
            "any",
            "contains",
          ].concat(a);
        function c(t, e, r) {
          const n = {};
          (this._baseState = n),
            (n.name = r),
            (n.enc = t),
            (n.parent = e || null),
            (n.children = null),
            (n.tag = null),
            (n.args = null),
            (n.reverseArgs = null),
            (n.choice = null),
            (n.optional = !1),
            (n.any = !1),
            (n.obj = !1),
            (n.use = null),
            (n.useDecoder = null),
            (n.key = null),
            (n.default = null),
            (n.explicit = null),
            (n.implicit = null),
            (n.contains = null),
            n.parent || ((n.children = []), this._wrap());
        }
        t.exports = c;
        const f = [
          "enc",
          "parent",
          "children",
          "tag",
          "args",
          "reverseArgs",
          "choice",
          "optional",
          "any",
          "obj",
          "use",
          "alteredUse",
          "key",
          "default",
          "explicit",
          "implicit",
          "contains",
        ];
        (c.prototype.clone = function () {
          const t = this._baseState,
            e = {};
          f.forEach(function (r) {
            e[r] = t[r];
          });
          const r = new this.constructor(e.parent);
          return (r._baseState = e), r;
        }),
          (c.prototype._wrap = function () {
            const t = this._baseState;
            u.forEach(function (e) {
              this[e] = function () {
                const r = new this.constructor(this);
                return t.children.push(r), r[e].apply(r, arguments);
              };
            }, this);
          }),
          (c.prototype._init = function (t) {
            const e = this._baseState;
            s(null === e.parent),
              t.call(this),
              (e.children = e.children.filter(function (t) {
                return t._baseState.parent === this;
              }, this)),
              s.equal(
                e.children.length,
                1,
                "Root node can have only one child",
              );
          }),
          (c.prototype._useArgs = function (t) {
            const e = this._baseState,
              r = t.filter(function (t) {
                return t instanceof this.constructor;
              }, this);
            (t = t.filter(function (t) {
              return !(t instanceof this.constructor);
            }, this)),
              0 !== r.length &&
                (s(null === e.children),
                (e.children = r),
                r.forEach(function (t) {
                  t._baseState.parent = this;
                }, this)),
              0 !== t.length &&
                (s(null === e.args),
                (e.args = t),
                (e.reverseArgs = t.map(function (t) {
                  if ("object" != typeof t || t.constructor !== Object)
                    return t;
                  const e = {};
                  return (
                    Object.keys(t).forEach(function (r) {
                      r == (0 | r) && (r |= 0);
                      const n = t[r];
                      e[n] = r;
                    }),
                    e
                  );
                })));
          }),
          [
            "_peekTag",
            "_decodeTag",
            "_use",
            "_decodeStr",
            "_decodeObjid",
            "_decodeTime",
            "_decodeNull",
            "_decodeInt",
            "_decodeBool",
            "_decodeList",
            "_encodeComposite",
            "_encodeStr",
            "_encodeObjid",
            "_encodeTime",
            "_encodeNull",
            "_encodeInt",
            "_encodeBool",
          ].forEach(function (t) {
            c.prototype[t] = function () {
              const e = this._baseState;
              throw new Error(t + " not implemented for encoding: " + e.enc);
            };
          }),
          a.forEach(function (t) {
            c.prototype[t] = function () {
              const e = this._baseState,
                r = Array.prototype.slice.call(arguments);
              return s(null === e.tag), (e.tag = t), this._useArgs(r), this;
            };
          }),
          (c.prototype.use = function (t) {
            s(t);
            const e = this._baseState;
            return s(null === e.use), (e.use = t), this;
          }),
          (c.prototype.optional = function () {
            return (this._baseState.optional = !0), this;
          }),
          (c.prototype.def = function (t) {
            const e = this._baseState;
            return (
              s(null === e.default), (e.default = t), (e.optional = !0), this
            );
          }),
          (c.prototype.explicit = function (t) {
            const e = this._baseState;
            return (
              s(null === e.explicit && null === e.implicit),
              (e.explicit = t),
              this
            );
          }),
          (c.prototype.implicit = function (t) {
            const e = this._baseState;
            return (
              s(null === e.explicit && null === e.implicit),
              (e.implicit = t),
              this
            );
          }),
          (c.prototype.obj = function () {
            const t = this._baseState,
              e = Array.prototype.slice.call(arguments);
            return (t.obj = !0), 0 !== e.length && this._useArgs(e), this;
          }),
          (c.prototype.key = function (t) {
            const e = this._baseState;
            return s(null === e.key), (e.key = t), this;
          }),
          (c.prototype.any = function () {
            return (this._baseState.any = !0), this;
          }),
          (c.prototype.choice = function (t) {
            const e = this._baseState;
            return (
              s(null === e.choice),
              (e.choice = t),
              this._useArgs(
                Object.keys(t).map(function (e) {
                  return t[e];
                }),
              ),
              this
            );
          }),
          (c.prototype.contains = function (t) {
            const e = this._baseState;
            return s(null === e.use), (e.contains = t), this;
          }),
          (c.prototype._decode = function (t, e) {
            const r = this._baseState;
            if (null === r.parent)
              return t.wrapResult(r.children[0]._decode(t, e));
            let n,
              i = r.default,
              s = !0,
              a = null;
            if ((null !== r.key && (a = t.enterKey(r.key)), r.optional)) {
              let n = null;
              if (
                (null !== r.explicit
                  ? (n = r.explicit)
                  : null !== r.implicit
                    ? (n = r.implicit)
                    : null !== r.tag && (n = r.tag),
                null !== n || r.any)
              ) {
                if (((s = this._peekTag(t, n, r.any)), t.isError(s))) return s;
              } else {
                const n = t.save();
                try {
                  null === r.choice
                    ? this._decodeGeneric(r.tag, t, e)
                    : this._decodeChoice(t, e),
                    (s = !0);
                } catch (t) {
                  s = !1;
                }
                t.restore(n);
              }
            }
            if ((r.obj && s && (n = t.enterObject()), s)) {
              if (null !== r.explicit) {
                const e = this._decodeTag(t, r.explicit);
                if (t.isError(e)) return e;
                t = e;
              }
              const n = t.offset;
              if (null === r.use && null === r.choice) {
                let e;
                r.any && (e = t.save());
                const n = this._decodeTag(
                  t,
                  null !== r.implicit ? r.implicit : r.tag,
                  r.any,
                );
                if (t.isError(n)) return n;
                r.any ? (i = t.raw(e)) : (t = n);
              }
              if (
                (e &&
                  e.track &&
                  null !== r.tag &&
                  e.track(t.path(), n, t.length, "tagged"),
                e &&
                  e.track &&
                  null !== r.tag &&
                  e.track(t.path(), t.offset, t.length, "content"),
                r.any ||
                  (i =
                    null === r.choice
                      ? this._decodeGeneric(r.tag, t, e)
                      : this._decodeChoice(t, e)),
                t.isError(i))
              )
                return i;
              if (
                (r.any ||
                  null !== r.choice ||
                  null === r.children ||
                  r.children.forEach(function (r) {
                    r._decode(t, e);
                  }),
                r.contains && ("octstr" === r.tag || "bitstr" === r.tag))
              ) {
                const n = new o(i);
                i = this._getUse(r.contains, t._reporterState.obj)._decode(
                  n,
                  e,
                );
              }
            }
            return (
              r.obj && s && (i = t.leaveObject(n)),
              null === r.key || (null === i && !0 !== s)
                ? null !== a && t.exitKey(a)
                : t.leaveKey(a, r.key, i),
              i
            );
          }),
          (c.prototype._decodeGeneric = function (t, e, r) {
            const n = this._baseState;
            return "seq" === t || "set" === t
              ? null
              : "seqof" === t || "setof" === t
                ? this._decodeList(e, t, n.args[0], r)
                : /str$/.test(t)
                  ? this._decodeStr(e, t, r)
                  : "objid" === t && n.args
                    ? this._decodeObjid(e, n.args[0], n.args[1], r)
                    : "objid" === t
                      ? this._decodeObjid(e, null, null, r)
                      : "gentime" === t || "utctime" === t
                        ? this._decodeTime(e, t, r)
                        : "null_" === t
                          ? this._decodeNull(e, r)
                          : "bool" === t
                            ? this._decodeBool(e, r)
                            : "objDesc" === t
                              ? this._decodeStr(e, t, r)
                              : "int" === t || "enum" === t
                                ? this._decodeInt(e, n.args && n.args[0], r)
                                : null !== n.use
                                  ? this._getUse(
                                      n.use,
                                      e._reporterState.obj,
                                    )._decode(e, r)
                                  : e.error("unknown tag: " + t);
          }),
          (c.prototype._getUse = function (t, e) {
            const r = this._baseState;
            return (
              (r.useDecoder = this._use(t, e)),
              s(null === r.useDecoder._baseState.parent),
              (r.useDecoder = r.useDecoder._baseState.children[0]),
              r.implicit !== r.useDecoder._baseState.implicit &&
                ((r.useDecoder = r.useDecoder.clone()),
                (r.useDecoder._baseState.implicit = r.implicit)),
              r.useDecoder
            );
          }),
          (c.prototype._decodeChoice = function (t, e) {
            const r = this._baseState;
            let n = null,
              i = !1;
            return (
              Object.keys(r.choice).some(function (o) {
                const s = t.save(),
                  a = r.choice[o];
                try {
                  const r = a._decode(t, e);
                  if (t.isError(r)) return !1;
                  (n = { type: o, value: r }), (i = !0);
                } catch (e) {
                  return t.restore(s), !1;
                }
                return !0;
              }, this),
              i ? n : t.error("Choice not matched")
            );
          }),
          (c.prototype._createEncoderBuffer = function (t) {
            return new i(t, this.reporter);
          }),
          (c.prototype._encode = function (t, e, r) {
            const n = this._baseState;
            if (null !== n.default && n.default === t) return;
            const i = this._encodeValue(t, e, r);
            return void 0 === i || this._skipDefault(i, e, r) ? void 0 : i;
          }),
          (c.prototype._encodeValue = function (t, e, r) {
            const i = this._baseState;
            if (null === i.parent)
              return i.children[0]._encode(t, e || new n());
            let o = null;
            if (((this.reporter = e), i.optional && void 0 === t)) {
              if (null === i.default) return;
              t = i.default;
            }
            let s = null,
              a = !1;
            if (i.any) o = this._createEncoderBuffer(t);
            else if (i.choice) o = this._encodeChoice(t, e);
            else if (i.contains)
              (s = this._getUse(i.contains, r)._encode(t, e)), (a = !0);
            else if (i.children)
              (s = i.children
                .map(function (r) {
                  if ("null_" === r._baseState.tag)
                    return r._encode(null, e, t);
                  if (null === r._baseState.key)
                    return e.error("Child should have a key");
                  const n = e.enterKey(r._baseState.key);
                  if ("object" != typeof t)
                    return e.error("Child expected, but input is not object");
                  const i = r._encode(t[r._baseState.key], e, t);
                  return e.leaveKey(n), i;
                }, this)
                .filter(function (t) {
                  return t;
                })),
                (s = this._createEncoderBuffer(s));
            else if ("seqof" === i.tag || "setof" === i.tag) {
              if (!i.args || 1 !== i.args.length)
                return e.error("Too many args for : " + i.tag);
              if (!Array.isArray(t))
                return e.error("seqof/setof, but data is not Array");
              const r = this.clone();
              (r._baseState.implicit = null),
                (s = this._createEncoderBuffer(
                  t.map(function (r) {
                    const n = this._baseState;
                    return this._getUse(n.args[0], t)._encode(r, e);
                  }, r),
                ));
            } else
              null !== i.use
                ? (o = this._getUse(i.use, r)._encode(t, e))
                : ((s = this._encodePrimitive(i.tag, t)), (a = !0));
            if (!i.any && null === i.choice) {
              const t = null !== i.implicit ? i.implicit : i.tag,
                r = null === i.implicit ? "universal" : "context";
              null === t
                ? null === i.use &&
                  e.error("Tag could be omitted only for .use()")
                : null === i.use && (o = this._encodeComposite(t, a, r, s));
            }
            return (
              null !== i.explicit &&
                (o = this._encodeComposite(i.explicit, !1, "context", o)),
              o
            );
          }),
          (c.prototype._encodeChoice = function (t, e) {
            const r = this._baseState,
              n = r.choice[t.type];
            return (
              n ||
                s(
                  !1,
                  t.type +
                    " not found in " +
                    JSON.stringify(Object.keys(r.choice)),
                ),
              n._encode(t.value, e)
            );
          }),
          (c.prototype._encodePrimitive = function (t, e) {
            const r = this._baseState;
            if (/str$/.test(t)) return this._encodeStr(e, t);
            if ("objid" === t && r.args)
              return this._encodeObjid(e, r.reverseArgs[0], r.args[1]);
            if ("objid" === t) return this._encodeObjid(e, null, null);
            if ("gentime" === t || "utctime" === t)
              return this._encodeTime(e, t);
            if ("null_" === t) return this._encodeNull();
            if ("int" === t || "enum" === t)
              return this._encodeInt(e, r.args && r.reverseArgs[0]);
            if ("bool" === t) return this._encodeBool(e);
            if ("objDesc" === t) return this._encodeStr(e, t);
            throw new Error("Unsupported tag: " + t);
          }),
          (c.prototype._isNumstr = function (t) {
            return /^[0-9 ]*$/.test(t);
          }),
          (c.prototype._isPrintstr = function (t) {
            return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(t);
          });
      },
      89220: (t, e, r) => {
        "use strict";
        const n = r(56698);
        function i(t) {
          this._reporterState = {
            obj: null,
            path: [],
            options: t || {},
            errors: [],
          };
        }
        function o(t, e) {
          (this.path = t), this.rethrow(e);
        }
        (e.a = i),
          (i.prototype.isError = function (t) {
            return t instanceof o;
          }),
          (i.prototype.save = function () {
            const t = this._reporterState;
            return { obj: t.obj, pathLen: t.path.length };
          }),
          (i.prototype.restore = function (t) {
            const e = this._reporterState;
            (e.obj = t.obj), (e.path = e.path.slice(0, t.pathLen));
          }),
          (i.prototype.enterKey = function (t) {
            return this._reporterState.path.push(t);
          }),
          (i.prototype.exitKey = function (t) {
            const e = this._reporterState;
            e.path = e.path.slice(0, t - 1);
          }),
          (i.prototype.leaveKey = function (t, e, r) {
            const n = this._reporterState;
            this.exitKey(t), null !== n.obj && (n.obj[e] = r);
          }),
          (i.prototype.path = function () {
            return this._reporterState.path.join("/");
          }),
          (i.prototype.enterObject = function () {
            const t = this._reporterState,
              e = t.obj;
            return (t.obj = {}), e;
          }),
          (i.prototype.leaveObject = function (t) {
            const e = this._reporterState,
              r = e.obj;
            return (e.obj = t), r;
          }),
          (i.prototype.error = function (t) {
            let e;
            const r = this._reporterState,
              n = t instanceof o;
            if (
              ((e = n
                ? t
                : new o(
                    r.path
                      .map(function (t) {
                        return "[" + JSON.stringify(t) + "]";
                      })
                      .join(""),
                    t.message || t,
                    t.stack,
                  )),
              !r.options.partial)
            )
              throw e;
            return n || r.errors.push(e), e;
          }),
          (i.prototype.wrapResult = function (t) {
            const e = this._reporterState;
            return e.options.partial
              ? { result: this.isError(t) ? null : t, errors: e.errors }
              : t;
          }),
          n(o, Error),
          (o.prototype.rethrow = function (t) {
            if (
              ((this.message = t + " at: " + (this.path || "(shallow)")),
              Error.captureStackTrace && Error.captureStackTrace(this, o),
              !this.stack)
            )
              try {
                throw new Error(this.message);
              } catch (t) {
                this.stack = t.stack;
              }
            return this;
          });
      },
      74598: (t, e) => {
        "use strict";
        function r(t) {
          const e = {};
          return (
            Object.keys(t).forEach(function (r) {
              (0 | r) == r && (r |= 0);
              const n = t[r];
              e[n] = r;
            }),
            e
          );
        }
        (e.tagClass = {
          0: "universal",
          1: "application",
          2: "context",
          3: "private",
        }),
          (e.tagClassByName = r(e.tagClass)),
          (e.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr",
          }),
          (e.tagByName = r(e.tag));
      },
      22153: (t, e, r) => {
        "use strict";
        const n = e;
        (n._reverse = function (t) {
          const e = {};
          return (
            Object.keys(t).forEach(function (r) {
              (0 | r) == r && (r |= 0);
              const n = t[r];
              e[n] = r;
            }),
            e
          );
        }),
          (n.der = r(74598));
      },
      62010: (t, e, r) => {
        "use strict";
        const n = r(56698),
          i = r(72344),
          o = r(47227).t,
          s = r(90993),
          a = r(74598);
        function u(t) {
          (this.enc = "der"),
            (this.name = t.name),
            (this.entity = t),
            (this.tree = new c()),
            this.tree._init(t.body);
        }
        function c(t) {
          s.call(this, "der", t);
        }
        function f(t, e) {
          let r = t.readUInt8(e);
          if (t.isError(r)) return r;
          const n = a.tagClass[r >> 6],
            i = !(32 & r);
          if (31 & ~r) r &= 31;
          else {
            let n = r;
            for (r = 0; !(128 & ~n); ) {
              if (((n = t.readUInt8(e)), t.isError(n))) return n;
              (r <<= 7), (r |= 127 & n);
            }
          }
          return { cls: n, primitive: i, tag: r, tagStr: a.tag[r] };
        }
        function h(t, e, r) {
          let n = t.readUInt8(r);
          if (t.isError(n)) return n;
          if (!e && 128 === n) return null;
          if (!(128 & n)) return n;
          const i = 127 & n;
          if (i > 4) return t.error("length octect is too long");
          n = 0;
          for (let e = 0; e < i; e++) {
            n <<= 8;
            const e = t.readUInt8(r);
            if (t.isError(e)) return e;
            n |= e;
          }
          return n;
        }
        (t.exports = u),
          (u.prototype.decode = function (t, e) {
            return (
              o.isDecoderBuffer(t) || (t = new o(t, e)), this.tree._decode(t, e)
            );
          }),
          n(c, s),
          (c.prototype._peekTag = function (t, e, r) {
            if (t.isEmpty()) return !1;
            const n = t.save(),
              i = f(t, 'Failed to peek tag: "' + e + '"');
            return t.isError(i)
              ? i
              : (t.restore(n),
                i.tag === e || i.tagStr === e || i.tagStr + "of" === e || r);
          }),
          (c.prototype._decodeTag = function (t, e, r) {
            const n = f(t, 'Failed to decode tag of "' + e + '"');
            if (t.isError(n)) return n;
            let i = h(t, n.primitive, 'Failed to get length of "' + e + '"');
            if (t.isError(i)) return i;
            if (!r && n.tag !== e && n.tagStr !== e && n.tagStr + "of" !== e)
              return t.error('Failed to match tag: "' + e + '"');
            if (n.primitive || null !== i)
              return t.skip(i, 'Failed to match body of: "' + e + '"');
            const o = t.save(),
              s = this._skipUntilEnd(
                t,
                'Failed to skip indefinite length body: "' + this.tag + '"',
              );
            return t.isError(s)
              ? s
              : ((i = t.offset - o.offset),
                t.restore(o),
                t.skip(i, 'Failed to match body of: "' + e + '"'));
          }),
          (c.prototype._skipUntilEnd = function (t, e) {
            for (;;) {
              const r = f(t, e);
              if (t.isError(r)) return r;
              const n = h(t, r.primitive, e);
              if (t.isError(n)) return n;
              let i;
              if (
                ((i =
                  r.primitive || null !== n
                    ? t.skip(n)
                    : this._skipUntilEnd(t, e)),
                t.isError(i))
              )
                return i;
              if ("end" === r.tagStr) break;
            }
          }),
          (c.prototype._decodeList = function (t, e, r, n) {
            const i = [];
            for (; !t.isEmpty(); ) {
              const e = this._peekTag(t, "end");
              if (t.isError(e)) return e;
              const o = r.decode(t, "der", n);
              if (t.isError(o) && e) break;
              i.push(o);
            }
            return i;
          }),
          (c.prototype._decodeStr = function (t, e) {
            if ("bitstr" === e) {
              const e = t.readUInt8();
              return t.isError(e) ? e : { unused: e, data: t.raw() };
            }
            if ("bmpstr" === e) {
              const e = t.raw();
              if (e.length % 2 == 1)
                return t.error(
                  "Decoding of string type: bmpstr length mismatch",
                );
              let r = "";
              for (let t = 0; t < e.length / 2; t++)
                r += String.fromCharCode(e.readUInt16BE(2 * t));
              return r;
            }
            if ("numstr" === e) {
              const e = t.raw().toString("ascii");
              return this._isNumstr(e)
                ? e
                : t.error(
                    "Decoding of string type: numstr unsupported characters",
                  );
            }
            if ("octstr" === e) return t.raw();
            if ("objDesc" === e) return t.raw();
            if ("printstr" === e) {
              const e = t.raw().toString("ascii");
              return this._isPrintstr(e)
                ? e
                : t.error(
                    "Decoding of string type: printstr unsupported characters",
                  );
            }
            return /str$/.test(e)
              ? t.raw().toString()
              : t.error("Decoding of string type: " + e + " unsupported");
          }),
          (c.prototype._decodeObjid = function (t, e, r) {
            let n;
            const i = [];
            let o = 0,
              s = 0;
            for (; !t.isEmpty(); )
              (s = t.readUInt8()),
                (o <<= 7),
                (o |= 127 & s),
                128 & s || (i.push(o), (o = 0));
            128 & s && i.push(o);
            const a = (i[0] / 40) | 0,
              u = i[0] % 40;
            if (((n = r ? i : [a, u].concat(i.slice(1))), e)) {
              let t = e[n.join(" ")];
              void 0 === t && (t = e[n.join(".")]), void 0 !== t && (n = t);
            }
            return n;
          }),
          (c.prototype._decodeTime = function (t, e) {
            const r = t.raw().toString();
            let n, i, o, s, a, u;
            if ("gentime" === e)
              (n = 0 | r.slice(0, 4)),
                (i = 0 | r.slice(4, 6)),
                (o = 0 | r.slice(6, 8)),
                (s = 0 | r.slice(8, 10)),
                (a = 0 | r.slice(10, 12)),
                (u = 0 | r.slice(12, 14));
            else {
              if ("utctime" !== e)
                return t.error("Decoding " + e + " time is not supported yet");
              (n = 0 | r.slice(0, 2)),
                (i = 0 | r.slice(2, 4)),
                (o = 0 | r.slice(4, 6)),
                (s = 0 | r.slice(6, 8)),
                (a = 0 | r.slice(8, 10)),
                (u = 0 | r.slice(10, 12)),
                (n = n < 70 ? 2e3 + n : 1900 + n);
            }
            return Date.UTC(n, i - 1, o, s, a, u, 0);
          }),
          (c.prototype._decodeNull = function () {
            return null;
          }),
          (c.prototype._decodeBool = function (t) {
            const e = t.readUInt8();
            return t.isError(e) ? e : 0 !== e;
          }),
          (c.prototype._decodeInt = function (t, e) {
            const r = t.raw();
            let n = new i(r);
            return e && (n = e[n.toString(10)] || n), n;
          }),
          (c.prototype._use = function (t, e) {
            return (
              "function" == typeof t && (t = t(e)), t._getDecoder("der").tree
            );
          });
      },
      22853: (t, e, r) => {
        "use strict";
        const n = e;
        (n.der = r(62010)), (n.pem = r(58903));
      },
      58903: (t, e, r) => {
        "use strict";
        const n = r(56698),
          i = r(54774).Buffer,
          o = r(62010);
        function s(t) {
          o.call(this, t), (this.enc = "pem");
        }
        n(s, o),
          (t.exports = s),
          (s.prototype.decode = function (t, e) {
            const r = t.toString().split(/[\r\n]+/g),
              n = e.label.toUpperCase(),
              s = /^-----(BEGIN|END) ([^-]+)-----$/;
            let a = -1,
              u = -1;
            for (let t = 0; t < r.length; t++) {
              const e = r[t].match(s);
              if (null !== e && e[2] === n) {
                if (-1 !== a) {
                  if ("END" !== e[1]) break;
                  u = t;
                  break;
                }
                if ("BEGIN" !== e[1]) break;
                a = t;
              }
            }
            if (-1 === a || -1 === u)
              throw new Error("PEM section not found for: " + n);
            const c = r.slice(a + 1, u).join("");
            c.replace(/[^a-z0-9+/=]+/gi, "");
            const f = i.from(c, "base64");
            return o.prototype.decode.call(this, f, e);
          });
      },
      70082: (t, e, r) => {
        "use strict";
        const n = r(56698),
          i = r(54774).Buffer,
          o = r(90993),
          s = r(74598);
        function a(t) {
          (this.enc = "der"),
            (this.name = t.name),
            (this.entity = t),
            (this.tree = new u()),
            this.tree._init(t.body);
        }
        function u(t) {
          o.call(this, "der", t);
        }
        function c(t) {
          return t < 10 ? "0" + t : t;
        }
        (t.exports = a),
          (a.prototype.encode = function (t, e) {
            return this.tree._encode(t, e).join();
          }),
          n(u, o),
          (u.prototype._encodeComposite = function (t, e, r, n) {
            const o = (function (t, e, r, n) {
              let i;
              "seqof" === t ? (t = "seq") : "setof" === t && (t = "set");
              if (s.tagByName.hasOwnProperty(t)) i = s.tagByName[t];
              else {
                if ("number" != typeof t || (0 | t) !== t)
                  return n.error("Unknown tag: " + t);
                i = t;
              }
              if (i >= 31)
                return n.error("Multi-octet tag encoding unsupported");
              e || (i |= 32);
              return (i |= s.tagClassByName[r || "universal"] << 6), i;
            })(t, e, r, this.reporter);
            if (n.length < 128) {
              const t = i.alloc(2);
              return (
                (t[0] = o), (t[1] = n.length), this._createEncoderBuffer([t, n])
              );
            }
            let a = 1;
            for (let t = n.length; t >= 256; t >>= 8) a++;
            const u = i.alloc(2 + a);
            (u[0] = o), (u[1] = 128 | a);
            for (let t = 1 + a, e = n.length; e > 0; t--, e >>= 8)
              u[t] = 255 & e;
            return this._createEncoderBuffer([u, n]);
          }),
          (u.prototype._encodeStr = function (t, e) {
            if ("bitstr" === e)
              return this._createEncoderBuffer([0 | t.unused, t.data]);
            if ("bmpstr" === e) {
              const e = i.alloc(2 * t.length);
              for (let r = 0; r < t.length; r++)
                e.writeUInt16BE(t.charCodeAt(r), 2 * r);
              return this._createEncoderBuffer(e);
            }
            return "numstr" === e
              ? this._isNumstr(t)
                ? this._createEncoderBuffer(t)
                : this.reporter.error(
                    "Encoding of string type: numstr supports only digits and space",
                  )
              : "printstr" === e
                ? this._isPrintstr(t)
                  ? this._createEncoderBuffer(t)
                  : this.reporter.error(
                      "Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark",
                    )
                : /str$/.test(e) || "objDesc" === e
                  ? this._createEncoderBuffer(t)
                  : this.reporter.error(
                      "Encoding of string type: " + e + " unsupported",
                    );
          }),
          (u.prototype._encodeObjid = function (t, e, r) {
            if ("string" == typeof t) {
              if (!e)
                return this.reporter.error(
                  "string objid given, but no values map found",
                );
              if (!e.hasOwnProperty(t))
                return this.reporter.error("objid not found in values map");
              t = e[t].split(/[\s.]+/g);
              for (let e = 0; e < t.length; e++) t[e] |= 0;
            } else if (Array.isArray(t)) {
              t = t.slice();
              for (let e = 0; e < t.length; e++) t[e] |= 0;
            }
            if (!Array.isArray(t))
              return this.reporter.error(
                "objid() should be either array or string, got: " +
                  JSON.stringify(t),
              );
            if (!r) {
              if (t[1] >= 40)
                return this.reporter.error("Second objid identifier OOB");
              t.splice(0, 2, 40 * t[0] + t[1]);
            }
            let n = 0;
            for (let e = 0; e < t.length; e++) {
              let r = t[e];
              for (n++; r >= 128; r >>= 7) n++;
            }
            const o = i.alloc(n);
            let s = o.length - 1;
            for (let e = t.length - 1; e >= 0; e--) {
              let r = t[e];
              for (o[s--] = 127 & r; (r >>= 7) > 0; ) o[s--] = 128 | (127 & r);
            }
            return this._createEncoderBuffer(o);
          }),
          (u.prototype._encodeTime = function (t, e) {
            let r;
            const n = new Date(t);
            return (
              "gentime" === e
                ? (r = [
                    c(n.getUTCFullYear()),
                    c(n.getUTCMonth() + 1),
                    c(n.getUTCDate()),
                    c(n.getUTCHours()),
                    c(n.getUTCMinutes()),
                    c(n.getUTCSeconds()),
                    "Z",
                  ].join(""))
                : "utctime" === e
                  ? (r = [
                      c(n.getUTCFullYear() % 100),
                      c(n.getUTCMonth() + 1),
                      c(n.getUTCDate()),
                      c(n.getUTCHours()),
                      c(n.getUTCMinutes()),
                      c(n.getUTCSeconds()),
                      "Z",
                    ].join(""))
                  : this.reporter.error(
                      "Encoding " + e + " time is not supported yet",
                    ),
              this._encodeStr(r, "octstr")
            );
          }),
          (u.prototype._encodeNull = function () {
            return this._createEncoderBuffer("");
          }),
          (u.prototype._encodeInt = function (t, e) {
            if ("string" == typeof t) {
              if (!e)
                return this.reporter.error(
                  "String int or enum given, but no values map",
                );
              if (!e.hasOwnProperty(t))
                return this.reporter.error(
                  "Values map doesn't contain: " + JSON.stringify(t),
                );
              t = e[t];
            }
            if ("number" != typeof t && !i.isBuffer(t)) {
              const e = t.toArray();
              !t.sign && 128 & e[0] && e.unshift(0), (t = i.from(e));
            }
            if (i.isBuffer(t)) {
              let e = t.length;
              0 === t.length && e++;
              const r = i.alloc(e);
              return (
                t.copy(r),
                0 === t.length && (r[0] = 0),
                this._createEncoderBuffer(r)
              );
            }
            if (t < 128) return this._createEncoderBuffer(t);
            if (t < 256) return this._createEncoderBuffer([0, t]);
            let r = 1;
            for (let e = t; e >= 256; e >>= 8) r++;
            const n = new Array(r);
            for (let e = n.length - 1; e >= 0; e--) (n[e] = 255 & t), (t >>= 8);
            return (
              128 & n[0] && n.unshift(0), this._createEncoderBuffer(i.from(n))
            );
          }),
          (u.prototype._encodeBool = function (t) {
            return this._createEncoderBuffer(t ? 255 : 0);
          }),
          (u.prototype._use = function (t, e) {
            return (
              "function" == typeof t && (t = t(e)), t._getEncoder("der").tree
            );
          }),
          (u.prototype._skipDefault = function (t, e, r) {
            const n = this._baseState;
            let i;
            if (null === n.default) return !1;
            const o = t.join();
            if (
              (void 0 === n.defaultBuffer &&
                (n.defaultBuffer = this._encodeValue(n.default, e, r).join()),
              o.length !== n.defaultBuffer.length)
            )
              return !1;
            for (i = 0; i < o.length; i++)
              if (o[i] !== n.defaultBuffer[i]) return !1;
            return !0;
          });
      },
      24669: (t, e, r) => {
        "use strict";
        const n = e;
        (n.der = r(70082)), (n.pem = r(90735));
      },
      90735: (t, e, r) => {
        "use strict";
        const n = r(56698),
          i = r(70082);
        function o(t) {
          i.call(this, t), (this.enc = "pem");
        }
        n(o, i),
          (t.exports = o),
          (o.prototype.encode = function (t, e) {
            const r = i.prototype.encode.call(this, t).toString("base64"),
              n = ["-----BEGIN " + e.label + "-----"];
            for (let t = 0; t < r.length; t += 64) n.push(r.slice(t, t + 64));
            return n.push("-----END " + e.label + "-----"), n.join("\n");
          });
      },
      72344: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(78982).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      94148: (t, e, r) => {
        "use strict";
        var n = r(65606);
        function i(t) {
          return (
            (i =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (t) {
                    return typeof t;
                  }
                : function (t) {
                    return t &&
                      "function" == typeof Symbol &&
                      t.constructor === Symbol &&
                      t !== Symbol.prototype
                      ? "symbol"
                      : typeof t;
                  }),
            i(t)
          );
        }
        function o(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(
                t,
                ((o = n.key),
                (s = void 0),
                (s = (function (t, e) {
                  if ("object" !== i(t) || null === t) return t;
                  var r = t[Symbol.toPrimitive];
                  if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" !== i(n)) return n;
                    throw new TypeError(
                      "@@toPrimitive must return a primitive value.",
                    );
                  }
                  return ("string" === e ? String : Number)(t);
                })(o, "string")),
                "symbol" === i(s) ? s : String(s)),
                n,
              );
          }
          var o, s;
        }
        function s(t, e, r) {
          return (
            e && o(t.prototype, e),
            r && o(t, r),
            Object.defineProperty(t, "prototype", { writable: !1 }),
            t
          );
        }
        var a,
          u,
          c = r(69597).codes,
          f = c.ERR_AMBIGUOUS_ARGUMENT,
          h = c.ERR_INVALID_ARG_TYPE,
          l = c.ERR_INVALID_ARG_VALUE,
          d = c.ERR_INVALID_RETURN_VALUE,
          p = c.ERR_MISSING_ARGS,
          y = r(3918),
          g = r(40537).inspect,
          m = r(40537).types,
          b = m.isPromise,
          w = m.isRegExp,
          v = r(11514)(),
          _ = r(9394)(),
          E = r(38075)("RegExp.prototype.test");
        new Map();
        function S() {
          var t = r(82299);
          (a = t.isDeepEqual), (u = t.isDeepStrictEqual);
        }
        var I = !1,
          M = (t.exports = O),
          A = {};
        function T(t) {
          if (t.message instanceof Error) throw t.message;
          throw new y(t);
        }
        function k(t, e, r, n) {
          if (!r) {
            var i = !1;
            if (0 === e)
              (i = !0), (n = "No value argument passed to `assert.ok()`");
            else if (n instanceof Error) throw n;
            var o = new y({
              actual: r,
              expected: !0,
              message: n,
              operator: "==",
              stackStartFn: t,
            });
            throw ((o.generatedMessage = i), o);
          }
        }
        function O() {
          for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
            e[r] = arguments[r];
          k.apply(void 0, [O, e.length].concat(e));
        }
        (M.fail = function t(e, r, i, o, s) {
          var a,
            u = arguments.length;
          if (0 === u) a = "Failed";
          else if (1 === u) (i = e), (e = void 0);
          else {
            if (!1 === I)
              (I = !0),
                (n.emitWarning ? n.emitWarning : console.warn.bind(console))(
                  "assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.",
                  "DeprecationWarning",
                  "DEP0094",
                );
            2 === u && (o = "!=");
          }
          if (i instanceof Error) throw i;
          var c = {
            actual: e,
            expected: r,
            operator: void 0 === o ? "fail" : o,
            stackStartFn: s || t,
          };
          void 0 !== i && (c.message = i);
          var f = new y(c);
          throw (a && ((f.message = a), (f.generatedMessage = !0)), f);
        }),
          (M.AssertionError = y),
          (M.ok = O),
          (M.equal = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            e != r &&
              T({
                actual: e,
                expected: r,
                message: n,
                operator: "==",
                stackStartFn: t,
              });
          }),
          (M.notEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            e == r &&
              T({
                actual: e,
                expected: r,
                message: n,
                operator: "!=",
                stackStartFn: t,
              });
          }),
          (M.deepEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            void 0 === a && S(),
              a(e, r) ||
                T({
                  actual: e,
                  expected: r,
                  message: n,
                  operator: "deepEqual",
                  stackStartFn: t,
                });
          }),
          (M.notDeepEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            void 0 === a && S(),
              a(e, r) &&
                T({
                  actual: e,
                  expected: r,
                  message: n,
                  operator: "notDeepEqual",
                  stackStartFn: t,
                });
          }),
          (M.deepStrictEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            void 0 === a && S(),
              u(e, r) ||
                T({
                  actual: e,
                  expected: r,
                  message: n,
                  operator: "deepStrictEqual",
                  stackStartFn: t,
                });
          }),
          (M.notDeepStrictEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            void 0 === a && S();
            u(e, r) &&
              T({
                actual: e,
                expected: r,
                message: n,
                operator: "notDeepStrictEqual",
                stackStartFn: t,
              });
          }),
          (M.strictEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            _(e, r) ||
              T({
                actual: e,
                expected: r,
                message: n,
                operator: "strictEqual",
                stackStartFn: t,
              });
          }),
          (M.notStrictEqual = function t(e, r, n) {
            if (arguments.length < 2) throw new p("actual", "expected");
            _(e, r) &&
              T({
                actual: e,
                expected: r,
                message: n,
                operator: "notStrictEqual",
                stackStartFn: t,
              });
          });
        var x = s(function t(e, r, n) {
          var i = this;
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            r.forEach(function (t) {
              t in e &&
                (void 0 !== n &&
                "string" == typeof n[t] &&
                w(e[t]) &&
                E(e[t], n[t])
                  ? (i[t] = n[t])
                  : (i[t] = e[t]));
            });
        });
        function P(t, e, r, n) {
          if ("function" != typeof e) {
            if (w(e)) return E(e, t);
            if (2 === arguments.length)
              throw new h("expected", ["Function", "RegExp"], e);
            if ("object" !== i(t) || null === t) {
              var o = new y({
                actual: t,
                expected: e,
                message: r,
                operator: "deepStrictEqual",
                stackStartFn: n,
              });
              throw ((o.operator = n.name), o);
            }
            var s = Object.keys(e);
            if (e instanceof Error) s.push("name", "message");
            else if (0 === s.length)
              throw new l("error", e, "may not be an empty object");
            return (
              void 0 === a && S(),
              s.forEach(function (i) {
                ("string" == typeof t[i] && w(e[i]) && E(e[i], t[i])) ||
                  (function (t, e, r, n, i, o) {
                    if (!(r in t) || !u(t[r], e[r])) {
                      if (!n) {
                        var s = new x(t, i),
                          a = new x(e, i, t),
                          c = new y({
                            actual: s,
                            expected: a,
                            operator: "deepStrictEqual",
                            stackStartFn: o,
                          });
                        throw (
                          ((c.actual = t),
                          (c.expected = e),
                          (c.operator = o.name),
                          c)
                        );
                      }
                      T({
                        actual: t,
                        expected: e,
                        message: n,
                        operator: o.name,
                        stackStartFn: o,
                      });
                    }
                  })(t, e, i, r, s, n);
              }),
              !0
            );
          }
          return (
            (void 0 !== e.prototype && t instanceof e) ||
            (!Error.isPrototypeOf(e) && !0 === e.call({}, t))
          );
        }
        function B(t) {
          if ("function" != typeof t) throw new h("fn", "Function", t);
          try {
            t();
          } catch (t) {
            return t;
          }
          return A;
        }
        function C(t) {
          return (
            b(t) ||
            (null !== t &&
              "object" === i(t) &&
              "function" == typeof t.then &&
              "function" == typeof t.catch)
          );
        }
        function R(t) {
          return Promise.resolve().then(function () {
            var e;
            if ("function" == typeof t) {
              if (!C((e = t())))
                throw new d("instance of Promise", "promiseFn", e);
            } else {
              if (!C(t)) throw new h("promiseFn", ["Function", "Promise"], t);
              e = t;
            }
            return Promise.resolve()
              .then(function () {
                return e;
              })
              .then(function () {
                return A;
              })
              .catch(function (t) {
                return t;
              });
          });
        }
        function N(t, e, r, n) {
          if ("string" == typeof r) {
            if (4 === arguments.length)
              throw new h(
                "error",
                ["Object", "Error", "Function", "RegExp"],
                r,
              );
            if ("object" === i(e) && null !== e) {
              if (e.message === r)
                throw new f(
                  "error/message",
                  'The error message "'.concat(
                    e.message,
                    '" is identical to the message.',
                  ),
                );
            } else if (e === r)
              throw new f(
                "error/message",
                'The error "'.concat(e, '" is identical to the message.'),
              );
            (n = r), (r = void 0);
          } else if (null != r && "object" !== i(r) && "function" != typeof r)
            throw new h("error", ["Object", "Error", "Function", "RegExp"], r);
          if (e === A) {
            var o = "";
            r && r.name && (o += " (".concat(r.name, ")")),
              (o += n ? ": ".concat(n) : ".");
            var s = "rejects" === t.name ? "rejection" : "exception";
            T({
              actual: void 0,
              expected: r,
              operator: t.name,
              message: "Missing expected ".concat(s).concat(o),
              stackStartFn: t,
            });
          }
          if (r && !P(e, r, n, t)) throw e;
        }
        function U(t, e, r, n) {
          if (e !== A) {
            if (
              ("string" == typeof r && ((n = r), (r = void 0)), !r || P(e, r))
            ) {
              var i = n ? ": ".concat(n) : ".",
                o = "doesNotReject" === t.name ? "rejection" : "exception";
              T({
                actual: e,
                expected: r,
                operator: t.name,
                message:
                  "Got unwanted ".concat(o).concat(i, "\n") +
                  'Actual message: "'.concat(e && e.message, '"'),
                stackStartFn: t,
              });
            }
            throw e;
          }
        }
        function D(t, e, r, n, o) {
          if (!w(e)) throw new h("regexp", "RegExp", e);
          var s = "match" === o;
          if ("string" != typeof t || E(e, t) !== s) {
            if (r instanceof Error) throw r;
            var a = !r;
            r =
              r ||
              ("string" != typeof t
                ? 'The "string" argument must be of type string. Received type ' +
                  "".concat(i(t), " (").concat(g(t), ")")
                : (s
                    ? "The input did not match the regular expression "
                    : "The input was expected to not match the regular expression ") +
                  "".concat(g(e), ". Input:\n\n").concat(g(t), "\n"));
            var u = new y({
              actual: t,
              expected: e,
              message: r,
              operator: o,
              stackStartFn: n,
            });
            throw ((u.generatedMessage = a), u);
          }
        }
        function L() {
          for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
            e[r] = arguments[r];
          k.apply(void 0, [L, e.length].concat(e));
        }
        (M.throws = function t(e) {
          for (
            var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;
            i < r;
            i++
          )
            n[i - 1] = arguments[i];
          N.apply(void 0, [t, B(e)].concat(n));
        }),
          (M.rejects = function t(e) {
            for (
              var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;
              i < r;
              i++
            )
              n[i - 1] = arguments[i];
            return R(e).then(function (e) {
              return N.apply(void 0, [t, e].concat(n));
            });
          }),
          (M.doesNotThrow = function t(e) {
            for (
              var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;
              i < r;
              i++
            )
              n[i - 1] = arguments[i];
            U.apply(void 0, [t, B(e)].concat(n));
          }),
          (M.doesNotReject = function t(e) {
            for (
              var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;
              i < r;
              i++
            )
              n[i - 1] = arguments[i];
            return R(e).then(function (e) {
              return U.apply(void 0, [t, e].concat(n));
            });
          }),
          (M.ifError = function t(e) {
            if (null != e) {
              var r = "ifError got unwanted exception: ";
              "object" === i(e) && "string" == typeof e.message
                ? 0 === e.message.length && e.constructor
                  ? (r += e.constructor.name)
                  : (r += e.message)
                : (r += g(e));
              var n = new y({
                  actual: e,
                  expected: null,
                  operator: "ifError",
                  message: r,
                  stackStartFn: t,
                }),
                o = e.stack;
              if ("string" == typeof o) {
                var s = o.split("\n");
                s.shift();
                for (var a = n.stack.split("\n"), u = 0; u < s.length; u++) {
                  var c = a.indexOf(s[u]);
                  if (-1 !== c) {
                    a = a.slice(0, c);
                    break;
                  }
                }
                n.stack = "".concat(a.join("\n"), "\n").concat(s.join("\n"));
              }
              throw n;
            }
          }),
          (M.match = function t(e, r, n) {
            D(e, r, n, t, "match");
          }),
          (M.doesNotMatch = function t(e, r, n) {
            D(e, r, n, t, "doesNotMatch");
          }),
          (M.strict = v(L, M, {
            equal: M.strictEqual,
            deepEqual: M.deepStrictEqual,
            notEqual: M.notStrictEqual,
            notDeepEqual: M.notDeepStrictEqual,
          })),
          (M.strict.strict = M.strict);
      },
      3918: (t, e, r) => {
        "use strict";
        var n = r(65606);
        function i(t, e) {
          var r = Object.keys(t);
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(t);
            e &&
              (n = n.filter(function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable;
              })),
              r.push.apply(r, n);
          }
          return r;
        }
        function o(t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = null != arguments[e] ? arguments[e] : {};
            e % 2
              ? i(Object(r), !0).forEach(function (e) {
                  s(t, e, r[e]);
                })
              : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(r),
                  )
                : i(Object(r)).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(r, e),
                    );
                  });
          }
          return t;
        }
        function s(t, e, r) {
          return (
            (e = u(e)) in t
              ? Object.defineProperty(t, e, {
                  value: r,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (t[e] = r),
            t
          );
        }
        function a(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(t, u(n.key), n);
          }
        }
        function u(t) {
          var e = (function (t, e) {
            if ("object" !== g(t) || null === t) return t;
            var r = t[Symbol.toPrimitive];
            if (void 0 !== r) {
              var n = r.call(t, e || "default");
              if ("object" !== g(n)) return n;
              throw new TypeError(
                "@@toPrimitive must return a primitive value.",
              );
            }
            return ("string" === e ? String : Number)(t);
          })(t, "string");
          return "symbol" === g(e) ? e : String(e);
        }
        function c(t, e) {
          if (e && ("object" === g(e) || "function" == typeof e)) return e;
          if (void 0 !== e)
            throw new TypeError(
              "Derived constructors may only return object or undefined",
            );
          return f(t);
        }
        function f(t) {
          if (void 0 === t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called",
            );
          return t;
        }
        function h(t) {
          var e = "function" == typeof Map ? new Map() : void 0;
          return (
            (h = function (t) {
              if (
                null === t ||
                ((r = t),
                -1 === Function.toString.call(r).indexOf("[native code]"))
              )
                return t;
              var r;
              if ("function" != typeof t)
                throw new TypeError(
                  "Super expression must either be null or a function",
                );
              if (void 0 !== e) {
                if (e.has(t)) return e.get(t);
                e.set(t, n);
              }
              function n() {
                return l(t, arguments, y(this).constructor);
              }
              return (
                (n.prototype = Object.create(t.prototype, {
                  constructor: {
                    value: n,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })),
                p(n, t)
              );
            }),
            h(t)
          );
        }
        function l(t, e, r) {
          return (
            (l = d()
              ? Reflect.construct.bind()
              : function (t, e, r) {
                  var n = [null];
                  n.push.apply(n, e);
                  var i = new (Function.bind.apply(t, n))();
                  return r && p(i, r.prototype), i;
                }),
            l.apply(null, arguments)
          );
        }
        function d() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return (
              Boolean.prototype.valueOf.call(
                Reflect.construct(Boolean, [], function () {}),
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        }
        function p(t, e) {
          return (
            (p = Object.setPrototypeOf
              ? Object.setPrototypeOf.bind()
              : function (t, e) {
                  return (t.__proto__ = e), t;
                }),
            p(t, e)
          );
        }
        function y(t) {
          return (
            (y = Object.setPrototypeOf
              ? Object.getPrototypeOf.bind()
              : function (t) {
                  return t.__proto__ || Object.getPrototypeOf(t);
                }),
            y(t)
          );
        }
        function g(t) {
          return (
            (g =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (t) {
                    return typeof t;
                  }
                : function (t) {
                    return t &&
                      "function" == typeof Symbol &&
                      t.constructor === Symbol &&
                      t !== Symbol.prototype
                      ? "symbol"
                      : typeof t;
                  }),
            g(t)
          );
        }
        var m = r(40537).inspect,
          b = r(69597).codes.ERR_INVALID_ARG_TYPE;
        function w(t, e, r) {
          return (
            (void 0 === r || r > t.length) && (r = t.length),
            t.substring(r - e.length, r) === e
          );
        }
        var v = "",
          _ = "",
          E = "",
          S = "",
          I = {
            deepStrictEqual: "Expected values to be strictly deep-equal:",
            strictEqual: "Expected values to be strictly equal:",
            strictEqualObject:
              'Expected "actual" to be reference-equal to "expected":',
            deepEqual: "Expected values to be loosely deep-equal:",
            equal: "Expected values to be loosely equal:",
            notDeepStrictEqual:
              'Expected "actual" not to be strictly deep-equal to:',
            notStrictEqual: 'Expected "actual" to be strictly unequal to:',
            notStrictEqualObject:
              'Expected "actual" not to be reference-equal to "expected":',
            notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
            notEqual: 'Expected "actual" to be loosely unequal to:',
            notIdentical: "Values identical but not reference-equal:",
          };
        function M(t) {
          var e = Object.keys(t),
            r = Object.create(Object.getPrototypeOf(t));
          return (
            e.forEach(function (e) {
              r[e] = t[e];
            }),
            Object.defineProperty(r, "message", { value: t.message }),
            r
          );
        }
        function A(t) {
          return m(t, {
            compact: !1,
            customInspect: !1,
            depth: 1e3,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0,
          });
        }
        function T(t, e, r) {
          var i = "",
            o = "",
            s = 0,
            a = "",
            u = !1,
            c = A(t),
            f = c.split("\n"),
            h = A(e).split("\n"),
            l = 0,
            d = "";
          if (
            ("strictEqual" === r &&
              "object" === g(t) &&
              "object" === g(e) &&
              null !== t &&
              null !== e &&
              (r = "strictEqualObject"),
            1 === f.length && 1 === h.length && f[0] !== h[0])
          ) {
            var p = f[0].length + h[0].length;
            if (p <= 10) {
              if (
                !(
                  ("object" === g(t) && null !== t) ||
                  ("object" === g(e) && null !== e) ||
                  (0 === t && 0 === e)
                )
              )
                return (
                  "".concat(I[r], "\n\n") +
                  "".concat(f[0], " !== ").concat(h[0], "\n")
                );
            } else if ("strictEqualObject" !== r) {
              if (p < (n.stderr && n.stderr.isTTY ? n.stderr.columns : 80)) {
                for (; f[0][l] === h[0][l]; ) l++;
                l > 2 &&
                  ((d = "\n  ".concat(
                    (function (t, e) {
                      if (((e = Math.floor(e)), 0 == t.length || 0 == e))
                        return "";
                      var r = t.length * e;
                      for (e = Math.floor(Math.log(e) / Math.log(2)); e; )
                        (t += t), e--;
                      return t + t.substring(0, r - t.length);
                    })(" ", l),
                    "^",
                  )),
                  (l = 0));
              }
            }
          }
          for (
            var y = f[f.length - 1], m = h[h.length - 1];
            y === m &&
            (l++ < 2 ? (a = "\n  ".concat(y).concat(a)) : (i = y),
            f.pop(),
            h.pop(),
            0 !== f.length && 0 !== h.length);

          )
            (y = f[f.length - 1]), (m = h[h.length - 1]);
          var b = Math.max(f.length, h.length);
          if (0 === b) {
            var M = c.split("\n");
            if (M.length > 30)
              for (M[26] = "".concat(v, "...").concat(S); M.length > 27; )
                M.pop();
            return "".concat(I.notIdentical, "\n\n").concat(M.join("\n"), "\n");
          }
          l > 3 && ((a = "\n".concat(v, "...").concat(S).concat(a)), (u = !0)),
            "" !== i && ((a = "\n  ".concat(i).concat(a)), (i = ""));
          var T = 0,
            k =
              I[r] +
              "\n"
                .concat(_, "+ actual")
                .concat(S, " ")
                .concat(E, "- expected")
                .concat(S),
            O = " ".concat(v, "...").concat(S, " Lines skipped");
          for (l = 0; l < b; l++) {
            var x = l - s;
            if (f.length < l + 1)
              x > 1 &&
                l > 2 &&
                (x > 4
                  ? ((o += "\n".concat(v, "...").concat(S)), (u = !0))
                  : x > 3 && ((o += "\n  ".concat(h[l - 2])), T++),
                (o += "\n  ".concat(h[l - 1])),
                T++),
                (s = l),
                (i += "\n".concat(E, "-").concat(S, " ").concat(h[l])),
                T++;
            else if (h.length < l + 1)
              x > 1 &&
                l > 2 &&
                (x > 4
                  ? ((o += "\n".concat(v, "...").concat(S)), (u = !0))
                  : x > 3 && ((o += "\n  ".concat(f[l - 2])), T++),
                (o += "\n  ".concat(f[l - 1])),
                T++),
                (s = l),
                (o += "\n".concat(_, "+").concat(S, " ").concat(f[l])),
                T++;
            else {
              var P = h[l],
                B = f[l],
                C = B !== P && (!w(B, ",") || B.slice(0, -1) !== P);
              C && w(P, ",") && P.slice(0, -1) === B && ((C = !1), (B += ",")),
                C
                  ? (x > 1 &&
                      l > 2 &&
                      (x > 4
                        ? ((o += "\n".concat(v, "...").concat(S)), (u = !0))
                        : x > 3 && ((o += "\n  ".concat(f[l - 2])), T++),
                      (o += "\n  ".concat(f[l - 1])),
                      T++),
                    (s = l),
                    (o += "\n".concat(_, "+").concat(S, " ").concat(B)),
                    (i += "\n".concat(E, "-").concat(S, " ").concat(P)),
                    (T += 2))
                  : ((o += i),
                    (i = ""),
                    (1 !== x && 0 !== l) || ((o += "\n  ".concat(B)), T++));
            }
            if (T > 20 && l < b - 2)
              return (
                ""
                  .concat(k)
                  .concat(O, "\n")
                  .concat(o, "\n")
                  .concat(v, "...")
                  .concat(S)
                  .concat(i, "\n") + "".concat(v, "...").concat(S)
              );
          }
          return ""
            .concat(k)
            .concat(u ? O : "", "\n")
            .concat(o)
            .concat(i)
            .concat(a)
            .concat(d);
        }
        var k = (function (t, e) {
          !(function (t, e) {
            if ("function" != typeof e && null !== e)
              throw new TypeError(
                "Super expression must either be null or a function",
              );
            (t.prototype = Object.create(e && e.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              Object.defineProperty(t, "prototype", { writable: !1 }),
              e && p(t, e);
          })(w, t);
          var r,
            i,
            s,
            u,
            h,
            l =
              ((r = w),
              (i = d()),
              function () {
                var t,
                  e = y(r);
                if (i) {
                  var n = y(this).constructor;
                  t = Reflect.construct(e, arguments, n);
                } else t = e.apply(this, arguments);
                return c(this, t);
              });
          function w(t) {
            var e;
            if (
              ((function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, w),
              "object" !== g(t) || null === t)
            )
              throw new b("options", "Object", t);
            var r = t.message,
              i = t.operator,
              o = t.stackStartFn,
              s = t.actual,
              a = t.expected,
              u = Error.stackTraceLimit;
            if (((Error.stackTraceLimit = 0), null != r))
              e = l.call(this, String(r));
            else if (
              (n.stderr &&
                n.stderr.isTTY &&
                (n.stderr &&
                n.stderr.getColorDepth &&
                1 !== n.stderr.getColorDepth()
                  ? ((v = "[34m"), (_ = "[32m"), (S = "[39m"), (E = "[31m"))
                  : ((v = ""), (_ = ""), (S = ""), (E = ""))),
              "object" === g(s) &&
                null !== s &&
                "object" === g(a) &&
                null !== a &&
                "stack" in s &&
                s instanceof Error &&
                "stack" in a &&
                a instanceof Error &&
                ((s = M(s)), (a = M(a))),
              "deepStrictEqual" === i || "strictEqual" === i)
            )
              e = l.call(this, T(s, a, i));
            else if ("notDeepStrictEqual" === i || "notStrictEqual" === i) {
              var h = I[i],
                d = A(s).split("\n");
              if (
                ("notStrictEqual" === i &&
                  "object" === g(s) &&
                  null !== s &&
                  (h = I.notStrictEqualObject),
                d.length > 30)
              )
                for (d[26] = "".concat(v, "...").concat(S); d.length > 27; )
                  d.pop();
              e =
                1 === d.length
                  ? l.call(this, "".concat(h, " ").concat(d[0]))
                  : l.call(
                      this,
                      "".concat(h, "\n\n").concat(d.join("\n"), "\n"),
                    );
            } else {
              var p = A(s),
                y = "",
                m = I[i];
              "notDeepEqual" === i || "notEqual" === i
                ? (p = "".concat(I[i], "\n\n").concat(p)).length > 1024 &&
                  (p = "".concat(p.slice(0, 1021), "..."))
                : ((y = "".concat(A(a))),
                  p.length > 512 && (p = "".concat(p.slice(0, 509), "...")),
                  y.length > 512 && (y = "".concat(y.slice(0, 509), "...")),
                  "deepEqual" === i || "equal" === i
                    ? (p = ""
                        .concat(m, "\n\n")
                        .concat(p, "\n\nshould equal\n\n"))
                    : (y = " ".concat(i, " ").concat(y))),
                (e = l.call(this, "".concat(p).concat(y)));
            }
            return (
              (Error.stackTraceLimit = u),
              (e.generatedMessage = !r),
              Object.defineProperty(f(e), "name", {
                value: "AssertionError [ERR_ASSERTION]",
                enumerable: !1,
                writable: !0,
                configurable: !0,
              }),
              (e.code = "ERR_ASSERTION"),
              (e.actual = s),
              (e.expected = a),
              (e.operator = i),
              Error.captureStackTrace && Error.captureStackTrace(f(e), o),
              e.stack,
              (e.name = "AssertionError"),
              c(e)
            );
          }
          return (
            (s = w),
            (u = [
              {
                key: "toString",
                value: function () {
                  return ""
                    .concat(this.name, " [")
                    .concat(this.code, "]: ")
                    .concat(this.message);
                },
              },
              {
                key: e,
                value: function (t, e) {
                  return m(
                    this,
                    o(o({}, e), {}, { customInspect: !1, depth: 0 }),
                  );
                },
              },
            ]) && a(s.prototype, u),
            h && a(s, h),
            Object.defineProperty(s, "prototype", { writable: !1 }),
            w
          );
        })(h(Error), m.custom);
        t.exports = k;
      },
      69597: (t, e, r) => {
        "use strict";
        function n(t) {
          return (
            (n =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (t) {
                    return typeof t;
                  }
                : function (t) {
                    return t &&
                      "function" == typeof Symbol &&
                      t.constructor === Symbol &&
                      t !== Symbol.prototype
                      ? "symbol"
                      : typeof t;
                  }),
            n(t)
          );
        }
        function i(t, e) {
          for (var r = 0; r < e.length; r++) {
            var i = e[r];
            (i.enumerable = i.enumerable || !1),
              (i.configurable = !0),
              "value" in i && (i.writable = !0),
              Object.defineProperty(
                t,
                ((o = i.key),
                (s = void 0),
                (s = (function (t, e) {
                  if ("object" !== n(t) || null === t) return t;
                  var r = t[Symbol.toPrimitive];
                  if (void 0 !== r) {
                    var i = r.call(t, e || "default");
                    if ("object" !== n(i)) return i;
                    throw new TypeError(
                      "@@toPrimitive must return a primitive value.",
                    );
                  }
                  return ("string" === e ? String : Number)(t);
                })(o, "string")),
                "symbol" === n(s) ? s : String(s)),
                i,
              );
          }
          var o, s;
        }
        function o(t, e) {
          return (
            (o = Object.setPrototypeOf
              ? Object.setPrototypeOf.bind()
              : function (t, e) {
                  return (t.__proto__ = e), t;
                }),
            o(t, e)
          );
        }
        function s(t) {
          var e = (function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var r,
              i = a(t);
            if (e) {
              var o = a(this).constructor;
              r = Reflect.construct(i, arguments, o);
            } else r = i.apply(this, arguments);
            return (function (t, e) {
              if (e && ("object" === n(e) || "function" == typeof e)) return e;
              if (void 0 !== e)
                throw new TypeError(
                  "Derived constructors may only return object or undefined",
                );
              return (function (t) {
                if (void 0 === t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called",
                  );
                return t;
              })(t);
            })(this, r);
          };
        }
        function a(t) {
          return (
            (a = Object.setPrototypeOf
              ? Object.getPrototypeOf.bind()
              : function (t) {
                  return t.__proto__ || Object.getPrototypeOf(t);
                }),
            a(t)
          );
        }
        var u,
          c,
          f = {};
        function h(t, e, r) {
          r || (r = Error);
          var n = (function (r) {
            !(function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function",
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: { value: t, writable: !0, configurable: !0 },
              })),
                Object.defineProperty(t, "prototype", { writable: !1 }),
                e && o(t, e);
            })(f, r);
            var n,
              a,
              u,
              c = s(f);
            function f(r, n, i) {
              var o;
              return (
                (function (t, e) {
                  if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function");
                })(this, f),
                (o = c.call(
                  this,
                  (function (t, r, n) {
                    return "string" == typeof e ? e : e(t, r, n);
                  })(r, n, i),
                )),
                (o.code = t),
                o
              );
            }
            return (
              (n = f),
              a && i(n.prototype, a),
              u && i(n, u),
              Object.defineProperty(n, "prototype", { writable: !1 }),
              n
            );
          })(r);
          f[t] = n;
        }
        function l(t, e) {
          if (Array.isArray(t)) {
            var r = t.length;
            return (
              (t = t.map(function (t) {
                return String(t);
              })),
              r > 2
                ? "one of "
                    .concat(e, " ")
                    .concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1]
                : 2 === r
                  ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1])
                  : "of ".concat(e, " ").concat(t[0])
            );
          }
          return "of ".concat(e, " ").concat(String(t));
        }
        h(
          "ERR_AMBIGUOUS_ARGUMENT",
          'The "%s" argument is ambiguous. %s',
          TypeError,
        ),
          h(
            "ERR_INVALID_ARG_TYPE",
            function (t, e, i) {
              var o, s, a, c;
              if (
                (void 0 === u && (u = r(94148)),
                u("string" == typeof t, "'name' must be a string"),
                "string" == typeof e &&
                ((s = "not "), e.substr(!a || a < 0 ? 0 : +a, s.length) === s)
                  ? ((o = "must not be"), (e = e.replace(/^not /, "")))
                  : (o = "must be"),
                (function (t, e, r) {
                  return (
                    (void 0 === r || r > t.length) && (r = t.length),
                    t.substring(r - e.length, r) === e
                  );
                })(t, " argument"))
              )
                c = "The ".concat(t, " ").concat(o, " ").concat(l(e, "type"));
              else {
                var f = (function (t, e, r) {
                  return (
                    "number" != typeof r && (r = 0),
                    !(r + e.length > t.length) && -1 !== t.indexOf(e, r)
                  );
                })(t, ".")
                  ? "property"
                  : "argument";
                c = 'The "'
                  .concat(t, '" ')
                  .concat(f, " ")
                  .concat(o, " ")
                  .concat(l(e, "type"));
              }
              return (c += ". Received type ".concat(n(i)));
            },
            TypeError,
          ),
          h(
            "ERR_INVALID_ARG_VALUE",
            function (t, e) {
              var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : "is invalid";
              void 0 === c && (c = r(40537));
              var i = c.inspect(e);
              return (
                i.length > 128 && (i = "".concat(i.slice(0, 128), "...")),
                "The argument '"
                  .concat(t, "' ")
                  .concat(n, ". Received ")
                  .concat(i)
              );
            },
            TypeError,
            RangeError,
          ),
          h(
            "ERR_INVALID_RETURN_VALUE",
            function (t, e, r) {
              var i;
              return (
                (i =
                  r && r.constructor && r.constructor.name
                    ? "instance of ".concat(r.constructor.name)
                    : "type ".concat(n(r))),
                "Expected "
                  .concat(t, ' to be returned from the "')
                  .concat(e, '"') + " function but got ".concat(i, ".")
              );
            },
            TypeError,
          ),
          h(
            "ERR_MISSING_ARGS",
            function () {
              for (
                var t = arguments.length, e = new Array(t), n = 0;
                n < t;
                n++
              )
                e[n] = arguments[n];
              void 0 === u && (u = r(94148)),
                u(e.length > 0, "At least one arg needs to be specified");
              var i = "The ",
                o = e.length;
              switch (
                ((e = e.map(function (t) {
                  return '"'.concat(t, '"');
                })),
                o)
              ) {
                case 1:
                  i += "".concat(e[0], " argument");
                  break;
                case 2:
                  i += "".concat(e[0], " and ").concat(e[1], " arguments");
                  break;
                default:
                  (i += e.slice(0, o - 1).join(", ")),
                    (i += ", and ".concat(e[o - 1], " arguments"));
              }
              return "".concat(i, " must be specified");
            },
            TypeError,
          ),
          (t.exports.codes = f);
      },
      82299: (t, e, r) => {
        "use strict";
        function n(t, e) {
          return (
            (function (t) {
              if (Array.isArray(t)) return t;
            })(t) ||
            (function (t, e) {
              var r =
                null == t
                  ? null
                  : ("undefined" != typeof Symbol && t[Symbol.iterator]) ||
                    t["@@iterator"];
              if (null != r) {
                var n,
                  i,
                  o,
                  s,
                  a = [],
                  u = !0,
                  c = !1;
                try {
                  if (((o = (r = r.call(t)).next), 0 === e)) {
                    if (Object(r) !== r) return;
                    u = !1;
                  } else
                    for (
                      ;
                      !(u = (n = o.call(r)).done) &&
                      (a.push(n.value), a.length !== e);
                      u = !0
                    );
                } catch (t) {
                  (c = !0), (i = t);
                } finally {
                  try {
                    if (
                      !u &&
                      null != r.return &&
                      ((s = r.return()), Object(s) !== s)
                    )
                      return;
                  } finally {
                    if (c) throw i;
                  }
                }
                return a;
              }
            })(t, e) ||
            (function (t, e) {
              if (!t) return;
              if ("string" == typeof t) return i(t, e);
              var r = Object.prototype.toString.call(t).slice(8, -1);
              "Object" === r && t.constructor && (r = t.constructor.name);
              if ("Map" === r || "Set" === r) return Array.from(t);
              if (
                "Arguments" === r ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
              )
                return i(t, e);
            })(t, e) ||
            (function () {
              throw new TypeError(
                "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
              );
            })()
          );
        }
        function i(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
          return n;
        }
        function o(t) {
          return (
            (o =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (t) {
                    return typeof t;
                  }
                : function (t) {
                    return t &&
                      "function" == typeof Symbol &&
                      t.constructor === Symbol &&
                      t !== Symbol.prototype
                      ? "symbol"
                      : typeof t;
                  }),
            o(t)
          );
        }
        var s = void 0 !== /a/g.flags,
          a = function (t) {
            var e = [];
            return (
              t.forEach(function (t) {
                return e.push(t);
              }),
              e
            );
          },
          u = function (t) {
            var e = [];
            return (
              t.forEach(function (t, r) {
                return e.push([r, t]);
              }),
              e
            );
          },
          c = Object.is ? Object.is : r(37653),
          f = Object.getOwnPropertySymbols
            ? Object.getOwnPropertySymbols
            : function () {
                return [];
              },
          h = Number.isNaN ? Number.isNaN : r(24133);
        function l(t) {
          return t.call.bind(t);
        }
        var d = l(Object.prototype.hasOwnProperty),
          p = l(Object.prototype.propertyIsEnumerable),
          y = l(Object.prototype.toString),
          g = r(40537).types,
          m = g.isAnyArrayBuffer,
          b = g.isArrayBufferView,
          w = g.isDate,
          v = g.isMap,
          _ = g.isRegExp,
          E = g.isSet,
          S = g.isNativeError,
          I = g.isBoxedPrimitive,
          M = g.isNumberObject,
          A = g.isStringObject,
          T = g.isBooleanObject,
          k = g.isBigIntObject,
          O = g.isSymbolObject,
          x = g.isFloat32Array,
          P = g.isFloat64Array;
        function B(t) {
          if (0 === t.length || t.length > 10) return !0;
          for (var e = 0; e < t.length; e++) {
            var r = t.charCodeAt(e);
            if (r < 48 || r > 57) return !0;
          }
          return 10 === t.length && t >= Math.pow(2, 32);
        }
        function C(t) {
          return Object.keys(t)
            .filter(B)
            .concat(f(t).filter(Object.prototype.propertyIsEnumerable.bind(t)));
        }
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */ function R(t, e) {
          if (t === e) return 0;
          for (
            var r = t.length, n = e.length, i = 0, o = Math.min(r, n);
            i < o;
            ++i
          )
            if (t[i] !== e[i]) {
              (r = t[i]), (n = e[i]);
              break;
            }
          return r < n ? -1 : n < r ? 1 : 0;
        }
        function N(t, e, r, n) {
          if (t === e) return 0 !== t || !r || c(t, e);
          if (r) {
            if ("object" !== o(t)) return "number" == typeof t && h(t) && h(e);
            if ("object" !== o(e) || null === t || null === e) return !1;
            if (Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
              return !1;
          } else {
            if (null === t || "object" !== o(t))
              return (null === e || "object" !== o(e)) && t == e;
            if (null === e || "object" !== o(e)) return !1;
          }
          var i,
            a,
            u,
            f,
            l = y(t);
          if (l !== y(e)) return !1;
          if (Array.isArray(t)) {
            if (t.length !== e.length) return !1;
            var d = C(t),
              p = C(e);
            return d.length === p.length && D(t, e, r, n, 1, d);
          }
          if ("[object Object]" === l && ((!v(t) && v(e)) || (!E(t) && E(e))))
            return !1;
          if (w(t)) {
            if (
              !w(e) ||
              Date.prototype.getTime.call(t) !== Date.prototype.getTime.call(e)
            )
              return !1;
          } else if (_(t)) {
            if (
              !_(e) ||
              ((u = t),
              (f = e),
              !(s
                ? u.source === f.source && u.flags === f.flags
                : RegExp.prototype.toString.call(u) ===
                  RegExp.prototype.toString.call(f)))
            )
              return !1;
          } else if (S(t) || t instanceof Error) {
            if (t.message !== e.message || t.name !== e.name) return !1;
          } else {
            if (b(t)) {
              if (r || (!x(t) && !P(t))) {
                if (
                  !(function (t, e) {
                    return (
                      t.byteLength === e.byteLength &&
                      0 ===
                        R(
                          new Uint8Array(t.buffer, t.byteOffset, t.byteLength),
                          new Uint8Array(e.buffer, e.byteOffset, e.byteLength),
                        )
                    );
                  })(t, e)
                )
                  return !1;
              } else if (
                !(function (t, e) {
                  if (t.byteLength !== e.byteLength) return !1;
                  for (var r = 0; r < t.byteLength; r++)
                    if (t[r] !== e[r]) return !1;
                  return !0;
                })(t, e)
              )
                return !1;
              var g = C(t),
                B = C(e);
              return g.length === B.length && D(t, e, r, n, 0, g);
            }
            if (E(t)) return !(!E(e) || t.size !== e.size) && D(t, e, r, n, 2);
            if (v(t)) return !(!v(e) || t.size !== e.size) && D(t, e, r, n, 3);
            if (m(t)) {
              if (
                ((a = e),
                (i = t).byteLength !== a.byteLength ||
                  0 !== R(new Uint8Array(i), new Uint8Array(a)))
              )
                return !1;
            } else if (
              I(t) &&
              !(function (t, e) {
                return M(t)
                  ? M(e) &&
                      c(
                        Number.prototype.valueOf.call(t),
                        Number.prototype.valueOf.call(e),
                      )
                  : A(t)
                    ? A(e) &&
                      String.prototype.valueOf.call(t) ===
                        String.prototype.valueOf.call(e)
                    : T(t)
                      ? T(e) &&
                        Boolean.prototype.valueOf.call(t) ===
                          Boolean.prototype.valueOf.call(e)
                      : k(t)
                        ? k(e) &&
                          BigInt.prototype.valueOf.call(t) ===
                            BigInt.prototype.valueOf.call(e)
                        : O(e) &&
                          Symbol.prototype.valueOf.call(t) ===
                            Symbol.prototype.valueOf.call(e);
              })(t, e)
            )
              return !1;
          }
          return D(t, e, r, n, 0);
        }
        function U(t, e) {
          return e.filter(function (e) {
            return p(t, e);
          });
        }
        function D(t, e, r, i, s, c) {
          if (5 === arguments.length) {
            c = Object.keys(t);
            var h = Object.keys(e);
            if (c.length !== h.length) return !1;
          }
          for (var l = 0; l < c.length; l++) if (!d(e, c[l])) return !1;
          if (r && 5 === arguments.length) {
            var y = f(t);
            if (0 !== y.length) {
              var g = 0;
              for (l = 0; l < y.length; l++) {
                var m = y[l];
                if (p(t, m)) {
                  if (!p(e, m)) return !1;
                  c.push(m), g++;
                } else if (p(e, m)) return !1;
              }
              var b = f(e);
              if (y.length !== b.length && U(e, b).length !== g) return !1;
            } else {
              var w = f(e);
              if (0 !== w.length && 0 !== U(e, w).length) return !1;
            }
          }
          if (
            0 === c.length &&
            (0 === s || (1 === s && 0 === t.length) || 0 === t.size)
          )
            return !0;
          if (void 0 === i)
            i = { val1: new Map(), val2: new Map(), position: 0 };
          else {
            var v = i.val1.get(t);
            if (void 0 !== v) {
              var _ = i.val2.get(e);
              if (void 0 !== _) return v === _;
            }
            i.position++;
          }
          i.val1.set(t, i.position), i.val2.set(e, i.position);
          var E = (function (t, e, r, i, s, c) {
            var f = 0;
            if (2 === c) {
              if (
                !(function (t, e, r, n) {
                  for (var i = null, s = a(t), u = 0; u < s.length; u++) {
                    var c = s[u];
                    if ("object" === o(c) && null !== c)
                      null === i && (i = new Set()), i.add(c);
                    else if (!e.has(c)) {
                      if (r) return !1;
                      if (!F(t, e, c)) return !1;
                      null === i && (i = new Set()), i.add(c);
                    }
                  }
                  if (null !== i) {
                    for (var f = a(e), h = 0; h < f.length; h++) {
                      var l = f[h];
                      if ("object" === o(l) && null !== l) {
                        if (!L(i, l, r, n)) return !1;
                      } else if (!r && !t.has(l) && !L(i, l, r, n)) return !1;
                    }
                    return 0 === i.size;
                  }
                  return !0;
                })(t, e, r, s)
              )
                return !1;
            } else if (3 === c) {
              if (
                !(function (t, e, r, i) {
                  for (var s = null, a = u(t), c = 0; c < a.length; c++) {
                    var f = n(a[c], 2),
                      h = f[0],
                      l = f[1];
                    if ("object" === o(h) && null !== h)
                      null === s && (s = new Set()), s.add(h);
                    else {
                      var d = e.get(h);
                      if ((void 0 === d && !e.has(h)) || !N(l, d, r, i)) {
                        if (r) return !1;
                        if (!H(t, e, h, l, i)) return !1;
                        null === s && (s = new Set()), s.add(h);
                      }
                    }
                  }
                  if (null !== s) {
                    for (var p = u(e), y = 0; y < p.length; y++) {
                      var g = n(p[y], 2),
                        m = g[0],
                        b = g[1];
                      if ("object" === o(m) && null !== m) {
                        if (!K(s, t, m, b, r, i)) return !1;
                      } else if (
                        !(
                          r ||
                          (t.has(m) && N(t.get(m), b, !1, i)) ||
                          K(s, t, m, b, !1, i)
                        )
                      )
                        return !1;
                    }
                    return 0 === s.size;
                  }
                  return !0;
                })(t, e, r, s)
              )
                return !1;
            } else if (1 === c)
              for (; f < t.length; f++) {
                if (!d(t, f)) {
                  if (d(e, f)) return !1;
                  for (var h = Object.keys(t); f < h.length; f++) {
                    var l = h[f];
                    if (!d(e, l) || !N(t[l], e[l], r, s)) return !1;
                  }
                  return h.length === Object.keys(e).length;
                }
                if (!d(e, f) || !N(t[f], e[f], r, s)) return !1;
              }
            for (f = 0; f < i.length; f++) {
              var p = i[f];
              if (!N(t[p], e[p], r, s)) return !1;
            }
            return !0;
          })(t, e, r, c, i, s);
          return i.val1.delete(t), i.val2.delete(e), E;
        }
        function L(t, e, r, n) {
          for (var i = a(t), o = 0; o < i.length; o++) {
            var s = i[o];
            if (N(e, s, r, n)) return t.delete(s), !0;
          }
          return !1;
        }
        function j(t) {
          switch (o(t)) {
            case "undefined":
              return null;
            case "object":
              return;
            case "symbol":
              return !1;
            case "string":
              t = +t;
            case "number":
              if (h(t)) return !1;
          }
          return !0;
        }
        function F(t, e, r) {
          var n = j(r);
          return null != n ? n : e.has(n) && !t.has(n);
        }
        function H(t, e, r, n, i) {
          var o = j(r);
          if (null != o) return o;
          var s = e.get(o);
          return (
            !((void 0 === s && !e.has(o)) || !N(n, s, !1, i)) &&
            !t.has(o) &&
            N(n, s, !1, i)
          );
        }
        function K(t, e, r, n, i, o) {
          for (var s = a(t), u = 0; u < s.length; u++) {
            var c = s[u];
            if (N(r, c, i, o) && N(n, e.get(c), i, o)) return t.delete(c), !0;
          }
          return !1;
        }
        t.exports = {
          isDeepEqual: function (t, e) {
            return N(t, e, false);
          },
          isDeepStrictEqual: function (t, e) {
            return N(t, e, true);
          },
        };
      },
      95364: (t) => {
        "use strict";
        t.exports = function (t) {
          if (t.length >= 255) throw new TypeError("Alphabet too long");
          for (var e = new Uint8Array(256), r = 0; r < e.length; r++)
            e[r] = 255;
          for (var n = 0; n < t.length; n++) {
            var i = t.charAt(n),
              o = i.charCodeAt(0);
            if (255 !== e[o]) throw new TypeError(i + " is ambiguous");
            e[o] = n;
          }
          var s = t.length,
            a = t.charAt(0),
            u = Math.log(s) / Math.log(256),
            c = Math.log(256) / Math.log(s);
          function f(t) {
            if ("string" != typeof t) throw new TypeError("Expected String");
            if (0 === t.length) return new Uint8Array();
            for (var r = 0, n = 0, i = 0; t[r] === a; ) n++, r++;
            for (
              var o = ((t.length - r) * u + 1) >>> 0, c = new Uint8Array(o);
              t[r];

            ) {
              var f = e[t.charCodeAt(r)];
              if (255 === f) return;
              for (
                var h = 0, l = o - 1;
                (0 !== f || h < i) && -1 !== l;
                l--, h++
              )
                (f += (s * c[l]) >>> 0),
                  (c[l] = f % 256 >>> 0),
                  (f = (f / 256) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (i = h), r++;
            }
            for (var d = o - i; d !== o && 0 === c[d]; ) d++;
            for (var p = new Uint8Array(n + (o - d)), y = n; d !== o; )
              p[y++] = c[d++];
            return p;
          }
          return {
            encode: function (e) {
              if (
                (e instanceof Uint8Array ||
                  (ArrayBuffer.isView(e)
                    ? (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
                    : Array.isArray(e) && (e = Uint8Array.from(e))),
                !(e instanceof Uint8Array))
              )
                throw new TypeError("Expected Uint8Array");
              if (0 === e.length) return "";
              for (
                var r = 0, n = 0, i = 0, o = e.length;
                i !== o && 0 === e[i];

              )
                i++, r++;
              for (
                var u = ((o - i) * c + 1) >>> 0, f = new Uint8Array(u);
                i !== o;

              ) {
                for (
                  var h = e[i], l = 0, d = u - 1;
                  (0 !== h || l < n) && -1 !== d;
                  d--, l++
                )
                  (h += (256 * f[d]) >>> 0),
                    (f[d] = h % s >>> 0),
                    (h = (h / s) >>> 0);
                if (0 !== h) throw new Error("Non-zero carry");
                (n = l), i++;
              }
              for (var p = u - n; p !== u && 0 === f[p]; ) p++;
              for (var y = a.repeat(r); p < u; ++p) y += t.charAt(f[p]);
              return y;
            },
            decodeUnsafe: f,
            decode: function (t) {
              var e = f(t);
              if (e) return e;
              throw new Error("Non-base" + s + " character");
            },
          };
        };
      },
      67526: (t, e) => {
        "use strict";
        (e.byteLength = function (t) {
          var e = a(t),
            r = e[0],
            n = e[1];
          return (3 * (r + n)) / 4 - n;
        }),
          (e.toByteArray = function (t) {
            var e,
              r,
              o = a(t),
              s = o[0],
              u = o[1],
              c = new i(
                (function (t, e, r) {
                  return (3 * (e + r)) / 4 - r;
                })(0, s, u),
              ),
              f = 0,
              h = u > 0 ? s - 4 : s;
            for (r = 0; r < h; r += 4)
              (e =
                (n[t.charCodeAt(r)] << 18) |
                (n[t.charCodeAt(r + 1)] << 12) |
                (n[t.charCodeAt(r + 2)] << 6) |
                n[t.charCodeAt(r + 3)]),
                (c[f++] = (e >> 16) & 255),
                (c[f++] = (e >> 8) & 255),
                (c[f++] = 255 & e);
            2 === u &&
              ((e = (n[t.charCodeAt(r)] << 2) | (n[t.charCodeAt(r + 1)] >> 4)),
              (c[f++] = 255 & e));
            1 === u &&
              ((e =
                (n[t.charCodeAt(r)] << 10) |
                (n[t.charCodeAt(r + 1)] << 4) |
                (n[t.charCodeAt(r + 2)] >> 2)),
              (c[f++] = (e >> 8) & 255),
              (c[f++] = 255 & e));
            return c;
          }),
          (e.fromByteArray = function (t) {
            for (
              var e,
                n = t.length,
                i = n % 3,
                o = [],
                s = 16383,
                a = 0,
                c = n - i;
              a < c;
              a += s
            )
              o.push(u(t, a, a + s > c ? c : a + s));
            1 === i
              ? ((e = t[n - 1]), o.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
              : 2 === i &&
                ((e = (t[n - 2] << 8) + t[n - 1]),
                o.push(r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "="));
            return o.join("");
          });
        for (
          var r = [],
            n = [],
            i = "undefined" != typeof Uint8Array ? Uint8Array : Array,
            o =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            s = 0;
          s < 64;
          ++s
        )
          (r[s] = o[s]), (n[o.charCodeAt(s)] = s);
        function a(t) {
          var e = t.length;
          if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r = t.indexOf("=");
          return -1 === r && (r = e), [r, r === e ? 0 : 4 - (r % 4)];
        }
        function u(t, e, n) {
          for (var i, o, s = [], a = e; a < n; a += 3)
            (i =
              ((t[a] << 16) & 16711680) +
              ((t[a + 1] << 8) & 65280) +
              (255 & t[a + 2])),
              s.push(
                r[((o = i) >> 18) & 63] +
                  r[(o >> 12) & 63] +
                  r[(o >> 6) & 63] +
                  r[63 & o],
              );
          return s.join("");
        }
        (n["-".charCodeAt(0)] = 62), (n["_".charCodeAt(0)] = 63);
      },
      92788: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        var i = r(12931);
        function o(t, e) {
          return (
            void 0 === e && (e = "utf8"),
            n.isBuffer(t)
              ? a(t.toString("base64"))
              : a(n.from(t, e).toString("base64"))
          );
        }
        function s(t) {
          return (
            (t = t.toString()),
            i.default(t).replace(/\-/g, "+").replace(/_/g, "/")
          );
        }
        function a(t) {
          return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        var u = o;
        (u.encode = o),
          (u.decode = function (t, e) {
            return (
              void 0 === e && (e = "utf8"), n.from(s(t), "base64").toString(e)
            );
          }),
          (u.toBase64 = s),
          (u.fromBase64 = a),
          (u.toBuffer = function (t) {
            return n.from(s(t), "base64");
          }),
          (e.default = u);
      },
      12931: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.default = function (t) {
            var e = t.length,
              r = e % 4;
            if (!r) return t;
            var i = e,
              o = 4 - r,
              s = e + o,
              a = n.alloc(s);
            for (a.write(t); o--; ) a.write("=", i++);
            return a.toString();
          });
      },
      84711: (t, e, r) => {
        (t.exports = r(92788).default), (t.exports.default = t.exports);
      },
      22343: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.bech32m = e.bech32 = void 0);
        const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
          n = {};
        for (let t = 0; t < 32; t++) {
          const e = r.charAt(t);
          n[e] = t;
        }
        function i(t) {
          const e = t >> 25;
          return (
            ((33554431 & t) << 5) ^
            (996825010 & -(1 & e)) ^
            (642813549 & -((e >> 1) & 1)) ^
            (513874426 & -((e >> 2) & 1)) ^
            (1027748829 & -((e >> 3) & 1)) ^
            (705979059 & -((e >> 4) & 1))
          );
        }
        function o(t) {
          let e = 1;
          for (let r = 0; r < t.length; ++r) {
            const n = t.charCodeAt(r);
            if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
            e = i(e) ^ (n >> 5);
          }
          e = i(e);
          for (let r = 0; r < t.length; ++r) {
            const n = t.charCodeAt(r);
            e = i(e) ^ (31 & n);
          }
          return e;
        }
        function s(t, e, r, n) {
          let i = 0,
            o = 0;
          const s = (1 << r) - 1,
            a = [];
          for (let n = 0; n < t.length; ++n)
            for (i = (i << e) | t[n], o += e; o >= r; )
              (o -= r), a.push((i >> o) & s);
          if (n) o > 0 && a.push((i << (r - o)) & s);
          else {
            if (o >= e) return "Excess padding";
            if ((i << (r - o)) & s) return "Non-zero padding";
          }
          return a;
        }
        function a(t) {
          return s(t, 8, 5, !0);
        }
        function u(t) {
          const e = s(t, 5, 8, !1);
          if (Array.isArray(e)) return e;
        }
        function c(t) {
          const e = s(t, 5, 8, !1);
          if (Array.isArray(e)) return e;
          throw new Error(e);
        }
        function f(t) {
          let e;
          function s(t, r) {
            if (((r = r || 90), t.length < 8)) return t + " too short";
            if (t.length > r) return "Exceeds length limit";
            const s = t.toLowerCase(),
              a = t.toUpperCase();
            if (t !== s && t !== a) return "Mixed-case string " + t;
            const u = (t = s).lastIndexOf("1");
            if (-1 === u) return "No separator character for " + t;
            if (0 === u) return "Missing prefix for " + t;
            const c = t.slice(0, u),
              f = t.slice(u + 1);
            if (f.length < 6) return "Data too short";
            let h = o(c);
            if ("string" == typeof h) return h;
            const l = [];
            for (let t = 0; t < f.length; ++t) {
              const e = f.charAt(t),
                r = n[e];
              if (void 0 === r) return "Unknown character " + e;
              (h = i(h) ^ r), t + 6 >= f.length || l.push(r);
            }
            return h !== e
              ? "Invalid checksum for " + t
              : { prefix: c, words: l };
          }
          return (
            (e = "bech32" === t ? 1 : 734539939),
            {
              decodeUnsafe: function (t, e) {
                const r = s(t, e);
                if ("object" == typeof r) return r;
              },
              decode: function (t, e) {
                const r = s(t, e);
                if ("object" == typeof r) return r;
                throw new Error(r);
              },
              encode: function (t, n, s) {
                if (((s = s || 90), t.length + 7 + n.length > s))
                  throw new TypeError("Exceeds length limit");
                let a = o((t = t.toLowerCase()));
                if ("string" == typeof a) throw new Error(a);
                let u = t + "1";
                for (let t = 0; t < n.length; ++t) {
                  const e = n[t];
                  if (e >> 5) throw new Error("Non 5-bit word");
                  (a = i(a) ^ e), (u += r.charAt(e));
                }
                for (let t = 0; t < 6; ++t) a = i(a);
                a ^= e;
                for (let t = 0; t < 6; ++t) {
                  u += r.charAt((a >> (5 * (5 - t))) & 31);
                }
                return u;
              },
              toWords: a,
              fromWordsUnsafe: u,
              fromWords: c,
            }
          );
        }
        (e.bech32 = f("bech32")), (e.bech32m = f("bech32m"));
      },
      61594: function (t, e, r) {
        var n;
        !(function () {
          "use strict";
          var i,
            o = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
            s = Math.ceil,
            a = Math.floor,
            u = "[BigNumber Error] ",
            c = u + "Number primitive has more than 15 significant digits: ",
            f = 1e14,
            h = 14,
            l = 9007199254740991,
            d = [
              1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12,
              1e13,
            ],
            p = 1e7,
            y = 1e9;
          function g(t) {
            var e = 0 | t;
            return t > 0 || t === e ? e : e - 1;
          }
          function m(t) {
            for (var e, r, n = 1, i = t.length, o = t[0] + ""; n < i; ) {
              for (e = t[n++] + "", r = h - e.length; r--; e = "0" + e);
              o += e;
            }
            for (i = o.length; 48 === o.charCodeAt(--i); );
            return o.slice(0, i + 1 || 1);
          }
          function b(t, e) {
            var r,
              n,
              i = t.c,
              o = e.c,
              s = t.s,
              a = e.s,
              u = t.e,
              c = e.e;
            if (!s || !a) return null;
            if (((r = i && !i[0]), (n = o && !o[0]), r || n))
              return r ? (n ? 0 : -a) : s;
            if (s != a) return s;
            if (((r = s < 0), (n = u == c), !i || !o))
              return n ? 0 : !i ^ r ? 1 : -1;
            if (!n) return (u > c) ^ r ? 1 : -1;
            for (a = (u = i.length) < (c = o.length) ? u : c, s = 0; s < a; s++)
              if (i[s] != o[s]) return (i[s] > o[s]) ^ r ? 1 : -1;
            return u == c ? 0 : (u > c) ^ r ? 1 : -1;
          }
          function w(t, e, r, n) {
            if (t < e || t > r || t !== a(t))
              throw Error(
                u +
                  (n || "Argument") +
                  ("number" == typeof t
                    ? t < e || t > r
                      ? " out of range: "
                      : " not an integer: "
                    : " not a primitive number: ") +
                  String(t),
              );
          }
          function v(t) {
            var e = t.c.length - 1;
            return g(t.e / h) == e && t.c[e] % 2 != 0;
          }
          function _(t, e) {
            return (
              (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) +
              (e < 0 ? "e" : "e+") +
              e
            );
          }
          function E(t, e, r) {
            var n, i;
            if (e < 0) {
              for (i = r + "."; ++e; i += r);
              t = i + t;
            } else if (++e > (n = t.length)) {
              for (i = r, e -= n; --e; i += r);
              t += i;
            } else e < n && (t = t.slice(0, e) + "." + t.slice(e));
            return t;
          }
          (i = (function t(e) {
            var r,
              n,
              i,
              S,
              I,
              M,
              A,
              T,
              k,
              O,
              x = (q.prototype = {
                constructor: q,
                toString: null,
                valueOf: null,
              }),
              P = new q(1),
              B = 20,
              C = 4,
              R = -7,
              N = 21,
              U = -1e7,
              D = 1e7,
              L = !1,
              j = 1,
              F = 0,
              H = {
                prefix: "",
                groupSize: 3,
                secondaryGroupSize: 0,
                groupSeparator: ",",
                decimalSeparator: ".",
                fractionGroupSize: 0,
                fractionGroupSeparator: " ",
                suffix: "",
              },
              K = "0123456789abcdefghijklmnopqrstuvwxyz",
              V = !0;
            function q(t, e) {
              var r,
                s,
                u,
                f,
                d,
                p,
                y,
                g,
                m = this;
              if (!(m instanceof q)) return new q(t, e);
              if (null == e) {
                if (t && !0 === t._isBigNumber)
                  return (
                    (m.s = t.s),
                    void (!t.c || t.e > D
                      ? (m.c = m.e = null)
                      : t.e < U
                        ? (m.c = [(m.e = 0)])
                        : ((m.e = t.e), (m.c = t.c.slice())))
                  );
                if ((p = "number" == typeof t) && 0 * t == 0) {
                  if (((m.s = 1 / t < 0 ? ((t = -t), -1) : 1), t === ~~t)) {
                    for (f = 0, d = t; d >= 10; d /= 10, f++);
                    return void (f > D
                      ? (m.c = m.e = null)
                      : ((m.e = f), (m.c = [t])));
                  }
                  g = String(t);
                } else {
                  if (!o.test((g = String(t)))) return i(m, g, p);
                  m.s = 45 == g.charCodeAt(0) ? ((g = g.slice(1)), -1) : 1;
                }
                (f = g.indexOf(".")) > -1 && (g = g.replace(".", "")),
                  (d = g.search(/e/i)) > 0
                    ? (f < 0 && (f = d),
                      (f += +g.slice(d + 1)),
                      (g = g.substring(0, d)))
                    : f < 0 && (f = g.length);
              } else {
                if ((w(e, 2, K.length, "Base"), 10 == e && V))
                  return W((m = new q(t)), B + m.e + 1, C);
                if (((g = String(t)), (p = "number" == typeof t))) {
                  if (0 * t != 0) return i(m, g, p, e);
                  if (
                    ((m.s = 1 / t < 0 ? ((g = g.slice(1)), -1) : 1),
                    q.DEBUG && g.replace(/^0\.0*|\./, "").length > 15)
                  )
                    throw Error(c + t);
                } else
                  m.s = 45 === g.charCodeAt(0) ? ((g = g.slice(1)), -1) : 1;
                for (r = K.slice(0, e), f = d = 0, y = g.length; d < y; d++)
                  if (r.indexOf((s = g.charAt(d))) < 0) {
                    if ("." == s) {
                      if (d > f) {
                        f = y;
                        continue;
                      }
                    } else if (
                      !u &&
                      ((g == g.toUpperCase() && (g = g.toLowerCase())) ||
                        (g == g.toLowerCase() && (g = g.toUpperCase())))
                    ) {
                      (u = !0), (d = -1), (f = 0);
                      continue;
                    }
                    return i(m, String(t), p, e);
                  }
                (p = !1),
                  (f = (g = n(g, e, 10, m.s)).indexOf(".")) > -1
                    ? (g = g.replace(".", ""))
                    : (f = g.length);
              }
              for (d = 0; 48 === g.charCodeAt(d); d++);
              for (y = g.length; 48 === g.charCodeAt(--y); );
              if ((g = g.slice(d, ++y))) {
                if (((y -= d), p && q.DEBUG && y > 15 && (t > l || t !== a(t))))
                  throw Error(c + m.s * t);
                if ((f = f - d - 1) > D) m.c = m.e = null;
                else if (f < U) m.c = [(m.e = 0)];
                else {
                  if (
                    ((m.e = f),
                    (m.c = []),
                    (d = (f + 1) % h),
                    f < 0 && (d += h),
                    d < y)
                  ) {
                    for (d && m.c.push(+g.slice(0, d)), y -= h; d < y; )
                      m.c.push(+g.slice(d, (d += h)));
                    d = h - (g = g.slice(d)).length;
                  } else d -= y;
                  for (; d--; g += "0");
                  m.c.push(+g);
                }
              } else m.c = [(m.e = 0)];
            }
            function z(t, e, r, n) {
              var i, o, s, a, u;
              if ((null == r ? (r = C) : w(r, 0, 8), !t.c)) return t.toString();
              if (((i = t.c[0]), (s = t.e), null == e))
                (u = m(t.c)),
                  (u =
                    1 == n || (2 == n && (s <= R || s >= N))
                      ? _(u, s)
                      : E(u, s, "0"));
              else if (
                ((o = (t = W(new q(t), e, r)).e),
                (a = (u = m(t.c)).length),
                1 == n || (2 == n && (e <= o || o <= R)))
              ) {
                for (; a < e; u += "0", a++);
                u = _(u, o);
              } else if (((e -= s), (u = E(u, o, "0")), o + 1 > a)) {
                if (--e > 0) for (u += "."; e--; u += "0");
              } else if ((e += o - a) > 0)
                for (o + 1 == a && (u += "."); e--; u += "0");
              return t.s < 0 && i ? "-" + u : u;
            }
            function $(t, e) {
              for (var r, n, i = 1, o = new q(t[0]); i < t.length; i++)
                (!(n = new q(t[i])).s ||
                  (r = b(o, n)) === e ||
                  (0 === r && o.s === e)) &&
                  (o = n);
              return o;
            }
            function G(t, e, r) {
              for (var n = 1, i = e.length; !e[--i]; e.pop());
              for (i = e[0]; i >= 10; i /= 10, n++);
              return (
                (r = n + r * h - 1) > D
                  ? (t.c = t.e = null)
                  : r < U
                    ? (t.c = [(t.e = 0)])
                    : ((t.e = r), (t.c = e)),
                t
              );
            }
            function W(t, e, r, n) {
              var i,
                o,
                u,
                c,
                l,
                p,
                y,
                g = t.c,
                m = d;
              if (g) {
                t: {
                  for (i = 1, c = g[0]; c >= 10; c /= 10, i++);
                  if ((o = e - i) < 0)
                    (o += h),
                      (u = e),
                      (l = g[(p = 0)]),
                      (y = a((l / m[i - u - 1]) % 10));
                  else if ((p = s((o + 1) / h)) >= g.length) {
                    if (!n) break t;
                    for (; g.length <= p; g.push(0));
                    (l = y = 0), (i = 1), (u = (o %= h) - h + 1);
                  } else {
                    for (l = c = g[p], i = 1; c >= 10; c /= 10, i++);
                    y =
                      (u = (o %= h) - h + i) < 0
                        ? 0
                        : a((l / m[i - u - 1]) % 10);
                  }
                  if (
                    ((n =
                      n ||
                      e < 0 ||
                      null != g[p + 1] ||
                      (u < 0 ? l : l % m[i - u - 1])),
                    (n =
                      r < 4
                        ? (y || n) && (0 == r || r == (t.s < 0 ? 3 : 2))
                        : y > 5 ||
                          (5 == y &&
                            (4 == r ||
                              n ||
                              (6 == r &&
                                (o > 0
                                  ? u > 0
                                    ? l / m[i - u]
                                    : 0
                                  : g[p - 1]) %
                                  10 &
                                  1) ||
                              r == (t.s < 0 ? 8 : 7)))),
                    e < 1 || !g[0])
                  )
                    return (
                      (g.length = 0),
                      n
                        ? ((e -= t.e + 1),
                          (g[0] = m[(h - (e % h)) % h]),
                          (t.e = -e || 0))
                        : (g[0] = t.e = 0),
                      t
                    );
                  if (
                    (0 == o
                      ? ((g.length = p), (c = 1), p--)
                      : ((g.length = p + 1),
                        (c = m[h - o]),
                        (g[p] = u > 0 ? a((l / m[i - u]) % m[u]) * c : 0)),
                    n)
                  )
                    for (;;) {
                      if (0 == p) {
                        for (o = 1, u = g[0]; u >= 10; u /= 10, o++);
                        for (u = g[0] += c, c = 1; u >= 10; u /= 10, c++);
                        o != c && (t.e++, g[0] == f && (g[0] = 1));
                        break;
                      }
                      if (((g[p] += c), g[p] != f)) break;
                      (g[p--] = 0), (c = 1);
                    }
                  for (o = g.length; 0 === g[--o]; g.pop());
                }
                t.e > D ? (t.c = t.e = null) : t.e < U && (t.c = [(t.e = 0)]);
              }
              return t;
            }
            function Y(t) {
              var e,
                r = t.e;
              return null === r
                ? t.toString()
                : ((e = m(t.c)),
                  (e = r <= R || r >= N ? _(e, r) : E(e, r, "0")),
                  t.s < 0 ? "-" + e : e);
            }
            return (
              (q.clone = t),
              (q.ROUND_UP = 0),
              (q.ROUND_DOWN = 1),
              (q.ROUND_CEIL = 2),
              (q.ROUND_FLOOR = 3),
              (q.ROUND_HALF_UP = 4),
              (q.ROUND_HALF_DOWN = 5),
              (q.ROUND_HALF_EVEN = 6),
              (q.ROUND_HALF_CEIL = 7),
              (q.ROUND_HALF_FLOOR = 8),
              (q.EUCLID = 9),
              (q.config = q.set =
                function (t) {
                  var e, r;
                  if (null != t) {
                    if ("object" != typeof t)
                      throw Error(u + "Object expected: " + t);
                    if (
                      (t.hasOwnProperty((e = "DECIMAL_PLACES")) &&
                        (w((r = t[e]), 0, y, e), (B = r)),
                      t.hasOwnProperty((e = "ROUNDING_MODE")) &&
                        (w((r = t[e]), 0, 8, e), (C = r)),
                      t.hasOwnProperty((e = "EXPONENTIAL_AT")) &&
                        ((r = t[e]) && r.pop
                          ? (w(r[0], -y, 0, e),
                            w(r[1], 0, y, e),
                            (R = r[0]),
                            (N = r[1]))
                          : (w(r, -y, y, e), (R = -(N = r < 0 ? -r : r)))),
                      t.hasOwnProperty((e = "RANGE")))
                    )
                      if ((r = t[e]) && r.pop)
                        w(r[0], -y, -1, e),
                          w(r[1], 1, y, e),
                          (U = r[0]),
                          (D = r[1]);
                      else {
                        if ((w(r, -y, y, e), !r))
                          throw Error(u + e + " cannot be zero: " + r);
                        U = -(D = r < 0 ? -r : r);
                      }
                    if (t.hasOwnProperty((e = "CRYPTO"))) {
                      if ((r = t[e]) !== !!r)
                        throw Error(u + e + " not true or false: " + r);
                      if (r) {
                        if (
                          "undefined" == typeof crypto ||
                          !crypto ||
                          (!crypto.getRandomValues && !crypto.randomBytes)
                        )
                          throw ((L = !r), Error(u + "crypto unavailable"));
                        L = r;
                      } else L = r;
                    }
                    if (
                      (t.hasOwnProperty((e = "MODULO_MODE")) &&
                        (w((r = t[e]), 0, 9, e), (j = r)),
                      t.hasOwnProperty((e = "POW_PRECISION")) &&
                        (w((r = t[e]), 0, y, e), (F = r)),
                      t.hasOwnProperty((e = "FORMAT")))
                    ) {
                      if ("object" != typeof (r = t[e]))
                        throw Error(u + e + " not an object: " + r);
                      H = r;
                    }
                    if (t.hasOwnProperty((e = "ALPHABET"))) {
                      if (
                        "string" != typeof (r = t[e]) ||
                        /^.?$|[+\-.\s]|(.).*\1/.test(r)
                      )
                        throw Error(u + e + " invalid: " + r);
                      (V = "0123456789" == r.slice(0, 10)), (K = r);
                    }
                  }
                  return {
                    DECIMAL_PLACES: B,
                    ROUNDING_MODE: C,
                    EXPONENTIAL_AT: [R, N],
                    RANGE: [U, D],
                    CRYPTO: L,
                    MODULO_MODE: j,
                    POW_PRECISION: F,
                    FORMAT: H,
                    ALPHABET: K,
                  };
                }),
              (q.isBigNumber = function (t) {
                if (!t || !0 !== t._isBigNumber) return !1;
                if (!q.DEBUG) return !0;
                var e,
                  r,
                  n = t.c,
                  i = t.e,
                  o = t.s;
                t: if ("[object Array]" == {}.toString.call(n)) {
                  if (
                    (1 === o || -1 === o) &&
                    i >= -y &&
                    i <= y &&
                    i === a(i)
                  ) {
                    if (0 === n[0]) {
                      if (0 === i && 1 === n.length) return !0;
                      break t;
                    }
                    if (
                      ((e = (i + 1) % h) < 1 && (e += h),
                      String(n[0]).length == e)
                    ) {
                      for (e = 0; e < n.length; e++)
                        if ((r = n[e]) < 0 || r >= f || r !== a(r)) break t;
                      if (0 !== r) return !0;
                    }
                  }
                } else if (
                  null === n &&
                  null === i &&
                  (null === o || 1 === o || -1 === o)
                )
                  return !0;
                throw Error(u + "Invalid BigNumber: " + t);
              }),
              (q.maximum = q.max =
                function () {
                  return $(arguments, -1);
                }),
              (q.minimum = q.min =
                function () {
                  return $(arguments, 1);
                }),
              (q.random =
                ((S = 9007199254740992),
                (I =
                  (Math.random() * S) & 2097151
                    ? function () {
                        return a(Math.random() * S);
                      }
                    : function () {
                        return (
                          8388608 * ((1073741824 * Math.random()) | 0) +
                          ((8388608 * Math.random()) | 0)
                        );
                      }),
                function (t) {
                  var e,
                    r,
                    n,
                    i,
                    o,
                    c = 0,
                    f = [],
                    l = new q(P);
                  if ((null == t ? (t = B) : w(t, 0, y), (i = s(t / h)), L))
                    if (crypto.getRandomValues) {
                      for (
                        e = crypto.getRandomValues(new Uint32Array((i *= 2)));
                        c < i;

                      )
                        (o = 131072 * e[c] + (e[c + 1] >>> 11)) >= 9e15
                          ? ((r = crypto.getRandomValues(new Uint32Array(2))),
                            (e[c] = r[0]),
                            (e[c + 1] = r[1]))
                          : (f.push(o % 1e14), (c += 2));
                      c = i / 2;
                    } else {
                      if (!crypto.randomBytes)
                        throw ((L = !1), Error(u + "crypto unavailable"));
                      for (e = crypto.randomBytes((i *= 7)); c < i; )
                        (o =
                          281474976710656 * (31 & e[c]) +
                          1099511627776 * e[c + 1] +
                          4294967296 * e[c + 2] +
                          16777216 * e[c + 3] +
                          (e[c + 4] << 16) +
                          (e[c + 5] << 8) +
                          e[c + 6]) >= 9e15
                          ? crypto.randomBytes(7).copy(e, c)
                          : (f.push(o % 1e14), (c += 7));
                      c = i / 7;
                    }
                  if (!L)
                    for (; c < i; ) (o = I()) < 9e15 && (f[c++] = o % 1e14);
                  for (
                    i = f[--c],
                      t %= h,
                      i && t && ((o = d[h - t]), (f[c] = a(i / o) * o));
                    0 === f[c];
                    f.pop(), c--
                  );
                  if (c < 0) f = [(n = 0)];
                  else {
                    for (n = -1; 0 === f[0]; f.splice(0, 1), n -= h);
                    for (c = 1, o = f[0]; o >= 10; o /= 10, c++);
                    c < h && (n -= h - c);
                  }
                  return (l.e = n), (l.c = f), l;
                })),
              (q.sum = function () {
                for (var t = 1, e = arguments, r = new q(e[0]); t < e.length; )
                  r = r.plus(e[t++]);
                return r;
              }),
              (n = (function () {
                var t = "0123456789";
                function e(t, e, r, n) {
                  for (var i, o, s = [0], a = 0, u = t.length; a < u; ) {
                    for (o = s.length; o--; s[o] *= e);
                    for (
                      s[0] += n.indexOf(t.charAt(a++)), i = 0;
                      i < s.length;
                      i++
                    )
                      s[i] > r - 1 &&
                        (null == s[i + 1] && (s[i + 1] = 0),
                        (s[i + 1] += (s[i] / r) | 0),
                        (s[i] %= r));
                  }
                  return s.reverse();
                }
                return function (n, i, o, s, a) {
                  var u,
                    c,
                    f,
                    h,
                    l,
                    d,
                    p,
                    y,
                    g = n.indexOf("."),
                    b = B,
                    w = C;
                  for (
                    g >= 0 &&
                      ((h = F),
                      (F = 0),
                      (n = n.replace(".", "")),
                      (d = (y = new q(i)).pow(n.length - g)),
                      (F = h),
                      (y.c = e(E(m(d.c), d.e, "0"), 10, o, t)),
                      (y.e = y.c.length)),
                      f = h =
                        (p = e(n, i, o, a ? ((u = K), t) : ((u = t), K)))
                          .length;
                    0 == p[--h];
                    p.pop()
                  );
                  if (!p[0]) return u.charAt(0);
                  if (
                    (g < 0
                      ? --f
                      : ((d.c = p),
                        (d.e = f),
                        (d.s = s),
                        (p = (d = r(d, y, b, w, o)).c),
                        (l = d.r),
                        (f = d.e)),
                    (g = p[(c = f + b + 1)]),
                    (h = o / 2),
                    (l = l || c < 0 || null != p[c + 1]),
                    (l =
                      w < 4
                        ? (null != g || l) && (0 == w || w == (d.s < 0 ? 3 : 2))
                        : g > h ||
                          (g == h &&
                            (4 == w ||
                              l ||
                              (6 == w && 1 & p[c - 1]) ||
                              w == (d.s < 0 ? 8 : 7)))),
                    c < 1 || !p[0])
                  )
                    n = l ? E(u.charAt(1), -b, u.charAt(0)) : u.charAt(0);
                  else {
                    if (((p.length = c), l))
                      for (--o; ++p[--c] > o; )
                        (p[c] = 0), c || (++f, (p = [1].concat(p)));
                    for (h = p.length; !p[--h]; );
                    for (g = 0, n = ""; g <= h; n += u.charAt(p[g++]));
                    n = E(n, f, u.charAt(0));
                  }
                  return n;
                };
              })()),
              (r = (function () {
                function t(t, e, r) {
                  var n,
                    i,
                    o,
                    s,
                    a = 0,
                    u = t.length,
                    c = e % p,
                    f = (e / p) | 0;
                  for (t = t.slice(); u--; )
                    (a =
                      (((i =
                        c * (o = t[u] % p) +
                        ((n = f * o + (s = (t[u] / p) | 0) * c) % p) * p +
                        a) /
                        r) |
                        0) +
                      ((n / p) | 0) +
                      f * s),
                      (t[u] = i % r);
                  return a && (t = [a].concat(t)), t;
                }
                function e(t, e, r, n) {
                  var i, o;
                  if (r != n) o = r > n ? 1 : -1;
                  else
                    for (i = o = 0; i < r; i++)
                      if (t[i] != e[i]) {
                        o = t[i] > e[i] ? 1 : -1;
                        break;
                      }
                  return o;
                }
                function r(t, e, r, n) {
                  for (var i = 0; r--; )
                    (t[r] -= i),
                      (i = t[r] < e[r] ? 1 : 0),
                      (t[r] = i * n + t[r] - e[r]);
                  for (; !t[0] && t.length > 1; t.splice(0, 1));
                }
                return function (n, i, o, s, u) {
                  var c,
                    l,
                    d,
                    p,
                    y,
                    m,
                    b,
                    w,
                    v,
                    _,
                    E,
                    S,
                    I,
                    M,
                    A,
                    T,
                    k,
                    O = n.s == i.s ? 1 : -1,
                    x = n.c,
                    P = i.c;
                  if (!(x && x[0] && P && P[0]))
                    return new q(
                      n.s && i.s && (x ? !P || x[0] != P[0] : P)
                        ? (x && 0 == x[0]) || !P
                          ? 0 * O
                          : O / 0
                        : NaN,
                    );
                  for (
                    v = (w = new q(O)).c = [],
                      O = o + (l = n.e - i.e) + 1,
                      u ||
                        ((u = f),
                        (l = g(n.e / h) - g(i.e / h)),
                        (O = (O / h) | 0)),
                      d = 0;
                    P[d] == (x[d] || 0);
                    d++
                  );
                  if ((P[d] > (x[d] || 0) && l--, O < 0)) v.push(1), (p = !0);
                  else {
                    for (
                      M = x.length,
                        T = P.length,
                        d = 0,
                        O += 2,
                        (y = a(u / (P[0] + 1))) > 1 &&
                          ((P = t(P, y, u)),
                          (x = t(x, y, u)),
                          (T = P.length),
                          (M = x.length)),
                        I = T,
                        E = (_ = x.slice(0, T)).length;
                      E < T;
                      _[E++] = 0
                    );
                    (k = P.slice()),
                      (k = [0].concat(k)),
                      (A = P[0]),
                      P[1] >= u / 2 && A++;
                    do {
                      if (((y = 0), (c = e(P, _, T, E)) < 0)) {
                        if (
                          ((S = _[0]),
                          T != E && (S = S * u + (_[1] || 0)),
                          (y = a(S / A)) > 1)
                        )
                          for (
                            y >= u && (y = u - 1),
                              b = (m = t(P, y, u)).length,
                              E = _.length;
                            1 == e(m, _, b, E);

                          )
                            y--,
                              r(m, T < b ? k : P, b, u),
                              (b = m.length),
                              (c = 1);
                        else
                          0 == y && (c = y = 1), (b = (m = P.slice()).length);
                        if (
                          (b < E && (m = [0].concat(m)),
                          r(_, m, E, u),
                          (E = _.length),
                          -1 == c)
                        )
                          for (; e(P, _, T, E) < 1; )
                            y++, r(_, T < E ? k : P, E, u), (E = _.length);
                      } else 0 === c && (y++, (_ = [0]));
                      (v[d++] = y),
                        _[0] ? (_[E++] = x[I] || 0) : ((_ = [x[I]]), (E = 1));
                    } while ((I++ < M || null != _[0]) && O--);
                    (p = null != _[0]), v[0] || v.splice(0, 1);
                  }
                  if (u == f) {
                    for (d = 1, O = v[0]; O >= 10; O /= 10, d++);
                    W(w, o + (w.e = d + l * h - 1) + 1, s, p);
                  } else (w.e = l), (w.r = +p);
                  return w;
                };
              })()),
              (M = /^(-?)0([xbo])(?=\w[\w.]*$)/i),
              (A = /^([^.]+)\.$/),
              (T = /^\.([^.]+)$/),
              (k = /^-?(Infinity|NaN)$/),
              (O = /^\s*\+(?=[\w.])|^\s+|\s+$/g),
              (i = function (t, e, r, n) {
                var i,
                  o = r ? e : e.replace(O, "");
                if (k.test(o)) t.s = isNaN(o) ? null : o < 0 ? -1 : 1;
                else {
                  if (
                    !r &&
                    ((o = o.replace(M, function (t, e, r) {
                      return (
                        (i =
                          "x" == (r = r.toLowerCase()) ? 16 : "b" == r ? 2 : 8),
                        n && n != i ? t : e
                      );
                    })),
                    n && ((i = n), (o = o.replace(A, "$1").replace(T, "0.$1"))),
                    e != o)
                  )
                    return new q(o, i);
                  if (q.DEBUG)
                    throw Error(
                      u + "Not a" + (n ? " base " + n : "") + " number: " + e,
                    );
                  t.s = null;
                }
                t.c = t.e = null;
              }),
              (x.absoluteValue = x.abs =
                function () {
                  var t = new q(this);
                  return t.s < 0 && (t.s = 1), t;
                }),
              (x.comparedTo = function (t, e) {
                return b(this, new q(t, e));
              }),
              (x.decimalPlaces = x.dp =
                function (t, e) {
                  var r,
                    n,
                    i,
                    o = this;
                  if (null != t)
                    return (
                      w(t, 0, y),
                      null == e ? (e = C) : w(e, 0, 8),
                      W(new q(o), t + o.e + 1, e)
                    );
                  if (!(r = o.c)) return null;
                  if (
                    ((n = ((i = r.length - 1) - g(this.e / h)) * h), (i = r[i]))
                  )
                    for (; i % 10 == 0; i /= 10, n--);
                  return n < 0 && (n = 0), n;
                }),
              (x.dividedBy = x.div =
                function (t, e) {
                  return r(this, new q(t, e), B, C);
                }),
              (x.dividedToIntegerBy = x.idiv =
                function (t, e) {
                  return r(this, new q(t, e), 0, 1);
                }),
              (x.exponentiatedBy = x.pow =
                function (t, e) {
                  var r,
                    n,
                    i,
                    o,
                    c,
                    f,
                    l,
                    d,
                    p = this;
                  if ((t = new q(t)).c && !t.isInteger())
                    throw Error(u + "Exponent not an integer: " + Y(t));
                  if (
                    (null != e && (e = new q(e)),
                    (c = t.e > 14),
                    !p.c ||
                      !p.c[0] ||
                      (1 == p.c[0] && !p.e && 1 == p.c.length) ||
                      !t.c ||
                      !t.c[0])
                  )
                    return (
                      (d = new q(
                        Math.pow(+Y(p), c ? t.s * (2 - v(t)) : +Y(t)),
                      )),
                      e ? d.mod(e) : d
                    );
                  if (((f = t.s < 0), e)) {
                    if (e.c ? !e.c[0] : !e.s) return new q(NaN);
                    (n = !f && p.isInteger() && e.isInteger()) &&
                      (p = p.mod(e));
                  } else {
                    if (
                      t.e > 9 &&
                      (p.e > 0 ||
                        p.e < -1 ||
                        (0 == p.e
                          ? p.c[0] > 1 || (c && p.c[1] >= 24e7)
                          : p.c[0] < 8e13 || (c && p.c[0] <= 9999975e7)))
                    )
                      return (
                        (o = p.s < 0 && v(t) ? -0 : 0),
                        p.e > -1 && (o = 1 / o),
                        new q(f ? 1 / o : o)
                      );
                    F && (o = s(F / h + 2));
                  }
                  for (
                    c
                      ? ((r = new q(0.5)), f && (t.s = 1), (l = v(t)))
                      : (l = (i = Math.abs(+Y(t))) % 2),
                      d = new q(P);
                    ;

                  ) {
                    if (l) {
                      if (!(d = d.times(p)).c) break;
                      o
                        ? d.c.length > o && (d.c.length = o)
                        : n && (d = d.mod(e));
                    }
                    if (i) {
                      if (0 === (i = a(i / 2))) break;
                      l = i % 2;
                    } else if ((W((t = t.times(r)), t.e + 1, 1), t.e > 14))
                      l = v(t);
                    else {
                      if (0 === (i = +Y(t))) break;
                      l = i % 2;
                    }
                    (p = p.times(p)),
                      o
                        ? p.c && p.c.length > o && (p.c.length = o)
                        : n && (p = p.mod(e));
                  }
                  return n
                    ? d
                    : (f && (d = P.div(d)),
                      e ? d.mod(e) : o ? W(d, F, C, undefined) : d);
                }),
              (x.integerValue = function (t) {
                var e = new q(this);
                return null == t ? (t = C) : w(t, 0, 8), W(e, e.e + 1, t);
              }),
              (x.isEqualTo = x.eq =
                function (t, e) {
                  return 0 === b(this, new q(t, e));
                }),
              (x.isFinite = function () {
                return !!this.c;
              }),
              (x.isGreaterThan = x.gt =
                function (t, e) {
                  return b(this, new q(t, e)) > 0;
                }),
              (x.isGreaterThanOrEqualTo = x.gte =
                function (t, e) {
                  return 1 === (e = b(this, new q(t, e))) || 0 === e;
                }),
              (x.isInteger = function () {
                return !!this.c && g(this.e / h) > this.c.length - 2;
              }),
              (x.isLessThan = x.lt =
                function (t, e) {
                  return b(this, new q(t, e)) < 0;
                }),
              (x.isLessThanOrEqualTo = x.lte =
                function (t, e) {
                  return -1 === (e = b(this, new q(t, e))) || 0 === e;
                }),
              (x.isNaN = function () {
                return !this.s;
              }),
              (x.isNegative = function () {
                return this.s < 0;
              }),
              (x.isPositive = function () {
                return this.s > 0;
              }),
              (x.isZero = function () {
                return !!this.c && 0 == this.c[0];
              }),
              (x.minus = function (t, e) {
                var r,
                  n,
                  i,
                  o,
                  s = this,
                  a = s.s;
                if (((e = (t = new q(t, e)).s), !a || !e)) return new q(NaN);
                if (a != e) return (t.s = -e), s.plus(t);
                var u = s.e / h,
                  c = t.e / h,
                  l = s.c,
                  d = t.c;
                if (!u || !c) {
                  if (!l || !d) return l ? ((t.s = -e), t) : new q(d ? s : NaN);
                  if (!l[0] || !d[0])
                    return d[0]
                      ? ((t.s = -e), t)
                      : new q(l[0] ? s : 3 == C ? -0 : 0);
                }
                if (((u = g(u)), (c = g(c)), (l = l.slice()), (a = u - c))) {
                  for (
                    (o = a < 0) ? ((a = -a), (i = l)) : ((c = u), (i = d)),
                      i.reverse(),
                      e = a;
                    e--;
                    i.push(0)
                  );
                  i.reverse();
                } else
                  for (
                    n = (o = (a = l.length) < (e = d.length)) ? a : e,
                      a = e = 0;
                    e < n;
                    e++
                  )
                    if (l[e] != d[e]) {
                      o = l[e] < d[e];
                      break;
                    }
                if (
                  (o && ((i = l), (l = d), (d = i), (t.s = -t.s)),
                  (e = (n = d.length) - (r = l.length)) > 0)
                )
                  for (; e--; l[r++] = 0);
                for (e = f - 1; n > a; ) {
                  if (l[--n] < d[n]) {
                    for (r = n; r && !l[--r]; l[r] = e);
                    --l[r], (l[n] += f);
                  }
                  l[n] -= d[n];
                }
                for (; 0 == l[0]; l.splice(0, 1), --c);
                return l[0]
                  ? G(t, l, c)
                  : ((t.s = 3 == C ? -1 : 1), (t.c = [(t.e = 0)]), t);
              }),
              (x.modulo = x.mod =
                function (t, e) {
                  var n,
                    i,
                    o = this;
                  return (
                    (t = new q(t, e)),
                    !o.c || !t.s || (t.c && !t.c[0])
                      ? new q(NaN)
                      : !t.c || (o.c && !o.c[0])
                        ? new q(o)
                        : (9 == j
                            ? ((i = t.s),
                              (t.s = 1),
                              (n = r(o, t, 0, 3)),
                              (t.s = i),
                              (n.s *= i))
                            : (n = r(o, t, 0, j)),
                          (t = o.minus(n.times(t))).c[0] ||
                            1 != j ||
                            (t.s = o.s),
                          t)
                  );
                }),
              (x.multipliedBy = x.times =
                function (t, e) {
                  var r,
                    n,
                    i,
                    o,
                    s,
                    a,
                    u,
                    c,
                    l,
                    d,
                    y,
                    m,
                    b,
                    w,
                    v,
                    _ = this,
                    E = _.c,
                    S = (t = new q(t, e)).c;
                  if (!(E && S && E[0] && S[0]))
                    return (
                      !_.s || !t.s || (E && !E[0] && !S) || (S && !S[0] && !E)
                        ? (t.c = t.e = t.s = null)
                        : ((t.s *= _.s),
                          E && S
                            ? ((t.c = [0]), (t.e = 0))
                            : (t.c = t.e = null)),
                      t
                    );
                  for (
                    n = g(_.e / h) + g(t.e / h),
                      t.s *= _.s,
                      (u = E.length) < (d = S.length) &&
                        ((b = E), (E = S), (S = b), (i = u), (u = d), (d = i)),
                      i = u + d,
                      b = [];
                    i--;
                    b.push(0)
                  );
                  for (w = f, v = p, i = d; --i >= 0; ) {
                    for (
                      r = 0, y = S[i] % v, m = (S[i] / v) | 0, o = i + (s = u);
                      o > i;

                    )
                      (r =
                        (((c =
                          y * (c = E[--s] % v) +
                          ((a = m * c + (l = (E[s] / v) | 0) * y) % v) * v +
                          b[o] +
                          r) /
                          w) |
                          0) +
                        ((a / v) | 0) +
                        m * l),
                        (b[o--] = c % w);
                    b[o] = r;
                  }
                  return r ? ++n : b.splice(0, 1), G(t, b, n);
                }),
              (x.negated = function () {
                var t = new q(this);
                return (t.s = -t.s || null), t;
              }),
              (x.plus = function (t, e) {
                var r,
                  n = this,
                  i = n.s;
                if (((e = (t = new q(t, e)).s), !i || !e)) return new q(NaN);
                if (i != e) return (t.s = -e), n.minus(t);
                var o = n.e / h,
                  s = t.e / h,
                  a = n.c,
                  u = t.c;
                if (!o || !s) {
                  if (!a || !u) return new q(i / 0);
                  if (!a[0] || !u[0]) return u[0] ? t : new q(a[0] ? n : 0 * i);
                }
                if (((o = g(o)), (s = g(s)), (a = a.slice()), (i = o - s))) {
                  for (
                    i > 0 ? ((s = o), (r = u)) : ((i = -i), (r = a)),
                      r.reverse();
                    i--;
                    r.push(0)
                  );
                  r.reverse();
                }
                for (
                  (i = a.length) - (e = u.length) < 0 &&
                    ((r = u), (u = a), (a = r), (e = i)),
                    i = 0;
                  e;

                )
                  (i = ((a[--e] = a[e] + u[e] + i) / f) | 0),
                    (a[e] = f === a[e] ? 0 : a[e] % f);
                return i && ((a = [i].concat(a)), ++s), G(t, a, s);
              }),
              (x.precision = x.sd =
                function (t, e) {
                  var r,
                    n,
                    i,
                    o = this;
                  if (null != t && t !== !!t)
                    return (
                      w(t, 1, y),
                      null == e ? (e = C) : w(e, 0, 8),
                      W(new q(o), t, e)
                    );
                  if (!(r = o.c)) return null;
                  if (((n = (i = r.length - 1) * h + 1), (i = r[i]))) {
                    for (; i % 10 == 0; i /= 10, n--);
                    for (i = r[0]; i >= 10; i /= 10, n++);
                  }
                  return t && o.e + 1 > n && (n = o.e + 1), n;
                }),
              (x.shiftedBy = function (t) {
                return w(t, -9007199254740991, l), this.times("1e" + t);
              }),
              (x.squareRoot = x.sqrt =
                function () {
                  var t,
                    e,
                    n,
                    i,
                    o,
                    s = this,
                    a = s.c,
                    u = s.s,
                    c = s.e,
                    f = B + 4,
                    h = new q("0.5");
                  if (1 !== u || !a || !a[0])
                    return new q(
                      !u || (u < 0 && (!a || a[0])) ? NaN : a ? s : 1 / 0,
                    );
                  if (
                    (0 == (u = Math.sqrt(+Y(s))) || u == 1 / 0
                      ? (((e = m(a)).length + c) % 2 == 0 && (e += "0"),
                        (u = Math.sqrt(+e)),
                        (c = g((c + 1) / 2) - (c < 0 || c % 2)),
                        (n = new q(
                          (e =
                            u == 1 / 0
                              ? "5e" + c
                              : (e = u.toExponential()).slice(
                                  0,
                                  e.indexOf("e") + 1,
                                ) + c),
                        )))
                      : (n = new q(u + "")),
                    n.c[0])
                  )
                    for ((u = (c = n.e) + f) < 3 && (u = 0); ; )
                      if (
                        ((o = n),
                        (n = h.times(o.plus(r(s, o, f, 1)))),
                        m(o.c).slice(0, u) === (e = m(n.c)).slice(0, u))
                      ) {
                        if (
                          (n.e < c && --u,
                          "9999" != (e = e.slice(u - 3, u + 1)) &&
                            (i || "4999" != e))
                        ) {
                          (+e && (+e.slice(1) || "5" != e.charAt(0))) ||
                            (W(n, n.e + B + 2, 1), (t = !n.times(n).eq(s)));
                          break;
                        }
                        if (!i && (W(o, o.e + B + 2, 0), o.times(o).eq(s))) {
                          n = o;
                          break;
                        }
                        (f += 4), (u += 4), (i = 1);
                      }
                  return W(n, n.e + B + 1, C, t);
                }),
              (x.toExponential = function (t, e) {
                return null != t && (w(t, 0, y), t++), z(this, t, e, 1);
              }),
              (x.toFixed = function (t, e) {
                return (
                  null != t && (w(t, 0, y), (t = t + this.e + 1)), z(this, t, e)
                );
              }),
              (x.toFormat = function (t, e, r) {
                var n,
                  i = this;
                if (null == r)
                  null != t && e && "object" == typeof e
                    ? ((r = e), (e = null))
                    : t && "object" == typeof t
                      ? ((r = t), (t = e = null))
                      : (r = H);
                else if ("object" != typeof r)
                  throw Error(u + "Argument not an object: " + r);
                if (((n = i.toFixed(t, e)), i.c)) {
                  var o,
                    s = n.split("."),
                    a = +r.groupSize,
                    c = +r.secondaryGroupSize,
                    f = r.groupSeparator || "",
                    h = s[0],
                    l = s[1],
                    d = i.s < 0,
                    p = d ? h.slice(1) : h,
                    y = p.length;
                  if (
                    (c && ((o = a), (a = c), (c = o), (y -= o)), a > 0 && y > 0)
                  ) {
                    for (o = y % a || a, h = p.substr(0, o); o < y; o += a)
                      h += f + p.substr(o, a);
                    c > 0 && (h += f + p.slice(o)), d && (h = "-" + h);
                  }
                  n = l
                    ? h +
                      (r.decimalSeparator || "") +
                      ((c = +r.fractionGroupSize)
                        ? l.replace(
                            new RegExp("\\d{" + c + "}\\B", "g"),
                            "$&" + (r.fractionGroupSeparator || ""),
                          )
                        : l)
                    : h;
                }
                return (r.prefix || "") + n + (r.suffix || "");
              }),
              (x.toFraction = function (t) {
                var e,
                  n,
                  i,
                  o,
                  s,
                  a,
                  c,
                  f,
                  l,
                  p,
                  y,
                  g,
                  b = this,
                  w = b.c;
                if (
                  null != t &&
                  ((!(c = new q(t)).isInteger() && (c.c || 1 !== c.s)) ||
                    c.lt(P))
                )
                  throw Error(
                    u +
                      "Argument " +
                      (c.isInteger() ? "out of range: " : "not an integer: ") +
                      Y(c),
                  );
                if (!w) return new q(b);
                for (
                  e = new q(P),
                    l = n = new q(P),
                    i = f = new q(P),
                    g = m(w),
                    s = e.e = g.length - b.e - 1,
                    e.c[0] = d[(a = s % h) < 0 ? h + a : a],
                    t = !t || c.comparedTo(e) > 0 ? (s > 0 ? e : l) : c,
                    a = D,
                    D = 1 / 0,
                    c = new q(g),
                    f.c[0] = 0;
                  (p = r(c, e, 0, 1)),
                    1 != (o = n.plus(p.times(i))).comparedTo(t);

                )
                  (n = i),
                    (i = o),
                    (l = f.plus(p.times((o = l)))),
                    (f = o),
                    (e = c.minus(p.times((o = e)))),
                    (c = o);
                return (
                  (o = r(t.minus(n), i, 0, 1)),
                  (f = f.plus(o.times(l))),
                  (n = n.plus(o.times(i))),
                  (f.s = l.s = b.s),
                  (y =
                    r(l, i, (s *= 2), C)
                      .minus(b)
                      .abs()
                      .comparedTo(r(f, n, s, C).minus(b).abs()) < 1
                      ? [l, i]
                      : [f, n]),
                  (D = a),
                  y
                );
              }),
              (x.toNumber = function () {
                return +Y(this);
              }),
              (x.toPrecision = function (t, e) {
                return null != t && w(t, 1, y), z(this, t, e, 2);
              }),
              (x.toString = function (t) {
                var e,
                  r = this,
                  i = r.s,
                  o = r.e;
                return (
                  null === o
                    ? i
                      ? ((e = "Infinity"), i < 0 && (e = "-" + e))
                      : (e = "NaN")
                    : (null == t
                        ? (e =
                            o <= R || o >= N ? _(m(r.c), o) : E(m(r.c), o, "0"))
                        : 10 === t && V
                          ? (e = E(
                              m((r = W(new q(r), B + o + 1, C)).c),
                              r.e,
                              "0",
                            ))
                          : (w(t, 2, K.length, "Base"),
                            (e = n(E(m(r.c), o, "0"), 10, t, i, !0))),
                      i < 0 && r.c[0] && (e = "-" + e)),
                  e
                );
              }),
              (x.valueOf = x.toJSON =
                function () {
                  return Y(this);
                }),
              (x._isBigNumber = !0),
              null != e && q.set(e),
              q
            );
          })()),
            (i.default = i.BigNumber = i),
            void 0 ===
              (n = function () {
                return i;
              }.call(e, r, e, t)) || (t.exports = n);
        })();
      },
      64863: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const n = r(91457);
        function i(t, e, r) {
          return (n) => {
            if (t.has(n)) return;
            const i = r.filter((t) => t.key.toString("hex") === n)[0];
            e.push(i), t.add(n);
          };
        }
        function o(t) {
          return t.globalMap.unsignedTx;
        }
        function s(t) {
          const e = new Set();
          return (
            t.forEach((t) => {
              const r = t.key.toString("hex");
              if (e.has(r))
                throw new Error("Combine: KeyValue Map keys should be unique");
              e.add(r);
            }),
            e
          );
        }
        e.combine = function (t) {
          const e = t[0],
            r = n.psbtToKeyVals(e),
            a = t.slice(1);
          if (0 === a.length) throw new Error("Combine: Nothing to combine");
          const u = o(e);
          if (void 0 === u)
            throw new Error("Combine: Self missing transaction");
          const c = s(r.globalKeyVals),
            f = r.inputKeyVals.map(s),
            h = r.outputKeyVals.map(s);
          for (const t of a) {
            const e = o(t);
            if (void 0 === e || !e.toBuffer().equals(u.toBuffer()))
              throw new Error(
                "Combine: One of the Psbts does not have the same transaction.",
              );
            const a = n.psbtToKeyVals(t);
            s(a.globalKeyVals).forEach(i(c, r.globalKeyVals, a.globalKeyVals));
            a.inputKeyVals
              .map(s)
              .forEach((t, e) =>
                t.forEach(i(f[e], r.inputKeyVals[e], a.inputKeyVals[e])),
              );
            a.outputKeyVals
              .map(s)
              .forEach((t, e) =>
                t.forEach(i(h[e], r.outputKeyVals[e], a.outputKeyVals[e])),
              );
          }
          return n.psbtFromKeyVals(u, {
            globalMapKeyVals: r.globalKeyVals,
            inputKeyVals: r.inputKeyVals,
            outputKeyVals: r.outputKeyVals,
          });
        };
      },
      4834: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.GlobalTypes.GLOBAL_XPUB)
            throw new Error(
              "Decode Error: could not decode globalXpub with key 0x" +
                t.key.toString("hex"),
            );
          if (79 !== t.key.length || ![2, 3].includes(t.key[46]))
            throw new Error(
              "Decode Error: globalXpub has invalid extended pubkey in key 0x" +
                t.key.toString("hex"),
            );
          if ((t.value.length / 4) % 1 != 0)
            throw new Error(
              "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4",
            );
          const e = t.key.slice(1),
            r = {
              masterFingerprint: t.value.slice(0, 4),
              extendedPubkey: e,
              path: "m",
            };
          for (const e of ((n = t.value.length / 4 - 1),
          [...Array(n).keys()])) {
            const n = t.value.readUInt32LE(4 * e + 4),
              i = !!(2147483648 & n),
              o = 2147483647 & n;
            r.path += "/" + o.toString(10) + (i ? "'" : "");
          }
          var n;
          return r;
        }),
          (e.encode = function (t) {
            const e = n.from([i.GlobalTypes.GLOBAL_XPUB]),
              r = n.concat([e, t.extendedPubkey]),
              o = t.path.split("/"),
              s = n.allocUnsafe(4 * o.length);
            t.masterFingerprint.copy(s, 0);
            let a = 4;
            return (
              o.slice(1).forEach((t) => {
                const e = "'" === t.slice(-1);
                let r = 2147483647 & parseInt(e ? t.slice(0, -1) : t, 10);
                e && (r += 2147483648), s.writeUInt32LE(r, a), (a += 4);
              }),
              { key: r, value: s }
            );
          }),
          (e.expected =
            "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }"),
          (e.check = function (t) {
            const e = t.extendedPubkey,
              r = t.masterFingerprint,
              i = t.path;
            return (
              n.isBuffer(e) &&
              78 === e.length &&
              [2, 3].indexOf(e[45]) > -1 &&
              n.isBuffer(r) &&
              4 === r.length &&
              "string" == typeof i &&
              !!i.match(/^m(\/\d+'?)*$/)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = e.extendedPubkey.toString("hex");
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter((t) => t.extendedPubkey.equals(e.extendedPubkey))
                  .length)
            );
          });
      },
      4213: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        e.encode = function (t) {
          return {
            key: n.from([i.GlobalTypes.UNSIGNED_TX]),
            value: t.toBuffer(),
          };
        };
      },
      22706: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const n = r(99080),
          i = r(4834),
          o = r(4213),
          s = r(76605),
          a = r(71795),
          u = r(4431),
          c = r(66907),
          f = r(95949),
          h = r(59344),
          l = r(72760),
          d = r(81695),
          p = r(98454),
          y = r(19034),
          g = r(82926),
          m = r(77851),
          b = r(97545),
          w = r(22412),
          v = r(54307),
          _ = r(87636),
          E = r(22223),
          S = r(75578),
          I = { unsignedTx: o, globalXpub: i, checkPubkey: w.makeChecker([]) };
        e.globals = I;
        const M = {
          nonWitnessUtxo: u,
          partialSig: c,
          sighashType: h,
          finalScriptSig: s,
          finalScriptWitness: a,
          porCommitment: f,
          witnessUtxo: g,
          bip32Derivation: b.makeConverter(n.InputTypes.BIP32_DERIVATION),
          redeemScript: v.makeConverter(n.InputTypes.REDEEM_SCRIPT),
          witnessScript: S.makeConverter(n.InputTypes.WITNESS_SCRIPT),
          checkPubkey: w.makeChecker([
            n.InputTypes.PARTIAL_SIG,
            n.InputTypes.BIP32_DERIVATION,
          ]),
          tapKeySig: l,
          tapScriptSig: y,
          tapLeafScript: d,
          tapBip32Derivation: _.makeConverter(
            n.InputTypes.TAP_BIP32_DERIVATION,
          ),
          tapInternalKey: E.makeConverter(n.InputTypes.TAP_INTERNAL_KEY),
          tapMerkleRoot: p,
        };
        e.inputs = M;
        const A = {
          bip32Derivation: b.makeConverter(n.OutputTypes.BIP32_DERIVATION),
          redeemScript: v.makeConverter(n.OutputTypes.REDEEM_SCRIPT),
          witnessScript: S.makeConverter(n.OutputTypes.WITNESS_SCRIPT),
          checkPubkey: w.makeChecker([n.OutputTypes.BIP32_DERIVATION]),
          tapBip32Derivation: _.makeConverter(
            n.OutputTypes.TAP_BIP32_DERIVATION,
          ),
          tapTree: m,
          tapInternalKey: E.makeConverter(n.OutputTypes.TAP_INTERNAL_KEY),
        };
        e.outputs = A;
      },
      76605: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.FINAL_SCRIPTSIG)
            throw new Error(
              "Decode Error: could not decode finalScriptSig with key 0x" +
                t.key.toString("hex"),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return { key: n.from([i.InputTypes.FINAL_SCRIPTSIG]), value: t };
          }),
          (e.expected = "Buffer"),
          (e.check = function (t) {
            return n.isBuffer(t);
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.finalScriptSig;
          });
      },
      71795: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.FINAL_SCRIPTWITNESS)
            throw new Error(
              "Decode Error: could not decode finalScriptWitness with key 0x" +
                t.key.toString("hex"),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: n.from([i.InputTypes.FINAL_SCRIPTWITNESS]),
              value: t,
            };
          }),
          (e.expected = "Buffer"),
          (e.check = function (t) {
            return n.isBuffer(t);
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.finalScriptWitness;
          });
      },
      4431: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.NON_WITNESS_UTXO)
            throw new Error(
              "Decode Error: could not decode nonWitnessUtxo with key 0x" +
                t.key.toString("hex"),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return { key: n.from([i.InputTypes.NON_WITNESS_UTXO]), value: t };
          }),
          (e.expected = "Buffer"),
          (e.check = function (t) {
            return n.isBuffer(t);
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.nonWitnessUtxo;
          });
      },
      66907: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.PARTIAL_SIG)
            throw new Error(
              "Decode Error: could not decode partialSig with key 0x" +
                t.key.toString("hex"),
            );
          if (
            (34 !== t.key.length && 66 !== t.key.length) ||
            ![2, 3, 4].includes(t.key[1])
          )
            throw new Error(
              "Decode Error: partialSig has invalid pubkey in key 0x" +
                t.key.toString("hex"),
            );
          return { pubkey: t.key.slice(1), signature: t.value };
        }),
          (e.encode = function (t) {
            const e = n.from([i.InputTypes.PARTIAL_SIG]);
            return { key: n.concat([e, t.pubkey]), value: t.signature };
          }),
          (e.expected = "{ pubkey: Buffer; signature: Buffer; }"),
          (e.check = function (t) {
            return (
              n.isBuffer(t.pubkey) &&
              n.isBuffer(t.signature) &&
              [33, 65].includes(t.pubkey.length) &&
              [2, 3, 4].includes(t.pubkey[0]) &&
              (function (t) {
                if (!n.isBuffer(t) || t.length < 9) return !1;
                if (48 !== t[0]) return !1;
                if (t.length !== t[1] + 3) return !1;
                if (2 !== t[2]) return !1;
                const e = t[3];
                if (e > 33 || e < 1) return !1;
                if (2 !== t[3 + e + 1]) return !1;
                const r = t[3 + e + 2];
                return !(r > 33 || r < 1) && t.length === 3 + e + 2 + r + 2;
              })(t.signature)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = e.pubkey.toString("hex");
            return (
              !r.has(n) &&
              (r.add(n),
              0 === t.filter((t) => t.pubkey.equals(e.pubkey)).length)
            );
          });
      },
      95949: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.POR_COMMITMENT)
            throw new Error(
              "Decode Error: could not decode porCommitment with key 0x" +
                t.key.toString("hex"),
            );
          return t.value.toString("utf8");
        }),
          (e.encode = function (t) {
            return {
              key: n.from([i.InputTypes.POR_COMMITMENT]),
              value: n.from(t, "utf8"),
            };
          }),
          (e.expected = "string"),
          (e.check = function (t) {
            return "string" == typeof t;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.porCommitment;
          });
      },
      59344: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.SIGHASH_TYPE)
            throw new Error(
              "Decode Error: could not decode sighashType with key 0x" +
                t.key.toString("hex"),
            );
          return t.value.readUInt32LE(0);
        }),
          (e.encode = function (t) {
            const e = n.from([i.InputTypes.SIGHASH_TYPE]),
              r = n.allocUnsafe(4);
            return r.writeUInt32LE(t, 0), { key: e, value: r };
          }),
          (e.expected = "number"),
          (e.check = function (t) {
            return "number" == typeof t;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.sighashType;
          });
      },
      72760: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        function o(t) {
          return n.isBuffer(t) && (64 === t.length || 65 === t.length);
        }
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_KEY_SIG || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapKeySig with key 0x" +
                t.key.toString("hex"),
            );
          if (!o(t.value))
            throw new Error(
              "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature",
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return { key: n.from([i.InputTypes.TAP_KEY_SIG]), value: t };
          }),
          (e.expected = "Buffer"),
          (e.check = o),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapKeySig;
          });
      },
      81695: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_LEAF_SCRIPT)
            throw new Error(
              "Decode Error: could not decode tapLeafScript with key 0x" +
                t.key.toString("hex"),
            );
          if ((t.key.length - 2) % 32 != 0)
            throw new Error(
              "Decode Error: tapLeafScript has invalid control block in key 0x" +
                t.key.toString("hex"),
            );
          const e = t.value[t.value.length - 1];
          if ((254 & t.key[1]) !== e)
            throw new Error(
              "Decode Error: tapLeafScript bad leaf version in key 0x" +
                t.key.toString("hex"),
            );
          const r = t.value.slice(0, -1);
          return { controlBlock: t.key.slice(1), script: r, leafVersion: e };
        }),
          (e.encode = function (t) {
            const e = n.from([i.InputTypes.TAP_LEAF_SCRIPT]),
              r = n.from([t.leafVersion]);
            return {
              key: n.concat([e, t.controlBlock]),
              value: n.concat([t.script, r]),
            };
          }),
          (e.expected =
            "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }"),
          (e.check = function (t) {
            return (
              n.isBuffer(t.controlBlock) &&
              (t.controlBlock.length - 1) % 32 == 0 &&
              (254 & t.controlBlock[0]) === t.leafVersion &&
              n.isBuffer(t.script)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = e.controlBlock.toString("hex");
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter((t) => t.controlBlock.equals(e.controlBlock)).length)
            );
          });
      },
      98454: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        function o(t) {
          return n.isBuffer(t) && 32 === t.length;
        }
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_MERKLE_ROOT || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapMerkleRoot with key 0x" +
                t.key.toString("hex"),
            );
          if (!o(t.value))
            throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
          return t.value;
        }),
          (e.encode = function (t) {
            return { key: n.from([i.InputTypes.TAP_MERKLE_ROOT]), value: t };
          }),
          (e.expected = "Buffer"),
          (e.check = o),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapMerkleRoot;
          });
      },
      19034: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_SCRIPT_SIG)
            throw new Error(
              "Decode Error: could not decode tapScriptSig with key 0x" +
                t.key.toString("hex"),
            );
          if (65 !== t.key.length)
            throw new Error(
              "Decode Error: tapScriptSig has invalid key 0x" +
                t.key.toString("hex"),
            );
          if (64 !== t.value.length && 65 !== t.value.length)
            throw new Error(
              "Decode Error: tapScriptSig has invalid signature in key 0x" +
                t.key.toString("hex"),
            );
          return {
            pubkey: t.key.slice(1, 33),
            leafHash: t.key.slice(33),
            signature: t.value,
          };
        }),
          (e.encode = function (t) {
            const e = n.from([i.InputTypes.TAP_SCRIPT_SIG]);
            return {
              key: n.concat([e, t.pubkey, t.leafHash]),
              value: t.signature,
            };
          }),
          (e.expected =
            "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }"),
          (e.check = function (t) {
            return (
              n.isBuffer(t.pubkey) &&
              n.isBuffer(t.leafHash) &&
              n.isBuffer(t.signature) &&
              32 === t.pubkey.length &&
              32 === t.leafHash.length &&
              (64 === t.signature.length || 65 === t.signature.length)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = e.pubkey.toString("hex") + e.leafHash.toString("hex");
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter(
                  (t) =>
                    t.pubkey.equals(e.pubkey) && t.leafHash.equals(e.leafHash),
                ).length)
            );
          });
      },
      82926: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080),
          o = r(78133),
          s = r(40394);
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.WITNESS_UTXO)
            throw new Error(
              "Decode Error: could not decode witnessUtxo with key 0x" +
                t.key.toString("hex"),
            );
          const e = o.readUInt64LE(t.value, 0);
          let r = 8;
          const n = s.decode(t.value, r);
          r += s.encodingLength(n);
          const a = t.value.slice(r);
          if (a.length !== n)
            throw new Error(
              "Decode Error: WITNESS_UTXO script is not proper length",
            );
          return { script: a, value: e };
        }),
          (e.encode = function (t) {
            const { script: e, value: r } = t,
              a = s.encodingLength(e.length),
              u = n.allocUnsafe(8 + a + e.length);
            return (
              o.writeUInt64LE(u, r, 0),
              s.encode(e.length, u, 8),
              e.copy(u, 8 + a),
              { key: n.from([i.InputTypes.WITNESS_UTXO]), value: u }
            );
          }),
          (e.expected = "{ script: Buffer; value: number; }"),
          (e.check = function (t) {
            return n.isBuffer(t.script) && "number" == typeof t.value;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.witnessUtxo;
          });
      },
      77851: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(99080),
          o = r(40394);
        (e.decode = function (t) {
          if (t.key[0] !== i.OutputTypes.TAP_TREE || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapTree with key 0x" +
                t.key.toString("hex"),
            );
          let e = 0;
          const r = [];
          for (; e < t.value.length; ) {
            const n = t.value[e++],
              i = t.value[e++],
              s = o.decode(t.value, e);
            (e += o.encodingLength(s)),
              r.push({
                depth: n,
                leafVersion: i,
                script: t.value.slice(e, e + s),
              }),
              (e += s);
          }
          return { leaves: r };
        }),
          (e.encode = function (t) {
            const e = n.from([i.OutputTypes.TAP_TREE]),
              r = [].concat(
                ...t.leaves.map((t) => [
                  n.of(t.depth, t.leafVersion),
                  o.encode(t.script.length),
                  t.script,
                ]),
              );
            return { key: e, value: n.concat(r) };
          }),
          (e.expected =
            "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }"),
          (e.check = function (t) {
            return (
              Array.isArray(t.leaves) &&
              t.leaves.every(
                (t) =>
                  t.depth >= 0 &&
                  t.depth <= 128 &&
                  (254 & t.leafVersion) === t.leafVersion &&
                  n.isBuffer(t.script),
              )
            );
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapTree;
          });
      },
      97545: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = (t) =>
          (33 === t.length && [2, 3].includes(t[0])) ||
          (65 === t.length && 4 === t[0]);
        e.makeConverter = function (t, e = i) {
          return {
            decode: function (r) {
              if (r.key[0] !== t)
                throw new Error(
                  "Decode Error: could not decode bip32Derivation with key 0x" +
                    r.key.toString("hex"),
                );
              const n = r.key.slice(1);
              if (!e(n))
                throw new Error(
                  "Decode Error: bip32Derivation has invalid pubkey in key 0x" +
                    r.key.toString("hex"),
                );
              if ((r.value.length / 4) % 1 != 0)
                throw new Error(
                  "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4",
                );
              const i = {
                masterFingerprint: r.value.slice(0, 4),
                pubkey: n,
                path: "m",
              };
              for (const t of ((o = r.value.length / 4 - 1),
              [...Array(o).keys()])) {
                const e = r.value.readUInt32LE(4 * t + 4),
                  n = !!(2147483648 & e),
                  o = 2147483647 & e;
                i.path += "/" + o.toString(10) + (n ? "'" : "");
              }
              var o;
              return i;
            },
            encode: function (e) {
              const r = n.from([t]),
                i = n.concat([r, e.pubkey]),
                o = e.path.split("/"),
                s = n.allocUnsafe(4 * o.length);
              e.masterFingerprint.copy(s, 0);
              let a = 4;
              return (
                o.slice(1).forEach((t) => {
                  const e = "'" === t.slice(-1);
                  let r = 2147483647 & parseInt(e ? t.slice(0, -1) : t, 10);
                  e && (r += 2147483648), s.writeUInt32LE(r, a), (a += 4);
                }),
                { key: i, value: s }
              );
            },
            check: function (t) {
              return (
                n.isBuffer(t.pubkey) &&
                n.isBuffer(t.masterFingerprint) &&
                "string" == typeof t.path &&
                e(t.pubkey) &&
                4 === t.masterFingerprint.length
              );
            },
            expected:
              "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }",
            canAddToArray: function (t, e, r) {
              const n = e.pubkey.toString("hex");
              return (
                !r.has(n) &&
                (r.add(n),
                0 === t.filter((t) => t.pubkey.equals(e.pubkey)).length)
              );
            },
          };
        };
      },
      22412: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.makeChecker = function (t) {
            return function (e) {
              let r;
              if (
                t.includes(e.key[0]) &&
                ((r = e.key.slice(1)),
                (33 !== r.length && 65 !== r.length) ||
                  ![2, 3, 4].includes(r[0]))
              )
                throw new Error(
                  "Format Error: invalid pubkey in key 0x" +
                    e.key.toString("hex"),
                );
              return r;
            };
          });
      },
      54307: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.makeConverter = function (t) {
            return {
              decode: function (e) {
                if (e.key[0] !== t)
                  throw new Error(
                    "Decode Error: could not decode redeemScript with key 0x" +
                      e.key.toString("hex"),
                  );
                return e.value;
              },
              encode: function (e) {
                return { key: n.from([t]), value: e };
              },
              check: function (t) {
                return n.isBuffer(t);
              },
              expected: "Buffer",
              canAdd: function (t, e) {
                return !!t && !!e && void 0 === t.redeemScript;
              },
            };
          });
      },
      87636: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(40394),
          o = r(97545),
          s = (t) => 32 === t.length;
        e.makeConverter = function (t) {
          const e = o.makeConverter(t, s);
          return {
            decode: function (t) {
              const r = i.decode(t.value),
                n = i.encodingLength(r),
                o = e.decode({ key: t.key, value: t.value.slice(n + 32 * r) }),
                s = new Array(r);
              for (let e = 0, i = n; e < r; e++, i += 32)
                s[e] = t.value.slice(i, i + 32);
              return Object.assign({}, o, { leafHashes: s });
            },
            encode: function (t) {
              const r = e.encode(t),
                o = i.encodingLength(t.leafHashes.length),
                s = n.allocUnsafe(o);
              i.encode(t.leafHashes.length, s);
              const a = n.concat([s, ...t.leafHashes, r.value]);
              return Object.assign({}, r, { value: a });
            },
            check: function (t) {
              return (
                Array.isArray(t.leafHashes) &&
                t.leafHashes.every((t) => n.isBuffer(t) && 32 === t.length) &&
                e.check(t)
              );
            },
            expected:
              "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }",
            canAddToArray: e.canAddToArray,
          };
        };
      },
      22223: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.makeConverter = function (t) {
            return {
              decode: function (e) {
                if (e.key[0] !== t || 1 !== e.key.length)
                  throw new Error(
                    "Decode Error: could not decode tapInternalKey with key 0x" +
                      e.key.toString("hex"),
                  );
                if (32 !== e.value.length)
                  throw new Error(
                    "Decode Error: tapInternalKey not a 32-byte x-only pubkey",
                  );
                return e.value;
              },
              encode: function (e) {
                return { key: n.from([t]), value: e };
              },
              check: function (t) {
                return n.isBuffer(t) && 32 === t.length;
              },
              expected: "Buffer",
              canAdd: function (t, e) {
                return !!t && !!e && void 0 === t.tapInternalKey;
              },
            };
          });
      },
      75578: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.makeConverter = function (t) {
            return {
              decode: function (e) {
                if (e.key[0] !== t)
                  throw new Error(
                    "Decode Error: could not decode witnessScript with key 0x" +
                      e.key.toString("hex"),
                  );
                return e.value;
              },
              encode: function (e) {
                return { key: n.from([t]), value: e };
              },
              check: function (t) {
                return n.isBuffer(t);
              },
              expected: "Buffer",
              canAdd: function (t, e) {
                return !!t && !!e && void 0 === t.witnessScript;
              },
            };
          });
      },
      78133: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(40394);
        function o(t) {
          const e = t.key.length,
            r = t.value.length,
            o = i.encodingLength(e),
            s = i.encodingLength(r),
            a = n.allocUnsafe(o + e + s + r);
          return (
            i.encode(e, a, 0),
            t.key.copy(a, o),
            i.encode(r, a, o + e),
            t.value.copy(a, o + e + s),
            a
          );
        }
        function s(t, e) {
          if ("number" != typeof t)
            throw new Error("cannot write a non-number as a number");
          if (t < 0)
            throw new Error(
              "specified a negative value for writing an unsigned value",
            );
          if (t > e) throw new Error("RangeError: value out of range");
          if (Math.floor(t) !== t)
            throw new Error("value has a fractional component");
        }
        (e.range = (t) => [...Array(t).keys()]),
          (e.reverseBuffer = function (t) {
            if (t.length < 1) return t;
            let e = t.length - 1,
              r = 0;
            for (let n = 0; n < t.length / 2; n++)
              (r = t[n]), (t[n] = t[e]), (t[e] = r), e--;
            return t;
          }),
          (e.keyValsToBuffer = function (t) {
            const e = t.map(o);
            return e.push(n.from([0])), n.concat(e);
          }),
          (e.keyValToBuffer = o),
          (e.readUInt64LE = function (t, e) {
            const r = t.readUInt32LE(e);
            let n = t.readUInt32LE(e + 4);
            return (n *= 4294967296), s(n + r, 9007199254740991), n + r;
          }),
          (e.writeUInt64LE = function (t, e, r) {
            return (
              s(e, 9007199254740991),
              t.writeInt32LE(-1 & e, r),
              t.writeUInt32LE(Math.floor(e / 4294967296), r + 4),
              r + 8
            );
          });
      },
      40394: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        function i(t) {
          if (t < 0 || t > 9007199254740991 || t % 1 != 0)
            throw new RangeError("value out of range");
        }
        function o(t) {
          return i(t), t < 253 ? 1 : t <= 65535 ? 3 : t <= 4294967295 ? 5 : 9;
        }
        (e.encode = function t(e, r, s) {
          if ((i(e), r || (r = n.allocUnsafe(o(e))), !n.isBuffer(r)))
            throw new TypeError("buffer must be a Buffer instance");
          return (
            s || (s = 0),
            e < 253
              ? (r.writeUInt8(e, s), Object.assign(t, { bytes: 1 }))
              : e <= 65535
                ? (r.writeUInt8(253, s),
                  r.writeUInt16LE(e, s + 1),
                  Object.assign(t, { bytes: 3 }))
                : e <= 4294967295
                  ? (r.writeUInt8(254, s),
                    r.writeUInt32LE(e, s + 1),
                    Object.assign(t, { bytes: 5 }))
                  : (r.writeUInt8(255, s),
                    r.writeUInt32LE(e >>> 0, s + 1),
                    r.writeUInt32LE((e / 4294967296) | 0, s + 5),
                    Object.assign(t, { bytes: 9 })),
            r
          );
        }),
          (e.decode = function t(e, r) {
            if (!n.isBuffer(e))
              throw new TypeError("buffer must be a Buffer instance");
            r || (r = 0);
            const o = e.readUInt8(r);
            if (o < 253) return Object.assign(t, { bytes: 1 }), o;
            if (253 === o)
              return Object.assign(t, { bytes: 3 }), e.readUInt16LE(r + 1);
            if (254 === o)
              return Object.assign(t, { bytes: 5 }), e.readUInt32LE(r + 1);
            {
              Object.assign(t, { bytes: 9 });
              const n = e.readUInt32LE(r + 1),
                o = 4294967296 * e.readUInt32LE(r + 5) + n;
              return i(o), o;
            }
          }),
          (e.encodingLength = o);
      },
      76263: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(22706),
          o = r(78133),
          s = r(40394),
          a = r(99080);
        function u(t, e, r) {
          if (!e.equals(n.from([r])))
            throw new Error(
              `Format Error: Invalid ${t} key: ${e.toString("hex")}`,
            );
        }
        function c(
          t,
          { globalMapKeyVals: e, inputKeyVals: r, outputKeyVals: n },
        ) {
          const s = { unsignedTx: t };
          let c = 0;
          for (const t of e)
            switch (t.key[0]) {
              case a.GlobalTypes.UNSIGNED_TX:
                if ((u("global", t.key, a.GlobalTypes.UNSIGNED_TX), c > 0))
                  throw new Error(
                    "Format Error: GlobalMap has multiple UNSIGNED_TX",
                  );
                c++;
                break;
              case a.GlobalTypes.GLOBAL_XPUB:
                void 0 === s.globalXpub && (s.globalXpub = []),
                  s.globalXpub.push(i.globals.globalXpub.decode(t));
                break;
              default:
                s.unknownKeyVals || (s.unknownKeyVals = []),
                  s.unknownKeyVals.push(t);
            }
          const f = r.length,
            h = n.length,
            l = [],
            d = [];
          for (const t of o.range(f)) {
            const e = {};
            for (const n of r[t])
              switch ((i.inputs.checkPubkey(n), n.key[0])) {
                case a.InputTypes.NON_WITNESS_UTXO:
                  if (
                    (u("input", n.key, a.InputTypes.NON_WITNESS_UTXO),
                    void 0 !== e.nonWitnessUtxo)
                  )
                    throw new Error(
                      "Format Error: Input has multiple NON_WITNESS_UTXO",
                    );
                  e.nonWitnessUtxo = i.inputs.nonWitnessUtxo.decode(n);
                  break;
                case a.InputTypes.WITNESS_UTXO:
                  if (
                    (u("input", n.key, a.InputTypes.WITNESS_UTXO),
                    void 0 !== e.witnessUtxo)
                  )
                    throw new Error(
                      "Format Error: Input has multiple WITNESS_UTXO",
                    );
                  e.witnessUtxo = i.inputs.witnessUtxo.decode(n);
                  break;
                case a.InputTypes.PARTIAL_SIG:
                  void 0 === e.partialSig && (e.partialSig = []),
                    e.partialSig.push(i.inputs.partialSig.decode(n));
                  break;
                case a.InputTypes.SIGHASH_TYPE:
                  if (
                    (u("input", n.key, a.InputTypes.SIGHASH_TYPE),
                    void 0 !== e.sighashType)
                  )
                    throw new Error(
                      "Format Error: Input has multiple SIGHASH_TYPE",
                    );
                  e.sighashType = i.inputs.sighashType.decode(n);
                  break;
                case a.InputTypes.REDEEM_SCRIPT:
                  if (
                    (u("input", n.key, a.InputTypes.REDEEM_SCRIPT),
                    void 0 !== e.redeemScript)
                  )
                    throw new Error(
                      "Format Error: Input has multiple REDEEM_SCRIPT",
                    );
                  e.redeemScript = i.inputs.redeemScript.decode(n);
                  break;
                case a.InputTypes.WITNESS_SCRIPT:
                  if (
                    (u("input", n.key, a.InputTypes.WITNESS_SCRIPT),
                    void 0 !== e.witnessScript)
                  )
                    throw new Error(
                      "Format Error: Input has multiple WITNESS_SCRIPT",
                    );
                  e.witnessScript = i.inputs.witnessScript.decode(n);
                  break;
                case a.InputTypes.BIP32_DERIVATION:
                  void 0 === e.bip32Derivation && (e.bip32Derivation = []),
                    e.bip32Derivation.push(i.inputs.bip32Derivation.decode(n));
                  break;
                case a.InputTypes.FINAL_SCRIPTSIG:
                  u("input", n.key, a.InputTypes.FINAL_SCRIPTSIG),
                    (e.finalScriptSig = i.inputs.finalScriptSig.decode(n));
                  break;
                case a.InputTypes.FINAL_SCRIPTWITNESS:
                  u("input", n.key, a.InputTypes.FINAL_SCRIPTWITNESS),
                    (e.finalScriptWitness =
                      i.inputs.finalScriptWitness.decode(n));
                  break;
                case a.InputTypes.POR_COMMITMENT:
                  u("input", n.key, a.InputTypes.POR_COMMITMENT),
                    (e.porCommitment = i.inputs.porCommitment.decode(n));
                  break;
                case a.InputTypes.TAP_KEY_SIG:
                  u("input", n.key, a.InputTypes.TAP_KEY_SIG),
                    (e.tapKeySig = i.inputs.tapKeySig.decode(n));
                  break;
                case a.InputTypes.TAP_SCRIPT_SIG:
                  void 0 === e.tapScriptSig && (e.tapScriptSig = []),
                    e.tapScriptSig.push(i.inputs.tapScriptSig.decode(n));
                  break;
                case a.InputTypes.TAP_LEAF_SCRIPT:
                  void 0 === e.tapLeafScript && (e.tapLeafScript = []),
                    e.tapLeafScript.push(i.inputs.tapLeafScript.decode(n));
                  break;
                case a.InputTypes.TAP_BIP32_DERIVATION:
                  void 0 === e.tapBip32Derivation &&
                    (e.tapBip32Derivation = []),
                    e.tapBip32Derivation.push(
                      i.inputs.tapBip32Derivation.decode(n),
                    );
                  break;
                case a.InputTypes.TAP_INTERNAL_KEY:
                  u("input", n.key, a.InputTypes.TAP_INTERNAL_KEY),
                    (e.tapInternalKey = i.inputs.tapInternalKey.decode(n));
                  break;
                case a.InputTypes.TAP_MERKLE_ROOT:
                  u("input", n.key, a.InputTypes.TAP_MERKLE_ROOT),
                    (e.tapMerkleRoot = i.inputs.tapMerkleRoot.decode(n));
                  break;
                default:
                  e.unknownKeyVals || (e.unknownKeyVals = []),
                    e.unknownKeyVals.push(n);
              }
            l.push(e);
          }
          for (const t of o.range(h)) {
            const e = {};
            for (const r of n[t])
              switch ((i.outputs.checkPubkey(r), r.key[0])) {
                case a.OutputTypes.REDEEM_SCRIPT:
                  if (
                    (u("output", r.key, a.OutputTypes.REDEEM_SCRIPT),
                    void 0 !== e.redeemScript)
                  )
                    throw new Error(
                      "Format Error: Output has multiple REDEEM_SCRIPT",
                    );
                  e.redeemScript = i.outputs.redeemScript.decode(r);
                  break;
                case a.OutputTypes.WITNESS_SCRIPT:
                  if (
                    (u("output", r.key, a.OutputTypes.WITNESS_SCRIPT),
                    void 0 !== e.witnessScript)
                  )
                    throw new Error(
                      "Format Error: Output has multiple WITNESS_SCRIPT",
                    );
                  e.witnessScript = i.outputs.witnessScript.decode(r);
                  break;
                case a.OutputTypes.BIP32_DERIVATION:
                  void 0 === e.bip32Derivation && (e.bip32Derivation = []),
                    e.bip32Derivation.push(i.outputs.bip32Derivation.decode(r));
                  break;
                case a.OutputTypes.TAP_INTERNAL_KEY:
                  u("output", r.key, a.OutputTypes.TAP_INTERNAL_KEY),
                    (e.tapInternalKey = i.outputs.tapInternalKey.decode(r));
                  break;
                case a.OutputTypes.TAP_TREE:
                  u("output", r.key, a.OutputTypes.TAP_TREE),
                    (e.tapTree = i.outputs.tapTree.decode(r));
                  break;
                case a.OutputTypes.TAP_BIP32_DERIVATION:
                  void 0 === e.tapBip32Derivation &&
                    (e.tapBip32Derivation = []),
                    e.tapBip32Derivation.push(
                      i.outputs.tapBip32Derivation.decode(r),
                    );
                  break;
                default:
                  e.unknownKeyVals || (e.unknownKeyVals = []),
                    e.unknownKeyVals.push(r);
              }
            d.push(e);
          }
          return { globalMap: s, inputs: l, outputs: d };
        }
        (e.psbtFromBuffer = function (t, e) {
          let r = 0;
          function n() {
            const e = s.decode(t, r);
            r += s.encodingLength(e);
            const n = t.slice(r, r + e);
            return (r += e), n;
          }
          function i() {
            return { key: n(), value: n() };
          }
          function u() {
            if (r >= t.length)
              throw new Error("Format Error: Unexpected End of PSBT");
            const e = 0 === t.readUInt8(r);
            return e && r++, e;
          }
          if (
            1886610036 !==
            (function () {
              const e = t.readUInt32BE(r);
              return (r += 4), e;
            })()
          )
            throw new Error("Format Error: Invalid Magic Number");
          if (
            255 !==
            (function () {
              const e = t.readUInt8(r);
              return (r += 1), e;
            })()
          )
            throw new Error(
              "Format Error: Magic Number must be followed by 0xff separator",
            );
          const f = [],
            h = {};
          for (; !u(); ) {
            const t = i(),
              e = t.key.toString("hex");
            if (h[e])
              throw new Error(
                "Format Error: Keys must be unique for global keymap: key " + e,
              );
            (h[e] = 1), f.push(t);
          }
          const l = f.filter((t) => t.key[0] === a.GlobalTypes.UNSIGNED_TX);
          if (1 !== l.length)
            throw new Error("Format Error: Only one UNSIGNED_TX allowed");
          const d = e(l[0].value),
            { inputCount: p, outputCount: y } = d.getInputOutputCounts(),
            g = [],
            m = [];
          for (const t of o.range(p)) {
            const e = {},
              r = [];
            for (; !u(); ) {
              const n = i(),
                o = n.key.toString("hex");
              if (e[o])
                throw new Error(
                  "Format Error: Keys must be unique for each input: input index " +
                    t +
                    " key " +
                    o,
                );
              (e[o] = 1), r.push(n);
            }
            g.push(r);
          }
          for (const t of o.range(y)) {
            const e = {},
              r = [];
            for (; !u(); ) {
              const n = i(),
                o = n.key.toString("hex");
              if (e[o])
                throw new Error(
                  "Format Error: Keys must be unique for each output: output index " +
                    t +
                    " key " +
                    o,
                );
              (e[o] = 1), r.push(n);
            }
            m.push(r);
          }
          return c(d, {
            globalMapKeyVals: f,
            inputKeyVals: g,
            outputKeyVals: m,
          });
        }),
          (e.checkKeyBuffer = u),
          (e.psbtFromKeyVals = c);
      },
      91457: (t, e, r) => {
        "use strict";
        function n(t) {
          for (var r in t) e.hasOwnProperty(r) || (e[r] = t[r]);
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          n(r(76263)),
          n(r(238));
      },
      238: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(22706),
          o = r(78133);
        e.psbtToBuffer = function ({ globalMap: t, inputs: e, outputs: r }) {
          const {
              globalKeyVals: i,
              inputKeyVals: s,
              outputKeyVals: a,
            } = u({ globalMap: t, inputs: e, outputs: r }),
            c = o.keyValsToBuffer(i),
            f = (t) =>
              0 === t.length ? [n.from([0])] : t.map(o.keyValsToBuffer),
            h = f(s),
            l = f(a),
            d = n.allocUnsafe(5);
          return (
            d.writeUIntBE(482972169471, 0, 5), n.concat([d, c].concat(h, l))
          );
        };
        const s = (t, e) => t.key.compare(e.key);
        function a(t, e) {
          const r = new Set(),
            n = Object.entries(t).reduce((t, [n, i]) => {
              if ("unknownKeyVals" === n) return t;
              const o = e[n];
              if (void 0 === o) return t;
              const s = (Array.isArray(i) ? i : [i]).map(o.encode);
              return (
                s
                  .map((t) => t.key.toString("hex"))
                  .forEach((t) => {
                    if (r.has(t))
                      throw new Error("Serialize Error: Duplicate key: " + t);
                    r.add(t);
                  }),
                t.concat(s)
              );
            }, []),
            i = t.unknownKeyVals
              ? t.unknownKeyVals.filter((t) => !r.has(t.key.toString("hex")))
              : [];
          return n.concat(i).sort(s);
        }
        function u({ globalMap: t, inputs: e, outputs: r }) {
          return {
            globalKeyVals: a(t, i.globals),
            inputKeyVals: e.map((t) => a(t, i.inputs)),
            outputKeyVals: r.map((t) => a(t, i.outputs)),
          };
        }
        e.psbtToKeyVals = u;
      },
      1614: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(64863),
          o = r(91457),
          s = r(99080),
          a = r(45080);
        e.Psbt = class {
          constructor(t) {
            (this.inputs = []),
              (this.outputs = []),
              (this.globalMap = { unsignedTx: t });
          }
          static fromBase64(t, e) {
            const r = n.from(t, "base64");
            return this.fromBuffer(r, e);
          }
          static fromHex(t, e) {
            const r = n.from(t, "hex");
            return this.fromBuffer(r, e);
          }
          static fromBuffer(t, e) {
            const r = o.psbtFromBuffer(t, e),
              n = new this(r.globalMap.unsignedTx);
            return Object.assign(n, r), n;
          }
          toBase64() {
            return this.toBuffer().toString("base64");
          }
          toHex() {
            return this.toBuffer().toString("hex");
          }
          toBuffer() {
            return o.psbtToBuffer(this);
          }
          updateGlobal(t) {
            return a.updateGlobal(t, this.globalMap), this;
          }
          updateInput(t, e) {
            const r = a.checkForInput(this.inputs, t);
            return a.updateInput(e, r), this;
          }
          updateOutput(t, e) {
            const r = a.checkForOutput(this.outputs, t);
            return a.updateOutput(e, r), this;
          }
          addUnknownKeyValToGlobal(t) {
            return (
              a.checkHasKey(
                t,
                this.globalMap.unknownKeyVals,
                a.getEnumLength(s.GlobalTypes),
              ),
              this.globalMap.unknownKeyVals ||
                (this.globalMap.unknownKeyVals = []),
              this.globalMap.unknownKeyVals.push(t),
              this
            );
          }
          addUnknownKeyValToInput(t, e) {
            const r = a.checkForInput(this.inputs, t);
            return (
              a.checkHasKey(e, r.unknownKeyVals, a.getEnumLength(s.InputTypes)),
              r.unknownKeyVals || (r.unknownKeyVals = []),
              r.unknownKeyVals.push(e),
              this
            );
          }
          addUnknownKeyValToOutput(t, e) {
            const r = a.checkForOutput(this.outputs, t);
            return (
              a.checkHasKey(
                e,
                r.unknownKeyVals,
                a.getEnumLength(s.OutputTypes),
              ),
              r.unknownKeyVals || (r.unknownKeyVals = []),
              r.unknownKeyVals.push(e),
              this
            );
          }
          addInput(t) {
            this.globalMap.unsignedTx.addInput(t),
              this.inputs.push({ unknownKeyVals: [] });
            const e = t.unknownKeyVals || [],
              r = this.inputs.length - 1;
            if (!Array.isArray(e))
              throw new Error("unknownKeyVals must be an Array");
            return (
              e.forEach((t) => this.addUnknownKeyValToInput(r, t)),
              a.addInputAttributes(this.inputs, t),
              this
            );
          }
          addOutput(t) {
            this.globalMap.unsignedTx.addOutput(t),
              this.outputs.push({ unknownKeyVals: [] });
            const e = t.unknownKeyVals || [],
              r = this.outputs.length - 1;
            if (!Array.isArray(e))
              throw new Error("unknownKeyVals must be an Array");
            return (
              e.forEach((t) => this.addUnknownKeyValToOutput(r, t)),
              a.addOutputAttributes(this.outputs, t),
              this
            );
          }
          clearFinalizedInput(t) {
            const e = a.checkForInput(this.inputs, t);
            a.inputCheckUncleanFinalized(t, e);
            for (const t of Object.keys(e))
              [
                "witnessUtxo",
                "nonWitnessUtxo",
                "finalScriptSig",
                "finalScriptWitness",
                "unknownKeyVals",
              ].includes(t) || delete e[t];
            return this;
          }
          combine(...t) {
            const e = i.combine([this].concat(t));
            return Object.assign(this, e), this;
          }
          getTransaction() {
            return this.globalMap.unsignedTx.toBuffer();
          }
        };
      },
      99080: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (function (t) {
            (t[(t.UNSIGNED_TX = 0)] = "UNSIGNED_TX"),
              (t[(t.GLOBAL_XPUB = 1)] = "GLOBAL_XPUB");
          })(e.GlobalTypes || (e.GlobalTypes = {})),
          (e.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"]),
          (function (t) {
            (t[(t.NON_WITNESS_UTXO = 0)] = "NON_WITNESS_UTXO"),
              (t[(t.WITNESS_UTXO = 1)] = "WITNESS_UTXO"),
              (t[(t.PARTIAL_SIG = 2)] = "PARTIAL_SIG"),
              (t[(t.SIGHASH_TYPE = 3)] = "SIGHASH_TYPE"),
              (t[(t.REDEEM_SCRIPT = 4)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 5)] = "WITNESS_SCRIPT"),
              (t[(t.BIP32_DERIVATION = 6)] = "BIP32_DERIVATION"),
              (t[(t.FINAL_SCRIPTSIG = 7)] = "FINAL_SCRIPTSIG"),
              (t[(t.FINAL_SCRIPTWITNESS = 8)] = "FINAL_SCRIPTWITNESS"),
              (t[(t.POR_COMMITMENT = 9)] = "POR_COMMITMENT"),
              (t[(t.TAP_KEY_SIG = 19)] = "TAP_KEY_SIG"),
              (t[(t.TAP_SCRIPT_SIG = 20)] = "TAP_SCRIPT_SIG"),
              (t[(t.TAP_LEAF_SCRIPT = 21)] = "TAP_LEAF_SCRIPT"),
              (t[(t.TAP_BIP32_DERIVATION = 22)] = "TAP_BIP32_DERIVATION"),
              (t[(t.TAP_INTERNAL_KEY = 23)] = "TAP_INTERNAL_KEY"),
              (t[(t.TAP_MERKLE_ROOT = 24)] = "TAP_MERKLE_ROOT");
          })(e.InputTypes || (e.InputTypes = {})),
          (e.INPUT_TYPE_NAMES = [
            "nonWitnessUtxo",
            "witnessUtxo",
            "partialSig",
            "sighashType",
            "redeemScript",
            "witnessScript",
            "bip32Derivation",
            "finalScriptSig",
            "finalScriptWitness",
            "porCommitment",
            "tapKeySig",
            "tapScriptSig",
            "tapLeafScript",
            "tapBip32Derivation",
            "tapInternalKey",
            "tapMerkleRoot",
          ]),
          (function (t) {
            (t[(t.REDEEM_SCRIPT = 0)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 1)] = "WITNESS_SCRIPT"),
              (t[(t.BIP32_DERIVATION = 2)] = "BIP32_DERIVATION"),
              (t[(t.TAP_INTERNAL_KEY = 5)] = "TAP_INTERNAL_KEY"),
              (t[(t.TAP_TREE = 6)] = "TAP_TREE"),
              (t[(t.TAP_BIP32_DERIVATION = 7)] = "TAP_BIP32_DERIVATION");
          })(e.OutputTypes || (e.OutputTypes = {})),
          (e.OUTPUT_TYPE_NAMES = [
            "redeemScript",
            "witnessScript",
            "bip32Derivation",
            "tapInternalKey",
            "tapTree",
            "tapBip32Derivation",
          ]);
      },
      45080: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(22706);
        function o(t, e) {
          const r = t[e];
          if (void 0 === r) throw new Error(`No input #${e}`);
          return r;
        }
        function s(t, e) {
          const r = t[e];
          if (void 0 === r) throw new Error(`No output #${e}`);
          return r;
        }
        function a(t, e, r, n) {
          throw new Error(
            `Data for ${t} key ${e} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`,
          );
        }
        function u(t) {
          return (e, r) => {
            for (const n of Object.keys(e)) {
              const o = e[n],
                {
                  canAdd: s,
                  canAddToArray: u,
                  check: c,
                  expected: f,
                } = i[t + "s"][n] || {};
              if (c)
                if (!!u) {
                  if (!Array.isArray(o) || (r[n] && !Array.isArray(r[n])))
                    throw new Error(`Key type ${n} must be an array`);
                  o.every(c) || a(t, n, f, o);
                  const e = r[n] || [],
                    i = new Set();
                  if (!o.every((t) => u(e, t, i)))
                    throw new Error("Can not add duplicate data to array");
                  r[n] = e.concat(o);
                } else {
                  if ((c(o) || a(t, n, f, o), !s(r, o)))
                    throw new Error(`Can not add duplicate data to ${t}`);
                  r[n] = o;
                }
            }
          };
        }
        (e.checkForInput = o),
          (e.checkForOutput = s),
          (e.checkHasKey = function (t, e, r) {
            if (t.key[0] < r)
              throw new Error(
                "Use the method for your specific key instead of addUnknownKeyVal*",
              );
            if (e && 0 !== e.filter((e) => e.key.equals(t.key)).length)
              throw new Error(`Duplicate Key: ${t.key.toString("hex")}`);
          }),
          (e.getEnumLength = function (t) {
            let e = 0;
            return (
              Object.keys(t).forEach((t) => {
                Number(isNaN(Number(t))) && e++;
              }),
              e
            );
          }),
          (e.inputCheckUncleanFinalized = function (t, e) {
            let r = !1;
            if (e.nonWitnessUtxo || e.witnessUtxo) {
              const t = !!e.redeemScript,
                n = !!e.witnessScript,
                i = !t || !!e.finalScriptSig,
                o = !n || !!e.finalScriptWitness,
                s = !!e.finalScriptSig || !!e.finalScriptWitness;
              r = i && o && s;
            }
            if (!1 === r)
              throw new Error(
                `Input #${t} has too much or too little data to clean`,
              );
          }),
          (e.updateGlobal = u("global")),
          (e.updateInput = u("input")),
          (e.updateOutput = u("output")),
          (e.addInputAttributes = function (t, r) {
            const n = o(t, t.length - 1);
            e.updateInput(r, n);
          }),
          (e.addOutputAttributes = function (t, r) {
            const n = s(t, t.length - 1);
            e.updateOutput(r, n);
          }),
          (e.defaultVersionSetter = function (t, e) {
            if (!n.isBuffer(e) || e.length < 4)
              throw new Error("Set Version: Invalid Transaction");
            return e.writeUInt32LE(t, 0), e;
          }),
          (e.defaultLocktimeSetter = function (t, e) {
            if (!n.isBuffer(e) || e.length < 4)
              throw new Error("Set Locktime: Invalid Transaction");
            return e.writeUInt32LE(t, e.length - 4), e;
          });
      },
      99235: (t) => {
        const e = 2147483648;
        var r = function (t) {
          if (!Array.isArray(t)) throw new Error("Input must be an Array");
          if (0 === t.length)
            throw new Error("Path must contain at least one level");
          for (var e = 0; e < t.length; e++)
            if ("number" != typeof t[e])
              throw new Error("Path element is not a number");
          this.path = t;
        };
        (r.validatePathArray = function (t) {
          try {
            return r.fromPathArray(t), !0;
          } catch (t) {
            return !1;
          }
        }),
          (r.validateString = function (t, e) {
            try {
              return r.fromString(t, e), !0;
            } catch (t) {
              return !1;
            }
          }),
          (r.fromPathArray = function (t) {
            return new r(t);
          }),
          (r.fromString = function (t, n) {
            if (/^m\//i.test(t)) t = t.slice(2);
            else if (n) throw new Error("Root element is required");
            for (
              var i = t.split("/"), o = new Array(i.length), s = 0;
              s < i.length;
              s++
            ) {
              var a = /(\d+)([hH\']?)/.exec(i[s]);
              if (null === a) throw new Error("Invalid input");
              if (((o[s] = parseInt(a[1], 10)), o[s] >= e))
                throw new Error("Invalid child index");
              if ("h" === a[2] || "H" === a[2] || "'" === a[2]) o[s] += e;
              else if (0 != a[2].length) throw new Error("Invalid modifier");
            }
            return new r(o);
          }),
          (r.prototype.toPathArray = function () {
            return this.path;
          }),
          (r.prototype.toString = function (t, r) {
            for (
              var n = new Array(this.path.length), i = 0;
              i < this.path.length;
              i++
            ) {
              var o = this.path[i];
              n[i] = o & e ? (o & ~e) + (r ? "h" : "'") : o;
            }
            return (t ? "" : "m/") + n.join("/");
          }),
          (r.prototype.inspect = function () {
            return "BIPPath <" + this.toString() + ">";
          }),
          (t.exports = r);
      },
      92368: (t, e, r) => {
        var n = r(92861).Buffer;
        t.exports = {
          check: function (t) {
            if (t.length < 8) return !1;
            if (t.length > 72) return !1;
            if (48 !== t[0]) return !1;
            if (t[1] !== t.length - 2) return !1;
            if (2 !== t[2]) return !1;
            var e = t[3];
            if (0 === e) return !1;
            if (5 + e >= t.length) return !1;
            if (2 !== t[4 + e]) return !1;
            var r = t[5 + e];
            return (
              0 !== r &&
              6 + e + r === t.length &&
              !(128 & t[4]) &&
              !(e > 1 && 0 === t[4] && !(128 & t[5])) &&
              !(128 & t[e + 6]) &&
              !(r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
            );
          },
          decode: function (t) {
            if (t.length < 8)
              throw new Error("DER sequence length is too short");
            if (t.length > 72)
              throw new Error("DER sequence length is too long");
            if (48 !== t[0]) throw new Error("Expected DER sequence");
            if (t[1] !== t.length - 2)
              throw new Error("DER sequence length is invalid");
            if (2 !== t[2]) throw new Error("Expected DER integer");
            var e = t[3];
            if (0 === e) throw new Error("R length is zero");
            if (5 + e >= t.length) throw new Error("R length is too long");
            if (2 !== t[4 + e]) throw new Error("Expected DER integer (2)");
            var r = t[5 + e];
            if (0 === r) throw new Error("S length is zero");
            if (6 + e + r !== t.length) throw new Error("S length is invalid");
            if (128 & t[4]) throw new Error("R value is negative");
            if (e > 1 && 0 === t[4] && !(128 & t[5]))
              throw new Error("R value excessively padded");
            if (128 & t[e + 6]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
              throw new Error("S value excessively padded");
            return { r: t.slice(4, 4 + e), s: t.slice(6 + e) };
          },
          encode: function (t, e) {
            var r = t.length,
              i = e.length;
            if (0 === r) throw new Error("R length is zero");
            if (0 === i) throw new Error("S length is zero");
            if (r > 33) throw new Error("R length is too long");
            if (i > 33) throw new Error("S length is too long");
            if (128 & t[0]) throw new Error("R value is negative");
            if (128 & e[0]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[0] && !(128 & t[1]))
              throw new Error("R value excessively padded");
            if (i > 1 && 0 === e[0] && !(128 & e[1]))
              throw new Error("S value excessively padded");
            var o = n.allocUnsafe(6 + r + i);
            return (
              (o[0] = 48),
              (o[1] = o.length - 2),
              (o[2] = 2),
              (o[3] = t.length),
              t.copy(o, 4),
              (o[4 + r] = 2),
              (o[5 + r] = e.length),
              e.copy(o, 6 + r),
              o
            );
          },
        };
      },
      90933: (t, e, r) => {
        "use strict";
        var n = r(16763);
        t.exports = function (t) {
          function e(e) {
            var r = e.slice(0, -4),
              n = e.slice(-4),
              i = t(r);
            if (
              !((n[0] ^ i[0]) | (n[1] ^ i[1]) | (n[2] ^ i[2]) | (n[3] ^ i[3]))
            )
              return r;
          }
          return {
            encode: function (e) {
              var r = Uint8Array.from(e),
                i = t(r),
                o = r.length + 4,
                s = new Uint8Array(o);
              return (
                s.set(r, 0), s.set(i.subarray(0, 4), r.length), n.encode(s, o)
              );
            },
            decode: function (t) {
              var r = e(n.decode(t));
              if (!r) throw new Error("Invalid checksum");
              return r;
            },
            decodeUnsafe: function (t) {
              var r = n.decodeUnsafe(t);
              if (r) return e(r);
            },
          };
        };
      },
      82894: (t, e, r) => {
        "use strict";
        var { sha256: n } = r(22623),
          i = r(90933);
        t.exports = i(function (t) {
          return n(n(t));
        });
      },
      70057: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.toOutputScript =
            e.fromOutputScript =
            e.toBech32 =
            e.toBase58Check =
            e.fromBech32 =
            e.fromBase58Check =
              void 0);
        const i = r(50622),
          o = r(30885),
          s = r(67038),
          a = r(98116),
          u = r(22343),
          c = r(82894),
          f =
            "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
        function h(t) {
          const e = n.from(c.decode(t));
          if (e.length < 21) throw new TypeError(t + " is too short");
          if (e.length > 21) throw new TypeError(t + " is too long");
          return { version: e.readUint8(0), hash: e.slice(1) };
        }
        function l(t) {
          let e, r;
          try {
            e = u.bech32.decode(t);
          } catch (t) {}
          if (e) {
            if (((r = e.words[0]), 0 !== r))
              throw new TypeError(t + " uses wrong encoding");
          } else if (((e = u.bech32m.decode(t)), (r = e.words[0]), 0 === r))
            throw new TypeError(t + " uses wrong encoding");
          const i = u.bech32.fromWords(e.words.slice(1));
          return { version: r, prefix: e.prefix, data: n.from(i) };
        }
        function d(t, e, r) {
          const n = u.bech32.toWords(t);
          return (
            n.unshift(e),
            0 === e ? u.bech32.encode(r, n) : u.bech32m.encode(r, n)
          );
        }
        (e.fromBase58Check = h),
          (e.fromBech32 = l),
          (e.toBase58Check = function (t, e) {
            (0, a.typeforce)((0, a.tuple)(a.Hash160bit, a.UInt8), arguments);
            const r = n.allocUnsafe(21);
            return r.writeUInt8(e, 0), t.copy(r, 1), c.encode(r);
          }),
          (e.toBech32 = d),
          (e.fromOutputScript = function (t, e) {
            e = e || i.bitcoin;
            try {
              return o.p2pkh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return o.p2sh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return o.p2wpkh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return o.p2wsh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return o.p2tr({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return (function (t, e) {
                const r = t.slice(2);
                if (r.length < 2 || r.length > 40)
                  throw new TypeError(
                    "Invalid program length for segwit address",
                  );
                const n = t[0] - 80;
                if (n < 2 || n > 16)
                  throw new TypeError("Invalid version for segwit address");
                if (t[1] !== r.length)
                  throw new TypeError("Invalid script for segwit address");
                return console.warn(f), d(r, n, e.bech32);
              })(t, e);
            } catch (t) {}
            throw new Error(s.toASM(t) + " has no matching Address");
          }),
          (e.toOutputScript = function (t, e) {
            let r, n;
            e = e || i.bitcoin;
            try {
              r = h(t);
            } catch (t) {}
            if (r) {
              if (r.version === e.pubKeyHash)
                return o.p2pkh({ hash: r.hash }).output;
              if (r.version === e.scriptHash)
                return o.p2sh({ hash: r.hash }).output;
            } else {
              try {
                n = l(t);
              } catch (t) {}
              if (n) {
                if (n.prefix !== e.bech32)
                  throw new Error(t + " has an invalid prefix");
                if (0 === n.version) {
                  if (20 === n.data.length)
                    return o.p2wpkh({ hash: n.data }).output;
                  if (32 === n.data.length)
                    return o.p2wsh({ hash: n.data }).output;
                } else if (1 === n.version) {
                  if (32 === n.data.length)
                    return o.p2tr({ pubkey: n.data }).output;
                } else if (
                  n.version >= 2 &&
                  n.version <= 16 &&
                  n.data.length >= 2 &&
                  n.data.length <= 40
                )
                  return console.warn(f), s.compile([n.version + 80, n.data]);
              }
            }
            throw new Error(t + " has no matching Script");
          });
      },
      13966: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encode = e.decode = e.check = void 0),
          (e.check = function (t) {
            if (t.length < 8) return !1;
            if (t.length > 72) return !1;
            if (48 !== t[0]) return !1;
            if (t[1] !== t.length - 2) return !1;
            if (2 !== t[2]) return !1;
            const e = t[3];
            if (0 === e) return !1;
            if (5 + e >= t.length) return !1;
            if (2 !== t[4 + e]) return !1;
            const r = t[5 + e];
            return (
              0 !== r &&
              6 + e + r === t.length &&
              !(128 & t[4]) &&
              !(e > 1 && 0 === t[4] && !(128 & t[5])) &&
              !(128 & t[e + 6]) &&
              !(r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
            );
          }),
          (e.decode = function (t) {
            if (t.length < 8)
              throw new Error("DER sequence length is too short");
            if (t.length > 72)
              throw new Error("DER sequence length is too long");
            if (48 !== t[0]) throw new Error("Expected DER sequence");
            if (t[1] !== t.length - 2)
              throw new Error("DER sequence length is invalid");
            if (2 !== t[2]) throw new Error("Expected DER integer");
            const e = t[3];
            if (0 === e) throw new Error("R length is zero");
            if (5 + e >= t.length) throw new Error("R length is too long");
            if (2 !== t[4 + e]) throw new Error("Expected DER integer (2)");
            const r = t[5 + e];
            if (0 === r) throw new Error("S length is zero");
            if (6 + e + r !== t.length) throw new Error("S length is invalid");
            if (128 & t[4]) throw new Error("R value is negative");
            if (e > 1 && 0 === t[4] && !(128 & t[5]))
              throw new Error("R value excessively padded");
            if (128 & t[e + 6]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
              throw new Error("S value excessively padded");
            return { r: t.slice(4, 4 + e), s: t.slice(6 + e) };
          }),
          (e.encode = function (t, e) {
            const r = t.length,
              i = e.length;
            if (0 === r) throw new Error("R length is zero");
            if (0 === i) throw new Error("S length is zero");
            if (r > 33) throw new Error("R length is too long");
            if (i > 33) throw new Error("S length is too long");
            if (128 & t[0]) throw new Error("R value is negative");
            if (128 & e[0]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[0] && !(128 & t[1]))
              throw new Error("R value excessively padded");
            if (i > 1 && 0 === e[0] && !(128 & e[1]))
              throw new Error("S value excessively padded");
            const o = n.allocUnsafe(6 + r + i);
            return (
              (o[0] = 48),
              (o[1] = o.length - 2),
              (o[2] = 2),
              (o[3] = t.length),
              t.copy(o, 4),
              (o[4 + r] = 2),
              (o[5 + r] = e.length),
              e.copy(o, 6 + r),
              o
            );
          });
      },
      41696: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Block = void 0);
        const i = r(30606),
          o = r(91944),
          s = r(31015),
          a = r(22021),
          u = r(98116),
          { typeforce: c } = u,
          f = new TypeError("Cannot compute merkle root for zero transactions"),
          h = new TypeError(
            "Cannot compute witness commit for non-segwit block",
          );
        class l {
          constructor() {
            (this.version = 1),
              (this.prevHash = void 0),
              (this.merkleRoot = void 0),
              (this.timestamp = 0),
              (this.witnessCommit = void 0),
              (this.bits = 0),
              (this.nonce = 0),
              (this.transactions = void 0);
          }
          static fromBuffer(t) {
            if (t.length < 80) throw new Error("Buffer too small (< 80 bytes)");
            const e = new i.BufferReader(t),
              r = new l();
            if (
              ((r.version = e.readInt32()),
              (r.prevHash = e.readSlice(32)),
              (r.merkleRoot = e.readSlice(32)),
              (r.timestamp = e.readUInt32()),
              (r.bits = e.readUInt32()),
              (r.nonce = e.readUInt32()),
              80 === t.length)
            )
              return r;
            const n = () => {
                const t = a.Transaction.fromBuffer(
                  e.buffer.slice(e.offset),
                  !0,
                );
                return (e.offset += t.byteLength()), t;
              },
              o = e.readVarInt();
            r.transactions = [];
            for (let t = 0; t < o; ++t) {
              const t = n();
              r.transactions.push(t);
            }
            const s = r.getWitnessCommit();
            return s && (r.witnessCommit = s), r;
          }
          static fromHex(t) {
            return l.fromBuffer(n.from(t, "hex"));
          }
          static calculateTarget(t) {
            const e = ((4278190080 & t) >> 24) - 3,
              r = 8388607 & t,
              i = n.alloc(32, 0);
            return i.writeUIntBE(r, 29 - e, 3), i;
          }
          static calculateMerkleRoot(t, e) {
            if ((c([{ getHash: u.Function }], t), 0 === t.length)) throw f;
            if (e && !d(t)) throw h;
            const r = t.map((t) => t.getHash(e)),
              i = (0, s.fastMerkleRoot)(r, o.hash256);
            return e ? o.hash256(n.concat([i, t[0].ins[0].witness[0]])) : i;
          }
          getWitnessCommit() {
            if (!d(this.transactions)) return null;
            const t = this.transactions[0].outs
              .filter((t) =>
                t.script.slice(0, 6).equals(n.from("6a24aa21a9ed", "hex")),
              )
              .map((t) => t.script.slice(6, 38));
            if (0 === t.length) return null;
            const e = t[t.length - 1];
            return e instanceof n && 32 === e.length ? e : null;
          }
          hasWitnessCommit() {
            return (
              (this.witnessCommit instanceof n &&
                32 === this.witnessCommit.length) ||
              null !== this.getWitnessCommit()
            );
          }
          hasWitness() {
            return (
              (t = this.transactions) instanceof Array &&
              t.some(
                (t) =>
                  "object" == typeof t &&
                  t.ins instanceof Array &&
                  t.ins.some(
                    (t) =>
                      "object" == typeof t &&
                      t.witness instanceof Array &&
                      t.witness.length > 0,
                  ),
              )
            );
            var t;
          }
          weight() {
            return 3 * this.byteLength(!1, !1) + this.byteLength(!1, !0);
          }
          byteLength(t, e = !0) {
            return t || !this.transactions
              ? 80
              : 80 +
                  i.varuint.encodingLength(this.transactions.length) +
                  this.transactions.reduce((t, r) => t + r.byteLength(e), 0);
          }
          getHash() {
            return o.hash256(this.toBuffer(!0));
          }
          getId() {
            return (0, i.reverseBuffer)(this.getHash()).toString("hex");
          }
          getUTCDate() {
            const t = new Date(0);
            return t.setUTCSeconds(this.timestamp), t;
          }
          toBuffer(t) {
            const e = n.allocUnsafe(this.byteLength(t)),
              r = new i.BufferWriter(e);
            return (
              r.writeInt32(this.version),
              r.writeSlice(this.prevHash),
              r.writeSlice(this.merkleRoot),
              r.writeUInt32(this.timestamp),
              r.writeUInt32(this.bits),
              r.writeUInt32(this.nonce),
              t ||
                !this.transactions ||
                (i.varuint.encode(this.transactions.length, e, r.offset),
                (r.offset += i.varuint.encode.bytes),
                this.transactions.forEach((t) => {
                  const n = t.byteLength();
                  t.toBuffer(e, r.offset), (r.offset += n);
                })),
              e
            );
          }
          toHex(t) {
            return this.toBuffer(t).toString("hex");
          }
          checkTxRoots() {
            const t = this.hasWitnessCommit();
            return (
              !(!t && this.hasWitness()) &&
              this.__checkMerkleRoot() &&
              (!t || this.__checkWitnessCommit())
            );
          }
          checkProofOfWork() {
            const t = (0, i.reverseBuffer)(this.getHash()),
              e = l.calculateTarget(this.bits);
            return t.compare(e) <= 0;
          }
          __checkMerkleRoot() {
            if (!this.transactions) throw f;
            const t = l.calculateMerkleRoot(this.transactions);
            return 0 === this.merkleRoot.compare(t);
          }
          __checkWitnessCommit() {
            if (!this.transactions) throw f;
            if (!this.hasWitnessCommit()) throw h;
            const t = l.calculateMerkleRoot(this.transactions, !0);
            return 0 === this.witnessCommit.compare(t);
          }
        }
        function d(t) {
          return (
            t instanceof Array &&
            t[0] &&
            t[0].ins &&
            t[0].ins instanceof Array &&
            t[0].ins[0] &&
            t[0].ins[0].witness &&
            t[0].ins[0].witness instanceof Array &&
            t[0].ins[0].witness.length > 0
          );
        }
        e.Block = l;
      },
      30606: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.BufferReader =
            e.BufferWriter =
            e.cloneBuffer =
            e.reverseBuffer =
            e.writeUInt64LE =
            e.readUInt64LE =
            e.varuint =
              void 0);
        const i = r(98116),
          { typeforce: o } = i,
          s = r(68469);
        function a(t, e) {
          if ("number" != typeof t)
            throw new Error("cannot write a non-number as a number");
          if (t < 0)
            throw new Error(
              "specified a negative value for writing an unsigned value",
            );
          if (t > e) throw new Error("RangeError: value out of range");
          if (Math.floor(t) !== t)
            throw new Error("value has a fractional component");
        }
        function u(t, e) {
          const r = t.readUInt32LE(e);
          let n = t.readUInt32LE(e + 4);
          return (n *= 4294967296), a(n + r, 9007199254740991), n + r;
        }
        function c(t, e, r) {
          return (
            a(e, 9007199254740991),
            t.writeInt32LE(-1 & e, r),
            t.writeUInt32LE(Math.floor(e / 4294967296), r + 4),
            r + 8
          );
        }
        (e.varuint = s),
          (e.readUInt64LE = u),
          (e.writeUInt64LE = c),
          (e.reverseBuffer = function (t) {
            if (t.length < 1) return t;
            let e = t.length - 1,
              r = 0;
            for (let n = 0; n < t.length / 2; n++)
              (r = t[n]), (t[n] = t[e]), (t[e] = r), e--;
            return t;
          }),
          (e.cloneBuffer = function (t) {
            const e = n.allocUnsafe(t.length);
            return t.copy(e), e;
          });
        class f {
          static withCapacity(t) {
            return new f(n.alloc(t));
          }
          constructor(t, e = 0) {
            (this.buffer = t),
              (this.offset = e),
              o(i.tuple(i.Buffer, i.UInt32), [t, e]);
          }
          writeUInt8(t) {
            this.offset = this.buffer.writeUInt8(t, this.offset);
          }
          writeInt32(t) {
            this.offset = this.buffer.writeInt32LE(t, this.offset);
          }
          writeUInt32(t) {
            this.offset = this.buffer.writeUInt32LE(t, this.offset);
          }
          writeUInt64(t) {
            this.offset = c(this.buffer, t, this.offset);
          }
          writeVarInt(t) {
            s.encode(t, this.buffer, this.offset),
              (this.offset += s.encode.bytes);
          }
          writeSlice(t) {
            if (this.buffer.length < this.offset + t.length)
              throw new Error("Cannot write slice out of bounds");
            this.offset += t.copy(this.buffer, this.offset);
          }
          writeVarSlice(t) {
            this.writeVarInt(t.length), this.writeSlice(t);
          }
          writeVector(t) {
            this.writeVarInt(t.length), t.forEach((t) => this.writeVarSlice(t));
          }
          end() {
            if (this.buffer.length === this.offset) return this.buffer;
            throw new Error(
              `buffer size ${this.buffer.length}, offset ${this.offset}`,
            );
          }
        }
        e.BufferWriter = f;
        e.BufferReader = class {
          constructor(t, e = 0) {
            (this.buffer = t),
              (this.offset = e),
              o(i.tuple(i.Buffer, i.UInt32), [t, e]);
          }
          readUInt8() {
            const t = this.buffer.readUInt8(this.offset);
            return this.offset++, t;
          }
          readInt32() {
            const t = this.buffer.readInt32LE(this.offset);
            return (this.offset += 4), t;
          }
          readUInt32() {
            const t = this.buffer.readUInt32LE(this.offset);
            return (this.offset += 4), t;
          }
          readUInt64() {
            const t = u(this.buffer, this.offset);
            return (this.offset += 8), t;
          }
          readVarInt() {
            const t = s.decode(this.buffer, this.offset);
            return (this.offset += s.decode.bytes), t;
          }
          readSlice(t) {
            if (this.buffer.length < this.offset + t)
              throw new Error("Cannot read slice out of bounds");
            const e = this.buffer.slice(this.offset, this.offset + t);
            return (this.offset += t), e;
          }
          readVarSlice() {
            return this.readSlice(this.readVarInt());
          }
          readVector() {
            const t = this.readVarInt(),
              e = [];
            for (let r = 0; r < t; r++) e.push(this.readVarSlice());
            return e;
          }
        };
      },
      91944: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.taggedHash =
            e.TAGGED_HASH_PREFIXES =
            e.TAGS =
            e.hash256 =
            e.hash160 =
            e.sha256 =
            e.sha1 =
            e.ripemd160 =
              void 0);
        const i = r(93238),
          o = r(31549),
          s = r(22623);
        function a(t) {
          return n.from((0, s.sha256)(Uint8Array.from(t)));
        }
        (e.ripemd160 = function (t) {
          return n.from((0, i.ripemd160)(Uint8Array.from(t)));
        }),
          (e.sha1 = function (t) {
            return n.from((0, o.sha1)(Uint8Array.from(t)));
          }),
          (e.sha256 = a),
          (e.hash160 = function (t) {
            return n.from((0, i.ripemd160)((0, s.sha256)(Uint8Array.from(t))));
          }),
          (e.hash256 = function (t) {
            return n.from((0, s.sha256)((0, s.sha256)(Uint8Array.from(t))));
          }),
          (e.TAGS = [
            "BIP0340/challenge",
            "BIP0340/aux",
            "BIP0340/nonce",
            "TapLeaf",
            "TapBranch",
            "TapSighash",
            "TapTweak",
            "KeyAgg list",
            "KeyAgg coefficient",
          ]),
          (e.TAGGED_HASH_PREFIXES = {
            "BIP0340/challenge": n.from([
              123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125,
              179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143,
              109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88, 50, 62, 177,
              191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79,
              73, 254, 81, 143, 109, 72, 211, 124,
            ]),
            "BIP0340/aux": n.from([
              241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152,
              126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46,
              216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202, 218, 109, 148,
              202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151,
              45, 119, 165, 46, 216, 193, 204, 144,
            ]),
            "BIP0340/nonce": n.from([
              7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18,
              28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191,
              235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3,
              79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251,
              82, 191, 235, 47,
            ]),
            TapLeaf: n.from([
              174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38,
              56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233,
              238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29,
              30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190,
              120, 233, 238,
            ]),
            TapBranch: n.from([
              25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92,
              1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91,
              245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95, 162, 169,
              241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70,
              52, 144, 208, 91, 245, 22, 160, 21,
            ]),
            TapSighash: n.from([
              244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70,
              97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198,
              40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200, 180, 146,
              75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135,
              35, 117, 151, 198, 40, 228, 160, 49,
            ]),
            TapTweak: n.from([
              232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67,
              198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244,
              175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160, 80, 227, 175,
              27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251,
              181, 197, 161, 244, 175, 87, 197, 233,
            ]),
            "KeyAgg list": n.from([
              72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78,
              44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153,
              2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174,
              89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158,
              160, 212, 153, 2, 148, 240,
            ]),
            "KeyAgg coefficient": n.from([
              191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86,
              109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205,
              82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229,
              61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0,
              249, 77, 205, 82, 201, 129,
            ]),
          }),
          (e.taggedHash = function (t, r) {
            return a(n.concat([e.TAGGED_HASH_PREFIXES[t], r]));
          });
      },
      60916: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.getEccLib = e.initEccLib = void 0);
        const i = {};
        (e.initEccLib = function (t) {
          t
            ? t !== i.eccLib &&
              (!(function (t) {
                s("function" == typeof t.isXOnlyPoint),
                  s(
                    t.isXOnlyPoint(
                      o(
                        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                      ),
                    ),
                  ),
                  s(
                    t.isXOnlyPoint(
                      o(
                        "fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e",
                      ),
                    ),
                  ),
                  s(
                    t.isXOnlyPoint(
                      o(
                        "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                      ),
                    ),
                  ),
                  s(
                    t.isXOnlyPoint(
                      o(
                        "0000000000000000000000000000000000000000000000000000000000000001",
                      ),
                    ),
                  ),
                  s(
                    !t.isXOnlyPoint(
                      o(
                        "0000000000000000000000000000000000000000000000000000000000000000",
                      ),
                    ),
                  ),
                  s(
                    !t.isXOnlyPoint(
                      o(
                        "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
                      ),
                    ),
                  ),
                  s("function" == typeof t.xOnlyPointAddTweak),
                  a.forEach((e) => {
                    const r = t.xOnlyPointAddTweak(o(e.pubkey), o(e.tweak));
                    null === e.result
                      ? s(null === r)
                      : (s(null !== r),
                        s(r.parity === e.parity),
                        s(n.from(r.xOnlyPubkey).equals(o(e.result))));
                  });
              })(t),
              (i.eccLib = t))
            : (i.eccLib = t);
        }),
          (e.getEccLib = function () {
            if (!i.eccLib)
              throw new Error(
                "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance",
              );
            return i.eccLib;
          });
        const o = (t) => n.from(t, "hex");
        function s(t) {
          if (!t) throw new Error("ecc library invalid");
        }
        const a = [
          {
            pubkey:
              "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            tweak:
              "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
            parity: -1,
            result: null,
          },
          {
            pubkey:
              "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
            tweak:
              "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
            parity: 1,
            result:
              "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf",
          },
          {
            pubkey:
              "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
            tweak:
              "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
            parity: 0,
            result:
              "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c",
          },
        ];
      },
      21757: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.initEccLib =
            e.Transaction =
            e.opcodes =
            e.Psbt =
            e.Block =
            e.script =
            e.payments =
            e.networks =
            e.crypto =
            e.address =
              void 0);
        const n = r(70057);
        e.address = n;
        const i = r(91944);
        e.crypto = i;
        const o = r(50622);
        e.networks = o;
        const s = r(30885);
        e.payments = s;
        const a = r(67038);
        e.script = a;
        var u = r(41696);
        Object.defineProperty(e, "Block", {
          enumerable: !0,
          get: function () {
            return u.Block;
          },
        });
        var c = r(59646);
        Object.defineProperty(e, "Psbt", {
          enumerable: !0,
          get: function () {
            return c.Psbt;
          },
        });
        var f = r(68417);
        Object.defineProperty(e, "opcodes", {
          enumerable: !0,
          get: function () {
            return f.OPS;
          },
        });
        var h = r(22021);
        Object.defineProperty(e, "Transaction", {
          enumerable: !0,
          get: function () {
            return h.Transaction;
          },
        });
        var l = r(60916);
        Object.defineProperty(e, "initEccLib", {
          enumerable: !0,
          get: function () {
            return l.initEccLib;
          },
        });
      },
      31015: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.fastMerkleRoot = void 0),
          (e.fastMerkleRoot = function (t, e) {
            if (!Array.isArray(t)) throw TypeError("Expected values Array");
            if ("function" != typeof e)
              throw TypeError("Expected digest Function");
            let r = t.length;
            const i = t.concat();
            for (; r > 1; ) {
              let t = 0;
              for (let o = 0; o < r; o += 2, ++t) {
                const s = i[o],
                  a = o + 1 === r ? s : i[o + 1],
                  u = n.concat([s, a]);
                i[t] = e(u);
              }
              r = t;
            }
            return i[0];
          });
      },
      50622: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.testnet = e.regtest = e.bitcoin = void 0),
          (e.bitcoin = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "bc",
            bip32: { public: 76067358, private: 76066276 },
            pubKeyHash: 0,
            scriptHash: 5,
            wif: 128,
          }),
          (e.regtest = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "bcrt",
            bip32: { public: 70617039, private: 70615956 },
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239,
          }),
          (e.testnet = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "tb",
            bip32: { public: 70617039, private: 70615956 },
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239,
          });
      },
      68417: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.REVERSE_OPS = e.OPS = void 0);
        const r = {
          OP_FALSE: 0,
          OP_0: 0,
          OP_PUSHDATA1: 76,
          OP_PUSHDATA2: 77,
          OP_PUSHDATA4: 78,
          OP_1NEGATE: 79,
          OP_RESERVED: 80,
          OP_TRUE: 81,
          OP_1: 81,
          OP_2: 82,
          OP_3: 83,
          OP_4: 84,
          OP_5: 85,
          OP_6: 86,
          OP_7: 87,
          OP_8: 88,
          OP_9: 89,
          OP_10: 90,
          OP_11: 91,
          OP_12: 92,
          OP_13: 93,
          OP_14: 94,
          OP_15: 95,
          OP_16: 96,
          OP_NOP: 97,
          OP_VER: 98,
          OP_IF: 99,
          OP_NOTIF: 100,
          OP_VERIF: 101,
          OP_VERNOTIF: 102,
          OP_ELSE: 103,
          OP_ENDIF: 104,
          OP_VERIFY: 105,
          OP_RETURN: 106,
          OP_TOALTSTACK: 107,
          OP_FROMALTSTACK: 108,
          OP_2DROP: 109,
          OP_2DUP: 110,
          OP_3DUP: 111,
          OP_2OVER: 112,
          OP_2ROT: 113,
          OP_2SWAP: 114,
          OP_IFDUP: 115,
          OP_DEPTH: 116,
          OP_DROP: 117,
          OP_DUP: 118,
          OP_NIP: 119,
          OP_OVER: 120,
          OP_PICK: 121,
          OP_ROLL: 122,
          OP_ROT: 123,
          OP_SWAP: 124,
          OP_TUCK: 125,
          OP_CAT: 126,
          OP_SUBSTR: 127,
          OP_LEFT: 128,
          OP_RIGHT: 129,
          OP_SIZE: 130,
          OP_INVERT: 131,
          OP_AND: 132,
          OP_OR: 133,
          OP_XOR: 134,
          OP_EQUAL: 135,
          OP_EQUALVERIFY: 136,
          OP_RESERVED1: 137,
          OP_RESERVED2: 138,
          OP_1ADD: 139,
          OP_1SUB: 140,
          OP_2MUL: 141,
          OP_2DIV: 142,
          OP_NEGATE: 143,
          OP_ABS: 144,
          OP_NOT: 145,
          OP_0NOTEQUAL: 146,
          OP_ADD: 147,
          OP_SUB: 148,
          OP_MUL: 149,
          OP_DIV: 150,
          OP_MOD: 151,
          OP_LSHIFT: 152,
          OP_RSHIFT: 153,
          OP_BOOLAND: 154,
          OP_BOOLOR: 155,
          OP_NUMEQUAL: 156,
          OP_NUMEQUALVERIFY: 157,
          OP_NUMNOTEQUAL: 158,
          OP_LESSTHAN: 159,
          OP_GREATERTHAN: 160,
          OP_LESSTHANOREQUAL: 161,
          OP_GREATERTHANOREQUAL: 162,
          OP_MIN: 163,
          OP_MAX: 164,
          OP_WITHIN: 165,
          OP_RIPEMD160: 166,
          OP_SHA1: 167,
          OP_SHA256: 168,
          OP_HASH160: 169,
          OP_HASH256: 170,
          OP_CODESEPARATOR: 171,
          OP_CHECKSIG: 172,
          OP_CHECKSIGVERIFY: 173,
          OP_CHECKMULTISIG: 174,
          OP_CHECKMULTISIGVERIFY: 175,
          OP_NOP1: 176,
          OP_NOP2: 177,
          OP_CHECKLOCKTIMEVERIFY: 177,
          OP_NOP3: 178,
          OP_CHECKSEQUENCEVERIFY: 178,
          OP_NOP4: 179,
          OP_NOP5: 180,
          OP_NOP6: 181,
          OP_NOP7: 182,
          OP_NOP8: 183,
          OP_NOP9: 184,
          OP_NOP10: 185,
          OP_CHECKSIGADD: 186,
          OP_PUBKEYHASH: 253,
          OP_PUBKEY: 254,
          OP_INVALIDOPCODE: 255,
        };
        e.OPS = r;
        const n = {};
        e.REVERSE_OPS = n;
        for (const t of Object.keys(r)) {
          n[r[t]] = t;
        }
      },
      82218: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.tweakKey =
            e.tapTweakHash =
            e.tapleafHash =
            e.findScriptPath =
            e.toHashTree =
            e.rootHashFromPath =
            e.MAX_TAPTREE_DEPTH =
            e.LEAF_VERSION_TAPSCRIPT =
              void 0);
        const n = r(48287),
          i = r(60916),
          o = r(91944),
          s = r(30606),
          a = r(98116);
        (e.LEAF_VERSION_TAPSCRIPT = 192), (e.MAX_TAPTREE_DEPTH = 128);
        function u(t) {
          const r = t.version || e.LEAF_VERSION_TAPSCRIPT;
          return o.taggedHash(
            "TapLeaf",
            n.Buffer.concat([n.Buffer.from([r]), h(t.output)]),
          );
        }
        function c(t, e) {
          return o.taggedHash("TapTweak", n.Buffer.concat(e ? [t, e] : [t]));
        }
        function f(t, e) {
          return o.taggedHash("TapBranch", n.Buffer.concat([t, e]));
        }
        function h(t) {
          const e = s.varuint.encodingLength(t.length),
            r = n.Buffer.allocUnsafe(e);
          return s.varuint.encode(t.length, r), n.Buffer.concat([r, t]);
        }
        (e.rootHashFromPath = function (t, e) {
          if (t.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${t.length}, expected min 33.`,
            );
          const r = (t.length - 33) / 32;
          let n = e;
          for (let e = 0; e < r; e++) {
            const r = t.slice(33 + 32 * e, 65 + 32 * e);
            n = n.compare(r) < 0 ? f(n, r) : f(r, n);
          }
          return n;
        }),
          (e.toHashTree = function t(e) {
            if ((0, a.isTapleaf)(e)) return { hash: u(e) };
            const r = [t(e[0]), t(e[1])];
            r.sort((t, e) => t.hash.compare(e.hash));
            const [n, i] = r;
            return { hash: f(n.hash, i.hash), left: n, right: i };
          }),
          (e.findScriptPath = function t(e, r) {
            if ("left" in (n = e) && "right" in n) {
              const n = t(e.left, r);
              if (void 0 !== n) return [...n, e.right.hash];
              const i = t(e.right, r);
              if (void 0 !== i) return [...i, e.left.hash];
            } else if (e.hash.equals(r)) return [];
            var n;
          }),
          (e.tapleafHash = u),
          (e.tapTweakHash = c),
          (e.tweakKey = function (t, e) {
            if (!n.Buffer.isBuffer(t)) return null;
            if (32 !== t.length) return null;
            if (e && 32 !== e.length) return null;
            const r = c(t, e),
              o = (0, i.getEccLib)().xOnlyPointAddTweak(t, r);
            return o && null !== o.xOnlyPubkey
              ? { parity: o.parity, x: n.Buffer.from(o.xOnlyPubkey) }
              : null;
          });
      },
      55472: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2data = void 0);
        const n = r(50622),
          i = r(67038),
          o = r(98116),
          s = r(20264),
          a = i.OPS;
        e.p2data = function (t, e) {
          if (!t.data && !t.output) throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, o.typeforce)(
              {
                network: o.typeforce.maybe(o.typeforce.Object),
                output: o.typeforce.maybe(o.typeforce.Buffer),
                data: o.typeforce.maybe(
                  o.typeforce.arrayOf(o.typeforce.Buffer),
                ),
              },
              t,
            );
          const r = { name: "embed", network: t.network || n.bitcoin };
          if (
            (s.prop(r, "output", () => {
              if (t.data) return i.compile([a.OP_RETURN].concat(t.data));
            }),
            s.prop(r, "data", () => {
              if (t.output) return i.decompile(t.output).slice(1);
            }),
            e.validate && t.output)
          ) {
            const e = i.decompile(t.output);
            if (e[0] !== a.OP_RETURN) throw new TypeError("Output is invalid");
            if (!e.slice(1).every(o.typeforce.Buffer))
              throw new TypeError("Output is invalid");
            if (
              t.data &&
              !(function (t, e) {
                return (
                  t.length === e.length && t.every((t, r) => t.equals(e[r]))
                );
              })(t.data, r.data)
            )
              throw new TypeError("Data mismatch");
          }
          return Object.assign(r, t);
        };
      },
      30885: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2tr =
            e.p2wsh =
            e.p2wpkh =
            e.p2sh =
            e.p2pkh =
            e.p2pk =
            e.p2ms =
            e.embed =
              void 0);
        const n = r(55472);
        Object.defineProperty(e, "embed", {
          enumerable: !0,
          get: function () {
            return n.p2data;
          },
        });
        const i = r(91395);
        Object.defineProperty(e, "p2ms", {
          enumerable: !0,
          get: function () {
            return i.p2ms;
          },
        });
        const o = r(4930);
        Object.defineProperty(e, "p2pk", {
          enumerable: !0,
          get: function () {
            return o.p2pk;
          },
        });
        const s = r(23504);
        Object.defineProperty(e, "p2pkh", {
          enumerable: !0,
          get: function () {
            return s.p2pkh;
          },
        });
        const a = r(8368);
        Object.defineProperty(e, "p2sh", {
          enumerable: !0,
          get: function () {
            return a.p2sh;
          },
        });
        const u = r(77027);
        Object.defineProperty(e, "p2wpkh", {
          enumerable: !0,
          get: function () {
            return u.p2wpkh;
          },
        });
        const c = r(79041);
        Object.defineProperty(e, "p2wsh", {
          enumerable: !0,
          get: function () {
            return c.p2wsh;
          },
        });
        const f = r(25501);
        Object.defineProperty(e, "p2tr", {
          enumerable: !0,
          get: function () {
            return f.p2tr;
          },
        });
      },
      20264: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.value = e.prop = void 0),
          (e.prop = function (t, e, r) {
            Object.defineProperty(t, e, {
              configurable: !0,
              enumerable: !0,
              get() {
                const t = r.call(this);
                return (this[e] = t), t;
              },
              set(t) {
                Object.defineProperty(this, e, {
                  configurable: !0,
                  enumerable: !0,
                  value: t,
                  writable: !0,
                });
              },
            });
          }),
          (e.value = function (t) {
            let e;
            return () => (void 0 !== e || (e = t()), e);
          });
      },
      91395: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2ms = void 0);
        const n = r(50622),
          i = r(67038),
          o = r(98116),
          s = r(20264),
          a = i.OPS,
          u = a.OP_RESERVED;
        function c(t, e) {
          return t.length === e.length && t.every((t, r) => t.equals(e[r]));
        }
        e.p2ms = function (t, e) {
          if (
            !(
              t.input ||
              t.output ||
              (t.pubkeys && void 0 !== t.m) ||
              t.signatures
            )
          )
            throw new TypeError("Not enough data");
          function r(t) {
            return (
              i.isCanonicalScriptSignature(t) ||
              void 0 !== (e.allowIncomplete && t === a.OP_0)
            );
          }
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, o.typeforce)(
              {
                network: o.typeforce.maybe(o.typeforce.Object),
                m: o.typeforce.maybe(o.typeforce.Number),
                n: o.typeforce.maybe(o.typeforce.Number),
                output: o.typeforce.maybe(o.typeforce.Buffer),
                pubkeys: o.typeforce.maybe(o.typeforce.arrayOf(o.isPoint)),
                signatures: o.typeforce.maybe(o.typeforce.arrayOf(r)),
                input: o.typeforce.maybe(o.typeforce.Buffer),
              },
              t,
            );
          const f = { network: t.network || n.bitcoin };
          let h = [],
            l = !1;
          function d(t) {
            l ||
              ((l = !0),
              (h = i.decompile(t)),
              (f.m = h[0] - u),
              (f.n = h[h.length - 2] - u),
              (f.pubkeys = h.slice(1, -2)));
          }
          if (
            (s.prop(f, "output", () => {
              if (t.m && f.n && t.pubkeys)
                return i.compile(
                  [].concat(u + t.m, t.pubkeys, u + f.n, a.OP_CHECKMULTISIG),
                );
            }),
            s.prop(f, "m", () => {
              if (f.output) return d(f.output), f.m;
            }),
            s.prop(f, "n", () => {
              if (f.pubkeys) return f.pubkeys.length;
            }),
            s.prop(f, "pubkeys", () => {
              if (t.output) return d(t.output), f.pubkeys;
            }),
            s.prop(f, "signatures", () => {
              if (t.input) return i.decompile(t.input).slice(1);
            }),
            s.prop(f, "input", () => {
              if (t.signatures) return i.compile([a.OP_0].concat(t.signatures));
            }),
            s.prop(f, "witness", () => {
              if (f.input) return [];
            }),
            s.prop(f, "name", () => {
              if (f.m && f.n) return `p2ms(${f.m} of ${f.n})`;
            }),
            e.validate)
          ) {
            if (t.output) {
              if ((d(t.output), !o.typeforce.Number(h[0])))
                throw new TypeError("Output is invalid");
              if (!o.typeforce.Number(h[h.length - 2]))
                throw new TypeError("Output is invalid");
              if (h[h.length - 1] !== a.OP_CHECKMULTISIG)
                throw new TypeError("Output is invalid");
              if (f.m <= 0 || f.n > 16 || f.m > f.n || f.n !== h.length - 3)
                throw new TypeError("Output is invalid");
              if (!f.pubkeys.every((t) => (0, o.isPoint)(t)))
                throw new TypeError("Output is invalid");
              if (void 0 !== t.m && t.m !== f.m)
                throw new TypeError("m mismatch");
              if (void 0 !== t.n && t.n !== f.n)
                throw new TypeError("n mismatch");
              if (t.pubkeys && !c(t.pubkeys, f.pubkeys))
                throw new TypeError("Pubkeys mismatch");
            }
            if (t.pubkeys) {
              if (void 0 !== t.n && t.n !== t.pubkeys.length)
                throw new TypeError("Pubkey count mismatch");
              if (((f.n = t.pubkeys.length), f.n < f.m))
                throw new TypeError("Pubkey count cannot be less than m");
            }
            if (t.signatures) {
              if (t.signatures.length < f.m)
                throw new TypeError("Not enough signatures provided");
              if (t.signatures.length > f.m)
                throw new TypeError("Too many signatures provided");
            }
            if (t.input) {
              if (t.input[0] !== a.OP_0)
                throw new TypeError("Input is invalid");
              if (0 === f.signatures.length || !f.signatures.every(r))
                throw new TypeError("Input has invalid signature(s)");
              if (t.signatures && !c(t.signatures, f.signatures))
                throw new TypeError("Signature mismatch");
              if (void 0 !== t.m && t.m !== t.signatures.length)
                throw new TypeError("Signature count mismatch");
            }
          }
          return Object.assign(f, t);
        };
      },
      4930: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2pk = void 0);
        const n = r(50622),
          i = r(67038),
          o = r(98116),
          s = r(20264),
          a = i.OPS;
        e.p2pk = function (t, e) {
          if (!(t.input || t.output || t.pubkey || t.input || t.signature))
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, o.typeforce)(
              {
                network: o.typeforce.maybe(o.typeforce.Object),
                output: o.typeforce.maybe(o.typeforce.Buffer),
                pubkey: o.typeforce.maybe(o.isPoint),
                signature: o.typeforce.maybe(i.isCanonicalScriptSignature),
                input: o.typeforce.maybe(o.typeforce.Buffer),
              },
              t,
            );
          const r = s.value(() => i.decompile(t.input)),
            u = { name: "p2pk", network: t.network || n.bitcoin };
          if (
            (s.prop(u, "output", () => {
              if (t.pubkey) return i.compile([t.pubkey, a.OP_CHECKSIG]);
            }),
            s.prop(u, "pubkey", () => {
              if (t.output) return t.output.slice(1, -1);
            }),
            s.prop(u, "signature", () => {
              if (t.input) return r()[0];
            }),
            s.prop(u, "input", () => {
              if (t.signature) return i.compile([t.signature]);
            }),
            s.prop(u, "witness", () => {
              if (u.input) return [];
            }),
            e.validate)
          ) {
            if (t.output) {
              if (t.output[t.output.length - 1] !== a.OP_CHECKSIG)
                throw new TypeError("Output is invalid");
              if (!(0, o.isPoint)(u.pubkey))
                throw new TypeError("Output pubkey is invalid");
              if (t.pubkey && !t.pubkey.equals(u.pubkey))
                throw new TypeError("Pubkey mismatch");
            }
            if (t.signature && t.input && !t.input.equals(u.input))
              throw new TypeError("Signature mismatch");
            if (t.input) {
              if (1 !== r().length) throw new TypeError("Input is invalid");
              if (!i.isCanonicalScriptSignature(u.signature))
                throw new TypeError("Input has invalid signature");
            }
          }
          return Object.assign(u, t);
        };
      },
      23504: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2pkh = void 0);
        const i = r(91944),
          o = r(50622),
          s = r(67038),
          a = r(98116),
          u = r(20264),
          c = r(82894),
          f = s.OPS;
        e.p2pkh = function (t, e) {
          if (!(t.address || t.hash || t.output || t.pubkey || t.input))
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, a.typeforce)(
              {
                network: a.typeforce.maybe(a.typeforce.Object),
                address: a.typeforce.maybe(a.typeforce.String),
                hash: a.typeforce.maybe(a.typeforce.BufferN(20)),
                output: a.typeforce.maybe(a.typeforce.BufferN(25)),
                pubkey: a.typeforce.maybe(a.isPoint),
                signature: a.typeforce.maybe(s.isCanonicalScriptSignature),
                input: a.typeforce.maybe(a.typeforce.Buffer),
              },
              t,
            );
          const r = u.value(() => {
              const e = n.from(c.decode(t.address));
              return { version: e.readUInt8(0), hash: e.slice(1) };
            }),
            h = u.value(() => s.decompile(t.input)),
            l = t.network || o.bitcoin,
            d = { name: "p2pkh", network: l };
          if (
            (u.prop(d, "address", () => {
              if (!d.hash) return;
              const t = n.allocUnsafe(21);
              return (
                t.writeUInt8(l.pubKeyHash, 0), d.hash.copy(t, 1), c.encode(t)
              );
            }),
            u.prop(d, "hash", () =>
              t.output
                ? t.output.slice(3, 23)
                : t.address
                  ? r().hash
                  : t.pubkey || d.pubkey
                    ? i.hash160(t.pubkey || d.pubkey)
                    : void 0,
            ),
            u.prop(d, "output", () => {
              if (d.hash)
                return s.compile([
                  f.OP_DUP,
                  f.OP_HASH160,
                  d.hash,
                  f.OP_EQUALVERIFY,
                  f.OP_CHECKSIG,
                ]);
            }),
            u.prop(d, "pubkey", () => {
              if (t.input) return h()[1];
            }),
            u.prop(d, "signature", () => {
              if (t.input) return h()[0];
            }),
            u.prop(d, "input", () => {
              if (t.pubkey && t.signature)
                return s.compile([t.signature, t.pubkey]);
            }),
            u.prop(d, "witness", () => {
              if (d.input) return [];
            }),
            e.validate)
          ) {
            let e = n.from([]);
            if (t.address) {
              if (r().version !== l.pubKeyHash)
                throw new TypeError("Invalid version or Network mismatch");
              if (20 !== r().hash.length)
                throw new TypeError("Invalid address");
              e = r().hash;
            }
            if (t.hash) {
              if (e.length > 0 && !e.equals(t.hash))
                throw new TypeError("Hash mismatch");
              e = t.hash;
            }
            if (t.output) {
              if (
                25 !== t.output.length ||
                t.output[0] !== f.OP_DUP ||
                t.output[1] !== f.OP_HASH160 ||
                20 !== t.output[2] ||
                t.output[23] !== f.OP_EQUALVERIFY ||
                t.output[24] !== f.OP_CHECKSIG
              )
                throw new TypeError("Output is invalid");
              const r = t.output.slice(3, 23);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
              e = r;
            }
            if (t.pubkey) {
              const r = i.hash160(t.pubkey);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
              e = r;
            }
            if (t.input) {
              const r = h();
              if (2 !== r.length) throw new TypeError("Input is invalid");
              if (!s.isCanonicalScriptSignature(r[0]))
                throw new TypeError("Input has invalid signature");
              if (!(0, a.isPoint)(r[1]))
                throw new TypeError("Input has invalid pubkey");
              if (t.signature && !t.signature.equals(r[0]))
                throw new TypeError("Signature mismatch");
              if (t.pubkey && !t.pubkey.equals(r[1]))
                throw new TypeError("Pubkey mismatch");
              const n = i.hash160(r[1]);
              if (e.length > 0 && !e.equals(n))
                throw new TypeError("Hash mismatch");
            }
          }
          return Object.assign(d, t);
        };
      },
      8368: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2sh = void 0);
        const i = r(91944),
          o = r(50622),
          s = r(67038),
          a = r(98116),
          u = r(20264),
          c = r(82894),
          f = s.OPS;
        e.p2sh = function (t, e) {
          if (!(t.address || t.hash || t.output || t.redeem || t.input))
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, a.typeforce)(
              {
                network: a.typeforce.maybe(a.typeforce.Object),
                address: a.typeforce.maybe(a.typeforce.String),
                hash: a.typeforce.maybe(a.typeforce.BufferN(20)),
                output: a.typeforce.maybe(a.typeforce.BufferN(23)),
                redeem: a.typeforce.maybe({
                  network: a.typeforce.maybe(a.typeforce.Object),
                  output: a.typeforce.maybe(a.typeforce.Buffer),
                  input: a.typeforce.maybe(a.typeforce.Buffer),
                  witness: a.typeforce.maybe(
                    a.typeforce.arrayOf(a.typeforce.Buffer),
                  ),
                }),
                input: a.typeforce.maybe(a.typeforce.Buffer),
                witness: a.typeforce.maybe(
                  a.typeforce.arrayOf(a.typeforce.Buffer),
                ),
              },
              t,
            );
          let r = t.network;
          r || (r = (t.redeem && t.redeem.network) || o.bitcoin);
          const h = { network: r },
            l = u.value(() => {
              const e = n.from(c.decode(t.address));
              return { version: e.readUInt8(0), hash: e.slice(1) };
            }),
            d = u.value(() => s.decompile(t.input)),
            p = u.value(() => {
              const e = d(),
                i = e[e.length - 1];
              return {
                network: r,
                output: i === f.OP_FALSE ? n.from([]) : i,
                input: s.compile(e.slice(0, -1)),
                witness: t.witness || [],
              };
            });
          if (
            (u.prop(h, "address", () => {
              if (!h.hash) return;
              const t = n.allocUnsafe(21);
              return (
                t.writeUInt8(h.network.scriptHash, 0),
                h.hash.copy(t, 1),
                c.encode(t)
              );
            }),
            u.prop(h, "hash", () =>
              t.output
                ? t.output.slice(2, 22)
                : t.address
                  ? l().hash
                  : h.redeem && h.redeem.output
                    ? i.hash160(h.redeem.output)
                    : void 0,
            ),
            u.prop(h, "output", () => {
              if (h.hash) return s.compile([f.OP_HASH160, h.hash, f.OP_EQUAL]);
            }),
            u.prop(h, "redeem", () => {
              if (t.input) return p();
            }),
            u.prop(h, "input", () => {
              if (t.redeem && t.redeem.input && t.redeem.output)
                return s.compile(
                  [].concat(s.decompile(t.redeem.input), t.redeem.output),
                );
            }),
            u.prop(h, "witness", () =>
              h.redeem && h.redeem.witness
                ? h.redeem.witness
                : h.input
                  ? []
                  : void 0,
            ),
            u.prop(h, "name", () => {
              const t = ["p2sh"];
              return (
                void 0 !== h.redeem &&
                  void 0 !== h.redeem.name &&
                  t.push(h.redeem.name),
                t.join("-")
              );
            }),
            e.validate)
          ) {
            let e = n.from([]);
            if (t.address) {
              if (l().version !== r.scriptHash)
                throw new TypeError("Invalid version or Network mismatch");
              if (20 !== l().hash.length)
                throw new TypeError("Invalid address");
              e = l().hash;
            }
            if (t.hash) {
              if (e.length > 0 && !e.equals(t.hash))
                throw new TypeError("Hash mismatch");
              e = t.hash;
            }
            if (t.output) {
              if (
                23 !== t.output.length ||
                t.output[0] !== f.OP_HASH160 ||
                20 !== t.output[1] ||
                t.output[22] !== f.OP_EQUAL
              )
                throw new TypeError("Output is invalid");
              const r = t.output.slice(2, 22);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
              e = r;
            }
            const o = (t) => {
              if (t.output) {
                const r = s.decompile(t.output);
                if (!r || r.length < 1)
                  throw new TypeError("Redeem.output too short");
                if (t.output.byteLength > 520)
                  throw new TypeError(
                    "Redeem.output unspendable if larger than 520 bytes",
                  );
                if (s.countNonPushOnlyOPs(r) > 201)
                  throw new TypeError(
                    "Redeem.output unspendable with more than 201 non-push ops",
                  );
                const n = i.hash160(t.output);
                if (e.length > 0 && !e.equals(n))
                  throw new TypeError("Hash mismatch");
                e = n;
              }
              if (t.input) {
                const e = t.input.length > 0,
                  r = t.witness && t.witness.length > 0;
                if (!e && !r) throw new TypeError("Empty input");
                if (e && r) throw new TypeError("Input and witness provided");
                if (e) {
                  const e = s.decompile(t.input);
                  if (!s.isPushOnly(e))
                    throw new TypeError("Non push-only scriptSig");
                }
              }
            };
            if (t.input) {
              const t = d();
              if (!t || t.length < 1) throw new TypeError("Input too short");
              if (!n.isBuffer(p().output))
                throw new TypeError("Input is invalid");
              o(p());
            }
            if (t.redeem) {
              if (t.redeem.network && t.redeem.network !== r)
                throw new TypeError("Network mismatch");
              if (t.input) {
                const e = p();
                if (t.redeem.output && !t.redeem.output.equals(e.output))
                  throw new TypeError("Redeem.output mismatch");
                if (t.redeem.input && !t.redeem.input.equals(e.input))
                  throw new TypeError("Redeem.input mismatch");
              }
              o(t.redeem);
            }
            if (
              t.witness &&
              t.redeem &&
              t.redeem.witness &&
              !(function (t, e) {
                return (
                  t.length === e.length && t.every((t, r) => t.equals(e[r]))
                );
              })(t.redeem.witness, t.witness)
            )
              throw new TypeError("Witness and redeem.witness mismatch");
          }
          return Object.assign(h, t);
        };
      },
      25501: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2tr = void 0);
        const n = r(48287),
          i = r(50622),
          o = r(67038),
          s = r(98116),
          a = r(60916),
          u = r(82218),
          c = r(20264),
          f = r(22343),
          h = o.OPS;
        e.p2tr = function (t, e) {
          if (
            !(
              t.address ||
              t.output ||
              t.pubkey ||
              t.internalPubkey ||
              (t.witness && t.witness.length > 1)
            )
          )
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, s.typeforce)(
              {
                address: s.typeforce.maybe(s.typeforce.String),
                input: s.typeforce.maybe(s.typeforce.BufferN(0)),
                network: s.typeforce.maybe(s.typeforce.Object),
                output: s.typeforce.maybe(s.typeforce.BufferN(34)),
                internalPubkey: s.typeforce.maybe(s.typeforce.BufferN(32)),
                hash: s.typeforce.maybe(s.typeforce.BufferN(32)),
                pubkey: s.typeforce.maybe(s.typeforce.BufferN(32)),
                signature: s.typeforce.maybe(
                  s.typeforce.anyOf(
                    s.typeforce.BufferN(64),
                    s.typeforce.BufferN(65),
                  ),
                ),
                witness: s.typeforce.maybe(
                  s.typeforce.arrayOf(s.typeforce.Buffer),
                ),
                scriptTree: s.typeforce.maybe(s.isTaptree),
                redeem: s.typeforce.maybe({
                  output: s.typeforce.maybe(s.typeforce.Buffer),
                  redeemVersion: s.typeforce.maybe(s.typeforce.Number),
                  witness: s.typeforce.maybe(
                    s.typeforce.arrayOf(s.typeforce.Buffer),
                  ),
                }),
                redeemVersion: s.typeforce.maybe(s.typeforce.Number),
              },
              t,
            );
          const r = c.value(() => {
              const e = f.bech32m.decode(t.address),
                r = e.words.shift(),
                i = f.bech32m.fromWords(e.words);
              return { version: r, prefix: e.prefix, data: n.Buffer.from(i) };
            }),
            l = c.value(() => {
              if (t.witness && t.witness.length)
                return t.witness.length >= 2 &&
                  80 === t.witness[t.witness.length - 1][0]
                  ? t.witness.slice(0, -1)
                  : t.witness.slice();
            }),
            d = c.value(() =>
              t.scriptTree
                ? (0, u.toHashTree)(t.scriptTree)
                : t.hash
                  ? { hash: t.hash }
                  : void 0,
            ),
            p = t.network || i.bitcoin,
            y = { name: "p2tr", network: p };
          if (
            (c.prop(y, "address", () => {
              if (!y.pubkey) return;
              const t = f.bech32m.toWords(y.pubkey);
              return t.unshift(1), f.bech32m.encode(p.bech32, t);
            }),
            c.prop(y, "hash", () => {
              const t = d();
              if (t) return t.hash;
              const e = l();
              if (e && e.length > 1) {
                const t = e[e.length - 1],
                  r = t[0] & s.TAPLEAF_VERSION_MASK,
                  n = e[e.length - 2],
                  i = (0, u.tapleafHash)({ output: n, version: r });
                return (0, u.rootHashFromPath)(t, i);
              }
              return null;
            }),
            c.prop(y, "output", () => {
              if (y.pubkey) return o.compile([h.OP_1, y.pubkey]);
            }),
            c.prop(y, "redeemVersion", () =>
              t.redeemVersion
                ? t.redeemVersion
                : t.redeem &&
                    void 0 !== t.redeem.redeemVersion &&
                    null !== t.redeem.redeemVersion
                  ? t.redeem.redeemVersion
                  : u.LEAF_VERSION_TAPSCRIPT,
            ),
            c.prop(y, "redeem", () => {
              const t = l();
              if (t && !(t.length < 2))
                return {
                  output: t[t.length - 2],
                  witness: t.slice(0, -2),
                  redeemVersion: t[t.length - 1][0] & s.TAPLEAF_VERSION_MASK,
                };
            }),
            c.prop(y, "pubkey", () => {
              if (t.pubkey) return t.pubkey;
              if (t.output) return t.output.slice(2);
              if (t.address) return r().data;
              if (y.internalPubkey) {
                const t = (0, u.tweakKey)(y.internalPubkey, y.hash);
                if (t) return t.x;
              }
            }),
            c.prop(y, "internalPubkey", () => {
              if (t.internalPubkey) return t.internalPubkey;
              const e = l();
              return e && e.length > 1 ? e[e.length - 1].slice(1, 33) : void 0;
            }),
            c.prop(y, "signature", () => {
              if (t.signature) return t.signature;
              const e = l();
              return e && 1 === e.length ? e[0] : void 0;
            }),
            c.prop(y, "witness", () => {
              if (t.witness) return t.witness;
              const e = d();
              if (e && t.redeem && t.redeem.output && t.internalPubkey) {
                const r = (0, u.tapleafHash)({
                    output: t.redeem.output,
                    version: y.redeemVersion,
                  }),
                  i = (0, u.findScriptPath)(e, r);
                if (!i) return;
                const o = (0, u.tweakKey)(t.internalPubkey, e.hash);
                if (!o) return;
                const s = n.Buffer.concat(
                  [
                    n.Buffer.from([y.redeemVersion | o.parity]),
                    t.internalPubkey,
                  ].concat(i),
                );
                return [t.redeem.output, s];
              }
              return t.signature ? [t.signature] : void 0;
            }),
            e.validate)
          ) {
            let e = n.Buffer.from([]);
            if (t.address) {
              if (p && p.bech32 !== r().prefix)
                throw new TypeError("Invalid prefix or Network mismatch");
              if (1 !== r().version)
                throw new TypeError("Invalid address version");
              if (32 !== r().data.length)
                throw new TypeError("Invalid address data");
              e = r().data;
            }
            if (t.pubkey) {
              if (e.length > 0 && !e.equals(t.pubkey))
                throw new TypeError("Pubkey mismatch");
              e = t.pubkey;
            }
            if (t.output) {
              if (
                34 !== t.output.length ||
                t.output[0] !== h.OP_1 ||
                32 !== t.output[1]
              )
                throw new TypeError("Output is invalid");
              if (e.length > 0 && !e.equals(t.output.slice(2)))
                throw new TypeError("Pubkey mismatch");
              e = t.output.slice(2);
            }
            if (t.internalPubkey) {
              const r = (0, u.tweakKey)(t.internalPubkey, y.hash);
              if (e.length > 0 && !e.equals(r.x))
                throw new TypeError("Pubkey mismatch");
              e = r.x;
            }
            if (e && e.length && !(0, a.getEccLib)().isXOnlyPoint(e))
              throw new TypeError("Invalid pubkey for p2tr");
            const i = d();
            if (t.hash && i && !t.hash.equals(i.hash))
              throw new TypeError("Hash mismatch");
            if (t.redeem && t.redeem.output && i) {
              const e = (0, u.tapleafHash)({
                output: t.redeem.output,
                version: y.redeemVersion,
              });
              if (!(0, u.findScriptPath)(i, e))
                throw new TypeError("Redeem script not in tree");
            }
            const c = l();
            if (t.redeem && y.redeem) {
              if (
                t.redeem.redeemVersion &&
                t.redeem.redeemVersion !== y.redeem.redeemVersion
              )
                throw new TypeError(
                  "Redeem.redeemVersion and witness mismatch",
                );
              if (t.redeem.output) {
                if (0 === o.decompile(t.redeem.output).length)
                  throw new TypeError("Redeem.output is invalid");
                if (y.redeem.output && !t.redeem.output.equals(y.redeem.output))
                  throw new TypeError("Redeem.output and witness mismatch");
              }
              if (
                t.redeem.witness &&
                y.redeem.witness &&
                !(function (t, e) {
                  return (
                    t.length === e.length && t.every((t, r) => t.equals(e[r]))
                  );
                })(t.redeem.witness, y.redeem.witness)
              )
                throw new TypeError("Redeem.witness and witness mismatch");
            }
            if (c && c.length)
              if (1 === c.length) {
                if (t.signature && !t.signature.equals(c[0]))
                  throw new TypeError("Signature mismatch");
              } else {
                const r = c[c.length - 1];
                if (r.length < 33)
                  throw new TypeError(
                    `The control-block length is too small. Got ${r.length}, expected min 33.`,
                  );
                if ((r.length - 33) % 32 != 0)
                  throw new TypeError(
                    `The control-block length of ${r.length} is incorrect!`,
                  );
                const n = (r.length - 33) / 32;
                if (n > 128)
                  throw new TypeError(
                    `The script path is too long. Got ${n}, expected max 128.`,
                  );
                const i = r.slice(1, 33);
                if (t.internalPubkey && !t.internalPubkey.equals(i))
                  throw new TypeError("Internal pubkey mismatch");
                if (!(0, a.getEccLib)().isXOnlyPoint(i))
                  throw new TypeError(
                    "Invalid internalPubkey for p2tr witness",
                  );
                const o = r[0] & s.TAPLEAF_VERSION_MASK,
                  f = c[c.length - 2],
                  h = (0, u.tapleafHash)({ output: f, version: o }),
                  l = (0, u.rootHashFromPath)(r, h),
                  d = (0, u.tweakKey)(i, l);
                if (!d)
                  throw new TypeError("Invalid outputKey for p2tr witness");
                if (e.length && !e.equals(d.x))
                  throw new TypeError("Pubkey mismatch for p2tr witness");
                if (d.parity !== (1 & r[0]))
                  throw new Error("Incorrect parity");
              }
          }
          return Object.assign(y, t);
        };
      },
      77027: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2wpkh = void 0);
        const i = r(91944),
          o = r(50622),
          s = r(67038),
          a = r(98116),
          u = r(20264),
          c = r(22343),
          f = s.OPS,
          h = n.alloc(0);
        e.p2wpkh = function (t, e) {
          if (!(t.address || t.hash || t.output || t.pubkey || t.witness))
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, a.typeforce)(
              {
                address: a.typeforce.maybe(a.typeforce.String),
                hash: a.typeforce.maybe(a.typeforce.BufferN(20)),
                input: a.typeforce.maybe(a.typeforce.BufferN(0)),
                network: a.typeforce.maybe(a.typeforce.Object),
                output: a.typeforce.maybe(a.typeforce.BufferN(22)),
                pubkey: a.typeforce.maybe(a.isPoint),
                signature: a.typeforce.maybe(s.isCanonicalScriptSignature),
                witness: a.typeforce.maybe(
                  a.typeforce.arrayOf(a.typeforce.Buffer),
                ),
              },
              t,
            );
          const r = u.value(() => {
              const e = c.bech32.decode(t.address),
                r = e.words.shift(),
                i = c.bech32.fromWords(e.words);
              return { version: r, prefix: e.prefix, data: n.from(i) };
            }),
            l = t.network || o.bitcoin,
            d = { name: "p2wpkh", network: l };
          if (
            (u.prop(d, "address", () => {
              if (!d.hash) return;
              const t = c.bech32.toWords(d.hash);
              return t.unshift(0), c.bech32.encode(l.bech32, t);
            }),
            u.prop(d, "hash", () =>
              t.output
                ? t.output.slice(2, 22)
                : t.address
                  ? r().data
                  : t.pubkey || d.pubkey
                    ? i.hash160(t.pubkey || d.pubkey)
                    : void 0,
            ),
            u.prop(d, "output", () => {
              if (d.hash) return s.compile([f.OP_0, d.hash]);
            }),
            u.prop(d, "pubkey", () =>
              t.pubkey ? t.pubkey : t.witness ? t.witness[1] : void 0,
            ),
            u.prop(d, "signature", () => {
              if (t.witness) return t.witness[0];
            }),
            u.prop(d, "input", () => {
              if (d.witness) return h;
            }),
            u.prop(d, "witness", () => {
              if (t.pubkey && t.signature) return [t.signature, t.pubkey];
            }),
            e.validate)
          ) {
            let e = n.from([]);
            if (t.address) {
              if (l && l.bech32 !== r().prefix)
                throw new TypeError("Invalid prefix or Network mismatch");
              if (0 !== r().version)
                throw new TypeError("Invalid address version");
              if (20 !== r().data.length)
                throw new TypeError("Invalid address data");
              e = r().data;
            }
            if (t.hash) {
              if (e.length > 0 && !e.equals(t.hash))
                throw new TypeError("Hash mismatch");
              e = t.hash;
            }
            if (t.output) {
              if (
                22 !== t.output.length ||
                t.output[0] !== f.OP_0 ||
                20 !== t.output[1]
              )
                throw new TypeError("Output is invalid");
              if (e.length > 0 && !e.equals(t.output.slice(2)))
                throw new TypeError("Hash mismatch");
              e = t.output.slice(2);
            }
            if (t.pubkey) {
              const r = i.hash160(t.pubkey);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
              if (
                ((e = r), !(0, a.isPoint)(t.pubkey) || 33 !== t.pubkey.length)
              )
                throw new TypeError("Invalid pubkey for p2wpkh");
            }
            if (t.witness) {
              if (2 !== t.witness.length)
                throw new TypeError("Witness is invalid");
              if (!s.isCanonicalScriptSignature(t.witness[0]))
                throw new TypeError("Witness has invalid signature");
              if (!(0, a.isPoint)(t.witness[1]) || 33 !== t.witness[1].length)
                throw new TypeError("Witness has invalid pubkey");
              if (t.signature && !t.signature.equals(t.witness[0]))
                throw new TypeError("Signature mismatch");
              if (t.pubkey && !t.pubkey.equals(t.witness[1]))
                throw new TypeError("Pubkey mismatch");
              const r = i.hash160(t.witness[1]);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
            }
          }
          return Object.assign(d, t);
        };
      },
      79041: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2wsh = void 0);
        const i = r(91944),
          o = r(50622),
          s = r(67038),
          a = r(98116),
          u = r(20264),
          c = r(22343),
          f = s.OPS,
          h = n.alloc(0);
        function l(t) {
          return !(
            !n.isBuffer(t) ||
            65 !== t.length ||
            4 !== t[0] ||
            !(0, a.isPoint)(t)
          );
        }
        e.p2wsh = function (t, e) {
          if (!(t.address || t.hash || t.output || t.redeem || t.witness))
            throw new TypeError("Not enough data");
          (e = Object.assign({ validate: !0 }, e || {})),
            (0, a.typeforce)(
              {
                network: a.typeforce.maybe(a.typeforce.Object),
                address: a.typeforce.maybe(a.typeforce.String),
                hash: a.typeforce.maybe(a.typeforce.BufferN(32)),
                output: a.typeforce.maybe(a.typeforce.BufferN(34)),
                redeem: a.typeforce.maybe({
                  input: a.typeforce.maybe(a.typeforce.Buffer),
                  network: a.typeforce.maybe(a.typeforce.Object),
                  output: a.typeforce.maybe(a.typeforce.Buffer),
                  witness: a.typeforce.maybe(
                    a.typeforce.arrayOf(a.typeforce.Buffer),
                  ),
                }),
                input: a.typeforce.maybe(a.typeforce.BufferN(0)),
                witness: a.typeforce.maybe(
                  a.typeforce.arrayOf(a.typeforce.Buffer),
                ),
              },
              t,
            );
          const r = u.value(() => {
              const e = c.bech32.decode(t.address),
                r = e.words.shift(),
                i = c.bech32.fromWords(e.words);
              return { version: r, prefix: e.prefix, data: n.from(i) };
            }),
            d = u.value(() => s.decompile(t.redeem.input));
          let p = t.network;
          p || (p = (t.redeem && t.redeem.network) || o.bitcoin);
          const y = { network: p };
          if (
            (u.prop(y, "address", () => {
              if (!y.hash) return;
              const t = c.bech32.toWords(y.hash);
              return t.unshift(0), c.bech32.encode(p.bech32, t);
            }),
            u.prop(y, "hash", () =>
              t.output
                ? t.output.slice(2)
                : t.address
                  ? r().data
                  : y.redeem && y.redeem.output
                    ? i.sha256(y.redeem.output)
                    : void 0,
            ),
            u.prop(y, "output", () => {
              if (y.hash) return s.compile([f.OP_0, y.hash]);
            }),
            u.prop(y, "redeem", () => {
              if (t.witness)
                return {
                  output: t.witness[t.witness.length - 1],
                  input: h,
                  witness: t.witness.slice(0, -1),
                };
            }),
            u.prop(y, "input", () => {
              if (y.witness) return h;
            }),
            u.prop(y, "witness", () => {
              if (
                t.redeem &&
                t.redeem.input &&
                t.redeem.input.length > 0 &&
                t.redeem.output &&
                t.redeem.output.length > 0
              ) {
                const e = s.toStack(d());
                return (
                  (y.redeem = Object.assign({ witness: e }, t.redeem)),
                  (y.redeem.input = h),
                  [].concat(e, t.redeem.output)
                );
              }
              if (t.redeem && t.redeem.output && t.redeem.witness)
                return [].concat(t.redeem.witness, t.redeem.output);
            }),
            u.prop(y, "name", () => {
              const t = ["p2wsh"];
              return (
                void 0 !== y.redeem &&
                  void 0 !== y.redeem.name &&
                  t.push(y.redeem.name),
                t.join("-")
              );
            }),
            e.validate)
          ) {
            let e = n.from([]);
            if (t.address) {
              if (r().prefix !== p.bech32)
                throw new TypeError("Invalid prefix or Network mismatch");
              if (0 !== r().version)
                throw new TypeError("Invalid address version");
              if (32 !== r().data.length)
                throw new TypeError("Invalid address data");
              e = r().data;
            }
            if (t.hash) {
              if (e.length > 0 && !e.equals(t.hash))
                throw new TypeError("Hash mismatch");
              e = t.hash;
            }
            if (t.output) {
              if (
                34 !== t.output.length ||
                t.output[0] !== f.OP_0 ||
                32 !== t.output[1]
              )
                throw new TypeError("Output is invalid");
              const r = t.output.slice(2);
              if (e.length > 0 && !e.equals(r))
                throw new TypeError("Hash mismatch");
              e = r;
            }
            if (t.redeem) {
              if (t.redeem.network && t.redeem.network !== p)
                throw new TypeError("Network mismatch");
              if (
                t.redeem.input &&
                t.redeem.input.length > 0 &&
                t.redeem.witness &&
                t.redeem.witness.length > 0
              )
                throw new TypeError("Ambiguous witness source");
              if (t.redeem.output) {
                const r = s.decompile(t.redeem.output);
                if (!r || r.length < 1)
                  throw new TypeError("Redeem.output is invalid");
                if (t.redeem.output.byteLength > 3600)
                  throw new TypeError(
                    "Redeem.output unspendable if larger than 3600 bytes",
                  );
                if (s.countNonPushOnlyOPs(r) > 201)
                  throw new TypeError(
                    "Redeem.output unspendable with more than 201 non-push ops",
                  );
                const n = i.sha256(t.redeem.output);
                if (e.length > 0 && !e.equals(n))
                  throw new TypeError("Hash mismatch");
                e = n;
              }
              if (t.redeem.input && !s.isPushOnly(d()))
                throw new TypeError("Non push-only scriptSig");
              if (
                t.witness &&
                t.redeem.witness &&
                !(function (t, e) {
                  return (
                    t.length === e.length && t.every((t, r) => t.equals(e[r]))
                  );
                })(t.witness, t.redeem.witness)
              )
                throw new TypeError("Witness and redeem.witness mismatch");
              if (
                (t.redeem.input && d().some(l)) ||
                (t.redeem.output &&
                  (s.decompile(t.redeem.output) || []).some(l))
              )
                throw new TypeError(
                  "redeem.input or redeem.output contains uncompressed pubkey",
                );
            }
            if (t.witness && t.witness.length > 0) {
              const e = t.witness[t.witness.length - 1];
              if (t.redeem && t.redeem.output && !t.redeem.output.equals(e))
                throw new TypeError("Witness and redeem.output mismatch");
              if (t.witness.some(l) || (s.decompile(e) || []).some(l))
                throw new TypeError("Witness contains uncompressed pubkey");
            }
          }
          return Object.assign(y, t);
        };
      },
      59646: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Psbt = void 0);
        const i = r(1614),
          o = r(40394),
          s = r(45080),
          a = r(70057),
          u = r(30606),
          c = r(50622),
          f = r(30885),
          h = r(82218),
          l = r(67038),
          d = r(22021),
          p = r(60477),
          y = r(34929),
          g = { network: c.bitcoin, maximumFeeRate: 5e3 };
        class m {
          static fromBase64(t, e = {}) {
            const r = n.from(t, "base64");
            return this.fromBuffer(r, e);
          }
          static fromHex(t, e = {}) {
            const r = n.from(t, "hex");
            return this.fromBuffer(r, e);
          }
          static fromBuffer(t, e = {}) {
            const r = i.Psbt.fromBuffer(t, b),
              n = new m(e, r);
            var o, s;
            return (
              (o = n.__CACHE.__TX),
              (s = n.__CACHE),
              o.ins.forEach((t) => {
                T(s, t);
              }),
              n
            );
          }
          constructor(t = {}, e = new i.Psbt(new w())) {
            (this.data = e),
              (this.opts = Object.assign({}, g, t)),
              (this.__CACHE = {
                __NON_WITNESS_UTXO_TX_CACHE: [],
                __NON_WITNESS_UTXO_BUF_CACHE: [],
                __TX_IN_CACHE: {},
                __TX: this.data.globalMap.unsignedTx.tx,
                __UNSAFE_SIGN_NONSEGWIT: !1,
              }),
              0 === this.data.inputs.length && this.setVersion(2);
            const r = (t, e, r, n) =>
              Object.defineProperty(t, e, { enumerable: r, writable: n });
            r(this, "__CACHE", !1, !0), r(this, "opts", !1, !0);
          }
          get inputCount() {
            return this.data.inputs.length;
          }
          get version() {
            return this.__CACHE.__TX.version;
          }
          set version(t) {
            this.setVersion(t);
          }
          get locktime() {
            return this.__CACHE.__TX.locktime;
          }
          set locktime(t) {
            this.setLocktime(t);
          }
          get txInputs() {
            return this.__CACHE.__TX.ins.map((t) => ({
              hash: (0, u.cloneBuffer)(t.hash),
              index: t.index,
              sequence: t.sequence,
            }));
          }
          get txOutputs() {
            return this.__CACHE.__TX.outs.map((t) => {
              let e;
              try {
                e = (0, a.fromOutputScript)(t.script, this.opts.network);
              } catch (t) {}
              return {
                script: (0, u.cloneBuffer)(t.script),
                value: t.value,
                address: e,
              };
            });
          }
          combine(...t) {
            return this.data.combine(...t.map((t) => t.data)), this;
          }
          clone() {
            const t = m.fromBuffer(this.data.toBuffer());
            return (t.opts = JSON.parse(JSON.stringify(this.opts))), t;
          }
          setMaximumFeeRate(t) {
            I(t), (this.opts.maximumFeeRate = t);
          }
          setVersion(t) {
            I(t), M(this.data.inputs, "setVersion");
            const e = this.__CACHE;
            return (e.__TX.version = t), (e.__EXTRACTED_TX = void 0), this;
          }
          setLocktime(t) {
            I(t), M(this.data.inputs, "setLocktime");
            const e = this.__CACHE;
            return (e.__TX.locktime = t), (e.__EXTRACTED_TX = void 0), this;
          }
          setInputSequence(t, e) {
            I(e), M(this.data.inputs, "setInputSequence");
            const r = this.__CACHE;
            if (r.__TX.ins.length <= t) throw new Error("Input index too high");
            return (
              (r.__TX.ins[t].sequence = e), (r.__EXTRACTED_TX = void 0), this
            );
          }
          addInputs(t) {
            return t.forEach((t) => this.addInput(t)), this;
          }
          addInput(t) {
            if (
              arguments.length > 1 ||
              !t ||
              void 0 === t.hash ||
              void 0 === t.index
            )
              throw new Error(
                "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]",
              );
            (0, p.checkTaprootInputFields)(t, t, "addInput"),
              M(this.data.inputs, "addInput"),
              t.witnessScript && W(t.witnessScript);
            const e = this.__CACHE;
            this.data.addInput(t);
            T(e, e.__TX.ins[e.__TX.ins.length - 1]);
            const r = this.data.inputs.length - 1,
              n = this.data.inputs[r];
            return (
              n.nonWitnessUtxo && H(this.__CACHE, n, r),
              (e.__FEE = void 0),
              (e.__FEE_RATE = void 0),
              (e.__EXTRACTED_TX = void 0),
              this
            );
          }
          addOutputs(t) {
            return t.forEach((t) => this.addOutput(t)), this;
          }
          addOutput(t) {
            if (
              arguments.length > 1 ||
              !t ||
              void 0 === t.value ||
              (void 0 === t.address && void 0 === t.script)
            )
              throw new Error(
                "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]",
              );
            M(this.data.inputs, "addOutput");
            const { address: e } = t;
            if ("string" == typeof e) {
              const { network: r } = this.opts,
                n = (0, a.toOutputScript)(e, r);
              t = Object.assign(t, { script: n });
            }
            (0, p.checkTaprootOutputFields)(t, t, "addOutput");
            const r = this.__CACHE;
            return (
              this.data.addOutput(t),
              (r.__FEE = void 0),
              (r.__FEE_RATE = void 0),
              (r.__EXTRACTED_TX = void 0),
              this
            );
          }
          extractTransaction(t) {
            if (!this.data.inputs.every(E)) throw new Error("Not finalized");
            const e = this.__CACHE;
            if (
              (t ||
                (function (t, e, r) {
                  const n = e.__FEE_RATE || t.getFeeRate(),
                    i = e.__EXTRACTED_TX.virtualSize(),
                    o = n * i;
                  if (n >= r.maximumFeeRate)
                    throw new Error(
                      `Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`,
                    );
                })(this, e, this.opts),
              e.__EXTRACTED_TX)
            )
              return e.__EXTRACTED_TX;
            const r = e.__TX.clone();
            return K(this.data.inputs, r, e, !0), r;
          }
          getFeeRate() {
            return P("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
          }
          getFee() {
            return P("__FEE", "fee", this.data.inputs, this.__CACHE);
          }
          finalizeAllInputs() {
            return (
              (0, s.checkForInput)(this.data.inputs, 0),
              X(this.data.inputs.length).forEach((t) => this.finalizeInput(t)),
              this
            );
          }
          finalizeInput(t, e) {
            const r = (0, s.checkForInput)(this.data.inputs, t);
            return (0, p.isTaprootInput)(r)
              ? this._finalizeTaprootInput(t, r, void 0, e)
              : this._finalizeInput(t, r, e);
          }
          finalizeTaprootInput(t, e, r = p.tapScriptFinalizer) {
            const n = (0, s.checkForInput)(this.data.inputs, t);
            if ((0, p.isTaprootInput)(n))
              return this._finalizeTaprootInput(t, n, e, r);
            throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
          }
          _finalizeInput(t, e, r = B) {
            const {
              script: n,
              isP2SH: i,
              isP2WSH: o,
              isSegwit: s,
            } = (function (t, e, r) {
              const n = r.__TX,
                i = { script: null, isSegwit: !1, isP2SH: !1, isP2WSH: !1 };
              if (
                ((i.isP2SH = !!e.redeemScript),
                (i.isP2WSH = !!e.witnessScript),
                e.witnessScript)
              )
                i.script = e.witnessScript;
              else if (e.redeemScript) i.script = e.redeemScript;
              else if (e.nonWitnessUtxo) {
                const o = V(r, e, t),
                  s = n.ins[t].index;
                i.script = o.outs[s].script;
              } else e.witnessUtxo && (i.script = e.witnessUtxo.script);
              (e.witnessScript || (0, y.isP2WPKH)(i.script)) &&
                (i.isSegwit = !0);
              return i;
            })(t, e, this.__CACHE);
            if (!n) throw new Error(`No script found for input #${t}`);
            !(function (t) {
              if (!t.sighashType || !t.partialSig) return;
              const { partialSig: e, sighashType: r } = t;
              e.forEach((t) => {
                const { hashType: e } = l.signature.decode(t.signature);
                if (r !== e)
                  throw new Error(
                    "Signature sighash does not match input sighash type",
                  );
              });
            })(e);
            const { finalScriptSig: a, finalScriptWitness: u } = r(
              t,
              e,
              n,
              s,
              i,
              o,
            );
            if (
              (a && this.data.updateInput(t, { finalScriptSig: a }),
              u && this.data.updateInput(t, { finalScriptWitness: u }),
              !a && !u)
            )
              throw new Error(`Unknown error finalizing input #${t}`);
            return this.data.clearFinalizedInput(t), this;
          }
          _finalizeTaprootInput(t, e, r, n = p.tapScriptFinalizer) {
            if (!e.witnessUtxo)
              throw new Error(
                `Cannot finalize input #${t}. Missing withness utxo.`,
              );
            if (e.tapKeySig) {
              const r = f.p2tr({
                  output: e.witnessUtxo.script,
                  signature: e.tapKeySig,
                }),
                n = (0, y.witnessStackToScriptWitness)(r.witness);
              this.data.updateInput(t, { finalScriptWitness: n });
            } else {
              const { finalScriptWitness: i } = n(t, e, r);
              this.data.updateInput(t, { finalScriptWitness: i });
            }
            return this.data.clearFinalizedInput(t), this;
          }
          getInputType(t) {
            const e = (0, s.checkForInput)(this.data.inputs, t),
              r = G(
                q(t, e, this.__CACHE),
                t,
                "input",
                e.redeemScript ||
                  (function (t) {
                    if (!t) return;
                    const e = l.decompile(t);
                    if (!e) return;
                    const r = e[e.length - 1];
                    if (
                      !n.isBuffer(r) ||
                      $(r) ||
                      ((i = r), l.isCanonicalScriptSignature(i))
                    )
                      return;
                    var i;
                    if (!l.decompile(r)) return;
                    return r;
                  })(e.finalScriptSig),
                e.witnessScript ||
                  (function (t) {
                    if (!t) return;
                    const e = F(t),
                      r = e[e.length - 1];
                    if ($(r)) return;
                    if (!l.decompile(r)) return;
                    return r;
                  })(e.finalScriptWitness),
              );
            return (
              ("raw" === r.type ? "" : r.type + "-") + Y(r.meaningfulScript)
            );
          }
          inputHasPubkey(t, e) {
            return (function (t, e, r, n) {
              const i = q(r, e, n),
                { meaningfulScript: o } = G(
                  i,
                  r,
                  "input",
                  e.redeemScript,
                  e.witnessScript,
                );
              return (0, y.pubkeyInScript)(t, o);
            })(e, (0, s.checkForInput)(this.data.inputs, t), t, this.__CACHE);
          }
          inputHasHDKey(t, e) {
            const r = (0, s.checkForInput)(this.data.inputs, t),
              n = S(e);
            return !!r.bip32Derivation && r.bip32Derivation.some(n);
          }
          outputHasPubkey(t, e) {
            return (function (t, e, r, n) {
              const i = n.__TX.outs[r].script,
                { meaningfulScript: o } = G(
                  i,
                  r,
                  "output",
                  e.redeemScript,
                  e.witnessScript,
                );
              return (0, y.pubkeyInScript)(t, o);
            })(e, (0, s.checkForOutput)(this.data.outputs, t), t, this.__CACHE);
          }
          outputHasHDKey(t, e) {
            const r = (0, s.checkForOutput)(this.data.outputs, t),
              n = S(e);
            return !!r.bip32Derivation && r.bip32Derivation.some(n);
          }
          validateSignaturesOfAllInputs(t) {
            (0, s.checkForInput)(this.data.inputs, 0);
            return X(this.data.inputs.length)
              .map((e) => this.validateSignaturesOfInput(e, t))
              .reduce((t, e) => !0 === e && t, !0);
          }
          validateSignaturesOfInput(t, e, r) {
            const n = this.data.inputs[t];
            return (0, p.isTaprootInput)(n)
              ? this.validateSignaturesOfTaprootInput(t, e, r)
              : this._validateSignaturesOfInput(t, e, r);
          }
          _validateSignaturesOfInput(t, e, r) {
            const n = this.data.inputs[t],
              i = (n || {}).partialSig;
            if (!n || !i || i.length < 1)
              throw new Error("No signatures to validate");
            if ("function" != typeof e)
              throw new Error("Need validator function to validate signatures");
            const o = r ? i.filter((t) => t.pubkey.equals(r)) : i;
            if (o.length < 1) throw new Error("No signatures for this pubkey");
            const s = [];
            let a, u, c;
            for (const r of o) {
              const i = l.signature.decode(r.signature),
                { hash: o, script: f } =
                  c !== i.hashType
                    ? R(
                        t,
                        Object.assign({}, n, { sighashType: i.hashType }),
                        this.__CACHE,
                        !0,
                      )
                    : { hash: a, script: u };
              (c = i.hashType),
                (a = o),
                (u = f),
                A(r.pubkey, f, "verify"),
                s.push(e(r.pubkey, o, i.signature));
            }
            return s.every((t) => !0 === t);
          }
          validateSignaturesOfTaprootInput(t, e, r) {
            const n = this.data.inputs[t],
              i = (n || {}).tapKeySig,
              o = (n || {}).tapScriptSig;
            if (!n && !i && (!o || o.length))
              throw new Error("No signatures to validate");
            if ("function" != typeof e)
              throw new Error("Need validator function to validate signatures");
            const s = (r = r && (0, p.toXOnly)(r))
              ? D(t, n, this.data.inputs, r, this.__CACHE)
              : (function (t, e, r, n) {
                  const i = [];
                  if (e.tapInternalKey) {
                    const r = N(t, e, n);
                    r && i.push(r);
                  }
                  if (e.tapScriptSig) {
                    const t = e.tapScriptSig.map((t) => t.pubkey);
                    i.push(...t);
                  }
                  const o = i.map((i) => D(t, e, r, i, n));
                  return o.flat();
                })(t, n, this.data.inputs, this.__CACHE);
            if (!s.length) throw new Error("No signatures for this pubkey");
            const a = s.find((t) => !t.leafHash);
            let u = 0;
            if (i && a) {
              if (!e(a.pubkey, a.hash, U(i))) return !1;
              u++;
            }
            if (o)
              for (const t of o) {
                const r = s.find((e) => t.pubkey.equals(e.pubkey));
                if (r) {
                  if (!e(t.pubkey, r.hash, U(t.signature))) return !1;
                  u++;
                }
              }
            return u > 0;
          }
          signAllInputsHD(t, e = [d.Transaction.SIGHASH_ALL]) {
            if (!t || !t.publicKey || !t.fingerprint)
              throw new Error("Need HDSigner to sign input");
            const r = [];
            for (const n of X(this.data.inputs.length))
              try {
                this.signInputHD(n, t, e), r.push(!0);
              } catch (t) {
                r.push(!1);
              }
            if (r.every((t) => !1 === t))
              throw new Error("No inputs were signed");
            return this;
          }
          signAllInputsHDAsync(t, e = [d.Transaction.SIGHASH_ALL]) {
            return new Promise((r, n) => {
              if (!t || !t.publicKey || !t.fingerprint)
                return n(new Error("Need HDSigner to sign input"));
              const i = [],
                o = [];
              for (const r of X(this.data.inputs.length))
                o.push(
                  this.signInputHDAsync(r, t, e).then(
                    () => {
                      i.push(!0);
                    },
                    () => {
                      i.push(!1);
                    },
                  ),
                );
              return Promise.all(o).then(() => {
                if (i.every((t) => !1 === t))
                  return n(new Error("No inputs were signed"));
                r();
              });
            });
          }
          signInputHD(t, e, r = [d.Transaction.SIGHASH_ALL]) {
            if (!e || !e.publicKey || !e.fingerprint)
              throw new Error("Need HDSigner to sign input");
            return (
              j(t, this.data.inputs, e).forEach((e) => this.signInput(t, e, r)),
              this
            );
          }
          signInputHDAsync(t, e, r = [d.Transaction.SIGHASH_ALL]) {
            return new Promise((n, i) => {
              if (!e || !e.publicKey || !e.fingerprint)
                return i(new Error("Need HDSigner to sign input"));
              const o = j(t, this.data.inputs, e).map((e) =>
                this.signInputAsync(t, e, r),
              );
              return Promise.all(o)
                .then(() => {
                  n();
                })
                .catch(i);
            });
          }
          signAllInputs(t, e) {
            if (!t || !t.publicKey)
              throw new Error("Need Signer to sign input");
            const r = [];
            for (const n of X(this.data.inputs.length))
              try {
                this.signInput(n, t, e), r.push(!0);
              } catch (t) {
                r.push(!1);
              }
            if (r.every((t) => !1 === t))
              throw new Error("No inputs were signed");
            return this;
          }
          signAllInputsAsync(t, e) {
            return new Promise((r, n) => {
              if (!t || !t.publicKey)
                return n(new Error("Need Signer to sign input"));
              const i = [],
                o = [];
              for (const [r] of this.data.inputs.entries())
                o.push(
                  this.signInputAsync(r, t, e).then(
                    () => {
                      i.push(!0);
                    },
                    () => {
                      i.push(!1);
                    },
                  ),
                );
              return Promise.all(o).then(() => {
                if (i.every((t) => !1 === t))
                  return n(new Error("No inputs were signed"));
                r();
              });
            });
          }
          signInput(t, e, r) {
            if (!e || !e.publicKey)
              throw new Error("Need Signer to sign input");
            const n = (0, s.checkForInput)(this.data.inputs, t);
            return (0, p.isTaprootInput)(n)
              ? this._signTaprootInput(t, n, e, void 0, r)
              : this._signInput(t, e, r);
          }
          signTaprootInput(t, e, r, n) {
            if (!e || !e.publicKey)
              throw new Error("Need Signer to sign input");
            const i = (0, s.checkForInput)(this.data.inputs, t);
            if ((0, p.isTaprootInput)(i))
              return this._signTaprootInput(t, i, e, r, n);
            throw new Error(`Input #${t} is not of type Taproot.`);
          }
          _signInput(t, e, r = [d.Transaction.SIGHASH_ALL]) {
            const { hash: n, sighashType: i } = C(
                this.data.inputs,
                t,
                e.publicKey,
                this.__CACHE,
                r,
              ),
              o = [
                {
                  pubkey: e.publicKey,
                  signature: l.signature.encode(e.sign(n), i),
                },
              ];
            return this.data.updateInput(t, { partialSig: o }), this;
          }
          _signTaprootInput(t, e, r, n, i = [d.Transaction.SIGHASH_DEFAULT]) {
            const o = this.checkTaprootHashesForSig(t, e, r, n, i),
              s = o
                .filter((t) => !t.leafHash)
                .map((t) =>
                  (0, p.serializeTaprootSignature)(
                    r.signSchnorr(t.hash),
                    e.sighashType,
                  ),
                )[0],
              a = o
                .filter((t) => !!t.leafHash)
                .map((t) => ({
                  pubkey: (0, p.toXOnly)(r.publicKey),
                  signature: (0, p.serializeTaprootSignature)(
                    r.signSchnorr(t.hash),
                    e.sighashType,
                  ),
                  leafHash: t.leafHash,
                }));
            return (
              s && this.data.updateInput(t, { tapKeySig: s }),
              a.length && this.data.updateInput(t, { tapScriptSig: a }),
              this
            );
          }
          signInputAsync(t, e, r) {
            return Promise.resolve().then(() => {
              if (!e || !e.publicKey)
                throw new Error("Need Signer to sign input");
              const n = (0, s.checkForInput)(this.data.inputs, t);
              return (0, p.isTaprootInput)(n)
                ? this._signTaprootInputAsync(t, n, e, void 0, r)
                : this._signInputAsync(t, e, r);
            });
          }
          signTaprootInputAsync(t, e, r, n) {
            return Promise.resolve().then(() => {
              if (!e || !e.publicKey)
                throw new Error("Need Signer to sign input");
              const i = (0, s.checkForInput)(this.data.inputs, t);
              if ((0, p.isTaprootInput)(i))
                return this._signTaprootInputAsync(t, i, e, r, n);
              throw new Error(`Input #${t} is not of type Taproot.`);
            });
          }
          _signInputAsync(t, e, r = [d.Transaction.SIGHASH_ALL]) {
            const { hash: n, sighashType: i } = C(
              this.data.inputs,
              t,
              e.publicKey,
              this.__CACHE,
              r,
            );
            return Promise.resolve(e.sign(n)).then((r) => {
              const n = [
                { pubkey: e.publicKey, signature: l.signature.encode(r, i) },
              ];
              this.data.updateInput(t, { partialSig: n });
            });
          }
          async _signTaprootInputAsync(
            t,
            e,
            r,
            n,
            i = [d.Transaction.SIGHASH_DEFAULT],
          ) {
            const o = this.checkTaprootHashesForSig(t, e, r, n, i),
              s = [],
              a = o.filter((t) => !t.leafHash)[0];
            if (a) {
              const t = Promise.resolve(r.signSchnorr(a.hash)).then((t) => ({
                tapKeySig: (0, p.serializeTaprootSignature)(t, e.sighashType),
              }));
              s.push(t);
            }
            const u = o.filter((t) => !!t.leafHash);
            if (u.length) {
              const t = u.map((t) =>
                Promise.resolve(r.signSchnorr(t.hash)).then((n) => ({
                  tapScriptSig: [
                    {
                      pubkey: (0, p.toXOnly)(r.publicKey),
                      signature: (0, p.serializeTaprootSignature)(
                        n,
                        e.sighashType,
                      ),
                      leafHash: t.leafHash,
                    },
                  ],
                })),
              );
              s.push(...t);
            }
            return Promise.all(s).then((e) => {
              e.forEach((e) => this.data.updateInput(t, e));
            });
          }
          checkTaprootHashesForSig(t, e, r, n, i) {
            if ("function" != typeof r.signSchnorr)
              throw new Error(
                `Need Schnorr Signer to sign taproot input #${t}.`,
              );
            const o = D(
              t,
              e,
              this.data.inputs,
              r.publicKey,
              this.__CACHE,
              n,
              i,
            );
            if (!o || !o.length)
              throw new Error(
                `Can not sign for input #${t} with the key ${r.publicKey.toString("hex")}`,
              );
            return o;
          }
          toBuffer() {
            return v(this.__CACHE), this.data.toBuffer();
          }
          toHex() {
            return v(this.__CACHE), this.data.toHex();
          }
          toBase64() {
            return v(this.__CACHE), this.data.toBase64();
          }
          updateGlobal(t) {
            return this.data.updateGlobal(t), this;
          }
          updateInput(t, e) {
            return (
              e.witnessScript && W(e.witnessScript),
              (0, p.checkTaprootInputFields)(
                this.data.inputs[t],
                e,
                "updateInput",
              ),
              this.data.updateInput(t, e),
              e.nonWitnessUtxo && H(this.__CACHE, this.data.inputs[t], t),
              this
            );
          }
          updateOutput(t, e) {
            const r = this.data.outputs[t];
            return (
              (0, p.checkTaprootOutputFields)(r, e, "updateOutput"),
              this.data.updateOutput(t, e),
              this
            );
          }
          addUnknownKeyValToGlobal(t) {
            return this.data.addUnknownKeyValToGlobal(t), this;
          }
          addUnknownKeyValToInput(t, e) {
            return this.data.addUnknownKeyValToInput(t, e), this;
          }
          addUnknownKeyValToOutput(t, e) {
            return this.data.addUnknownKeyValToOutput(t, e), this;
          }
          clearFinalizedInput(t) {
            return this.data.clearFinalizedInput(t), this;
          }
        }
        e.Psbt = m;
        const b = (t) => new w(t);
        class w {
          constructor(t = n.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
            (this.tx = d.Transaction.fromBuffer(t)),
              (function (t) {
                if (
                  !t.ins.every(
                    (t) =>
                      t.script &&
                      0 === t.script.length &&
                      t.witness &&
                      0 === t.witness.length,
                  )
                )
                  throw new Error(
                    "Format Error: Transaction ScriptSigs are not empty",
                  );
              })(this.tx),
              Object.defineProperty(this, "tx", {
                enumerable: !1,
                writable: !0,
              });
          }
          getInputOutputCounts() {
            return {
              inputCount: this.tx.ins.length,
              outputCount: this.tx.outs.length,
            };
          }
          addInput(t) {
            if (
              void 0 === t.hash ||
              void 0 === t.index ||
              (!n.isBuffer(t.hash) && "string" != typeof t.hash) ||
              "number" != typeof t.index
            )
              throw new Error("Error adding input.");
            const e =
              "string" == typeof t.hash
                ? (0, u.reverseBuffer)(n.from(t.hash, "hex"))
                : t.hash;
            this.tx.addInput(e, t.index, t.sequence);
          }
          addOutput(t) {
            if (
              void 0 === t.script ||
              void 0 === t.value ||
              !n.isBuffer(t.script) ||
              "number" != typeof t.value
            )
              throw new Error("Error adding output.");
            this.tx.addOutput(t.script, t.value);
          }
          toBuffer() {
            return this.tx.toBuffer();
          }
        }
        function v(t) {
          if (!1 !== t.__UNSAFE_SIGN_NONSEGWIT)
            throw new Error("Not BIP174 compliant, can not export");
        }
        function _(t, e, r) {
          if (!e) return !1;
          let n;
          if (
            ((n = r
              ? r
                  .map((t) => {
                    const r = (function (t) {
                      if (65 === t.length) {
                        const e = 1 & t[64],
                          r = t.slice(0, 33);
                        return (r[0] = 2 | e), r;
                      }
                      return t.slice();
                    })(t);
                    return e.find((t) => t.pubkey.equals(r));
                  })
                  .filter((t) => !!t)
              : e),
            n.length > t)
          )
            throw new Error("Too many signatures");
          return n.length === t;
        }
        function E(t) {
          return !!t.finalScriptSig || !!t.finalScriptWitness;
        }
        function S(t) {
          return (e) =>
            !!e.masterFingerprint.equals(t.fingerprint) &&
            !!t.derivePath(e.path).publicKey.equals(e.pubkey);
        }
        function I(t) {
          if (
            "number" != typeof t ||
            t !== Math.floor(t) ||
            t > 4294967295 ||
            t < 0
          )
            throw new Error("Invalid 32 bit integer");
        }
        function M(t, e) {
          t.forEach((t) => {
            if (
              (0, p.isTaprootInput)(t)
                ? (0, p.checkTaprootInputForSigs)(t, e)
                : (0, y.checkInputForSig)(t, e)
            )
              throw new Error("Can not modify transaction, signatures exist.");
          });
        }
        function A(t, e, r) {
          if (!(0, y.pubkeyInScript)(t, e))
            throw new Error(
              `Can not ${r} for this input with the key ${t.toString("hex")}`,
            );
        }
        function T(t, e) {
          const r =
            (0, u.reverseBuffer)(n.from(e.hash)).toString("hex") +
            ":" +
            e.index;
          if (t.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
          t.__TX_IN_CACHE[r] = 1;
        }
        function k(t, e) {
          return (r, n, i, o) => {
            const s = t({ redeem: { output: i } }).output;
            if (!n.equals(s))
              throw new Error(
                `${e} for ${o} #${r} doesn't match the scriptPubKey in the prevout`,
              );
          };
        }
        const O = k(f.p2sh, "Redeem script"),
          x = k(f.p2wsh, "Witness script");
        function P(t, e, r, n) {
          if (!r.every(E))
            throw new Error(`PSBT must be finalized to calculate ${e}`);
          if ("__FEE_RATE" === t && n.__FEE_RATE) return n.__FEE_RATE;
          if ("__FEE" === t && n.__FEE) return n.__FEE;
          let i,
            o = !0;
          return (
            n.__EXTRACTED_TX
              ? ((i = n.__EXTRACTED_TX), (o = !1))
              : (i = n.__TX.clone()),
            K(r, i, n, o),
            "__FEE_RATE" === t ? n.__FEE_RATE : "__FEE" === t ? n.__FEE : void 0
          );
        }
        function B(t, e, r, n, i, o) {
          const s = Y(r);
          if (
            !(function (t, e, r) {
              switch (r) {
                case "pubkey":
                case "pubkeyhash":
                case "witnesspubkeyhash":
                  return _(1, t.partialSig);
                case "multisig":
                  const r = f.p2ms({ output: e });
                  return _(r.m, t.partialSig, r.pubkeys);
                default:
                  return !1;
              }
            })(e, r, s)
          )
            throw new Error(`Can not finalize input #${t}`);
          return (function (t, e, r, n, i, o) {
            let s, a;
            const u = (function (t, e, r) {
                let n;
                switch (e) {
                  case "multisig":
                    const e = (function (t, e) {
                      const r = f.p2ms({ output: t });
                      return r.pubkeys
                        .map(
                          (t) =>
                            (e.filter((e) => e.pubkey.equals(t))[0] || {})
                              .signature,
                        )
                        .filter((t) => !!t);
                    })(t, r);
                    n = f.p2ms({ output: t, signatures: e });
                    break;
                  case "pubkey":
                    n = f.p2pk({ output: t, signature: r[0].signature });
                    break;
                  case "pubkeyhash":
                    n = f.p2pkh({
                      output: t,
                      pubkey: r[0].pubkey,
                      signature: r[0].signature,
                    });
                    break;
                  case "witnesspubkeyhash":
                    n = f.p2wpkh({
                      output: t,
                      pubkey: r[0].pubkey,
                      signature: r[0].signature,
                    });
                }
                return n;
              })(t, e, r),
              c = o ? f.p2wsh({ redeem: u }) : null,
              h = i ? f.p2sh({ redeem: c || u }) : null;
            n
              ? ((a = c
                  ? (0, y.witnessStackToScriptWitness)(c.witness)
                  : (0, y.witnessStackToScriptWitness)(u.witness)),
                h && (s = h.input))
              : (s = h ? h.input : u.input);
            return { finalScriptSig: s, finalScriptWitness: a };
          })(r, s, e.partialSig, n, i, o);
        }
        function C(t, e, r, n, i) {
          const o = (0, s.checkForInput)(t, e),
            { hash: a, sighashType: u, script: c } = R(e, o, n, !1, i);
          return A(r, c, "sign"), { hash: a, sighashType: u };
        }
        function R(t, e, r, n, i) {
          const o = r.__TX,
            s = e.sighashType || d.Transaction.SIGHASH_ALL;
          let a, u;
          if ((L(s, i), e.nonWitnessUtxo)) {
            const n = V(r, e, t),
              i = o.ins[t].hash,
              s = n.getHash();
            if (!i.equals(s))
              throw new Error(
                `Non-witness UTXO hash for input #${t} doesn't match the hash specified in the prevout`,
              );
            const a = o.ins[t].index;
            u = n.outs[a];
          } else {
            if (!e.witnessUtxo)
              throw new Error("Need a Utxo input item for signing");
            u = e.witnessUtxo;
          }
          const { meaningfulScript: c, type: h } = G(
            u.script,
            t,
            "input",
            e.redeemScript,
            e.witnessScript,
          );
          if (["p2sh-p2wsh", "p2wsh"].indexOf(h) >= 0)
            a = o.hashForWitnessV0(t, c, u.value, s);
          else if ((0, y.isP2WPKH)(c)) {
            const e = f.p2pkh({ hash: c.slice(2) }).output;
            a = o.hashForWitnessV0(t, e, u.value, s);
          } else {
            if (void 0 === e.nonWitnessUtxo && !1 === r.__UNSAFE_SIGN_NONSEGWIT)
              throw new Error(
                `Input #${t} has witnessUtxo but non-segwit script: ${c.toString("hex")}`,
              );
            n ||
              !1 === r.__UNSAFE_SIGN_NONSEGWIT ||
              console.warn(
                "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecesor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************",
              ),
              (a = o.hashForSignature(t, c, s));
          }
          return { script: c, sighashType: s, hash: a };
        }
        function N(t, e, r) {
          const { script: n } = z(t, e, r);
          return (0, y.isP2TR)(n) ? n.subarray(2, 34) : null;
        }
        function U(t) {
          return 64 === t.length ? t : t.subarray(0, 64);
        }
        function D(t, e, r, i, o, s, a) {
          const u = o.__TX,
            c = e.sighashType || d.Transaction.SIGHASH_DEFAULT;
          L(c, a);
          const f = r.map((t, e) => z(e, t, o)),
            l = f.map((t) => t.script),
            g = f.map((t) => t.value),
            m = [];
          if (e.tapInternalKey && !s) {
            const r = N(t, e, o) || n.from([]);
            if ((0, p.toXOnly)(i).equals(r)) {
              const e = u.hashForWitnessV1(t, l, g, c);
              m.push({ pubkey: i, hash: e });
            }
          }
          const b = (e.tapLeafScript || [])
            .filter((t) => (0, y.pubkeyInScript)(i, t.script))
            .map((t) => {
              const e = (0, h.tapleafHash)({
                output: t.script,
                version: t.leafVersion,
              });
              return Object.assign({ hash: e }, t);
            })
            .filter((t) => !s || s.equals(t.hash))
            .map((e) => {
              const r = u.hashForWitnessV1(
                t,
                l,
                g,
                d.Transaction.SIGHASH_DEFAULT,
                e.hash,
              );
              return { pubkey: i, hash: r, leafHash: e.hash };
            });
          return m.concat(b);
        }
        function L(t, e) {
          if (e && e.indexOf(t) < 0) {
            const e = (function (t) {
              let e =
                t & d.Transaction.SIGHASH_ANYONECANPAY
                  ? "SIGHASH_ANYONECANPAY | "
                  : "";
              switch (31 & t) {
                case d.Transaction.SIGHASH_ALL:
                  e += "SIGHASH_ALL";
                  break;
                case d.Transaction.SIGHASH_SINGLE:
                  e += "SIGHASH_SINGLE";
                  break;
                case d.Transaction.SIGHASH_NONE:
                  e += "SIGHASH_NONE";
              }
              return e;
            })(t);
            throw new Error(
              `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${e}`,
            );
          }
        }
        function j(t, e, r) {
          const n = (0, s.checkForInput)(e, t);
          if (!n.bip32Derivation || 0 === n.bip32Derivation.length)
            throw new Error("Need bip32Derivation to sign with HD");
          const i = n.bip32Derivation
            .map((t) =>
              t.masterFingerprint.equals(r.fingerprint) ? t : void 0,
            )
            .filter((t) => !!t);
          if (0 === i.length)
            throw new Error(
              "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint",
            );
          return i.map((t) => {
            const e = r.derivePath(t.path);
            if (!t.pubkey.equals(e.publicKey))
              throw new Error("pubkey did not match bip32Derivation");
            return e;
          });
        }
        function F(t) {
          let e = 0;
          function r() {
            const r = o.decode(t, e);
            return (e += o.decode.bytes), r;
          }
          function n() {
            return (n = r()), (e += n), t.slice(e - n, e);
            var n;
          }
          return (function () {
            const t = r(),
              e = [];
            for (let r = 0; r < t; r++) e.push(n());
            return e;
          })();
        }
        function H(t, e, r) {
          t.__NON_WITNESS_UTXO_BUF_CACHE[r] = e.nonWitnessUtxo;
          const n = d.Transaction.fromBuffer(e.nonWitnessUtxo);
          t.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
          const i = t,
            o = r;
          delete e.nonWitnessUtxo,
            Object.defineProperty(e, "nonWitnessUtxo", {
              enumerable: !0,
              get() {
                const t = i.__NON_WITNESS_UTXO_BUF_CACHE[o],
                  e = i.__NON_WITNESS_UTXO_TX_CACHE[o];
                if (void 0 !== t) return t;
                {
                  const t = e.toBuffer();
                  return (i.__NON_WITNESS_UTXO_BUF_CACHE[o] = t), t;
                }
              },
              set(t) {
                i.__NON_WITNESS_UTXO_BUF_CACHE[o] = t;
              },
            });
        }
        function K(t, e, r, n) {
          let i = 0;
          t.forEach((t, o) => {
            if (
              (n && t.finalScriptSig && (e.ins[o].script = t.finalScriptSig),
              n &&
                t.finalScriptWitness &&
                (e.ins[o].witness = F(t.finalScriptWitness)),
              t.witnessUtxo)
            )
              i += t.witnessUtxo.value;
            else if (t.nonWitnessUtxo) {
              const n = V(r, t, o),
                s = e.ins[o].index,
                a = n.outs[s];
              i += a.value;
            }
          });
          const o = e.outs.reduce((t, e) => t + e.value, 0),
            s = i - o;
          if (s < 0) throw new Error("Outputs are spending more than Inputs");
          const a = e.virtualSize();
          (r.__FEE = s),
            (r.__EXTRACTED_TX = e),
            (r.__FEE_RATE = Math.floor(s / a));
        }
        function V(t, e, r) {
          const n = t.__NON_WITNESS_UTXO_TX_CACHE;
          return n[r] || H(t, e, r), n[r];
        }
        function q(t, e, r) {
          const { script: n } = z(t, e, r);
          return n;
        }
        function z(t, e, r) {
          if (void 0 !== e.witnessUtxo)
            return { script: e.witnessUtxo.script, value: e.witnessUtxo.value };
          if (void 0 !== e.nonWitnessUtxo) {
            const n = V(r, e, t).outs[r.__TX.ins[t].index];
            return { script: n.script, value: n.value };
          }
          throw new Error("Can't find pubkey in input without Utxo data");
        }
        function $(t) {
          return 33 === t.length && l.isCanonicalPubKey(t);
        }
        function G(t, e, r, n, i) {
          const o = (0, y.isP2SHScript)(t),
            s = o && n && (0, y.isP2WSHScript)(n),
            a = (0, y.isP2WSHScript)(t);
          if (o && void 0 === n)
            throw new Error("scriptPubkey is P2SH but redeemScript missing");
          if ((a || s) && void 0 === i)
            throw new Error(
              "scriptPubkey or redeemScript is P2WSH but witnessScript missing",
            );
          let u;
          return (
            s
              ? ((u = i), O(e, t, n, r), x(e, n, i, r), W(u))
              : a
                ? ((u = i), x(e, t, i, r), W(u))
                : o
                  ? ((u = n), O(e, t, n, r))
                  : (u = t),
            {
              meaningfulScript: u,
              type: s ? "p2sh-p2wsh" : o ? "p2sh" : a ? "p2wsh" : "raw",
            }
          );
        }
        function W(t) {
          if ((0, y.isP2WPKH)(t) || (0, y.isP2SHScript)(t))
            throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
        }
        function Y(t) {
          return (0, y.isP2WPKH)(t)
            ? "witnesspubkeyhash"
            : (0, y.isP2PKH)(t)
              ? "pubkeyhash"
              : (0, y.isP2MS)(t)
                ? "multisig"
                : (0, y.isP2PK)(t)
                  ? "pubkey"
                  : "nonstandard";
        }
        function X(t) {
          return [...Array(t).keys()];
        }
      },
      60477: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.checkTaprootInputForSigs =
            e.tapTreeFromList =
            e.tapTreeToList =
            e.tweakInternalPubKey =
            e.checkTaprootOutputFields =
            e.checkTaprootInputFields =
            e.isTaprootOutput =
            e.isTaprootInput =
            e.serializeTaprootSignature =
            e.tapScriptFinalizer =
            e.toXOnly =
              void 0);
        const i = r(98116),
          o = r(22021),
          s = r(34929),
          a = r(82218),
          u = r(30885),
          c = r(34929);
        function f(t) {
          return (
            t &&
            !!(
              t.tapInternalKey ||
              t.tapMerkleRoot ||
              (t.tapLeafScript && t.tapLeafScript.length) ||
              (t.tapBip32Derivation && t.tapBip32Derivation.length) ||
              (t.witnessUtxo && (0, s.isP2TR)(t.witnessUtxo.script))
            )
          );
        }
        function h(t, e) {
          return (
            t &&
            !!(
              t.tapInternalKey ||
              t.tapTree ||
              (t.tapBip32Derivation && t.tapBip32Derivation.length) ||
              (e && (0, s.isP2TR)(e))
            )
          );
        }
        function l(t = []) {
          return 1 === t.length && 0 === t[0].depth
            ? { output: t[0].script, version: t[0].leafVersion }
            : (function (t) {
                let e;
                for (const r of t)
                  if (((e = y(r, e)), !e))
                    throw new Error("No room left to insert tapleaf in tree");
                return e;
              })(t);
        }
        function d(t) {
          return {
            signature: t.slice(0, 64),
            hashType: t.slice(64)[0] || o.Transaction.SIGHASH_DEFAULT,
          };
        }
        function p(t, e = [], r = 0) {
          if (r > a.MAX_TAPTREE_DEPTH)
            throw new Error("Max taptree depth exceeded.");
          return t
            ? (0, i.isTapleaf)(t)
              ? (e.push({
                  depth: r,
                  leafVersion: t.version || a.LEAF_VERSION_TAPSCRIPT,
                  script: t.output,
                }),
                e)
              : (t[0] && p(t[0], e, r + 1), t[1] && p(t[1], e, r + 1), e)
            : [];
        }
        function y(t, e, r = 0) {
          if (r > a.MAX_TAPTREE_DEPTH)
            throw new Error("Max taptree depth exceeded.");
          if (t.depth === r)
            return e ? void 0 : { output: t.script, version: t.leafVersion };
          if ((0, i.isTapleaf)(e)) return;
          const n = y(t, e && e[0], r + 1);
          if (n) return [n, e && e[1]];
          const o = y(t, e && e[1], r + 1);
          return o ? [e && e[0], o] : void 0;
        }
        function g(t, e) {
          if (!e) return !0;
          const r = (0, a.tapleafHash)({
            output: t.script,
            version: t.leafVersion,
          });
          return (0, a.rootHashFromPath)(t.controlBlock, r).equals(e);
        }
        function m(t) {
          return (
            t &&
            !!(
              t.redeemScript ||
              t.witnessScript ||
              (t.bip32Derivation && t.bip32Derivation.length)
            )
          );
        }
        (e.toXOnly = (t) => (32 === t.length ? t : t.slice(1, 33))),
          (e.tapScriptFinalizer = function (t, e, r) {
            const n = (function (t, e, r) {
              if (!t.tapScriptSig || !t.tapScriptSig.length)
                throw new Error(
                  `Can not finalize taproot input #${e}. No tapleaf script signature provided.`,
                );
              const n = (t.tapLeafScript || [])
                .sort((t, e) => t.controlBlock.length - e.controlBlock.length)
                .find((e) =>
                  (function (t, e, r) {
                    const n = (0, a.tapleafHash)({
                      output: t.script,
                      version: t.leafVersion,
                    });
                    return (
                      (!r || r.equals(n)) &&
                      void 0 !== e.find((t) => t.leafHash.equals(n))
                    );
                  })(e, t.tapScriptSig, r),
                );
              if (!n)
                throw new Error(
                  `Can not finalize taproot input #${e}. Signature for tapleaf script not found.`,
                );
              return n;
            })(e, t, r);
            try {
              const t = (function (t, e) {
                  const r = (0, a.tapleafHash)({
                    output: e.script,
                    version: e.leafVersion,
                  });
                  return (t.tapScriptSig || [])
                    .filter((t) => t.leafHash.equals(r))
                    .map((t) =>
                      (function (t, e) {
                        return Object.assign(
                          {
                            positionInScript: (0, s.pubkeyPositionInScript)(
                              e.pubkey,
                              t,
                            ),
                          },
                          e,
                        );
                      })(e.script, t),
                    )
                    .sort((t, e) => e.positionInScript - t.positionInScript)
                    .map((t) => t.signature);
                })(e, n),
                r = t.concat(n.script).concat(n.controlBlock);
              return {
                finalScriptWitness: (0, s.witnessStackToScriptWitness)(r),
              };
            } catch (e) {
              throw new Error(`Can not finalize taproot input #${t}: ${e}`);
            }
          }),
          (e.serializeTaprootSignature = function (t, e) {
            const r = e ? n.from([e]) : n.from([]);
            return n.concat([t, r]);
          }),
          (e.isTaprootInput = f),
          (e.isTaprootOutput = h),
          (e.checkTaprootInputFields = function (t, e, r) {
            !(function (t, e, r) {
              const n = f(t) && m(e),
                i = m(t) && f(e),
                o = t === e && f(e) && m(e);
              if (n || i || o)
                throw new Error(
                  `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`,
                );
            })(t, e, r),
              (function (t, e, r) {
                if (e.tapMerkleRoot) {
                  const n = (e.tapLeafScript || []).every((t) =>
                      g(t, e.tapMerkleRoot),
                    ),
                    i = (t.tapLeafScript || []).every((t) =>
                      g(t, e.tapMerkleRoot),
                    );
                  if (!n || !i)
                    throw new Error(
                      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`,
                    );
                } else if (t.tapMerkleRoot) {
                  if (
                    !(e.tapLeafScript || []).every((e) => g(e, t.tapMerkleRoot))
                  )
                    throw new Error(
                      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`,
                    );
                }
              })(t, e, r);
          }),
          (e.checkTaprootOutputFields = function (t, e, r) {
            !(function (t, e, r) {
              const n = h(t) && m(e),
                i = m(t) && h(e),
                o = t === e && h(e) && m(e);
              if (n || i || o)
                throw new Error(
                  `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`,
                );
            })(t, e, r),
              (function (t, e) {
                if (!e.tapTree && !e.tapInternalKey) return;
                const r = e.tapInternalKey || t.tapInternalKey,
                  n = e.tapTree || t.tapTree;
                if (r) {
                  const { script: e } = t,
                    i = (function (t, e) {
                      const r = e && l(e.leaves),
                        { output: n } = (0, u.p2tr)({
                          internalPubkey: t,
                          scriptTree: r,
                        });
                      return n;
                    })(r, n);
                  if (e && !e.equals(i))
                    throw new Error(
                      "Error adding output. Script or address missmatch.",
                    );
                }
              })(t, e);
          }),
          (e.tweakInternalPubKey = function (t, e) {
            const r = e.tapInternalKey,
              n = r && (0, a.tweakKey)(r, e.tapMerkleRoot);
            if (!n)
              throw new Error(
                `Cannot tweak tap internal key for input #${t}. Public key: ${r && r.toString("hex")}`,
              );
            return n.x;
          }),
          (e.tapTreeToList = function (t) {
            if (!(0, i.isTaptree)(t))
              throw new Error(
                "Cannot convert taptree to tapleaf list. Expecting a tapree structure.",
              );
            return p(t);
          }),
          (e.tapTreeFromList = l),
          (e.checkTaprootInputForSigs = function (t, e) {
            return (function (t) {
              const e = [];
              t.tapKeySig && e.push(t.tapKeySig);
              t.tapScriptSig &&
                e.push(...t.tapScriptSig.map((t) => t.signature));
              if (!e.length) {
                const r = (function (t) {
                  if (!t) return;
                  const e = t.slice(2);
                  if (64 === e.length || 65 === e.length) return e;
                })(t.finalScriptWitness);
                r && e.push(r);
              }
              return e;
            })(t).some((t) => (0, c.signatureBlocksAction)(t, d, e));
          });
      },
      34929: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.signatureBlocksAction =
            e.checkInputForSig =
            e.pubkeyInScript =
            e.pubkeyPositionInScript =
            e.witnessStackToScriptWitness =
            e.isP2TR =
            e.isP2SHScript =
            e.isP2WSHScript =
            e.isP2WPKH =
            e.isP2PKH =
            e.isP2PK =
            e.isP2MS =
              void 0);
        const i = r(40394),
          o = r(67038),
          s = r(22021),
          a = r(91944),
          u = r(30885);
        function c(t) {
          return (e) => {
            try {
              return t({ output: e }), !0;
            } catch (t) {
              return !1;
            }
          };
        }
        function f(t, e) {
          const r = (0, a.hash160)(t),
            n = t.slice(1, 33),
            i = o.decompile(e);
          if (null === i) throw new Error("Unknown script error");
          return i.findIndex(
            (e) =>
              "number" != typeof e &&
              (e.equals(t) || e.equals(r) || e.equals(n)),
          );
        }
        function h(t, e, r) {
          const { hashType: n } = e(t),
            i = [];
          n & s.Transaction.SIGHASH_ANYONECANPAY && i.push("addInput");
          switch (31 & n) {
            case s.Transaction.SIGHASH_ALL:
              break;
            case s.Transaction.SIGHASH_SINGLE:
            case s.Transaction.SIGHASH_NONE:
              i.push("addOutput"), i.push("setInputSequence");
          }
          return -1 === i.indexOf(r);
        }
        (e.isP2MS = c(u.p2ms)),
          (e.isP2PK = c(u.p2pk)),
          (e.isP2PKH = c(u.p2pkh)),
          (e.isP2WPKH = c(u.p2wpkh)),
          (e.isP2WSHScript = c(u.p2wsh)),
          (e.isP2SHScript = c(u.p2sh)),
          (e.isP2TR = c(u.p2tr)),
          (e.witnessStackToScriptWitness = function (t) {
            let e = n.allocUnsafe(0);
            function r(t) {
              const r = e.length,
                o = i.encodingLength(t);
              (e = n.concat([e, n.allocUnsafe(o)])), i.encode(t, e, r);
            }
            function o(t) {
              r(t.length),
                (function (t) {
                  e = n.concat([e, n.from(t)]);
                })(t);
            }
            var s;
            return r((s = t).length), s.forEach(o), e;
          }),
          (e.pubkeyPositionInScript = f),
          (e.pubkeyInScript = function (t, e) {
            return -1 !== f(t, e);
          }),
          (e.checkInputForSig = function (t, e) {
            return (function (t) {
              let e = [];
              if (0 === (t.partialSig || []).length) {
                if (!t.finalScriptSig && !t.finalScriptWitness) return [];
                e = (function (t) {
                  const e =
                      (t.finalScriptSig && o.decompile(t.finalScriptSig)) || [],
                    r =
                      (t.finalScriptWitness &&
                        o.decompile(t.finalScriptWitness)) ||
                      [];
                  return e
                    .concat(r)
                    .filter(
                      (t) => n.isBuffer(t) && o.isCanonicalScriptSignature(t),
                    )
                    .map((t) => ({ signature: t }));
                })(t);
              } else e = t.partialSig;
              return e.map((t) => t.signature);
            })(t).some((t) => h(t, o.signature.decode, e));
          }),
          (e.signatureBlocksAction = h);
      },
      34344: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = e.encode = e.encodingLength = void 0);
        const n = r(68417);
        function i(t) {
          return t < n.OPS.OP_PUSHDATA1 ? 1 : t <= 255 ? 2 : t <= 65535 ? 3 : 5;
        }
        (e.encodingLength = i),
          (e.encode = function (t, e, r) {
            const o = i(e);
            return (
              1 === o
                ? t.writeUInt8(e, r)
                : 2 === o
                  ? (t.writeUInt8(n.OPS.OP_PUSHDATA1, r),
                    t.writeUInt8(e, r + 1))
                  : 3 === o
                    ? (t.writeUInt8(n.OPS.OP_PUSHDATA2, r),
                      t.writeUInt16LE(e, r + 1))
                    : (t.writeUInt8(n.OPS.OP_PUSHDATA4, r),
                      t.writeUInt32LE(e, r + 1)),
              o
            );
          }),
          (e.decode = function (t, e) {
            const r = t.readUInt8(e);
            let i, o;
            if (r < n.OPS.OP_PUSHDATA1) (i = r), (o = 1);
            else if (r === n.OPS.OP_PUSHDATA1) {
              if (e + 2 > t.length) return null;
              (i = t.readUInt8(e + 1)), (o = 2);
            } else if (r === n.OPS.OP_PUSHDATA2) {
              if (e + 3 > t.length) return null;
              (i = t.readUInt16LE(e + 1)), (o = 3);
            } else {
              if (e + 5 > t.length) return null;
              if (r !== n.OPS.OP_PUSHDATA4)
                throw new Error("Unexpected opcode");
              (i = t.readUInt32LE(e + 1)), (o = 5);
            }
            return { opcode: r, number: i, size: o };
          });
      },
      67038: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.signature =
            e.number =
            e.isCanonicalScriptSignature =
            e.isDefinedHashType =
            e.isCanonicalPubKey =
            e.toStack =
            e.fromASM =
            e.toASM =
            e.decompile =
            e.compile =
            e.countNonPushOnlyOPs =
            e.isPushOnly =
            e.OPS =
              void 0);
        const i = r(13966),
          o = r(68417);
        Object.defineProperty(e, "OPS", {
          enumerable: !0,
          get: function () {
            return o.OPS;
          },
        });
        const s = r(34344),
          a = r(19464),
          u = r(41043),
          c = r(98116),
          { typeforce: f } = c,
          h = o.OPS.OP_RESERVED;
        function l(t) {
          return (
            c.Buffer(t) ||
            (function (t) {
              return (
                c.Number(t) &&
                (t === o.OPS.OP_0 ||
                  (t >= o.OPS.OP_1 && t <= o.OPS.OP_16) ||
                  t === o.OPS.OP_1NEGATE)
              );
            })(t)
          );
        }
        function d(t) {
          return c.Array(t) && t.every(l);
        }
        function p(t) {
          return 0 === t.length
            ? o.OPS.OP_0
            : 1 === t.length
              ? t[0] >= 1 && t[0] <= 16
                ? h + t[0]
                : 129 === t[0]
                  ? o.OPS.OP_1NEGATE
                  : void 0
              : void 0;
        }
        function y(t) {
          return n.isBuffer(t);
        }
        function g(t) {
          return n.isBuffer(t);
        }
        function m(t) {
          if (y(t)) return t;
          f(c.Array, t);
          const e = t.reduce(
              (t, e) =>
                g(e)
                  ? 1 === e.length && void 0 !== p(e)
                    ? t + 1
                    : t + s.encodingLength(e.length) + e.length
                  : t + 1,
              0,
            ),
            r = n.allocUnsafe(e);
          let i = 0;
          if (
            (t.forEach((t) => {
              if (g(t)) {
                const e = p(t);
                if (void 0 !== e) return r.writeUInt8(e, i), void (i += 1);
                (i += s.encode(r, t.length, i)), t.copy(r, i), (i += t.length);
              } else r.writeUInt8(t, i), (i += 1);
            }),
            i !== r.length)
          )
            throw new Error("Could not decode chunks");
          return r;
        }
        function b(t) {
          if (((e = t), c.Array(e))) return t;
          var e;
          f(c.Buffer, t);
          const r = [];
          let n = 0;
          for (; n < t.length; ) {
            const e = t[n];
            if (e > o.OPS.OP_0 && e <= o.OPS.OP_PUSHDATA4) {
              const e = s.decode(t, n);
              if (null === e) return null;
              if (((n += e.size), n + e.number > t.length)) return null;
              const i = t.slice(n, n + e.number);
              n += e.number;
              const o = p(i);
              void 0 !== o ? r.push(o) : r.push(i);
            } else r.push(e), (n += 1);
          }
          return r;
        }
        function w(t) {
          const e = -129 & t;
          return e > 0 && e < 4;
        }
        (e.isPushOnly = d),
          (e.countNonPushOnlyOPs = function (t) {
            return t.length - t.filter(l).length;
          }),
          (e.compile = m),
          (e.decompile = b),
          (e.toASM = function (t) {
            return (
              y(t) && (t = b(t)),
              t
                .map((t) => {
                  if (g(t)) {
                    const e = p(t);
                    if (void 0 === e) return t.toString("hex");
                    t = e;
                  }
                  return o.REVERSE_OPS[t];
                })
                .join(" ")
            );
          }),
          (e.fromASM = function (t) {
            return (
              f(c.String, t),
              m(
                t
                  .split(" ")
                  .map((t) =>
                    void 0 !== o.OPS[t]
                      ? o.OPS[t]
                      : (f(c.Hex, t), n.from(t, "hex")),
                  ),
              )
            );
          }),
          (e.toStack = function (t) {
            return (
              (t = b(t)),
              f(d, t),
              t.map((t) =>
                g(t)
                  ? t
                  : t === o.OPS.OP_0
                    ? n.allocUnsafe(0)
                    : a.encode(t - h),
              )
            );
          }),
          (e.isCanonicalPubKey = function (t) {
            return c.isPoint(t);
          }),
          (e.isDefinedHashType = w),
          (e.isCanonicalScriptSignature = function (t) {
            return (
              !!n.isBuffer(t) && !!w(t[t.length - 1]) && i.check(t.slice(0, -1))
            );
          }),
          (e.number = a),
          (e.signature = u);
      },
      19464: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encode = e.decode = void 0),
          (e.decode = function (t, e, r) {
            (e = e || 4), (r = void 0 === r || r);
            const n = t.length;
            if (0 === n) return 0;
            if (n > e) throw new TypeError("Script number overflow");
            if (r && !(127 & t[n - 1] || (!(n <= 1) && 128 & t[n - 2])))
              throw new Error("Non-minimally encoded script number");
            if (5 === n) {
              const e = t.readUInt32LE(0),
                r = t.readUInt8(4);
              return 128 & r
                ? -(4294967296 * (-129 & r) + e)
                : 4294967296 * r + e;
            }
            let i = 0;
            for (let e = 0; e < n; ++e) i |= t[e] << (8 * e);
            return 128 & t[n - 1] ? -(i & ~(128 << (8 * (n - 1)))) : i;
          }),
          (e.encode = function (t) {
            let e = Math.abs(t);
            const r =
              (i = e) > 2147483647
                ? 5
                : i > 8388607
                  ? 4
                  : i > 32767
                    ? 3
                    : i > 127
                      ? 2
                      : i > 0
                        ? 1
                        : 0;
            var i;
            const o = n.allocUnsafe(r),
              s = t < 0;
            for (let t = 0; t < r; ++t) o.writeUInt8(255 & e, t), (e >>= 8);
            return (
              128 & o[r - 1]
                ? o.writeUInt8(s ? 128 : 0, r - 1)
                : s && (o[r - 1] |= 128),
              o
            );
          });
      },
      41043: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encode = e.decode = void 0);
        const i = r(13966),
          o = r(98116),
          { typeforce: s } = o,
          a = n.alloc(1, 0);
        function u(t) {
          let e = 0;
          for (; 0 === t[e]; ) ++e;
          return e === t.length
            ? a
            : 128 & (t = t.slice(e))[0]
              ? n.concat([a, t], 1 + t.length)
              : t;
        }
        function c(t) {
          0 === t[0] && (t = t.slice(1));
          const e = n.alloc(32, 0),
            r = Math.max(0, 32 - t.length);
          return t.copy(e, r), e;
        }
        (e.decode = function (t) {
          const e = t.readUInt8(t.length - 1),
            r = -129 & e;
          if (r <= 0 || r >= 4) throw new Error("Invalid hashType " + e);
          const o = i.decode(t.slice(0, -1)),
            s = c(o.r),
            a = c(o.s);
          return { signature: n.concat([s, a], 64), hashType: e };
        }),
          (e.encode = function (t, e) {
            s(
              { signature: o.BufferN(64), hashType: o.UInt8 },
              { signature: t, hashType: e },
            );
            const r = -129 & e;
            if (r <= 0 || r >= 4) throw new Error("Invalid hashType " + e);
            const a = n.allocUnsafe(1);
            a.writeUInt8(e, 0);
            const c = u(t.slice(0, 32)),
              f = u(t.slice(32, 64));
            return n.concat([i.encode(c, f), a]);
          });
      },
      22021: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Transaction = void 0);
        const i = r(30606),
          o = r(91944),
          s = r(67038),
          a = r(67038),
          u = r(98116),
          { typeforce: c } = u;
        function f(t) {
          const e = t.length;
          return i.varuint.encodingLength(e) + e;
        }
        const h = n.allocUnsafe(0),
          l = [],
          d = n.from(
            "0000000000000000000000000000000000000000000000000000000000000000",
            "hex",
          ),
          p = n.from(
            "0000000000000000000000000000000000000000000000000000000000000001",
            "hex",
          ),
          y = n.from("ffffffffffffffff", "hex"),
          g = { script: h, valueBuffer: y };
        class m {
          constructor() {
            (this.version = 1),
              (this.locktime = 0),
              (this.ins = []),
              (this.outs = []);
          }
          static fromBuffer(t, e) {
            const r = new i.BufferReader(t),
              n = new m();
            n.version = r.readInt32();
            const o = r.readUInt8(),
              s = r.readUInt8();
            let a = !1;
            o === m.ADVANCED_TRANSACTION_MARKER &&
            s === m.ADVANCED_TRANSACTION_FLAG
              ? (a = !0)
              : (r.offset -= 2);
            const u = r.readVarInt();
            for (let t = 0; t < u; ++t)
              n.ins.push({
                hash: r.readSlice(32),
                index: r.readUInt32(),
                script: r.readVarSlice(),
                sequence: r.readUInt32(),
                witness: l,
              });
            const c = r.readVarInt();
            for (let t = 0; t < c; ++t)
              n.outs.push({ value: r.readUInt64(), script: r.readVarSlice() });
            if (a) {
              for (let t = 0; t < u; ++t) n.ins[t].witness = r.readVector();
              if (!n.hasWitnesses())
                throw new Error("Transaction has superfluous witness data");
            }
            if (((n.locktime = r.readUInt32()), e)) return n;
            if (r.offset !== t.length)
              throw new Error("Transaction has unexpected data");
            return n;
          }
          static fromHex(t) {
            return m.fromBuffer(n.from(t, "hex"), !1);
          }
          static isCoinbaseHash(t) {
            c(u.Hash256bit, t);
            for (let e = 0; e < 32; ++e) if (0 !== t[e]) return !1;
            return !0;
          }
          isCoinbase() {
            return 1 === this.ins.length && m.isCoinbaseHash(this.ins[0].hash);
          }
          addInput(t, e, r, n) {
            return (
              c(
                u.tuple(
                  u.Hash256bit,
                  u.UInt32,
                  u.maybe(u.UInt32),
                  u.maybe(u.Buffer),
                ),
                arguments,
              ),
              u.Null(r) && (r = m.DEFAULT_SEQUENCE),
              this.ins.push({
                hash: t,
                index: e,
                script: n || h,
                sequence: r,
                witness: l,
              }) - 1
            );
          }
          addOutput(t, e) {
            return (
              c(u.tuple(u.Buffer, u.Satoshi), arguments),
              this.outs.push({ script: t, value: e }) - 1
            );
          }
          hasWitnesses() {
            return this.ins.some((t) => 0 !== t.witness.length);
          }
          weight() {
            return 3 * this.byteLength(!1) + this.byteLength(!0);
          }
          virtualSize() {
            return Math.ceil(this.weight() / 4);
          }
          byteLength(t = !0) {
            const e = t && this.hasWitnesses();
            return (
              (e ? 10 : 8) +
              i.varuint.encodingLength(this.ins.length) +
              i.varuint.encodingLength(this.outs.length) +
              this.ins.reduce((t, e) => t + 40 + f(e.script), 0) +
              this.outs.reduce((t, e) => t + 8 + f(e.script), 0) +
              (e
                ? this.ins.reduce(
                    (t, e) =>
                      t +
                      (function (t) {
                        const e = t.length;
                        return (
                          i.varuint.encodingLength(e) +
                          t.reduce((t, e) => t + f(e), 0)
                        );
                      })(e.witness),
                    0,
                  )
                : 0)
            );
          }
          clone() {
            const t = new m();
            return (
              (t.version = this.version),
              (t.locktime = this.locktime),
              (t.ins = this.ins.map((t) => ({
                hash: t.hash,
                index: t.index,
                script: t.script,
                sequence: t.sequence,
                witness: t.witness,
              }))),
              (t.outs = this.outs.map((t) => ({
                script: t.script,
                value: t.value,
              }))),
              t
            );
          }
          hashForSignature(t, e, r) {
            if (
              (c(u.tuple(u.UInt32, u.Buffer, u.Number), arguments),
              t >= this.ins.length)
            )
              return p;
            const i = s.compile(
                s.decompile(e).filter((t) => t !== a.OPS.OP_CODESEPARATOR),
              ),
              f = this.clone();
            if ((31 & r) === m.SIGHASH_NONE)
              (f.outs = []),
                f.ins.forEach((e, r) => {
                  r !== t && (e.sequence = 0);
                });
            else if ((31 & r) === m.SIGHASH_SINGLE) {
              if (t >= this.outs.length) return p;
              f.outs.length = t + 1;
              for (let e = 0; e < t; e++) f.outs[e] = g;
              f.ins.forEach((e, r) => {
                r !== t && (e.sequence = 0);
              });
            }
            r & m.SIGHASH_ANYONECANPAY
              ? ((f.ins = [f.ins[t]]), (f.ins[0].script = i))
              : (f.ins.forEach((t) => {
                  t.script = h;
                }),
                (f.ins[t].script = i));
            const l = n.allocUnsafe(f.byteLength(!1) + 4);
            return (
              l.writeInt32LE(r, l.length - 4),
              f.__toBuffer(l, 0, !1),
              o.hash256(l)
            );
          }
          hashForWitnessV1(t, e, r, s, a, l) {
            if (
              (c(
                u.tuple(
                  u.UInt32,
                  c.arrayOf(u.Buffer),
                  c.arrayOf(u.Satoshi),
                  u.UInt32,
                ),
                arguments,
              ),
              r.length !== this.ins.length || e.length !== this.ins.length)
            )
              throw new Error(
                "Must supply prevout script and value for all inputs",
              );
            const d =
                s === m.SIGHASH_DEFAULT
                  ? m.SIGHASH_ALL
                  : s & m.SIGHASH_OUTPUT_MASK,
              p = (s & m.SIGHASH_INPUT_MASK) === m.SIGHASH_ANYONECANPAY,
              y = d === m.SIGHASH_NONE,
              g = d === m.SIGHASH_SINGLE;
            let b = h,
              w = h,
              v = h,
              _ = h,
              E = h;
            if (!p) {
              let t = i.BufferWriter.withCapacity(36 * this.ins.length);
              this.ins.forEach((e) => {
                t.writeSlice(e.hash), t.writeUInt32(e.index);
              }),
                (b = o.sha256(t.end())),
                (t = i.BufferWriter.withCapacity(8 * this.ins.length)),
                r.forEach((e) => t.writeUInt64(e)),
                (w = o.sha256(t.end())),
                (t = i.BufferWriter.withCapacity(
                  e.map(f).reduce((t, e) => t + e),
                )),
                e.forEach((e) => t.writeVarSlice(e)),
                (v = o.sha256(t.end())),
                (t = i.BufferWriter.withCapacity(4 * this.ins.length)),
                this.ins.forEach((e) => t.writeUInt32(e.sequence)),
                (_ = o.sha256(t.end()));
            }
            if (y || g) {
              if (g && t < this.outs.length) {
                const e = this.outs[t],
                  r = i.BufferWriter.withCapacity(8 + f(e.script));
                r.writeUInt64(e.value),
                  r.writeVarSlice(e.script),
                  (E = o.sha256(r.end()));
              }
            } else {
              const t = this.outs
                  .map((t) => 8 + f(t.script))
                  .reduce((t, e) => t + e),
                e = i.BufferWriter.withCapacity(t);
              this.outs.forEach((t) => {
                e.writeUInt64(t.value), e.writeVarSlice(t.script);
              }),
                (E = o.sha256(e.end()));
            }
            const S = (a ? 2 : 0) + (l ? 1 : 0),
              I =
                174 - (p ? 49 : 0) - (y ? 32 : 0) + (l ? 32 : 0) + (a ? 37 : 0),
              M = i.BufferWriter.withCapacity(I);
            if (
              (M.writeUInt8(s),
              M.writeInt32(this.version),
              M.writeUInt32(this.locktime),
              M.writeSlice(b),
              M.writeSlice(w),
              M.writeSlice(v),
              M.writeSlice(_),
              y || g || M.writeSlice(E),
              M.writeUInt8(S),
              p)
            ) {
              const n = this.ins[t];
              M.writeSlice(n.hash),
                M.writeUInt32(n.index),
                M.writeUInt64(r[t]),
                M.writeVarSlice(e[t]),
                M.writeUInt32(n.sequence);
            } else M.writeUInt32(t);
            if (l) {
              const t = i.BufferWriter.withCapacity(f(l));
              t.writeVarSlice(l), M.writeSlice(o.sha256(t.end()));
            }
            return (
              g && M.writeSlice(E),
              a &&
                (M.writeSlice(a), M.writeUInt8(0), M.writeUInt32(4294967295)),
              o.taggedHash("TapSighash", n.concat([n.from([0]), M.end()]))
            );
          }
          hashForWitnessV0(t, e, r, s) {
            c(u.tuple(u.UInt32, u.Buffer, u.Satoshi, u.UInt32), arguments);
            let a,
              h = n.from([]),
              l = d,
              p = d,
              y = d;
            if (
              (s & m.SIGHASH_ANYONECANPAY ||
                ((h = n.allocUnsafe(36 * this.ins.length)),
                (a = new i.BufferWriter(h, 0)),
                this.ins.forEach((t) => {
                  a.writeSlice(t.hash), a.writeUInt32(t.index);
                }),
                (p = o.hash256(h))),
              s & m.SIGHASH_ANYONECANPAY ||
                (31 & s) === m.SIGHASH_SINGLE ||
                (31 & s) === m.SIGHASH_NONE ||
                ((h = n.allocUnsafe(4 * this.ins.length)),
                (a = new i.BufferWriter(h, 0)),
                this.ins.forEach((t) => {
                  a.writeUInt32(t.sequence);
                }),
                (y = o.hash256(h))),
              (31 & s) !== m.SIGHASH_SINGLE && (31 & s) !== m.SIGHASH_NONE)
            ) {
              const t = this.outs.reduce((t, e) => t + 8 + f(e.script), 0);
              (h = n.allocUnsafe(t)),
                (a = new i.BufferWriter(h, 0)),
                this.outs.forEach((t) => {
                  a.writeUInt64(t.value), a.writeVarSlice(t.script);
                }),
                (l = o.hash256(h));
            } else if ((31 & s) === m.SIGHASH_SINGLE && t < this.outs.length) {
              const e = this.outs[t];
              (h = n.allocUnsafe(8 + f(e.script))),
                (a = new i.BufferWriter(h, 0)),
                a.writeUInt64(e.value),
                a.writeVarSlice(e.script),
                (l = o.hash256(h));
            }
            (h = n.allocUnsafe(156 + f(e))), (a = new i.BufferWriter(h, 0));
            const g = this.ins[t];
            return (
              a.writeInt32(this.version),
              a.writeSlice(p),
              a.writeSlice(y),
              a.writeSlice(g.hash),
              a.writeUInt32(g.index),
              a.writeVarSlice(e),
              a.writeUInt64(r),
              a.writeUInt32(g.sequence),
              a.writeSlice(l),
              a.writeUInt32(this.locktime),
              a.writeUInt32(s),
              o.hash256(h)
            );
          }
          getHash(t) {
            return t && this.isCoinbase()
              ? n.alloc(32, 0)
              : o.hash256(this.__toBuffer(void 0, void 0, t));
          }
          getId() {
            return (0, i.reverseBuffer)(this.getHash(!1)).toString("hex");
          }
          toBuffer(t, e) {
            return this.__toBuffer(t, e, !0);
          }
          toHex() {
            return this.toBuffer(void 0, void 0).toString("hex");
          }
          setInputScript(t, e) {
            c(u.tuple(u.Number, u.Buffer), arguments), (this.ins[t].script = e);
          }
          setWitness(t, e) {
            c(u.tuple(u.Number, [u.Buffer]), arguments),
              (this.ins[t].witness = e);
          }
          __toBuffer(t, e, r = !1) {
            t || (t = n.allocUnsafe(this.byteLength(r)));
            const o = new i.BufferWriter(t, e || 0);
            o.writeInt32(this.version);
            const s = r && this.hasWitnesses();
            return (
              s &&
                (o.writeUInt8(m.ADVANCED_TRANSACTION_MARKER),
                o.writeUInt8(m.ADVANCED_TRANSACTION_FLAG)),
              o.writeVarInt(this.ins.length),
              this.ins.forEach((t) => {
                o.writeSlice(t.hash),
                  o.writeUInt32(t.index),
                  o.writeVarSlice(t.script),
                  o.writeUInt32(t.sequence);
              }),
              o.writeVarInt(this.outs.length),
              this.outs.forEach((t) => {
                void 0 !== t.value
                  ? o.writeUInt64(t.value)
                  : o.writeSlice(t.valueBuffer),
                  o.writeVarSlice(t.script);
              }),
              s &&
                this.ins.forEach((t) => {
                  o.writeVector(t.witness);
                }),
              o.writeUInt32(this.locktime),
              void 0 !== e ? t.slice(e, o.offset) : t
            );
          }
        }
        (e.Transaction = m),
          (m.DEFAULT_SEQUENCE = 4294967295),
          (m.SIGHASH_DEFAULT = 0),
          (m.SIGHASH_ALL = 1),
          (m.SIGHASH_NONE = 2),
          (m.SIGHASH_SINGLE = 3),
          (m.SIGHASH_ANYONECANPAY = 128),
          (m.SIGHASH_OUTPUT_MASK = 3),
          (m.SIGHASH_INPUT_MASK = 128),
          (m.ADVANCED_TRANSACTION_MARKER = 0),
          (m.ADVANCED_TRANSACTION_FLAG = 1);
      },
      98116: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.oneOf =
            e.Null =
            e.BufferN =
            e.Function =
            e.UInt32 =
            e.UInt8 =
            e.tuple =
            e.maybe =
            e.Hex =
            e.Buffer =
            e.String =
            e.Boolean =
            e.Array =
            e.Number =
            e.Hash256bit =
            e.Hash160bit =
            e.Buffer256bit =
            e.isTaptree =
            e.isTapleaf =
            e.TAPLEAF_VERSION_MASK =
            e.Network =
            e.ECPoint =
            e.Satoshi =
            e.Signer =
            e.BIP32Path =
            e.UInt31 =
            e.isPoint =
            e.typeforce =
              void 0);
        const n = r(48287);
        e.typeforce = r(8676);
        const i = n.Buffer.alloc(32, 0),
          o = n.Buffer.from(
            "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
            "hex",
          );
        e.isPoint = function (t) {
          if (!n.Buffer.isBuffer(t)) return !1;
          if (t.length < 33) return !1;
          const e = t[0],
            r = t.slice(1, 33);
          if (0 === r.compare(i)) return !1;
          if (r.compare(o) >= 0) return !1;
          if ((2 === e || 3 === e) && 33 === t.length) return !0;
          const s = t.slice(33);
          return (
            0 !== s.compare(i) &&
            !(s.compare(o) >= 0) &&
            4 === e &&
            65 === t.length
          );
        };
        const s = Math.pow(2, 31) - 1;
        function a(t) {
          return e.typeforce.String(t) && !!t.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
        }
        (e.UInt31 = function (t) {
          return e.typeforce.UInt32(t) && t <= s;
        }),
          (e.BIP32Path = a),
          (a.toJSON = () => "BIP32 derivation path"),
          (e.Signer = function (t) {
            return (
              (e.typeforce.Buffer(t.publicKey) ||
                "function" == typeof t.getPublicKey) &&
              "function" == typeof t.sign
            );
          });
        function u(t) {
          return (
            !(!t || !("output" in t)) &&
            !!n.Buffer.isBuffer(t.output) &&
            (void 0 === t.version ||
              (t.version & e.TAPLEAF_VERSION_MASK) === t.version)
          );
        }
        (e.Satoshi = function (t) {
          return e.typeforce.UInt53(t) && t <= 21e14;
        }),
          (e.ECPoint = e.typeforce.quacksLike("Point")),
          (e.Network = e.typeforce.compile({
            messagePrefix: e.typeforce.oneOf(
              e.typeforce.Buffer,
              e.typeforce.String,
            ),
            bip32: { public: e.typeforce.UInt32, private: e.typeforce.UInt32 },
            pubKeyHash: e.typeforce.UInt8,
            scriptHash: e.typeforce.UInt8,
            wif: e.typeforce.UInt8,
          })),
          (e.TAPLEAF_VERSION_MASK = 254),
          (e.isTapleaf = u),
          (e.isTaptree = function t(r) {
            return (0, e.Array)(r)
              ? 2 === r.length && r.every((e) => t(e))
              : u(r);
          }),
          (e.Buffer256bit = e.typeforce.BufferN(32)),
          (e.Hash160bit = e.typeforce.BufferN(20)),
          (e.Hash256bit = e.typeforce.BufferN(32)),
          (e.Number = e.typeforce.Number),
          (e.Array = e.typeforce.Array),
          (e.Boolean = e.typeforce.Boolean),
          (e.String = e.typeforce.String),
          (e.Buffer = e.typeforce.Buffer),
          (e.Hex = e.typeforce.Hex),
          (e.maybe = e.typeforce.maybe),
          (e.tuple = e.typeforce.tuple),
          (e.UInt8 = e.typeforce.UInt8),
          (e.UInt32 = e.typeforce.UInt32),
          (e.Function = e.typeforce.Function),
          (e.BufferN = e.typeforce.BufferN),
          (e.Null = e.typeforce.Null),
          (e.oneOf = e.typeforce.oneOf);
      },
      1948: (t, e, r) => {
        var n = r(48287).Buffer;
        const i = r(91889),
          o = r(73423),
          s = r(65699),
          a = r(47108),
          u = r(37141),
          c = r(68469),
          f = "p2wpkh",
          h = "p2sh(p2wpkh)";
        function l(t) {
          return a("sha256").update(t).digest();
        }
        function d(t) {
          return a("ripemd160").update(l(t)).digest();
        }
        function p(t, e, r, i) {
          return (
            void 0 !== i ? ((e += 8), i === f && (e += 4)) : r && (e += 4),
            n.concat([n.alloc(1, e + 27), t])
          );
        }
        function y(t, e) {
          (e = e || "Bitcoin Signed Message:\n"),
            n.isBuffer(e) || (e = n.from(e, "utf8")),
            n.isBuffer(t) || (t = n.from(t, "utf8"));
          const r = c.encodingLength(t.length),
            i = n.allocUnsafe(e.length + r + t.length);
          return (
            e.copy(i, 0),
            c.encode(t.length, i, e.length),
            t.copy(i, e.length + r),
            (function (t) {
              return l(l(t));
            })(i)
          );
        }
        function g(t, e) {
          "object" == typeof t && void 0 === e && ((e = t), (t = void 0));
          let { segwitType: r, extraEntropy: n } = e || {};
          if (
            (r &&
              ("string" == typeof r || r instanceof String) &&
              (r = r.toLowerCase()),
            r && r !== h && r !== f)
          )
            throw new Error(
              'Unrecognized segwitType: use "' + h + '" or "' + f + '"',
            );
          return { messagePrefixArg: t, segwitType: r, extraEntropy: n };
        }
        function m(t) {
          return t && "function" == typeof t.sign;
        }
        function b(t) {
          return d(n.concat([n.from("0014", "hex"), t]));
        }
        function w(t) {
          const e = o.decode(t),
            r = o.fromWords(e.words.slice(1));
          return n.from(r);
        }
        t.exports = {
          magicHash: y,
          sign: function (t, e, r, n, i) {
            const {
                messagePrefixArg: o,
                segwitType: s,
                extraEntropy: a,
              } = g(n, i),
              c = y(t, o),
              f = m(e) ? e.sign(c, a) : u.sign(c, e, { data: a });
            return p(f.signature, f.recovery, r, s);
          },
          signAsync: function (t, e, r, n, i) {
            let o, s, a;
            return Promise.resolve()
              .then(() => {
                ({
                  messagePrefixArg: o,
                  segwitType: s,
                  extraEntropy: a,
                } = g(n, i));
                const r = y(t, o);
                return m(e) ? e.sign(r, a) : u.sign(r, e, { data: a });
              })
              .then((t) => p(t.signature, t.recovery, r, s));
          },
          verify: function (t, e, r, o, a) {
            n.isBuffer(r) || (r = n.from(r, "base64"));
            const c = (function (t) {
              if (65 !== t.length) throw new Error("Invalid signature length");
              const e = t.readUInt8(0) - 27;
              if (e > 15 || e < 0)
                throw new Error("Invalid signature parameter");
              return {
                compressed: !!(12 & e),
                segwitType: 8 & e ? (4 & e ? f : h) : null,
                recovery: 3 & e,
                signature: t.slice(1),
              };
            })(r);
            if (a && !c.compressed)
              throw new Error(
                "checkSegwitAlways can only be used with a compressed pubkey signature flagbyte",
              );
            const l = y(t, o),
              p = d(u.recover(l, c.signature, c.recovery, c.compressed));
            let g, m;
            if (c.segwitType)
              c.segwitType === h
                ? ((g = b(p)), (m = i.decode(e).slice(1)))
                : ((g = p), (m = w(e)));
            else if (a)
              try {
                return (m = w(e)), s(p, m);
              } catch (t) {
                const r = b(p);
                return (m = i.decode(e).slice(1)), s(p, m) || s(r, m);
              }
            else (g = p), (m = i.decode(e).slice(1));
            return s(g, m);
          },
        };
      },
      73423: (t) => {
        "use strict";
        for (
          var e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", r = {}, n = 0;
          n < 32;
          n++
        ) {
          var i = e.charAt(n);
          if (void 0 !== r[i]) throw new TypeError(i + " is ambiguous");
          r[i] = n;
        }
        function o(t) {
          var e = t >> 25;
          return (
            ((33554431 & t) << 5) ^
            (996825010 & -(1 & e)) ^
            (642813549 & -((e >> 1) & 1)) ^
            (513874426 & -((e >> 2) & 1)) ^
            (1027748829 & -((e >> 3) & 1)) ^
            (705979059 & -((e >> 4) & 1))
          );
        }
        function s(t) {
          for (var e = 1, r = 0; r < t.length; ++r) {
            var n = t.charCodeAt(r);
            if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
            e = o(e) ^ (n >> 5);
          }
          for (e = o(e), r = 0; r < t.length; ++r) {
            var i = t.charCodeAt(r);
            e = o(e) ^ (31 & i);
          }
          return e;
        }
        function a(t, e) {
          if (((e = e || 90), t.length < 8)) return t + " too short";
          if (t.length > e) return "Exceeds length limit";
          var n = t.toLowerCase(),
            i = t.toUpperCase();
          if (t !== n && t !== i) return "Mixed-case string " + t;
          var a = (t = n).lastIndexOf("1");
          if (-1 === a) return "No separator character for " + t;
          if (0 === a) return "Missing prefix for " + t;
          var u = t.slice(0, a),
            c = t.slice(a + 1);
          if (c.length < 6) return "Data too short";
          var f = s(u);
          if ("string" == typeof f) return f;
          for (var h = [], l = 0; l < c.length; ++l) {
            var d = c.charAt(l),
              p = r[d];
            if (void 0 === p) return "Unknown character " + d;
            (f = o(f) ^ p), l + 6 >= c.length || h.push(p);
          }
          return 1 !== f
            ? "Invalid checksum for " + t
            : { prefix: u, words: h };
        }
        function u(t, e, r, n) {
          for (
            var i = 0, o = 0, s = (1 << r) - 1, a = [], u = 0;
            u < t.length;
            ++u
          )
            for (i = (i << e) | t[u], o += e; o >= r; )
              (o -= r), a.push((i >> o) & s);
          if (n) o > 0 && a.push((i << (r - o)) & s);
          else {
            if (o >= e) return "Excess padding";
            if ((i << (r - o)) & s) return "Non-zero padding";
          }
          return a;
        }
        t.exports = {
          decodeUnsafe: function () {
            var t = a.apply(null, arguments);
            if ("object" == typeof t) return t;
          },
          decode: function (t) {
            var e = a.apply(null, arguments);
            if ("object" == typeof e) return e;
            throw new Error(e);
          },
          encode: function (t, r, n) {
            if (((n = n || 90), t.length + 7 + r.length > n))
              throw new TypeError("Exceeds length limit");
            var i = s((t = t.toLowerCase()));
            if ("string" == typeof i) throw new Error(i);
            for (var a = t + "1", u = 0; u < r.length; ++u) {
              var c = r[u];
              if (c >> 5) throw new Error("Non 5-bit word");
              (i = o(i) ^ c), (a += e.charAt(c));
            }
            for (u = 0; u < 6; ++u) i = o(i);
            for (i ^= 1, u = 0; u < 6; ++u) {
              a += e.charAt((i >> (5 * (5 - u))) & 31);
            }
            return a;
          },
          toWordsUnsafe: function (t) {
            var e = u(t, 8, 5, !0);
            if (Array.isArray(e)) return e;
          },
          toWords: function (t) {
            var e = u(t, 8, 5, !0);
            if (Array.isArray(e)) return e;
            throw new Error(e);
          },
          fromWordsUnsafe: function (t) {
            var e = u(t, 5, 8, !1);
            if (Array.isArray(e)) return e;
          },
          fromWords: function (t) {
            var e = u(t, 5, 8, !1);
            if (Array.isArray(e)) return e;
            throw new Error(e);
          },
        };
      },
      39404: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(47790).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 48 && r <= 57
              ? r - 48
              : r >= 65 && r <= 70
                ? r - 55
                : r >= 97 && r <= 102
                  ? r - 87
                  : void n(!1, "Invalid character in " + t);
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, i) {
            for (
              var o = 0, s = 0, a = Math.min(t.length, r), u = e;
              u < a;
              u++
            ) {
              var c = t.charCodeAt(u) - 48;
              (o *= i),
                (s = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c),
                n(c >= 0 && s < i, "Invalid character"),
                (o += s);
            }
            return o;
          }
          function f(t, e) {
            (t.words = e.words),
              (t.length = e.length),
              (t.negative = e.negative),
              (t.red = e.red);
          }
          if (
            ((o.isBN = function (t) {
              return (
                t instanceof o ||
                (null !== t &&
                  "object" == typeof t &&
                  t.constructor.wordSize === o.wordSize &&
                  Array.isArray(t.words))
              );
            }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this._strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this._strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this._strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype._move = function (t) {
              f(t, this);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype._strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          )
            try {
              o.prototype[Symbol.for("nodejs.util.inspect.custom")] = h;
            } catch (t) {
              o.prototype.inspect = h;
            }
          else o.prototype.inspect = h;
          function h() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var l = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            d = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            p = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (o = (a >>> (24 - i)) & 16777215),
                  (i += 2) >= 26 && ((i -= 26), s--),
                  (r =
                    0 !== o || s !== this.length - 1
                      ? l[6 - u.length] + u + r
                      : u + r);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = d[t],
                f = p[t];
              r = "";
              var h = this.clone();
              for (h.negative = 0; !h.isZero(); ) {
                var y = h.modrn(f).toString(t);
                r = (h = h.idivn(f)).isZero() ? y + r : l[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            s &&
              (o.prototype.toBuffer = function (t, e) {
                return this.toArrayLike(s, t, e);
              }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            });
          function y(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r._strip();
          }
          (o.prototype.toArrayLike = function (t, e, r) {
            this._strip();
            var i = this.byteLength(),
              o = r || Math.max(1, i);
            n(i <= o, "byte array longer than desired length"),
              n(o > 0, "Requested array length <= 0");
            var s = (function (t, e) {
              return t.allocUnsafe ? t.allocUnsafe(e) : new t(e);
            })(t, o);
            return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](s, i), s;
          }),
            (o.prototype._toArrayLikeLE = function (t, e) {
              for (var r = 0, n = 0, i = 0, o = 0; i < this.length; i++) {
                var s = (this.words[i] << o) | n;
                (t[r++] = 255 & s),
                  r < t.length && (t[r++] = (s >> 8) & 255),
                  r < t.length && (t[r++] = (s >> 16) & 255),
                  6 === o
                    ? (r < t.length && (t[r++] = (s >> 24) & 255),
                      (n = 0),
                      (o = 0))
                    : ((n = s >>> 24), (o += 2));
              }
              if (r < t.length) for (t[r++] = n; r < t.length; ) t[r++] = 0;
            }),
            (o.prototype._toArrayLikeBE = function (t, e) {
              for (
                var r = t.length - 1, n = 0, i = 0, o = 0;
                i < this.length;
                i++
              ) {
                var s = (this.words[i] << o) | n;
                (t[r--] = 255 & s),
                  r >= 0 && (t[r--] = (s >> 8) & 255),
                  r >= 0 && (t[r--] = (s >> 16) & 255),
                  6 === o
                    ? (r >= 0 && (t[r--] = (s >> 24) & 255), (n = 0), (o = 0))
                    : ((n = s >>> 24), (o += 2));
              }
              if (r >= 0) for (t[r--] = n; r >= 0; ) t[r--] = 0;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this._strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this._strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this._strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var g = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function m(t, e, r) {
            (r.negative = e.negative ^ t.negative),
              (r.length = t.length + e.length);
            for (var n = 0, i = 0, o = 0; o < r.length - 1; o++) {
              var s = i;
              i = 0;
              for (
                var a = 67108863 & n,
                  u = Math.min(o, e.length - 1),
                  c = Math.max(0, o - t.length + 1);
                c <= u;
                c++
              ) {
                var f = o - c,
                  h = (0 | t.words[f]) * (0 | e.words[c]),
                  l = 67108863 & h;
                (a = 67108863 & (l = (l + a) | 0)),
                  (i +=
                    (s =
                      ((s = (s + ((h / 67108864) | 0)) | 0) + (l >>> 26)) |
                      0) >>> 26),
                  (s &= 67108863);
              }
              (r.words[o] = a), (n = s), (s = i);
            }
            return 0 !== n ? (r.words[o] = n) : r.length--, r._strip();
          }
          function b(t, e, r) {
            return m(t, e, r);
          }
          function w(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (g = y),
            (o.prototype.mulTo = function (t, e) {
              var r = this.length + t.length;
              return 10 === this.length && 10 === t.length
                ? g(this, t, e)
                : r < 63
                  ? y(this, t, e)
                  : r < 1024
                    ? m(this, t, e)
                    : b(this, t, e);
            }),
            (w.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (w.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (w.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (w.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (w.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (w.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (w.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (w.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (w.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (w.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r._strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), b(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              var e = t < 0;
              e && (t = -t), n("number" == typeof t), n(t < 67108864);
              for (var r = 0, i = 0; i < this.length; i++) {
                var o = (0 | this.words[i]) * t,
                  s = (67108863 & o) + (67108863 & r);
                (r >>= 26),
                  (r += (o / 67108864) | 0),
                  (r += s >>> 26),
                  (this.words[i] = 67108863 & s);
              }
              return (
                0 !== r && ((this.words[i] = r), this.length++),
                e ? this.ineg() : this
              );
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] >>> i) & 1;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this._strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this._strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) <= t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this._strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this._strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this._strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a._strip(),
                n._strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modrn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modrn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modrn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (
                var r = (1 << 26) % t, i = 0, o = this.length - 1;
                o >= 0;
                o--
              )
                i = (r * i + (0 | this.words[o])) % t;
              return e ? -i : i;
            }),
            (o.prototype.modn = function (t) {
              return this.modrn(t);
            }),
            (o.prototype.idivn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (var r = 0, i = this.length - 1; i >= 0; i--) {
                var o = (0 | this.words[i]) + 67108864 * r;
                (this.words[i] = (o / t) | 0), (r = o % t);
              }
              return this._strip(), e ? this.ineg() : this;
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this._strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new A(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var v = { k256: null, p224: null, p192: null, p25519: null };
          function _(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function E() {
            _.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function S() {
            _.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function I() {
            _.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function M() {
            _.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function A(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function T(t) {
            A.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (_.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (_.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (_.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (_.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(E, _),
            (E.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (E.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(S, _),
            i(I, _),
            i(M, _),
            (M.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (v[t]) return v[t];
              var e;
              if ("k256" === t) e = new E();
              else if ("p224" === t) e = new S();
              else if ("p192" === t) e = new I();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new M();
              }
              return (v[t] = e), e;
            }),
            (A.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (A.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (A.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : (f(t, t.umod(this.m)._forceRed(this)), t);
            }),
            (A.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (A.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (A.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (A.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (A.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (A.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (A.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (A.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (A.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (A.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (A.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (A.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (A.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (A.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (A.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new T(t);
            }),
            i(T, A),
            (T.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (T.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (T.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (T.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (T.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      7041: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.bnsV2ReadOnlyCall = async function (t) {
            const e = (0, s.getNetwork)(t.network),
              r = (0, i.getBnsContractAddress)(t.network);
            return u(t, r, i.BnsContractName, e, !1);
          }),
          (e.zonefileReadOnlyCall = async function (t) {
            const e = (0, s.getNetwork)(t.network),
              r = (0, i.getZonefileContractAddress)(t.network);
            return u(t, r, i.ZonefileContractName, e, !0);
          });
        const n = r(86582),
          i = r(16335),
          o = r(46577),
          s = r(17291),
          a = r(67266);
        async function u(t, e, r, i, u = !1) {
          const c = i instanceof o.StacksMainnet ? "mainnet" : "testnet",
            f = (0, s.getFallbackUrl)(c);
          async function h(i) {
            "mainnet" === c
              ? new o.StacksMainnet({ url: i })
              : new o.StacksTestnet({ url: i });
            try {
              const i = await (0, n.fetchCallReadOnlyFunction)({
                contractAddress: e,
                contractName: r,
                functionName: t.functionName,
                functionArgs: t.functionArgs,
                senderAddress: t.senderAddress,
                network: c,
              });
              if (i.error) throw new Error(i.error);
              return i;
            } catch (t) {
              throw (
                (a.debug.error("Call failed:", {
                  error: t.message,
                  url: i,
                  networkType: c,
                }),
                t)
              );
            }
          }
          a.debug.log("executeReadOnlyCall initiated:", {
            networkType: c,
            contractAddress: e,
            contractName: r,
            functionName: t.functionName,
            coreApiUrl: i.coreApiUrl,
            fallbackUrl: f,
            isZonefile: u,
          });
          try {
            return await h(i.coreApiUrl);
          } catch (t) {
            if (f && f !== i.coreApiUrl) return await h(f);
            throw t;
          }
        }
      },
      16335: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ZonefileContractName =
            e.BnsContractAddress =
            e.BnsContractName =
              void 0),
          (e.getBnsContractAddress = function (t) {
            return "mainnet" === t ? r.Mainnet : r.Testnet;
          }),
          (e.getZonefileContractAddress = function (t) {
            return "mainnet" === t
              ? "SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF"
              : "ST2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D9SZJQ0M";
          }),
          (e.BnsContractName = "BNS-V2"),
          (function (t) {
            (t.Mainnet = "SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF"),
              (t.Testnet = "ST2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D9SZJQ0M");
          })(r || (e.BnsContractAddress = r = {})),
          (e.ZonefileContractName = "zonefile-resolver");
      },
      36622: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.buildTransferNameTx = async function ({
            fullyQualifiedName: t,
            newOwnerAddress: e,
            senderAddress: r,
            network: n,
          }) {
            const { subdomain: i, namespace: c, name: f } = (0, a.decodeFQN)(t);
            if (i)
              throw new Error(
                "Cannot transfer a subdomain using transferName()",
              );
            const h = await (0, u.getIdFromBns)({
                fullyQualifiedName: t,
                network: n,
              }),
              l = [
                (0, o.uintCV)(h),
                (0, o.standardPrincipalCV)(r),
                (0, o.standardPrincipalCV)(e),
              ],
              d = o.Pc.principal(r)
                .willSendAsset()
                .nft(
                  `${(0, s.getBnsContractAddress)(n)}.${s.BnsContractName}::BNS-V2`,
                  (0, o.uintCV)(h),
                ),
              p = o.Pc.principal(e)
                .willNotSendAsset()
                .nft(
                  `${(0, s.getBnsContractAddress)(n)}.${s.BnsContractName}::BNS-V2`,
                  (0, o.uintCV)(h),
                );
            return {
              contractAddress: (0, s.getBnsContractAddress)(n),
              contractName: s.BnsContractName,
              functionName: "transfer",
              functionArgs: l,
              postConditions: [d, p],
              network: n,
            };
          }),
          (e.buildListInUstxTx = async function ({
            id: t,
            price: e,
            commissionTraitAddress: r,
            commissionTraitName: n,
            senderAddress: i,
            network: a,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(a),
              contractName: s.BnsContractName,
              functionName: "list-in-ustx",
              functionArgs: [
                (0, o.uintCV)(t),
                (0, o.uintCV)(e),
                (0, o.contractPrincipalCV)(r, n),
              ],
              postConditions: [],
              network: a,
            };
          }),
          (e.buildUnlistInUstxTx = async function ({
            id: t,
            senderAddress: e,
            network: r,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "unlist-in-ustx",
              functionArgs: [(0, o.uintCV)(t)],
              postConditions: [],
              network: r,
            };
          }),
          (e.buildBuyInUstxTx = async function ({
            id: t,
            expectedPrice: e,
            commissionTraitAddress: r,
            commissionTraitName: n,
            senderAddress: i,
            network: a,
          }) {
            const c = await (0, u.getOwnerById)({ id: t, network: a });
            if (!c)
              throw new Error("Failed to fetch current owner of the name");
            const f = o.Pc.principal(i).willSendLte(e).ustx(),
              h = o.Pc.principal(c)
                .willSendAsset()
                .nft(
                  `${(0, s.getBnsContractAddress)(a)}.${s.BnsContractName}::BNS-V2`,
                  (0, o.uintCV)(t),
                ),
              l = [f, h];
            return {
              contractAddress: (0, s.getBnsContractAddress)(a),
              contractName: s.BnsContractName,
              functionName: "buy-in-ustx",
              functionArgs: [
                (0, o.uintCV)(t),
                (0, o.contractPrincipalCV)(r, n),
              ],
              postConditions: l,
              network: a,
            };
          }),
          (e.buildSetPrimaryNameTx = async function ({
            fullyQualifiedName: t,
            senderAddress: e,
            network: r,
          }) {
            const { subdomain: n } = (0, a.decodeFQN)(t);
            if (n) throw new Error("Cannot set a subdomain as primary name");
            const i = await (0, u.getIdFromBns)({
                fullyQualifiedName: t,
                network: r,
              }),
              c = await (0, u.getOwner)({ fullyQualifiedName: t, network: r });
            if (!c)
              throw new Error("Failed to fetch current owner of the name");
            const f = [
              o.Pc.principal(c)
                .willNotSendAsset()
                .nft(
                  `${(0, s.getBnsContractAddress)(r)}.${s.BnsContractName}::BNS-V2`,
                  (0, o.uintCV)(i),
                ),
            ];
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "set-primary-name",
              functionArgs: [(0, o.uintCV)(i)],
              postConditions: f,
              network: r,
            };
          }),
          (e.buildFreezeManagerTx = async function ({
            namespace: t,
            senderAddress: e,
            network: r,
          }) {
            const n = await (0, u.getNamespaceProperties)({
              namespace: t,
              network: r,
            });
            if (!n) throw new Error("Failed to fetch namespace properties");
            if (!n.properties["namespace-manager"])
              throw new Error("This namespace does not have a manager");
            if (n.properties["manager-frozen"])
              throw new Error("Manager is already frozen for this namespace");
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "freeze-manager",
              functionArgs: [(0, o.bufferCVFromString)(t)],
              postConditions: [],
              network: r,
            };
          }),
          (e.buildPreorderNamespaceTx = async function ({
            namespace: t,
            salt: e,
            stxToBurn: r,
            senderAddress: n,
            network: a,
          }) {
            const u = (0, i.utf8ToBytes)(`${t}.${e}`),
              c = (0, o.hash160)(u),
              f = o.Pc.principal(n).willSendEq(r).ustx();
            return {
              contractAddress: (0, s.getBnsContractAddress)(a),
              contractName: s.BnsContractName,
              functionName: "namespace-preorder",
              functionArgs: [(0, o.bufferCV)(c), (0, o.uintCV)(r)],
              postConditions: [f],
              network: a,
            };
          }),
          (e.buildRevealNamespaceTx = async function ({
            namespace: t,
            salt: e,
            priceFunction: r,
            lifetime: n = 0n,
            namespaceImportAddress: i,
            namespaceManagerAddress: a,
            canUpdatePrice: u,
            managerTransfer: f = !1,
            managerFrozen: h = !0,
            senderAddress: l,
            network: d,
          }) {
            let p;
            if (a)
              if (a.includes(".")) {
                const [t, e] = a.split(".");
                p = (0, o.someCV)((0, o.contractPrincipalCV)(t, e));
              } else p = (0, o.someCV)((0, o.standardPrincipalCV)(a));
            else p = (0, o.noneCV)();
            const y = r || c;
            return {
              contractAddress: (0, s.getBnsContractAddress)(d),
              contractName: s.BnsContractName,
              functionName: "namespace-reveal",
              functionArgs: [
                (0, o.bufferCVFromString)(t),
                (0, o.bufferCVFromString)(e),
                (0, o.uintCV)(y.base),
                (0, o.uintCV)(y.coefficient),
                (0, o.uintCV)(y.b1),
                (0, o.uintCV)(y.b2),
                (0, o.uintCV)(y.b3),
                (0, o.uintCV)(y.b4),
                (0, o.uintCV)(y.b5),
                (0, o.uintCV)(y.b6),
                (0, o.uintCV)(y.b7),
                (0, o.uintCV)(y.b8),
                (0, o.uintCV)(y.b9),
                (0, o.uintCV)(y.b10),
                (0, o.uintCV)(y.b11),
                (0, o.uintCV)(y.b12),
                (0, o.uintCV)(y.b13),
                (0, o.uintCV)(y.b14),
                (0, o.uintCV)(y.b15),
                (0, o.uintCV)(y.b16),
                (0, o.uintCV)(y.nonAlphaDiscount),
                (0, o.uintCV)(y.noVowelDiscount),
                (0, o.uintCV)(n),
                (0, o.standardPrincipalCV)(i),
                p,
                (0, o.boolCV)(u),
                (0, o.boolCV)(f),
                (0, o.boolCV)(h),
              ],
              postConditions: [],
              network: d,
            };
          }),
          (e.buildLaunchNamespaceTx = async function ({
            namespace: t,
            senderAddress: e,
            network: r,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "namespace-launch",
              functionArgs: [(0, o.bufferCVFromString)(t)],
              postConditions: [],
              network: r,
            };
          }),
          (e.buildTurnOffManagerTransfersTx = async function ({
            namespace: t,
            senderAddress: e,
            network: r,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "turn-off-manager-transfers",
              functionArgs: [(0, o.bufferCVFromString)(t)],
              postConditions: [],
              network: r,
            };
          }),
          (e.buildImportNameTx = async function ({
            namespace: t,
            name: e,
            beneficiary: r,
            senderAddress: n,
            network: i,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(i),
              contractName: s.BnsContractName,
              functionName: "name-import",
              functionArgs: [
                (0, o.bufferCVFromString)(t),
                (0, o.bufferCVFromString)(e),
                (0, o.standardPrincipalCV)(r),
              ],
              postConditions: [],
              network: i,
            };
          }),
          (e.buildNamespaceUpdatePriceTx = async function ({
            namespace: t,
            priceFunction: e,
            senderAddress: r,
            network: n,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(n),
              contractName: s.BnsContractName,
              functionName: "namespace-update-price",
              functionArgs: [
                (0, o.bufferCVFromString)(t),
                (0, o.uintCV)(e.base),
                (0, o.uintCV)(e.coefficient),
                (0, o.uintCV)(e.b1),
                (0, o.uintCV)(e.b2),
                (0, o.uintCV)(e.b3),
                (0, o.uintCV)(e.b4),
                (0, o.uintCV)(e.b5),
                (0, o.uintCV)(e.b6),
                (0, o.uintCV)(e.b7),
                (0, o.uintCV)(e.b8),
                (0, o.uintCV)(e.b9),
                (0, o.uintCV)(e.b10),
                (0, o.uintCV)(e.b11),
                (0, o.uintCV)(e.b12),
                (0, o.uintCV)(e.b13),
                (0, o.uintCV)(e.b14),
                (0, o.uintCV)(e.b15),
                (0, o.uintCV)(e.b16),
                (0, o.uintCV)(e.nonAlphaDiscount),
                (0, o.uintCV)(e.noVowelDiscount),
              ],
              postConditions: [],
              network: n,
            };
          }),
          (e.buildNamespaceFreezePriceTx = async function ({
            namespace: t,
            senderAddress: e,
            network: r,
          }) {
            return {
              contractAddress: (0, s.getBnsContractAddress)(r),
              contractName: s.BnsContractName,
              functionName: "namespace-freeze-price",
              functionArgs: [(0, o.bufferCVFromString)(t)],
              postConditions: [],
              network: r,
            };
          }),
          (e.buildNameClaimFastTx = async function ({
            fullyQualifiedName: t,
            stxToBurn: e,
            sendTo: r,
            senderAddress: i,
            network: u,
          }) {
            const { namespace: c, name: f, subdomain: h } = (0, a.decodeFQN)(t);
            if (h)
              throw new Error(
                "Cannot register a subdomain using registerName()",
              );
            const l = r.includes(".")
              ? (0, o.contractPrincipalCV)(r.split(".")[0], r.split(".")[1])
              : (0, o.standardPrincipalCV)(r);
            let d = [];
            if (e > 0) {
              const t = o.Pc.principal(i).willSendEq(e).ustx();
              d.push(t);
            }
            return {
              contractAddress: (0, s.getBnsContractAddress)(u),
              contractName: s.BnsContractName,
              functionName: "name-claim-fast",
              functionArgs: [
                (0, o.bufferCV)(n.from(f)),
                (0, o.bufferCV)(n.from(c)),
                l,
              ],
              postConditions: d,
              network: u,
            };
          }),
          (e.buildPreorderNameTx = async function ({
            fullyQualifiedName: t,
            salt: e,
            stxToBurn: r,
            senderAddress: i,
            network: u,
          }) {
            const { subdomain: c } = (0, a.decodeFQN)(t);
            if (c)
              throw new Error(
                "Cannot preorder a subdomain using preorderName()",
              );
            const f = n.from(`${t}${e}`),
              h = (0, o.hash160)(f);
            let l = [];
            if (r > 0) {
              const t = o.Pc.principal(i).willSendEq(r).ustx();
              l.push(t);
            }
            return {
              contractAddress: (0, s.getBnsContractAddress)(u),
              contractName: s.BnsContractName,
              functionName: "name-preorder",
              functionArgs: [(0, o.bufferCV)(h), (0, o.uintCV)(r)],
              postConditions: l,
              network: u,
            };
          }),
          (e.buildRegisterNameTx = async function ({
            fullyQualifiedName: t,
            salt: e,
            stxToBurn: r,
            senderAddress: i,
            network: u,
          }) {
            const { subdomain: c, namespace: f, name: h } = (0, a.decodeFQN)(t);
            if (c)
              throw new Error(
                "Cannot register a subdomain using registerName()",
              );
            let l = [];
            if (r > 0) {
              const t = o.Pc.principal(
                `${(0, s.getBnsContractAddress)(u)}.${s.BnsContractName}`,
              )
                .willSendEq(r)
                .ustx();
              l.push(t);
            }
            return {
              contractAddress: (0, s.getBnsContractAddress)(u),
              contractName: s.BnsContractName,
              functionName: "name-register",
              functionArgs: [
                (0, o.bufferCV)(n.from(f)),
                (0, o.bufferCV)(n.from(h)),
                (0, o.bufferCV)(n.from(e)),
              ],
              postConditions: l,
              network: u,
            };
          }),
          (e.buildPreviousRegisterNameTx = async function ({
            fullyQualifiedName: t,
            salt: e,
            stxToBurn: r,
            senderAddress: i,
            network: c,
          }) {
            const { subdomain: f, namespace: h, name: l } = (0, a.decodeFQN)(t);
            if (f)
              throw new Error(
                "Cannot register a subdomain using registerName()",
              );
            const d = await (0, u.getIdFromBns)({
                fullyQualifiedName: t,
                network: c,
              }),
              p = await (0, u.getOwner)({ fullyQualifiedName: t, network: c });
            if (!p)
              throw new Error("Failed to fetch current owner of the name");
            let y = [];
            if (r > 0) {
              const t = o.Pc.principal(
                `${(0, s.getBnsContractAddress)(c)}.${s.BnsContractName}`,
              )
                .willSendEq(r)
                .ustx();
              y.push(t);
            }
            const g = o.Pc.principal(p)
              .willSendAsset()
              .nft(
                `${(0, s.getBnsContractAddress)(c)}.${s.BnsContractName}::BNS-V2`,
                (0, o.uintCV)(d),
              );
            return (
              y.push(g),
              {
                contractAddress: (0, s.getBnsContractAddress)(c),
                contractName: s.BnsContractName,
                functionName: "name-register",
                functionArgs: [
                  (0, o.bufferCV)(n.from(h)),
                  (0, o.bufferCV)(n.from(l)),
                  (0, o.bufferCV)(n.from(e)),
                ],
                postConditions: y,
                network: c,
              }
            );
          }),
          (e.buildClaimPreorderTx = async function ({
            fullyQualifiedName: t,
            salt: e,
            stxToClaim: r,
            senderAddress: n,
            network: u,
          }) {
            const { subdomain: c } = (0, a.decodeFQN)(t);
            if (c)
              throw new Error(
                "Cannot claim a subdomain using claim-preorder()",
              );
            const f = (0, i.utf8ToBytes)(`${t}${e}`),
              h = (0, o.hash160)(f),
              l = o.Pc.principal(
                `${(0, s.getBnsContractAddress)(u)}.${s.BnsContractName}`,
              )
                .willSendEq(r)
                .ustx();
            return {
              contractAddress: (0, s.getBnsContractAddress)(u),
              contractName: s.BnsContractName,
              functionName: "claim-preorder",
              functionArgs: [(0, o.bufferCV)(h)],
              postConditions: [l],
              network: u,
            };
          }),
          (e.buildRenewNameTx = async function ({
            fullyQualifiedName: t,
            stxToBurn: e,
            senderAddress: r,
            network: n,
          }) {
            const { subdomain: i, namespace: u, name: c } = (0, a.decodeFQN)(t);
            if (i)
              throw new Error("Cannot renew a subdomain using renewName()");
            const f = o.Pc.principal(r).willSendEq(e).ustx();
            return {
              contractAddress: (0, s.getBnsContractAddress)(n),
              contractName: s.BnsContractName,
              functionName: "name-renewal",
              functionArgs: [
                (0, o.bufferCVFromString)(u),
                (0, o.bufferCVFromString)(c),
              ],
              postConditions: [f],
              network: n,
            };
          }),
          (e.buildUpdateZonefileTx = async function ({
            fullyQualifiedName: t,
            zonefileInputs: e,
            senderAddress: r,
            network: n,
          }) {
            const { name: i, namespace: u } = (0, a.decodeFQN)(t);
            let c;
            if (e) {
              const t = (0, a.createZonefileData)(e),
                r = (0, a.stringifyZonefile)(t);
              c = (0, o.someCV)((0, o.bufferCVFromString)(r));
            } else c = (0, o.noneCV)();
            return {
              contractAddress: (0, s.getZonefileContractAddress)(n),
              contractName: s.ZonefileContractName,
              functionName: "update-zonefile",
              functionArgs: [
                (0, o.bufferCVFromString)(i),
                (0, o.bufferCVFromString)(u),
                c,
              ],
              postConditions: [],
              network: n,
            };
          });
        const i = r(48329),
          o = r(86582),
          s = r(16335),
          a = r(80136),
          u = r(82250);
        const c = {
          base: 1n,
          coefficient: 1n,
          b1: 1n,
          b2: 1n,
          b3: 1n,
          b4: 1n,
          b5: 1n,
          b6: 1n,
          b7: 1n,
          b8: 1n,
          b9: 1n,
          b10: 1n,
          b11: 1n,
          b12: 1n,
          b13: 1n,
          b14: 1n,
          b15: 1n,
          b16: 1n,
          nonAlphaDiscount: 1n,
          noVowelDiscount: 1n,
        };
      },
      67266: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.debug = void 0);
        let r = !1;
        e.debug = {
          enable: () => {
            r = !0;
          },
          disable: () => {
            r = !1;
          },
          log: (...t) => {
            r && console.log("[BNS-V2-SDK]:", ...t);
          },
          error: (...t) => {
            r && console.error("[BNS-V2-SDK]:", ...t);
          },
        };
      },
      55549: (t, e, r) => {
        "use strict";
        var n = r(82250);
        var i = r(36622);
        var o = r(67266);
      },
      17291: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.configureNetwork = function (t) {
            (o = t.testnetFallbackUrl),
              i.debug.log(
                "Network configuration updated - testnet fallback URL:",
                o,
              );
          }),
          (e.getNetwork = function (t) {
            if (
              (i.debug.log("Getting network for type:", t), "mainnet" === t)
            ) {
              const t = new n.StacksMainnet();
              return (
                i.debug.log("Created mainnet network:", {
                  apiUrl: t.coreApiUrl,
                }),
                t
              );
            }
            {
              const t = new n.StacksTestnet();
              return (
                i.debug.log("Created testnet network:", {
                  apiUrl: t.coreApiUrl,
                }),
                t
              );
            }
          }),
          (e.getFallbackUrl = function (t) {
            if (
              (i.debug.log("Getting fallback URL for network type:", t),
              "testnet" === t && o)
            )
              return i.debug.log("Using testnet fallback URL:", o), o;
            return i.debug.log("No fallback URL available"), "";
          });
        const n = r(46577),
          i = r(67266);
        let o;
      },
      82250: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.getLastTokenId = async function ({ network: t }) {
            try {
              return (await h("/token/last-id", t)).last_token_id;
            } catch (e) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                e,
              );
              const r = (0, a.generateRandomAddress)(),
                n = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-last-token-id",
                  senderAddress: r,
                  functionArgs: [],
                  network: t,
                });
              if (n.type === o.ClarityType.ResponseOk) {
                if (n.value.type === o.ClarityType.UInt) return n.value.value;
                throw new Error("Response did not contain a UInt");
              }
              if (n.type === o.ClarityType.ResponseErr)
                throw new Error((0, o.cvToString)(n.value));
              throw new Error(
                `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(n)}`,
              );
            }
          }),
          (e.getRenewalHeight = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            try {
              const r = await h(`/names/${t}/renewal`, e);
              return BigInt(r.renewal_height);
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const { subdomain: n } = (0, a.decodeFQN)(t);
              if (n)
                throw new Error("Cannot get renewal height for a subdomain");
              const i = (0, a.generateRandomAddress)(),
                s = await l({ fullyQualifiedName: t, network: e }),
                u = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-renewal-height",
                  senderAddress: i,
                  functionArgs: [(0, o.uintCV)(s)],
                  network: e,
                });
              if (u.type === o.ClarityType.ResponseOk) {
                if (u.value.type === o.ClarityType.UInt) return u.value.value;
                throw new Error("Response did not contain a UInt");
              }
              if (u.type === o.ClarityType.ResponseErr)
                throw new Error((0, o.cvToString)(u.value));
              throw new Error(
                `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(u)}`,
              );
            }
          }),
          (e.canResolveName = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            try {
              const r = await h(`/names/${t}/can-resolve`, e);
              return { renewal: BigInt(r.renewal_height), owner: r.owner };
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const {
                subdomain: n,
                namespace: i,
                name: s,
              } = (0, a.decodeFQN)(t);
              if (n) throw new Error("Cannot check resolution for a subdomain");
              const u = (0, a.generateRandomAddress)(),
                h = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "can-resolve-name",
                  senderAddress: u,
                  functionArgs: [
                    (0, o.bufferCVFromString)(i),
                    (0, o.bufferCVFromString)(s),
                  ],
                  network: e,
                });
              if (
                h.type === o.ClarityType.ResponseOk &&
                h.value.type === o.ClarityType.Tuple
              ) {
                const t = h.value.value.renewal,
                  e = h.value.value.owner;
                if (
                  t.type === o.ClarityType.UInt &&
                  (e.type === o.ClarityType.PrincipalStandard ||
                    e.type === o.ClarityType.PrincipalContract)
                )
                  return { renewal: t.value, owner: (0, o.cvToString)(e) };
                throw new Error("Unexpected data types in response tuple");
              }
              throw new Error("Invalid response from contract");
            }
          }),
          (e.getOwner = async function ({ fullyQualifiedName: t, network: e }) {
            try {
              return (await h(`/names/${t}/owner`, e)).owner;
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const {
                subdomain: n,
                namespace: i,
                name: s,
              } = (0, a.decodeFQN)(t);
              if (n) throw new Error("Cannot check resolution for a subdomain");
              const u = (0, a.generateRandomAddress)(),
                h = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-owner-name",
                  senderAddress: u,
                  functionArgs: [
                    (0, o.bufferCVFromString)(s),
                    (0, o.bufferCVFromString)(i),
                  ],
                  network: e,
                });
              if (h.type === o.ClarityType.ResponseOk) {
                if (h.value.type === o.ClarityType.OptionalSome) {
                  if (
                    h.value.value.type === o.ClarityType.PrincipalStandard ||
                    h.value.value.type === o.ClarityType.PrincipalContract
                  )
                    return (0, o.cvToString)(h.value.value);
                  throw new Error("Owner is not a principal");
                }
                if (h.value.type === o.ClarityType.OptionalNone) return null;
              }
              throw new Error("Invalid response from contract");
            }
          }),
          (e.getOwnerById = async function ({ id: t, network: e }) {
            try {
              return (await h(`/tokens/${t}/owner`, e)).owner;
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const n = (0, a.generateRandomAddress)(),
                i = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-owner",
                  senderAddress: n,
                  functionArgs: [(0, o.uintCV)(t)],
                  network: e,
                });
              if (i.type === o.ClarityType.ResponseOk) {
                if (i.value.type === o.ClarityType.OptionalSome) {
                  if (
                    i.value.value.type === o.ClarityType.PrincipalStandard ||
                    i.value.value.type === o.ClarityType.PrincipalContract
                  )
                    return (0, o.cvToString)(i.value.value);
                  throw new Error("Owner is not a principal");
                }
                if (i.value.type === o.ClarityType.OptionalNone) return null;
              }
              throw new Error("Invalid response from contract");
            }
          }),
          (e.getIdFromBns = l),
          (e.getBnsFromId = d),
          (e.canRegisterName = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            const { subdomain: r, namespace: n, name: i } = (0, a.decodeFQN)(t);
            if (r)
              throw new Error("Cannot register a subdomain using registerName");
            try {
              return (await h(`/names/${n}/${i}/can-register`, e)).can_register;
            } catch (t) {
              return (
                f.debug.error(
                  "API call failed, falling back to contract call:",
                  t,
                ),
                (async function (t, e, r) {
                  const n = (0, a.generateRandomAddress)();
                  return (
                    f.debug.log("Falling back to contract call:", {
                      name: t,
                      namespace: e,
                      network: r,
                    }),
                    (0, c.bnsV2ReadOnlyCall)({
                      functionName: "get-bns-info",
                      senderAddress: n,
                      functionArgs: [
                        (0, o.bufferCVFromString)(t),
                        (0, o.bufferCVFromString)(e),
                      ],
                      network: r,
                    }).then((t) => {
                      if (t.type === o.ClarityType.OptionalSome)
                        return f.debug.log("Name exists in contract"), !1;
                      if (t.type === o.ClarityType.OptionalNone)
                        return f.debug.log("Name available in contract"), !0;
                      throw new Error(`Unexpected response type: ${t.type}`);
                    })
                  );
                })(i, n, e)
              );
            }
          }),
          (e.getNamespacePrice = async function ({ namespace: t, network: e }) {
            const r = (0, a.generateRandomAddress)();
            return (0, c.bnsV2ReadOnlyCall)({
              functionName: "get-namespace-price",
              senderAddress: r,
              functionArgs: [(0, o.bufferCVFromString)(t)],
              network: e,
            }).then((t) => {
              if (t.type === o.ClarityType.ResponseOk) {
                if (
                  t.value.type === o.ClarityType.Int ||
                  t.value.type === o.ClarityType.UInt
                )
                  return t.value.value;
                throw new Error("Response did not contain a number");
              }
              throw t.type === o.ClarityType.ResponseErr
                ? new Error((0, o.cvToString)(t.value))
                : new Error(
                    `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(t)}`,
                  );
            });
          }),
          (e.getNamePrice = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            const { subdomain: r, namespace: n, name: i } = (0, a.decodeFQN)(t);
            if (r) throw new Error("Cannot get subdomain price");
            const s = (0, a.generateRandomAddress)();
            return (0, c.bnsV2ReadOnlyCall)({
              functionName: "get-name-price",
              senderAddress: s,
              functionArgs: [
                (0, o.bufferCVFromString)(n),
                (0, o.bufferCVFromString)(i),
              ],
              network: e,
            })
              .then((t) => {
                if (t.type === o.ClarityType.ResponseOk) {
                  const e = t.value;
                  if (e.type === o.ClarityType.ResponseOk) {
                    const t = e.value;
                    if (
                      t.type === o.ClarityType.Int ||
                      t.type === o.ClarityType.UInt
                    )
                      return t.value;
                    throw new Error("Nested response did not contain a number");
                  }
                  if (
                    e.type === o.ClarityType.Int ||
                    e.type === o.ClarityType.UInt
                  )
                    return e.value;
                  throw new Error("Response did not contain a number");
                }
                {
                  const e = t;
                  throw new Error((0, o.cvToString)(e.value));
                }
              })
              .catch((t) => {
                throw t;
              });
          }),
          (e.canNamespaceBeRegistered = async function ({
            namespace: t,
            network: e,
          }) {
            const r = (0, a.generateRandomAddress)();
            return (0, c.bnsV2ReadOnlyCall)({
              functionName: "can-namespace-be-registered",
              senderAddress: r,
              functionArgs: [(0, o.bufferCVFromString)(t)],
              network: e,
            }).then((t) => {
              if (t.type === o.ClarityType.ResponseOk) {
                if (t.value.type === o.ClarityType.BoolTrue) return !0;
                if (t.value.type === o.ClarityType.BoolFalse) return !1;
                throw new Error("Response did not contain a boolean");
              }
              throw t.type === o.ClarityType.ResponseErr
                ? new Error((0, o.cvToString)(t.value))
                : new Error(
                    `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(t)}`,
                  );
            });
          }),
          (e.getNamespaceProperties = async function ({
            namespace: t,
            network: e,
          }) {
            try {
              const r = (await h(`/namespaces/${t}`, e)).namespace;
              return {
                namespace: t,
                properties: {
                  "namespace-manager": r.namespace_manager || null,
                  "manager-transferable": r.manager_transferable,
                  "manager-frozen": r.manager_frozen || !1,
                  "namespace-import": r.namespace_import,
                  "revealed-at": BigInt(r.revealed_at || 0),
                  "launched-at": r.launched_at ? BigInt(r.launched_at) : null,
                  lifetime: BigInt(r.lifetime || 0),
                  "can-update-price-function": r.can_update_price_function,
                  "price-function": {
                    base: BigInt(r.price_function_base),
                    coefficient: BigInt(r.price_function_coeff),
                    b1: BigInt(r.price_function_buckets[0] || 0),
                    b2: BigInt(r.price_function_buckets[1] || 0),
                    b3: BigInt(r.price_function_buckets[2] || 0),
                    b4: BigInt(r.price_function_buckets[3] || 0),
                    b5: BigInt(r.price_function_buckets[4] || 0),
                    b6: BigInt(r.price_function_buckets[5] || 0),
                    b7: BigInt(r.price_function_buckets[6] || 0),
                    b8: BigInt(r.price_function_buckets[7] || 0),
                    b9: BigInt(r.price_function_buckets[8] || 0),
                    b10: BigInt(r.price_function_buckets[9] || 0),
                    b11: BigInt(r.price_function_buckets[10] || 0),
                    b12: BigInt(r.price_function_buckets[11] || 0),
                    b13: BigInt(r.price_function_buckets[12] || 0),
                    b14: BigInt(r.price_function_buckets[13] || 0),
                    b15: BigInt(r.price_function_buckets[14] || 0),
                    b16: BigInt(r.price_function_buckets[15] || 0),
                    nonAlphaDiscount: BigInt(
                      r.price_function_nonalpha_discount,
                    ),
                    noVowelDiscount: BigInt(r.price_function_no_vowel_discount),
                  },
                },
              };
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const n = (0, a.generateRandomAddress)(),
                i = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-namespace-properties",
                  senderAddress: n,
                  functionArgs: [(0, o.bufferCVFromString)(t)],
                  network: e,
                });
              if (
                i.type === o.ClarityType.ResponseOk &&
                i.value.type === o.ClarityType.Tuple
              ) {
                const t = i.value.value.namespace,
                  e = i.value.value.properties.value;
                return {
                  namespace: t.value.toString(),
                  properties: {
                    "namespace-manager":
                      e["namespace-manager"].type === o.ClarityType.OptionalNone
                        ? null
                        : (0, o.cvToString)(e["namespace-manager"].value),
                    "manager-transferable":
                      e["manager-transferable"].type === o.ClarityType.BoolTrue,
                    "manager-frozen":
                      e["manager-frozen"].type === o.ClarityType.BoolTrue,
                    "namespace-import": (0, o.cvToString)(
                      e["namespace-import"],
                    ),
                    "revealed-at": e["revealed-at"].value,
                    "launched-at":
                      e["launched-at"].type === o.ClarityType.OptionalNone
                        ? null
                        : e["launched-at"].value.value,
                    lifetime: e.lifetime.value,
                    "can-update-price-function":
                      e["can-update-price-function"].type ===
                      o.ClarityType.BoolTrue,
                    "price-function": (0, a.parsePriceFunction)(
                      e["price-function"].value,
                    ),
                  },
                };
              }
              throw new Error("Invalid response from contract");
            }
          }),
          (e.getNameInfo = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            try {
              const r = (await h(`/names/${t}`, e)).data;
              return {
                owner: r.owner,
                registeredAt: r.registered_at ? BigInt(r.registered_at) : null,
                renewalHeight: BigInt(r.renewal_height || 0),
                stxBurn: BigInt(r.stx_burn || 0),
                importedAt: r.imported_at ? BigInt(r.imported_at) : null,
                preorderedBy: r.preordered_by,
                hashedSaltedFqnPreorder: r.hashedSaltedFqnPreorder,
              };
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const {
                subdomain: n,
                namespace: i,
                name: s,
              } = (0, a.decodeFQN)(t);
              if (n) throw new Error("Cannot get info for a subdomain");
              const u = (0, a.generateRandomAddress)(),
                h = await (0, c.bnsV2ReadOnlyCall)({
                  functionName: "get-bns-info",
                  senderAddress: u,
                  functionArgs: [
                    (0, o.bufferCVFromString)(s),
                    (0, o.bufferCVFromString)(i),
                  ],
                  network: e,
                });
              if (
                h.type === o.ClarityType.OptionalSome &&
                h.value.type === o.ClarityType.Tuple
              ) {
                const t = h.value.value;
                return {
                  owner: (0, o.cvToString)(t.owner),
                  registeredAt:
                    t["registered-at"].type === o.ClarityType.OptionalNone
                      ? null
                      : t["registered-at"].value.value,
                  renewalHeight: t["renewal-height"].value,
                  stxBurn: t["stx-burn"].value,
                  importedAt:
                    t["imported-at"].type === o.ClarityType.OptionalNone
                      ? null
                      : t["imported-at"].value.value,
                  preorderedBy:
                    t["preordered-by"].type === o.ClarityType.OptionalNone
                      ? null
                      : (0, o.cvToString)(t["preordered-by"].value),
                  hashedSaltedFqnPreorder:
                    t["hashed-salted-fqn-preorder"].type ===
                    o.ClarityType.OptionalNone
                      ? null
                      : t["hashed-salted-fqn-preorder"].value.toString(),
                };
              }
              throw new Error("Invalid response from contract");
            }
          }),
          (e.getPrimaryName = async function ({ address: t, network: e }) {
            const r = (0, a.generateRandomAddress)();
            return (0, c.bnsV2ReadOnlyCall)({
              functionName: "get-primary",
              senderAddress: r,
              functionArgs: [(0, o.standardPrincipalCV)(t)],
              network: e,
            }).then((t) => {
              if (t.type === o.ClarityType.ResponseOk) {
                if (t.value.type === o.ClarityType.Tuple) {
                  const e = t.value.value.name,
                    r = t.value.value.namespace;
                  return {
                    name: n.from(e.value, "hex").toString(),
                    namespace: n.from(r.value, "hex").toString(),
                  };
                }
                if (t.value.type === o.ClarityType.OptionalSome) {
                  const e = t.value.value;
                  if (e.type === o.ClarityType.Tuple) {
                    const t = e.value.name,
                      r = e.value.namespace;
                    return {
                      name: n.from(t.value, "hex").toString(),
                      namespace: n.from(r.value, "hex").toString(),
                    };
                  }
                }
                throw new Error("Unexpected response structure");
              }
              if (t.type === o.ClarityType.ResponseErr) {
                if ("u131" === (0, o.cvToString)(t.value)) return null;
                throw new Error((0, o.cvToString)(t.value));
              }
              throw new Error(
                `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(t)}`,
              );
            });
          }),
          (e.fetchUserOwnedNames = async function ({
            senderAddress: t,
            network: e,
          }) {
            try {
              let r = [],
                n = 0;
              const i = 50;
              for (;;) {
                const o = await h(
                  `/names/address/${t}/valid?limit=${i}&offset=${n}`,
                  e,
                );
                if (
                  ((r = r.concat(o.names)),
                  o.names.length < i || r.length >= o.total)
                )
                  break;
                n += i;
              }
              return r.map((t) => ({
                name: t.name_string,
                namespace: t.namespace_string,
              }));
            } catch (r) {
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const n = `${(0, u.getBnsContractAddress)(e)}.${u.BnsContractName}::BNS-V2`,
                i =
                  "mainnet" === e
                    ? "https://api.hiro.so"
                    : "https://api.testnet.hiro.so";
              let o = [],
                c = 0;
              const h = 50;
              for (;;) {
                const e = await s.default.get(
                    `${i}/extended/v1/tokens/nft/holdings?principal=${t}&asset_identifiers=${n}&limit=${h}&offset=${c}`,
                  ),
                  r = e.data.results.map((t) =>
                    parseInt(t.value.repr.slice(1)),
                  );
                if (((o = o.concat(r)), e.data.total <= c + h)) break;
                c += h;
              }
              const l = o.map((t) => d({ id: BigInt(t), network: e }));
              return (await Promise.all(l))
                .filter((t) => null !== t)
                .map((t) => ({
                  name: (0, a.asciiToUtf8)(t.name),
                  namespace: (0, a.asciiToUtf8)(t.namespace),
                }))
                .sort((t, e) =>
                  t.namespace !== e.namespace
                    ? t.namespace.localeCompare(e.namespace)
                    : t.name.localeCompare(e.name),
                );
            }
          }),
          (e.resolveNameZonefile = async function ({
            fullyQualifiedName: t,
            network: e,
          }) {
            try {
              return (await h(`/resolve-name/${t}`, e)).zonefile || null;
            } catch (r) {
              if (s.default.isAxiosError(r) && 404 === r.response?.status)
                return null;
              f.debug.error(
                "API call failed, falling back to contract call:",
                r,
              );
              const {
                subdomain: i,
                namespace: u,
                name: h,
              } = (0, a.decodeFQN)(t);
              if (i) throw new Error("Cannot resolve a subdomain");
              const l = (0, a.generateRandomAddress)(),
                d = await (0, c.zonefileReadOnlyCall)({
                  functionName: "resolve-name",
                  senderAddress: l,
                  functionArgs: [
                    (0, o.bufferCVFromString)(h),
                    (0, o.bufferCVFromString)(u),
                  ],
                  network: e,
                });
              if (d.type === o.ClarityType.ResponseOk) {
                if (
                  d.value.type === o.ClarityType.OptionalSome &&
                  d.value.value.type === o.ClarityType.Buffer
                ) {
                  const t = n.from(d.value.value.value).toString("utf8");
                  return (0, a.parseZonefile)(t);
                }
                if (d.value.type === o.ClarityType.OptionalNone) return null;
              }
              throw new Error("Invalid response from contract");
            }
          });
        const o = r(86582),
          s = i(r(86425)),
          a = r(80136),
          u = r(16335),
          c = r(7041),
          f = r(67266),
          h = async (t, e) => {
            try {
              const r = `https://api.bnsv2.com${"testnet" === e ? "/testnet" : ""}${t}`;
              f.debug.log("Making API call to:", r);
              return (await s.default.get(r)).data;
            } catch (t) {
              throw (f.debug.error("API call failed:", t), t);
            }
          };
        async function l({ fullyQualifiedName: t, network: e }) {
          try {
            const r = await h(`/names/${t}/id`, e);
            return BigInt(r.id);
          } catch (r) {
            f.debug.error("API call failed, falling back to contract call:", r);
            const { subdomain: n, namespace: i, name: s } = (0, a.decodeFQN)(t);
            if (n) throw new Error("Cannot get info for a subdomain");
            const u = (0, a.generateRandomAddress)(),
              h = await (0, c.bnsV2ReadOnlyCall)({
                functionName: "get-id-from-bns",
                senderAddress: u,
                functionArgs: [
                  (0, o.bufferCVFromString)(s),
                  (0, o.bufferCVFromString)(i),
                ],
                network: e,
              });
            if (h.type === o.ClarityType.OptionalSome) {
              if (h.value.type === o.ClarityType.UInt) return h.value.value;
              throw new Error("Response did not contain a UInt");
            }
            if (h.type === o.ClarityType.OptionalNone)
              throw new Error("Name not found");
            throw new Error(
              `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(h)}`,
            );
          }
        }
        async function d({ id: t, network: e }) {
          try {
            const r = await h(`/tokens/${t}/name`, e);
            return { name: r.name, namespace: r.namespace };
          } catch (r) {
            f.debug.error("API call failed, falling back to contract call:", r);
            const n = (0, a.generateRandomAddress)(),
              i = await (0, c.bnsV2ReadOnlyCall)({
                functionName: "get-bns-from-id",
                senderAddress: n,
                functionArgs: [(0, o.uintCV)(t)],
                network: e,
              });
            if (i.type === o.ClarityType.OptionalSome) {
              if (i.value.type === o.ClarityType.Tuple) {
                const t = i.value.value.name;
                i.value.value.namespace;
                return {
                  name: t.value.toString(),
                  namespace: t.value.toString(),
                };
              }
              throw new Error("Response did not contain a Tuple");
            }
            if (i.type === o.ClarityType.OptionalNone) return null;
            throw new Error(
              `Unexpected Clarity Value type: ${(0, o.getCVTypeString)(i)}`,
            );
          }
        }
      },
      80136: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decodeFQN = function (t) {
            const e = t.split(".");
            if (e.length > 2)
              return { subdomain: e[0], name: e[1], namespace: e[2] };
            return { name: e[0], namespace: e[1] };
          }),
          (e.parsePriceFunction = function (t) {
            const e = t.buckets.value;
            return {
              base: t.base.value,
              coefficient: t.coeff.value,
              b1: e[0].value,
              b2: e[1].value,
              b3: e[2].value,
              b4: e[3].value,
              b5: e[4].value,
              b6: e[5].value,
              b7: e[6].value,
              b8: e[7].value,
              b9: e[8].value,
              b10: e[9].value,
              b11: e[10].value,
              b12: e[11].value,
              b13: e[12].value,
              b14: e[13].value,
              b15: e[14].value,
              b16: e[15].value,
              nonAlphaDiscount: t["nonalpha-discount"].value,
              noVowelDiscount: t["no-vowel-discount"].value,
            };
          }),
          (e.asciiToUtf8 = function (t) {
            return t
              .split(",")
              .map((t) => String.fromCharCode(parseInt(t.trim())))
              .join("");
          }),
          (e.generateRandomAddress = function () {
            const t = (0, n.makeRandomPrivKey)();
            return (0, n.getAddressFromPrivateKey)(t);
          }),
          (e.parseZonefile = function (t) {
            try {
              const e = JSON.parse(t);
              return {
                owner: e.owner || "",
                general: e.general || "",
                twitter: e.twitter || "",
                url: e.url || "",
                nostr: e.nostr || "",
                lightning: e.lightning || "",
                btc: e.btc || "",
                subdomains: Array.isArray(e.subdomains) ? e.subdomains : [],
              };
            } catch (t) {
              return (
                console.error("Error parsing zonefile:", t),
                {
                  owner: "",
                  general: "",
                  twitter: "",
                  url: "",
                  nostr: "",
                  lightning: "",
                  btc: "",
                  subdomains: [],
                }
              );
            }
          }),
          (e.stringifyZonefile = function (t) {
            return JSON.stringify(t);
          }),
          (e.createZonefileData = function (t) {
            return {
              owner: t.owner,
              general: t.general || "",
              twitter: t.twitter || "",
              url: t.url || "",
              nostr: t.nostr || "",
              lightning: t.lightning || "",
              btc: t.btc || "",
              subdomains: t.subdomains || [],
            };
          }),
          (e.addCallbacks = function (t, e, r) {
            return { ...t, onFinish: e, onCancel: r };
          });
        const n = r(86582);
      },
      19621: (t, e, r) => {
        "use strict";
        var n, i, o;
        r.d(e, {
          Fw: () => s,
          J_: () => i,
          c7: () => o,
          i4: () => a,
          n_: () => n,
          zB: () => u,
        }),
          (function (t) {
            (t[(t.Testnet = 2147483648)] = "Testnet"),
              (t[(t.Mainnet = 1)] = "Mainnet");
          })(n || (n = {})),
          (function (t) {
            (t[(t.Mainnet = 0)] = "Mainnet"),
              (t[(t.Testnet = 128)] = "Testnet");
          })(i || (i = {})),
          (function (t) {
            (t[(t.Mainnet = 385875968)] = "Mainnet"),
              (t[(t.Testnet = 4278190080)] = "Testnet");
          })(o || (o = {}));
        const s = 33,
          a = 32,
          u = "https://hub.blockstack.org";
      },
      48329: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            BLOCKSTACK_DEFAULT_GAIA_HUB_URL: () => ht.zB,
            BLOCKSTACK_HANDLER: () => O,
            BadPathError: () => _,
            BlockstackError: () => o,
            ChainID: () => ht.n_,
            ConflictError: () => w,
            DoesNotExist: () => b,
            ERROR_CODES: () => i,
            FailedDecryptionError: () => p,
            GaiaHubError: () => m,
            InvalidAmountError: () => h,
            InvalidDIDError: () => c,
            InvalidParameterError: () => s,
            InvalidStateError: () => y,
            Logger: () => k,
            LoginFailedError: () => l,
            MissingParameterError: () => a,
            NoSessionDataError: () => g,
            NotEnoughFundsError: () => f,
            NotEnoughProofError: () => v,
            PRIVATE_KEY_COMPRESSED_LENGTH: () => ht.Fw,
            PRIVATE_KEY_UNCOMPRESSED_LENGTH: () => ht.i4,
            PayloadTooLargeError: () => S,
            PeerNetworkID: () => ht.c7,
            PreconditionFailedError: () => I,
            RemoteServiceError: () => u,
            SignatureVerificationError: () => d,
            TransactionVersion: () => ht.J_,
            ValidationError: () => E,
            alloc: () => bt,
            asciiToBytes: () => it,
            bigIntToBytes: () => X,
            bytesToAscii: () => ot,
            bytesToHex: () => tt,
            bytesToUtf8: () => nt,
            concatArray: () => ct,
            concatBytes: () => ut,
            config: () => n,
            equals: () => mt,
            fromTwos: () => J,
            getAesCbcOutputLength: () => R,
            getBase64OutputLength: () => N,
            getGlobalObject: () => K,
            getGlobalObjects: () => V,
            getGlobalScope: () => F,
            hexToBigInt: () => G,
            hexToBytes: () => et,
            hexToInt: () => Y,
            intToBigInt: () => z,
            intToBytes: () => q,
            intToHex: () => W,
            isInstance: () => ft,
            isLaterVersion: () => D,
            isSameOriginAbsoluteUrl: () => j,
            makeUUID4: () => L,
            megabytesToBytes: () => C,
            nextHour: () => B,
            nextMonth: () => P,
            nextYear: () => x,
            octetsToBytes: () => at,
            parseRecoverableSignatureVrs: () => dt,
            privateKeyToBytes: () => gt,
            readUInt16BE: () => wt,
            readUInt16LE: () => St,
            readUInt32BE: () => Mt,
            readUInt32LE: () => Tt,
            readUInt8: () => _t,
            signatureRsvToVrs: () => yt,
            signatureVrsToRsv: () => pt,
            toTwos: () => Z,
            updateQueryStringParameter: () => U,
            utf8ToBytes: () => rt,
            with0x: () => $,
            writeUInt16BE: () => vt,
            writeUInt16LE: () => It,
            writeUInt32BE: () => At,
            writeUInt32LE: () => kt,
            writeUInt8: () => Et,
          });
        const n = { network: { layer1: "placeholder" }, logLevel: "debug" },
          i = {
            MISSING_PARAMETER: "missing_parameter",
            REMOTE_SERVICE_ERROR: "remote_service_error",
            INVALID_STATE: "invalid_state",
            NO_SESSION_DATA: "no_session_data",
            DOES_NOT_EXIST: "does_not_exist",
            FAILED_DECRYPTION_ERROR: "failed_decryption_error",
            INVALID_DID_ERROR: "invalid_did_error",
            NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
            INVALID_AMOUNT_ERROR: "invalid_amount_error",
            LOGIN_FAILED_ERROR: "login_failed",
            SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
            CONFLICT_ERROR: "conflict_error",
            NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
            BAD_PATH_ERROR: "bad_path_error",
            VALIDATION_ERROR: "validation_error",
            PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
            PRECONDITION_FAILED_ERROR: "precondition_failed_error",
            UNKNOWN: "unknown",
          };
        Object.freeze(i);
        class o extends Error {
          constructor(t) {
            super();
            let e = t.message,
              r = `Error Code: ${t.code}`,
              n = this.stack;
            if (n) r += `Stack Trace:\n${n}`;
            else
              try {
                throw new Error();
              } catch (t) {
                n = t.stack;
              }
            (e += `\nIf you believe this exception is caused by a bug in stacks.js,\n      please file a bug report: https://github.com/blockstack/stacks.js/issues\n\n${r}`),
              (this.message = e),
              (this.code = t.code),
              (this.parameter = t.parameter ? t.parameter : void 0);
          }
          toString() {
            return `${super.toString()}\n    code: ${this.code} param: ${this.parameter ? this.parameter : "n/a"}`;
          }
        }
        class s extends o {
          constructor(t, e = "") {
            super({ code: i.MISSING_PARAMETER, message: e, parameter: t }),
              (this.name = "MissingParametersError");
          }
        }
        class a extends o {
          constructor(t, e = "") {
            super({ code: i.MISSING_PARAMETER, message: e, parameter: t }),
              (this.name = "MissingParametersError");
          }
        }
        class u extends o {
          constructor(t, e = "") {
            super({ code: i.REMOTE_SERVICE_ERROR, message: e }),
              (this.response = t);
          }
        }
        class c extends o {
          constructor(t = "") {
            super({ code: i.INVALID_DID_ERROR, message: t }),
              (this.name = "InvalidDIDError");
          }
        }
        class f extends o {
          constructor(t) {
            const e = `Not enough UTXOs to fund. Left to fund: ${t}`;
            super({ code: i.NOT_ENOUGH_FUNDS_ERROR, message: e }),
              (this.leftToFund = t),
              (this.name = "NotEnoughFundsError"),
              (this.message = e);
          }
        }
        class h extends o {
          constructor(t, e) {
            const r = `Not enough coin to fund fees transaction fees. Fees would be ${t}, specified spend is  ${e}`;
            super({ code: i.INVALID_AMOUNT_ERROR, message: r }),
              (this.specifiedAmount = e),
              (this.fees = t),
              (this.name = "InvalidAmountError"),
              (this.message = r);
          }
        }
        class l extends o {
          constructor(t) {
            const e = `Failed to login: ${t}`;
            super({ code: i.LOGIN_FAILED_ERROR, message: e }),
              (this.message = e),
              (this.name = "LoginFailedError");
          }
        }
        class d extends o {
          constructor(t) {
            const e = `Failed to verify signature: ${t}`;
            super({ code: i.SIGNATURE_VERIFICATION_ERROR, message: e }),
              (this.message = e),
              (this.name = "SignatureVerificationError");
          }
        }
        class p extends o {
          constructor(t = "Unable to decrypt cipher object.") {
            super({ code: i.FAILED_DECRYPTION_ERROR, message: t }),
              (this.message = t),
              (this.name = "FailedDecryptionError");
          }
        }
        class y extends o {
          constructor(t) {
            super({ code: i.INVALID_STATE, message: t }),
              (this.message = t),
              (this.name = "InvalidStateError");
          }
        }
        class g extends o {
          constructor(t) {
            super({ code: i.INVALID_STATE, message: t }),
              (this.message = t),
              (this.name = "NoSessionDataError");
          }
        }
        class m extends o {
          constructor(t, e) {
            super(t),
              e &&
                ((this.hubError = {
                  statusCode: e.status,
                  statusText: e.statusText,
                }),
                "string" == typeof e.body
                  ? (this.hubError.message = e.body)
                  : "object" == typeof e.body &&
                    Object.assign(this.hubError, e.body));
          }
        }
        class b extends m {
          constructor(t, e) {
            super({ message: t, code: i.DOES_NOT_EXIST }, e),
              (this.name = "DoesNotExist");
          }
        }
        class w extends m {
          constructor(t, e) {
            super({ message: t, code: i.CONFLICT_ERROR }, e),
              (this.name = "ConflictError");
          }
        }
        class v extends m {
          constructor(t, e) {
            super({ message: t, code: i.NOT_ENOUGH_PROOF_ERROR }, e),
              (this.name = "NotEnoughProofError");
          }
        }
        class _ extends m {
          constructor(t, e) {
            super({ message: t, code: i.BAD_PATH_ERROR }, e),
              (this.name = "BadPathError");
          }
        }
        class E extends m {
          constructor(t, e) {
            super({ message: t, code: i.VALIDATION_ERROR }, e),
              (this.name = "ValidationError");
          }
        }
        class S extends m {
          constructor(t, e, r) {
            super({ message: t, code: i.PAYLOAD_TOO_LARGE_ERROR }, e),
              (this.name = "PayloadTooLargeError"),
              (this.maxUploadByteSize = r);
          }
        }
        class I extends m {
          constructor(t, e) {
            super({ message: t, code: i.PRECONDITION_FAILED_ERROR }, e),
              (this.name = "PreconditionFailedError");
          }
        }
        const M = ["debug", "info", "warn", "error", "none"],
          A = {},
          T = {};
        for (let t = 0; t < M.length; t++) {
          const e = M[t];
          (A[e] = t), (T[t] = e);
        }
        class k {
          static error(t) {
            this.shouldLog("error") &&
              console.error(this.logMessage("error", t));
          }
          static warn(t) {
            this.shouldLog("warn") && console.warn(this.logMessage("warn", t));
          }
          static info(t) {
            this.shouldLog("info") && console.log(this.logMessage("info", t));
          }
          static debug(t) {
            this.shouldLog("debug") && console.log(this.logMessage("debug", t));
          }
          static logMessage(t, e) {
            return `[${t.toUpperCase()}] ${e}`;
          }
          static shouldLog(t) {
            return A[n.logLevel] <= A[t];
          }
        }
        const O = "blockstack";
        function x() {
          return new Date(new Date().setFullYear(new Date().getFullYear() + 1));
        }
        function P() {
          return new Date(new Date().setMonth(new Date().getMonth() + 1));
        }
        function B() {
          return new Date(new Date().setHours(new Date().getHours() + 1));
        }
        function C(t) {
          return Number.isFinite(t) ? Math.floor(1024 * t * 1024) : 0;
        }
        function R(t) {
          return 16 * (Math.floor(t / 16) + 1);
        }
        function N(t) {
          return 4 * Math.ceil(t / 3);
        }
        function U(t, e, r) {
          const n = new RegExp(`([?&])${e}=.*?(&|$)`, "i"),
            i = -1 !== t.indexOf("?") ? "&" : "?";
          return t.match(n)
            ? t.replace(n, `$1${e}=${r}$2`)
            : `${t}${i}${e}=${r}`;
        }
        function D(t, e) {
          (void 0 !== t && "" !== t) || (t = "0.0.0"),
            (void 0 !== e && "" !== t) || (e = "0.0.0");
          const r = t.split(".").map((t) => parseInt(t, 10)),
            n = e.split(".").map((t) => parseInt(t, 10));
          for (let i = 0; i < e.length; i++)
            if ((i >= t.length && n.push(0), r[i] < n[i])) return !1;
          return !0;
        }
        function L() {
          let t = new Date().getTime();
          return (
            "undefined" != typeof performance &&
              "function" == typeof performance.now &&
              (t += performance.now()),
            "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
              const r = (t + 16 * Math.random()) % 16 | 0;
              return (
                (t = Math.floor(t / 16)),
                ("x" === e ? r : (3 & r) | 8).toString(16)
              );
            })
          );
        }
        function j(t, e) {
          try {
            const r = new URL(t),
              n = new URL(e),
              i =
                0 | parseInt(r.port || "0", 10) ||
                ("https:" === r.protocol ? 443 : 80),
              o =
                0 | parseInt(n.port || "0", 10) ||
                ("https:" === n.protocol ? 443 : 80),
              s = {
                scheme: r.protocol === n.protocol,
                hostname: r.hostname === n.hostname,
                port: i === o,
                absolute:
                  (t.includes("http://") || t.includes("https://")) &&
                  (e.includes("http://") || e.includes("https://")),
              };
            return s.scheme && s.hostname && s.port && s.absolute;
          } catch (t) {
            return (
              console.log(t),
              console.log("Parsing error in same URL origin check"),
              !1
            );
          }
        }
        function F() {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if (void 0 !== r.g) return r.g;
          throw new Error(
            "Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available",
          );
        }
        function H(t, e, r) {
          return r
            ? `Use of '${r}' requires \`${e}\` which is unavailable on the '${t}' object within the currently executing environment.`
            : `\`${e}\` is unavailable on the '${t}' object within the currently executing environment.`;
        }
        function K(
          t,
          { throwIfUnavailable: e, usageDesc: r, returnEmptyObject: n } = {},
        ) {
          let i;
          try {
            if (((i = F()), i)) {
              const e = i[t];
              if (e) return e;
            }
          } catch (e) {
            k.error(
              `Error getting object '${t}' from global scope '${i}': ${e}`,
            );
          }
          if (e) {
            const e = H(i, t.toString(), r);
            throw (k.error(e), new Error(e));
          }
          if (n) return {};
        }
        function V(
          t,
          { throwIfUnavailable: e, usageDesc: r, returnEmptyObject: n } = {},
        ) {
          let i;
          try {
            i = F();
          } catch (o) {
            if ((k.error(`Error getting global scope: ${o}`), e)) {
              const e = H(i, t[0].toString(), r);
              throw (k.error(e), e);
            }
            n && (i = {});
          }
          const o = {};
          for (let s = 0; s < t.length; s++) {
            const a = t[s];
            try {
              if (i) {
                const t = i[a];
                if (t) o[a] = t;
                else {
                  if (e) {
                    const t = H(i, a.toString(), r);
                    throw (k.error(t), new Error(t));
                  }
                  n && (o[a] = {});
                }
              }
            } catch (t) {
              if (e) {
                const t = H(i, a.toString(), r);
                throw (k.error(t), new Error(t));
              }
            }
          }
          return o;
        }
        function q(t, e, r) {
          return X(z(t, e), r);
        }
        function z(t, e) {
          let r = t;
          if ("number" == typeof r) {
            if (!Number.isInteger(r))
              throw new RangeError(
                "Invalid value. Values of type 'number' must be an integer.",
              );
            if (r > Number.MAX_SAFE_INTEGER)
              throw new RangeError(
                `Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`,
              );
            return BigInt(r);
          }
          if ("string" == typeof r)
            if (r.toLowerCase().startsWith("0x")) {
              let t = r.slice(2);
              (t = t.padStart(t.length + (t.length % 2), "0")), (r = et(t));
            } else
              try {
                return BigInt(r);
              } catch (t) {
                if (t instanceof SyntaxError)
                  throw new RangeError(
                    `Invalid value. String integer '${r}' is not finite.`,
                  );
              }
          if ("bigint" == typeof r) return r;
          if (r instanceof Uint8Array) {
            if (e) {
              const t = J(BigInt(`0x${tt(r)}`), BigInt(8 * r.byteLength));
              return BigInt(t.toString());
            }
            return BigInt(`0x${tt(r)}`);
          }
          if (null != r && "object" == typeof r && "BN" === r.constructor.name)
            return BigInt(r.toString());
          throw new TypeError(
            "Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.",
          );
        }
        function $(t) {
          return t.startsWith("0x") ? t : `0x${t}`;
        }
        function G(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToBigInt: expected string, got " + typeof t,
            );
          return BigInt(`0x${t}`);
        }
        function W(t, e = 8) {
          return ("bigint" == typeof t ? t : z(t, !1))
            .toString(16)
            .padStart(2 * e, "0");
        }
        function Y(t) {
          return parseInt(t, 16);
        }
        function X(t, e = 16) {
          return et(W(t, e));
        }
        function Z(t, e) {
          if (
            t < -(BigInt(1) << (e - BigInt(1))) ||
            (BigInt(1) << (e - BigInt(1))) - BigInt(1) < t
          )
            throw `Unable to represent integer in width: ${e}`;
          return t >= BigInt(0) ? BigInt(t) : t + (BigInt(1) << e);
        }
        function J(t, e) {
          return (function (t, e) {
            return t & (BigInt(1) << e);
          })(t, e - BigInt(1))
            ? t - (BigInt(1) << e)
            : t;
        }
        const Q = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        function tt(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let e = "";
          for (const r of t) e += Q[r];
          return e;
        }
        function et(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          const e =
              (t = t.startsWith("0x") || t.startsWith("0X") ? t.slice(2) : t)
                .length % 2
                ? `0${t}`
                : t,
            r = new Uint8Array(e.length / 2);
          for (let t = 0; t < r.length; t++) {
            const n = 2 * t,
              i = e.slice(n, n + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            r[t] = o;
          }
          return r;
        }
        function rt(t) {
          return new TextEncoder().encode(t);
        }
        function nt(t) {
          return new TextDecoder().decode(t);
        }
        function it(t) {
          const e = [];
          for (let r = 0; r < t.length; r++) e.push(255 & t.charCodeAt(r));
          return new Uint8Array(e);
        }
        function ot(t) {
          return String.fromCharCode.apply(null, t);
        }
        function st(t) {
          return !Number.isInteger(t) || t < 0 || t > 255;
        }
        function at(t) {
          if (t.some(st)) throw new Error("Some values are invalid bytes.");
          return new Uint8Array(t);
        }
        function ut(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        function ct(t) {
          return ut(
            ...t.map((t) =>
              "number" == typeof t ? at([t]) : t instanceof Array ? at(t) : t,
            ),
          );
        }
        function ft(t, e) {
          return (
            t instanceof e || t?.constructor?.name?.toLowerCase() === e.name
          );
        }
        var ht = r(19621);
        const lt = 32;
        function dt(t) {
          if (t.length < 2 * lt * 2 + 1) throw new Error("Invalid signature");
          const e = t.slice(0, 2),
            r = t.slice(2, 2 + 2 * lt),
            n = t.slice(2 + 2 * lt);
          return { recoveryId: Y(e), r, s: n };
        }
        function pt(t) {
          return t.slice(2) + t.slice(0, 2);
        }
        function yt(t) {
          return t.slice(-2) + t.slice(0, -2);
        }
        function gt(t) {
          const e = "string" == typeof t ? et(t) : t;
          if (32 != e.length && 33 != e.length)
            throw new Error(
              `Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${e.length}`,
            );
          if (33 == e.length && 1 !== e[32])
            throw new Error(
              "Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01",
            );
          return e;
        }
        function mt(t, e) {
          if (t.byteLength !== e.byteLength) return !1;
          for (let r = 0; r < t.byteLength; r++) if (t[r] !== e[r]) return !1;
          return !0;
        }
        function bt(t, e) {
          const r = new Uint8Array(t);
          for (let n = 0; n < t; n++) r[n] = e;
          return r;
        }
        function wt(t, e) {
          return ((t[e + 0] << 8) | t[e + 1]) >>> 0;
        }
        function vt(t, e, r = 0) {
          return (t[r + 0] = e >>> 8), (t[r + 1] = e >>> 0), t;
        }
        function _t(t, e) {
          return t[e];
        }
        function Et(t, e, r = 0) {
          return (t[r] = e), t;
        }
        function St(t, e) {
          return ((t[e + 0] | 0) >>> 0) | ((t[e + 1] << 8) >>> 0);
        }
        function It(t, e, r = 0) {
          return (t[r + 0] = 255 & e), (e >>>= 8), (t[r + 1] = 255 & e), t;
        }
        function Mt(t, e) {
          return t[e] * 2 ** 24 + 65536 * t[e + 1] + 256 * t[e + 2] + t[e + 3];
        }
        function At(t, e, r = 0) {
          return (
            (t[r + 3] = e),
            (e >>>= 8),
            (t[r + 2] = e),
            (e >>>= 8),
            (t[r + 1] = e),
            (e >>>= 8),
            (t[r] = e),
            t
          );
        }
        function Tt(t, e) {
          return (
            ((t[e + 0] | 0) >>> 0) |
            ((t[e + 1] << 8) >>> 0) |
            ((t[e + 2] << 16) >>> 0) |
            ((t[e + 3] << 24) >>> 0)
          );
        }
        function kt(t, e, r = 0) {
          return (
            (t[r + 0] = 255 & e),
            (e >>>= 8),
            (t[r + 1] = 255 & e),
            (e >>>= 8),
            (t[r + 2] = 255 & e),
            (e >>>= 8),
            (t[r + 3] = 255 & e),
            t
          );
        }
      },
      46577: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            HIRO_MAINNET_DEFAULT: () => h,
            HIRO_MOCKNET_DEFAULT: () => d,
            HIRO_TESTNET_DEFAULT: () => l,
            StacksDevnet: () => w,
            StacksMainnet: () => g,
            StacksMocknet: () => b,
            StacksNetwork: () => y,
            StacksNetworks: () => p,
            StacksTestnet: () => m,
            createApiKeyMiddleware: () => u,
            createFetchFn: () => c,
            fetchWrapper: () => s,
            getFetchOptions: () => i,
            hostMatches: () => a,
            setFetchOptions: () => o,
          });
        r(86547);
        const n = {
            referrerPolicy: "origin",
            headers: { "x-hiro-product": "stacksjs" },
          },
          i = () => n,
          o = (t) => Object.assign(n, t);
        async function s(t, e) {
          const r = {};
          Object.assign(r, n, e);
          return await fetch(t, r);
        }
        function a(t, e) {
          return "string" == typeof e ? e === t : e.exec(t);
        }
        function u({
          apiKey: t,
          host: e = /(.*)api(.*)(\.stacks\.co|\.hiro\.so)$/i,
          httpHeader: r = "x-api-key",
        }) {
          return {
            pre: (n) => {
              if (!a(new URL(n.url).host, e)) return;
              (n.init.headers instanceof Headers
                ? n.init.headers
                : (n.init.headers = new Headers(n.init.headers))
              ).set(r, t);
            },
          };
        }
        function c(...t) {
          const { fetchLib: e, middlewares: r } = (function (t) {
            let e = s,
              r = [];
            return (
              t.length > 0 && "function" == typeof t[0] && (e = t.shift()),
              t.length > 0 && (r = t),
              { fetchLib: e, middlewares: r }
            );
          })(t);
          return async (t, n) => {
            let i = { url: t, init: n ?? {} };
            for (const t of r)
              if ("function" == typeof t.pre) {
                i = (await Promise.resolve(t.pre({ fetch: e, ...i }))) ?? i;
              }
            let o = await e(i.url, i.init);
            for (const t of r)
              if ("function" == typeof t.post) {
                const r = await Promise.resolve(
                  t.post({
                    fetch: e,
                    url: i.url,
                    init: i.init,
                    response: o?.clone() ?? o,
                  }),
                );
                o = r ?? o;
              }
            return o;
          };
        }
        var f = r(19621);
        const h = "https://api.mainnet.hiro.so",
          l = "https://api.testnet.hiro.so",
          d = "http://localhost:3999",
          p = ["mainnet", "testnet", "devnet", "mocknet"];
        class y {
          constructor(t) {
            (this.version = f.J_.Mainnet),
              (this.chainId = f.n_.Mainnet),
              (this.bnsLookupUrl = "https://api.mainnet.hiro.so"),
              (this.broadcastEndpoint = "/v2/transactions"),
              (this.transferFeeEstimateEndpoint = "/v2/fees/transfer"),
              (this.transactionFeeEstimateEndpoint = "/v2/fees/transaction"),
              (this.accountEndpoint = "/v2/accounts"),
              (this.contractAbiEndpoint = "/v2/contracts/interface"),
              (this.readOnlyFunctionCallEndpoint = "/v2/contracts/call-read"),
              (this.isMainnet = () => this.version === f.J_.Mainnet),
              (this.getBroadcastApiUrl = () =>
                `${this.coreApiUrl}${this.broadcastEndpoint}`),
              (this.getTransferFeeEstimateApiUrl = () =>
                `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`),
              (this.getTransactionFeeEstimateApiUrl = () =>
                `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`),
              (this.getAccountApiUrl = (t) =>
                `${this.coreApiUrl}${this.accountEndpoint}/${t}?proof=0`),
              (this.getAccountExtendedBalancesApiUrl = (t) =>
                `${this.coreApiUrl}/extended/v1/address/${t}/balances`),
              (this.getAbiApiUrl = (t, e) =>
                `${this.coreApiUrl}${this.contractAbiEndpoint}/${t}/${e}`),
              (this.getReadOnlyFunctionCallApiUrl = (t, e, r) =>
                `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${t}/${e}/${encodeURIComponent(r)}`),
              (this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`),
              (this.getBlockTimeInfoUrl = () =>
                `${this.coreApiUrl}/extended/v1/info/network_block_times`),
              (this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`),
              (this.getRewardsUrl = (t, e) => {
                let r = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${t}`;
                return e && (r = `${r}?limit=${e.limit}&offset=${e.offset}`), r;
              }),
              (this.getRewardsTotalUrl = (t) =>
                `${this.coreApiUrl}/extended/v1/burnchain/rewards/${t}/total`),
              (this.getRewardHoldersUrl = (t, e) => {
                let r = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${t}`;
                return e && (r = `${r}?limit=${e.limit}&offset=${e.offset}`), r;
              }),
              (this.getStackerInfoUrl = (t, e) =>
                `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}\n    ${t}/${e}/get-stacker-info`),
              (this.getDataVarUrl = (t, e, r) =>
                `${this.coreApiUrl}/v2/data_var/${t}/${e}/${r}?proof=0`),
              (this.getMapEntryUrl = (t, e, r) =>
                `${this.coreApiUrl}/v2/map_entry/${t}/${e}/${r}?proof=0`),
              (this.coreApiUrl = t.url),
              (this.fetchFn = t.fetchFn ?? c());
          }
          getNameInfo(t) {
            const e = `${this.bnsLookupUrl}/v1/names/${t}`;
            return this.fetchFn(e)
              .then((t) => {
                if (404 === t.status) throw new Error("Name not found");
                if (200 !== t.status)
                  throw new Error(`Bad response status: ${t.status}`);
                return t.json();
              })
              .then((t) =>
                t.address ? Object.assign({}, t, { address: t.address }) : t,
              );
          }
        }
        (y.fromName = (t) => {
          switch (t) {
            case "mainnet":
              return new g();
            case "testnet":
              return new m();
            case "devnet":
              return new w();
            case "mocknet":
              return new b();
            default:
              throw new Error(
                `Invalid network name provided. Must be one of the following: ${p.join(", ")}`,
              );
          }
        }),
          (y.fromNameOrNetwork = (t) =>
            "string" != typeof t && "version" in t ? t : y.fromName(t));
        class g extends y {
          constructor(t) {
            super({ url: t?.url ?? h, fetchFn: t?.fetchFn }),
              (this.version = f.J_.Mainnet),
              (this.chainId = f.n_.Mainnet);
          }
        }
        class m extends y {
          constructor(t) {
            super({ url: t?.url ?? l, fetchFn: t?.fetchFn }),
              (this.version = f.J_.Testnet),
              (this.chainId = f.n_.Testnet);
          }
        }
        class b extends y {
          constructor(t) {
            super({ url: t?.url ?? d, fetchFn: t?.fetchFn }),
              (this.version = f.J_.Testnet),
              (this.chainId = f.n_.Testnet);
          }
        }
        const w = b;
      },
      15037: (t, e, r) => {
        var n;
        function i(t) {
          this.rand = t;
        }
        if (
          ((t.exports = function (t) {
            return n || (n = new i(null)), n.generate(t);
          }),
          (t.exports.Rand = i),
          (i.prototype.generate = function (t) {
            return this._rand(t);
          }),
          (i.prototype._rand = function (t) {
            if (this.rand.getBytes) return this.rand.getBytes(t);
            for (var e = new Uint8Array(t), r = 0; r < e.length; r++)
              e[r] = this.rand.getByte();
            return e;
          }),
          "object" == typeof self)
        )
          self.crypto && self.crypto.getRandomValues
            ? (i.prototype._rand = function (t) {
                var e = new Uint8Array(t);
                return self.crypto.getRandomValues(e), e;
              })
            : self.msCrypto && self.msCrypto.getRandomValues
              ? (i.prototype._rand = function (t) {
                  var e = new Uint8Array(t);
                  return self.msCrypto.getRandomValues(e), e;
                })
              : "object" == typeof window &&
                (i.prototype._rand = function () {
                  throw new Error("Not implemented yet");
                });
        else
          try {
            var o = r(73776);
            if ("function" != typeof o.randomBytes)
              throw new Error("Not supported");
            i.prototype._rand = function (t) {
              return o.randomBytes(t);
            };
          } catch (t) {}
      },
      50462: (t, e, r) => {
        var n = r(92861).Buffer;
        function i(t) {
          n.isBuffer(t) || (t = n.from(t));
          for (var e = (t.length / 4) | 0, r = new Array(e), i = 0; i < e; i++)
            r[i] = t.readUInt32BE(4 * i);
          return r;
        }
        function o(t) {
          for (; 0 < t.length; t++) t[0] = 0;
        }
        function s(t, e, r, n, i) {
          for (
            var o,
              s,
              a,
              u,
              c = r[0],
              f = r[1],
              h = r[2],
              l = r[3],
              d = t[0] ^ e[0],
              p = t[1] ^ e[1],
              y = t[2] ^ e[2],
              g = t[3] ^ e[3],
              m = 4,
              b = 1;
            b < i;
            b++
          )
            (o =
              c[d >>> 24] ^
              f[(p >>> 16) & 255] ^
              h[(y >>> 8) & 255] ^
              l[255 & g] ^
              e[m++]),
              (s =
                c[p >>> 24] ^
                f[(y >>> 16) & 255] ^
                h[(g >>> 8) & 255] ^
                l[255 & d] ^
                e[m++]),
              (a =
                c[y >>> 24] ^
                f[(g >>> 16) & 255] ^
                h[(d >>> 8) & 255] ^
                l[255 & p] ^
                e[m++]),
              (u =
                c[g >>> 24] ^
                f[(d >>> 16) & 255] ^
                h[(p >>> 8) & 255] ^
                l[255 & y] ^
                e[m++]),
              (d = o),
              (p = s),
              (y = a),
              (g = u);
          return (
            (o =
              ((n[d >>> 24] << 24) |
                (n[(p >>> 16) & 255] << 16) |
                (n[(y >>> 8) & 255] << 8) |
                n[255 & g]) ^
              e[m++]),
            (s =
              ((n[p >>> 24] << 24) |
                (n[(y >>> 16) & 255] << 16) |
                (n[(g >>> 8) & 255] << 8) |
                n[255 & d]) ^
              e[m++]),
            (a =
              ((n[y >>> 24] << 24) |
                (n[(g >>> 16) & 255] << 16) |
                (n[(d >>> 8) & 255] << 8) |
                n[255 & p]) ^
              e[m++]),
            (u =
              ((n[g >>> 24] << 24) |
                (n[(d >>> 16) & 255] << 16) |
                (n[(p >>> 8) & 255] << 8) |
                n[255 & y]) ^
              e[m++]),
            [(o >>>= 0), (s >>>= 0), (a >>>= 0), (u >>>= 0)]
          );
        }
        var a = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
          u = (function () {
            for (var t = new Array(256), e = 0; e < 256; e++)
              t[e] = e < 128 ? e << 1 : (e << 1) ^ 283;
            for (
              var r = [],
                n = [],
                i = [[], [], [], []],
                o = [[], [], [], []],
                s = 0,
                a = 0,
                u = 0;
              u < 256;
              ++u
            ) {
              var c = a ^ (a << 1) ^ (a << 2) ^ (a << 3) ^ (a << 4);
              (c = (c >>> 8) ^ (255 & c) ^ 99), (r[s] = c), (n[c] = s);
              var f = t[s],
                h = t[f],
                l = t[h],
                d = (257 * t[c]) ^ (16843008 * c);
              (i[0][s] = (d << 24) | (d >>> 8)),
                (i[1][s] = (d << 16) | (d >>> 16)),
                (i[2][s] = (d << 8) | (d >>> 24)),
                (i[3][s] = d),
                (d = (16843009 * l) ^ (65537 * h) ^ (257 * f) ^ (16843008 * s)),
                (o[0][c] = (d << 24) | (d >>> 8)),
                (o[1][c] = (d << 16) | (d >>> 16)),
                (o[2][c] = (d << 8) | (d >>> 24)),
                (o[3][c] = d),
                0 === s
                  ? (s = a = 1)
                  : ((s = f ^ t[t[t[l ^ f]]]), (a ^= t[t[a]]));
            }
            return { SBOX: r, INV_SBOX: n, SUB_MIX: i, INV_SUB_MIX: o };
          })();
        function c(t) {
          (this._key = i(t)), this._reset();
        }
        (c.blockSize = 16),
          (c.keySize = 32),
          (c.prototype.blockSize = c.blockSize),
          (c.prototype.keySize = c.keySize),
          (c.prototype._reset = function () {
            for (
              var t = this._key,
                e = t.length,
                r = e + 6,
                n = 4 * (r + 1),
                i = [],
                o = 0;
              o < e;
              o++
            )
              i[o] = t[o];
            for (o = e; o < n; o++) {
              var s = i[o - 1];
              o % e == 0
                ? ((s = (s << 8) | (s >>> 24)),
                  (s =
                    (u.SBOX[s >>> 24] << 24) |
                    (u.SBOX[(s >>> 16) & 255] << 16) |
                    (u.SBOX[(s >>> 8) & 255] << 8) |
                    u.SBOX[255 & s]),
                  (s ^= a[(o / e) | 0] << 24))
                : e > 6 &&
                  o % e == 4 &&
                  (s =
                    (u.SBOX[s >>> 24] << 24) |
                    (u.SBOX[(s >>> 16) & 255] << 16) |
                    (u.SBOX[(s >>> 8) & 255] << 8) |
                    u.SBOX[255 & s]),
                (i[o] = i[o - e] ^ s);
            }
            for (var c = [], f = 0; f < n; f++) {
              var h = n - f,
                l = i[h - (f % 4 ? 0 : 4)];
              c[f] =
                f < 4 || h <= 4
                  ? l
                  : u.INV_SUB_MIX[0][u.SBOX[l >>> 24]] ^
                    u.INV_SUB_MIX[1][u.SBOX[(l >>> 16) & 255]] ^
                    u.INV_SUB_MIX[2][u.SBOX[(l >>> 8) & 255]] ^
                    u.INV_SUB_MIX[3][u.SBOX[255 & l]];
            }
            (this._nRounds = r),
              (this._keySchedule = i),
              (this._invKeySchedule = c);
          }),
          (c.prototype.encryptBlockRaw = function (t) {
            return s(
              (t = i(t)),
              this._keySchedule,
              u.SUB_MIX,
              u.SBOX,
              this._nRounds,
            );
          }),
          (c.prototype.encryptBlock = function (t) {
            var e = this.encryptBlockRaw(t),
              r = n.allocUnsafe(16);
            return (
              r.writeUInt32BE(e[0], 0),
              r.writeUInt32BE(e[1], 4),
              r.writeUInt32BE(e[2], 8),
              r.writeUInt32BE(e[3], 12),
              r
            );
          }),
          (c.prototype.decryptBlock = function (t) {
            var e = (t = i(t))[1];
            (t[1] = t[3]), (t[3] = e);
            var r = s(
                t,
                this._invKeySchedule,
                u.INV_SUB_MIX,
                u.INV_SBOX,
                this._nRounds,
              ),
              o = n.allocUnsafe(16);
            return (
              o.writeUInt32BE(r[0], 0),
              o.writeUInt32BE(r[3], 4),
              o.writeUInt32BE(r[2], 8),
              o.writeUInt32BE(r[1], 12),
              o
            );
          }),
          (c.prototype.scrub = function () {
            o(this._keySchedule), o(this._invKeySchedule), o(this._key);
          }),
          (t.exports.AES = c);
      },
      92356: (t, e, r) => {
        var n = r(50462),
          i = r(92861).Buffer,
          o = r(56168),
          s = r(56698),
          a = r(25892),
          u = r(30295),
          c = r(45122);
        function f(t, e, r, s) {
          o.call(this);
          var u = i.alloc(4, 0);
          this._cipher = new n.AES(e);
          var f = this._cipher.encryptBlock(u);
          (this._ghash = new a(f)),
            (r = (function (t, e, r) {
              if (12 === e.length)
                return (
                  (t._finID = i.concat([e, i.from([0, 0, 0, 1])])),
                  i.concat([e, i.from([0, 0, 0, 2])])
                );
              var n = new a(r),
                o = e.length,
                s = o % 16;
              n.update(e),
                s && ((s = 16 - s), n.update(i.alloc(s, 0))),
                n.update(i.alloc(8, 0));
              var u = 8 * o,
                f = i.alloc(8);
              f.writeUIntBE(u, 0, 8), n.update(f), (t._finID = n.state);
              var h = i.from(t._finID);
              return c(h), h;
            })(this, r, f)),
            (this._prev = i.from(r)),
            (this._cache = i.allocUnsafe(0)),
            (this._secCache = i.allocUnsafe(0)),
            (this._decrypt = s),
            (this._alen = 0),
            (this._len = 0),
            (this._mode = t),
            (this._authTag = null),
            (this._called = !1);
        }
        s(f, o),
          (f.prototype._update = function (t) {
            if (!this._called && this._alen) {
              var e = 16 - (this._alen % 16);
              e < 16 && ((e = i.alloc(e, 0)), this._ghash.update(e));
            }
            this._called = !0;
            var r = this._mode.encrypt(this, t);
            return (
              this._decrypt ? this._ghash.update(t) : this._ghash.update(r),
              (this._len += t.length),
              r
            );
          }),
          (f.prototype._final = function () {
            if (this._decrypt && !this._authTag)
              throw new Error(
                "Unsupported state or unable to authenticate data",
              );
            var t = u(
              this._ghash.final(8 * this._alen, 8 * this._len),
              this._cipher.encryptBlock(this._finID),
            );
            if (
              this._decrypt &&
              (function (t, e) {
                var r = 0;
                t.length !== e.length && r++;
                for (var n = Math.min(t.length, e.length), i = 0; i < n; ++i)
                  r += t[i] ^ e[i];
                return r;
              })(t, this._authTag)
            )
              throw new Error(
                "Unsupported state or unable to authenticate data",
              );
            (this._authTag = t), this._cipher.scrub();
          }),
          (f.prototype.getAuthTag = function () {
            if (this._decrypt || !i.isBuffer(this._authTag))
              throw new Error(
                "Attempting to get auth tag in unsupported state",
              );
            return this._authTag;
          }),
          (f.prototype.setAuthTag = function (t) {
            if (!this._decrypt)
              throw new Error(
                "Attempting to set auth tag in unsupported state",
              );
            this._authTag = t;
          }),
          (f.prototype.setAAD = function (t) {
            if (this._called)
              throw new Error("Attempting to set AAD in unsupported state");
            this._ghash.update(t), (this._alen += t.length);
          }),
          (t.exports = f);
      },
      1241: (t, e, r) => {
        var n = r(25799),
          i = r(36171),
          o = r(3219);
        (e.createCipher = e.Cipher = n.createCipher),
          (e.createCipheriv = e.Cipheriv = n.createCipheriv),
          (e.createDecipher = e.Decipher = i.createDecipher),
          (e.createDecipheriv = e.Decipheriv = i.createDecipheriv),
          (e.listCiphers = e.getCiphers =
            function () {
              return Object.keys(o);
            });
      },
      36171: (t, e, r) => {
        var n = r(92356),
          i = r(92861).Buffer,
          o = r(530),
          s = r(50650),
          a = r(56168),
          u = r(50462),
          c = r(68078);
        function f(t, e, r) {
          a.call(this),
            (this._cache = new h()),
            (this._last = void 0),
            (this._cipher = new u.AES(e)),
            (this._prev = i.from(r)),
            (this._mode = t),
            (this._autopadding = !0);
        }
        function h() {
          this.cache = i.allocUnsafe(0);
        }
        function l(t, e, r) {
          var a = o[t.toLowerCase()];
          if (!a) throw new TypeError("invalid suite type");
          if (
            ("string" == typeof r && (r = i.from(r)),
            "GCM" !== a.mode && r.length !== a.iv)
          )
            throw new TypeError("invalid iv length " + r.length);
          if (("string" == typeof e && (e = i.from(e)), e.length !== a.key / 8))
            throw new TypeError("invalid key length " + e.length);
          return "stream" === a.type
            ? new s(a.module, e, r, !0)
            : "auth" === a.type
              ? new n(a.module, e, r, !0)
              : new f(a.module, e, r);
        }
        r(56698)(f, a),
          (f.prototype._update = function (t) {
            var e, r;
            this._cache.add(t);
            for (var n = []; (e = this._cache.get(this._autopadding)); )
              (r = this._mode.decrypt(this, e)), n.push(r);
            return i.concat(n);
          }),
          (f.prototype._final = function () {
            var t = this._cache.flush();
            if (this._autopadding)
              return (function (t) {
                var e = t[15];
                if (e < 1 || e > 16) throw new Error("unable to decrypt data");
                var r = -1;
                for (; ++r < e; )
                  if (t[r + (16 - e)] !== e)
                    throw new Error("unable to decrypt data");
                if (16 === e) return;
                return t.slice(0, 16 - e);
              })(this._mode.decrypt(this, t));
            if (t) throw new Error("data not multiple of block length");
          }),
          (f.prototype.setAutoPadding = function (t) {
            return (this._autopadding = !!t), this;
          }),
          (h.prototype.add = function (t) {
            this.cache = i.concat([this.cache, t]);
          }),
          (h.prototype.get = function (t) {
            var e;
            if (t) {
              if (this.cache.length > 16)
                return (
                  (e = this.cache.slice(0, 16)),
                  (this.cache = this.cache.slice(16)),
                  e
                );
            } else if (this.cache.length >= 16)
              return (
                (e = this.cache.slice(0, 16)),
                (this.cache = this.cache.slice(16)),
                e
              );
            return null;
          }),
          (h.prototype.flush = function () {
            if (this.cache.length) return this.cache;
          }),
          (e.createDecipher = function (t, e) {
            var r = o[t.toLowerCase()];
            if (!r) throw new TypeError("invalid suite type");
            var n = c(e, !1, r.key, r.iv);
            return l(t, n.key, n.iv);
          }),
          (e.createDecipheriv = l);
      },
      25799: (t, e, r) => {
        var n = r(530),
          i = r(92356),
          o = r(92861).Buffer,
          s = r(50650),
          a = r(56168),
          u = r(50462),
          c = r(68078);
        function f(t, e, r) {
          a.call(this),
            (this._cache = new l()),
            (this._cipher = new u.AES(e)),
            (this._prev = o.from(r)),
            (this._mode = t),
            (this._autopadding = !0);
        }
        r(56698)(f, a),
          (f.prototype._update = function (t) {
            var e, r;
            this._cache.add(t);
            for (var n = []; (e = this._cache.get()); )
              (r = this._mode.encrypt(this, e)), n.push(r);
            return o.concat(n);
          });
        var h = o.alloc(16, 16);
        function l() {
          this.cache = o.allocUnsafe(0);
        }
        function d(t, e, r) {
          var a = n[t.toLowerCase()];
          if (!a) throw new TypeError("invalid suite type");
          if (("string" == typeof e && (e = o.from(e)), e.length !== a.key / 8))
            throw new TypeError("invalid key length " + e.length);
          if (
            ("string" == typeof r && (r = o.from(r)),
            "GCM" !== a.mode && r.length !== a.iv)
          )
            throw new TypeError("invalid iv length " + r.length);
          return "stream" === a.type
            ? new s(a.module, e, r)
            : "auth" === a.type
              ? new i(a.module, e, r)
              : new f(a.module, e, r);
        }
        (f.prototype._final = function () {
          var t = this._cache.flush();
          if (this._autopadding)
            return (t = this._mode.encrypt(this, t)), this._cipher.scrub(), t;
          if (!t.equals(h))
            throw (
              (this._cipher.scrub(),
              new Error("data not multiple of block length"))
            );
        }),
          (f.prototype.setAutoPadding = function (t) {
            return (this._autopadding = !!t), this;
          }),
          (l.prototype.add = function (t) {
            this.cache = o.concat([this.cache, t]);
          }),
          (l.prototype.get = function () {
            if (this.cache.length > 15) {
              var t = this.cache.slice(0, 16);
              return (this.cache = this.cache.slice(16)), t;
            }
            return null;
          }),
          (l.prototype.flush = function () {
            for (
              var t = 16 - this.cache.length, e = o.allocUnsafe(t), r = -1;
              ++r < t;

            )
              e.writeUInt8(t, r);
            return o.concat([this.cache, e]);
          }),
          (e.createCipheriv = d),
          (e.createCipher = function (t, e) {
            var r = n[t.toLowerCase()];
            if (!r) throw new TypeError("invalid suite type");
            var i = c(e, !1, r.key, r.iv);
            return d(t, i.key, i.iv);
          });
      },
      25892: (t, e, r) => {
        var n = r(92861).Buffer,
          i = n.alloc(16, 0);
        function o(t) {
          var e = n.allocUnsafe(16);
          return (
            e.writeUInt32BE(t[0] >>> 0, 0),
            e.writeUInt32BE(t[1] >>> 0, 4),
            e.writeUInt32BE(t[2] >>> 0, 8),
            e.writeUInt32BE(t[3] >>> 0, 12),
            e
          );
        }
        function s(t) {
          (this.h = t),
            (this.state = n.alloc(16, 0)),
            (this.cache = n.allocUnsafe(0));
        }
        (s.prototype.ghash = function (t) {
          for (var e = -1; ++e < t.length; ) this.state[e] ^= t[e];
          this._multiply();
        }),
          (s.prototype._multiply = function () {
            for (
              var t,
                e,
                r,
                n = [
                  (t = this.h).readUInt32BE(0),
                  t.readUInt32BE(4),
                  t.readUInt32BE(8),
                  t.readUInt32BE(12),
                ],
                i = [0, 0, 0, 0],
                s = -1;
              ++s < 128;

            ) {
              for (
                !!(this.state[~~(s / 8)] & (1 << (7 - (s % 8)))) &&
                  ((i[0] ^= n[0]),
                  (i[1] ^= n[1]),
                  (i[2] ^= n[2]),
                  (i[3] ^= n[3])),
                  r = !!(1 & n[3]),
                  e = 3;
                e > 0;
                e--
              )
                n[e] = (n[e] >>> 1) | ((1 & n[e - 1]) << 31);
              (n[0] = n[0] >>> 1), r && (n[0] = n[0] ^ (225 << 24));
            }
            this.state = o(i);
          }),
          (s.prototype.update = function (t) {
            var e;
            for (
              this.cache = n.concat([this.cache, t]);
              this.cache.length >= 16;

            )
              (e = this.cache.slice(0, 16)),
                (this.cache = this.cache.slice(16)),
                this.ghash(e);
          }),
          (s.prototype.final = function (t, e) {
            return (
              this.cache.length && this.ghash(n.concat([this.cache, i], 16)),
              this.ghash(o([0, t, 0, e])),
              this.state
            );
          }),
          (t.exports = s);
      },
      45122: (t) => {
        t.exports = function (t) {
          for (var e, r = t.length; r--; ) {
            if (255 !== (e = t.readUInt8(r))) {
              e++, t.writeUInt8(e, r);
              break;
            }
            t.writeUInt8(0, r);
          }
        };
      },
      92884: (t, e, r) => {
        var n = r(30295);
        (e.encrypt = function (t, e) {
          var r = n(e, t._prev);
          return (t._prev = t._cipher.encryptBlock(r)), t._prev;
        }),
          (e.decrypt = function (t, e) {
            var r = t._prev;
            t._prev = e;
            var i = t._cipher.decryptBlock(e);
            return n(i, r);
          });
      },
      46383: (t, e, r) => {
        var n = r(92861).Buffer,
          i = r(30295);
        function o(t, e, r) {
          var o = e.length,
            s = i(e, t._cache);
          return (
            (t._cache = t._cache.slice(o)),
            (t._prev = n.concat([t._prev, r ? e : s])),
            s
          );
        }
        e.encrypt = function (t, e, r) {
          for (var i, s = n.allocUnsafe(0); e.length; ) {
            if (
              (0 === t._cache.length &&
                ((t._cache = t._cipher.encryptBlock(t._prev)),
                (t._prev = n.allocUnsafe(0))),
              !(t._cache.length <= e.length))
            ) {
              s = n.concat([s, o(t, e, r)]);
              break;
            }
            (i = t._cache.length),
              (s = n.concat([s, o(t, e.slice(0, i), r)])),
              (e = e.slice(i));
          }
          return s;
        };
      },
      55264: (t, e, r) => {
        var n = r(92861).Buffer;
        function i(t, e, r) {
          for (var n, i, s = -1, a = 0; ++s < 8; )
            (n = e & (1 << (7 - s)) ? 128 : 0),
              (a +=
                (128 & (i = t._cipher.encryptBlock(t._prev)[0] ^ n)) >> s % 8),
              (t._prev = o(t._prev, r ? n : i));
          return a;
        }
        function o(t, e) {
          var r = t.length,
            i = -1,
            o = n.allocUnsafe(t.length);
          for (t = n.concat([t, n.from([e])]); ++i < r; )
            o[i] = (t[i] << 1) | (t[i + 1] >> 7);
          return o;
        }
        e.encrypt = function (t, e, r) {
          for (var o = e.length, s = n.allocUnsafe(o), a = -1; ++a < o; )
            s[a] = i(t, e[a], r);
          return s;
        };
      },
      86975: (t, e, r) => {
        var n = r(92861).Buffer;
        function i(t, e, r) {
          var i = t._cipher.encryptBlock(t._prev)[0] ^ e;
          return (
            (t._prev = n.concat([t._prev.slice(1), n.from([r ? e : i])])), i
          );
        }
        e.encrypt = function (t, e, r) {
          for (var o = e.length, s = n.allocUnsafe(o), a = -1; ++a < o; )
            s[a] = i(t, e[a], r);
          return s;
        };
      },
      63053: (t, e, r) => {
        var n = r(30295),
          i = r(92861).Buffer,
          o = r(45122);
        function s(t) {
          var e = t._cipher.encryptBlockRaw(t._prev);
          return o(t._prev), e;
        }
        e.encrypt = function (t, e) {
          var r = Math.ceil(e.length / 16),
            o = t._cache.length;
          t._cache = i.concat([t._cache, i.allocUnsafe(16 * r)]);
          for (var a = 0; a < r; a++) {
            var u = s(t),
              c = o + 16 * a;
            t._cache.writeUInt32BE(u[0], c + 0),
              t._cache.writeUInt32BE(u[1], c + 4),
              t._cache.writeUInt32BE(u[2], c + 8),
              t._cache.writeUInt32BE(u[3], c + 12);
          }
          var f = t._cache.slice(0, e.length);
          return (t._cache = t._cache.slice(e.length)), n(e, f);
        };
      },
      52632: (t, e) => {
        (e.encrypt = function (t, e) {
          return t._cipher.encryptBlock(e);
        }),
          (e.decrypt = function (t, e) {
            return t._cipher.decryptBlock(e);
          });
      },
      530: (t, e, r) => {
        var n = {
            ECB: r(52632),
            CBC: r(92884),
            CFB: r(46383),
            CFB8: r(86975),
            CFB1: r(55264),
            OFB: r(46843),
            CTR: r(63053),
            GCM: r(63053),
          },
          i = r(3219);
        for (var o in i) i[o].module = n[i[o].mode];
        t.exports = i;
      },
      46843: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(30295);
        function o(t) {
          return (t._prev = t._cipher.encryptBlock(t._prev)), t._prev;
        }
        e.encrypt = function (t, e) {
          for (; t._cache.length < e.length; )
            t._cache = n.concat([t._cache, o(t)]);
          var r = t._cache.slice(0, e.length);
          return (t._cache = t._cache.slice(e.length)), i(e, r);
        };
      },
      50650: (t, e, r) => {
        var n = r(50462),
          i = r(92861).Buffer,
          o = r(56168);
        function s(t, e, r, s) {
          o.call(this),
            (this._cipher = new n.AES(e)),
            (this._prev = i.from(r)),
            (this._cache = i.allocUnsafe(0)),
            (this._secCache = i.allocUnsafe(0)),
            (this._decrypt = s),
            (this._mode = t);
        }
        r(56698)(s, o),
          (s.prototype._update = function (t) {
            return this._mode.encrypt(this, t, this._decrypt);
          }),
          (s.prototype._final = function () {
            this._cipher.scrub();
          }),
          (t.exports = s);
      },
      30125: (t, e, r) => {
        var n = r(84050),
          i = r(1241),
          o = r(530),
          s = r(32438),
          a = r(68078);
        function u(t, e, r) {
          if (((t = t.toLowerCase()), o[t])) return i.createCipheriv(t, e, r);
          if (s[t]) return new n({ key: e, iv: r, mode: t });
          throw new TypeError("invalid suite type");
        }
        function c(t, e, r) {
          if (((t = t.toLowerCase()), o[t])) return i.createDecipheriv(t, e, r);
          if (s[t]) return new n({ key: e, iv: r, mode: t, decrypt: !0 });
          throw new TypeError("invalid suite type");
        }
        (e.createCipher = e.Cipher =
          function (t, e) {
            var r, n;
            if (((t = t.toLowerCase()), o[t])) (r = o[t].key), (n = o[t].iv);
            else {
              if (!s[t]) throw new TypeError("invalid suite type");
              (r = 8 * s[t].key), (n = s[t].iv);
            }
            var i = a(e, !1, r, n);
            return u(t, i.key, i.iv);
          }),
          (e.createCipheriv = e.Cipheriv = u),
          (e.createDecipher = e.Decipher =
            function (t, e) {
              var r, n;
              if (((t = t.toLowerCase()), o[t])) (r = o[t].key), (n = o[t].iv);
              else {
                if (!s[t]) throw new TypeError("invalid suite type");
                (r = 8 * s[t].key), (n = s[t].iv);
              }
              var i = a(e, !1, r, n);
              return c(t, i.key, i.iv);
            }),
          (e.createDecipheriv = e.Decipheriv = c),
          (e.listCiphers = e.getCiphers =
            function () {
              return Object.keys(s).concat(i.getCiphers());
            });
      },
      84050: (t, e, r) => {
        var n = r(56168),
          i = r(29560),
          o = r(56698),
          s = r(92861).Buffer,
          a = {
            "des-ede3-cbc": i.CBC.instantiate(i.EDE),
            "des-ede3": i.EDE,
            "des-ede-cbc": i.CBC.instantiate(i.EDE),
            "des-ede": i.EDE,
            "des-cbc": i.CBC.instantiate(i.DES),
            "des-ecb": i.DES,
          };
        function u(t) {
          n.call(this);
          var e,
            r = t.mode.toLowerCase(),
            i = a[r];
          e = t.decrypt ? "decrypt" : "encrypt";
          var o = t.key;
          s.isBuffer(o) || (o = s.from(o)),
            ("des-ede" !== r && "des-ede-cbc" !== r) ||
              (o = s.concat([o, o.slice(0, 8)]));
          var u = t.iv;
          s.isBuffer(u) || (u = s.from(u)),
            (this._des = i.create({ key: o, iv: u, type: e }));
        }
        (a.des = a["des-cbc"]),
          (a.des3 = a["des-ede3-cbc"]),
          (t.exports = u),
          o(u, n),
          (u.prototype._update = function (t) {
            return s.from(this._des.update(t));
          }),
          (u.prototype._final = function () {
            return s.from(this._des.final());
          });
      },
      32438: (t, e) => {
        (e["des-ecb"] = { key: 8, iv: 0 }),
          (e["des-cbc"] = e.des = { key: 8, iv: 8 }),
          (e["des-ede3-cbc"] = e.des3 = { key: 24, iv: 8 }),
          (e["des-ede3"] = { key: 24, iv: 0 }),
          (e["des-ede-cbc"] = { key: 16, iv: 8 }),
          (e["des-ede"] = { key: 16, iv: 0 });
      },
      67332: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(39404),
          o = r(53209);
        function s(t) {
          var e,
            r = t.modulus.byteLength();
          do {
            e = new i(o(r));
          } while (
            e.cmp(t.modulus) >= 0 ||
            !e.umod(t.prime1) ||
            !e.umod(t.prime2)
          );
          return e;
        }
        function a(t, e) {
          var r = (function (t) {
              var e = s(t);
              return {
                blinder: e
                  .toRed(i.mont(t.modulus))
                  .redPow(new i(t.publicExponent))
                  .fromRed(),
                unblinder: e.invm(t.modulus),
              };
            })(e),
            o = e.modulus.byteLength(),
            a = new i(t).mul(r.blinder).umod(e.modulus),
            u = a.toRed(i.mont(e.prime1)),
            c = a.toRed(i.mont(e.prime2)),
            f = e.coefficient,
            h = e.prime1,
            l = e.prime2,
            d = u.redPow(e.exponent1).fromRed(),
            p = c.redPow(e.exponent2).fromRed(),
            y = d.isub(p).imul(f).umod(h).imul(l);
          return p
            .iadd(y)
            .imul(r.unblinder)
            .umod(e.modulus)
            .toArrayLike(n, "be", o);
        }
        (a.getr = s), (t.exports = a);
      },
      55715: (t, e, r) => {
        "use strict";
        t.exports = r(62951);
      },
      20: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(47108),
          o = r(28399),
          s = r(56698),
          a = r(35359),
          u = r(74847),
          c = r(62951);
        function f(t) {
          o.Writable.call(this);
          var e = c[t];
          if (!e) throw new Error("Unknown message digest");
          (this._hashType = e.hash),
            (this._hash = i(e.hash)),
            (this._tag = e.id),
            (this._signType = e.sign);
        }
        function h(t) {
          o.Writable.call(this);
          var e = c[t];
          if (!e) throw new Error("Unknown message digest");
          (this._hash = i(e.hash)),
            (this._tag = e.id),
            (this._signType = e.sign);
        }
        function l(t) {
          return new f(t);
        }
        function d(t) {
          return new h(t);
        }
        Object.keys(c).forEach(function (t) {
          (c[t].id = n.from(c[t].id, "hex")), (c[t.toLowerCase()] = c[t]);
        }),
          s(f, o.Writable),
          (f.prototype._write = function (t, e, r) {
            this._hash.update(t), r();
          }),
          (f.prototype.update = function (t, e) {
            return (
              this._hash.update("string" == typeof t ? n.from(t, e) : t), this
            );
          }),
          (f.prototype.sign = function (t, e) {
            this.end();
            var r = this._hash.digest(),
              n = a(r, t, this._hashType, this._signType, this._tag);
            return e ? n.toString(e) : n;
          }),
          s(h, o.Writable),
          (h.prototype._write = function (t, e, r) {
            this._hash.update(t), r();
          }),
          (h.prototype.update = function (t, e) {
            return (
              this._hash.update("string" == typeof t ? n.from(t, e) : t), this
            );
          }),
          (h.prototype.verify = function (t, e, r) {
            var i = "string" == typeof e ? n.from(e, r) : e;
            this.end();
            var o = this._hash.digest();
            return u(i, o, t, this._signType, this._tag);
          }),
          (t.exports = { Sign: l, Verify: d, createSign: l, createVerify: d });
      },
      35359: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(83507),
          o = r(67332),
          s = r(86729).ec,
          a = r(39404),
          u = r(78170),
          c = r(64589);
        function f(t, e, r, o) {
          if ((t = n.from(t.toArray())).length < e.byteLength()) {
            var s = n.alloc(e.byteLength() - t.length);
            t = n.concat([s, t]);
          }
          var a = r.length,
            u = (function (t, e) {
              (t = h(t, e)), (t = t.mod(e));
              var r = n.from(t.toArray());
              if (r.length < e.byteLength()) {
                var i = n.alloc(e.byteLength() - r.length);
                r = n.concat([i, r]);
              }
              return r;
            })(r, e),
            c = n.alloc(a);
          c.fill(1);
          var f = n.alloc(a);
          return (
            (f = i(o, f)
              .update(c)
              .update(n.from([0]))
              .update(t)
              .update(u)
              .digest()),
            (c = i(o, f).update(c).digest()),
            {
              k: (f = i(o, f)
                .update(c)
                .update(n.from([1]))
                .update(t)
                .update(u)
                .digest()),
              v: (c = i(o, f).update(c).digest()),
            }
          );
        }
        function h(t, e) {
          var r = new a(t),
            n = (t.length << 3) - e.bitLength();
          return n > 0 && r.ishrn(n), r;
        }
        function l(t, e, r) {
          var o, s;
          do {
            for (o = n.alloc(0); 8 * o.length < t.bitLength(); )
              (e.v = i(r, e.k).update(e.v).digest()), (o = n.concat([o, e.v]));
            (s = h(o, t)),
              (e.k = i(r, e.k)
                .update(e.v)
                .update(n.from([0]))
                .digest()),
              (e.v = i(r, e.k).update(e.v).digest());
          } while (-1 !== s.cmp(t));
          return s;
        }
        function d(t, e, r, n) {
          return t.toRed(a.mont(r)).redPow(e).fromRed().mod(n);
        }
        (t.exports = function (t, e, r, i, p) {
          var y = u(e);
          if (y.curve) {
            if ("ecdsa" !== i && "ecdsa/rsa" !== i)
              throw new Error("wrong private key type");
            return (function (t, e) {
              var r = c[e.curve.join(".")];
              if (!r) throw new Error("unknown curve " + e.curve.join("."));
              var i = new s(r).keyFromPrivate(e.privateKey),
                o = i.sign(t);
              return n.from(o.toDER());
            })(t, y);
          }
          if ("dsa" === y.type) {
            if ("dsa" !== i) throw new Error("wrong private key type");
            return (function (t, e, r) {
              var i,
                o = e.params.priv_key,
                s = e.params.p,
                u = e.params.q,
                c = e.params.g,
                p = new a(0),
                y = h(t, u).mod(u),
                g = !1,
                m = f(o, u, t, r);
              for (; !1 === g; )
                (p = d(c, (i = l(u, m, r)), s, u)),
                  0 ===
                    (g = i
                      .invm(u)
                      .imul(y.add(o.mul(p)))
                      .mod(u)).cmpn(0) && ((g = !1), (p = new a(0)));
              return (function (t, e) {
                (t = t.toArray()),
                  (e = e.toArray()),
                  128 & t[0] && (t = [0].concat(t));
                128 & e[0] && (e = [0].concat(e));
                var r = t.length + e.length + 4,
                  i = [48, r, 2, t.length];
                return (i = i.concat(t, [2, e.length], e)), n.from(i);
              })(p, g);
            })(t, y, r);
          }
          if ("rsa" !== i && "ecdsa/rsa" !== i)
            throw new Error("wrong private key type");
          if (void 0 !== e.padding && 1 !== e.padding)
            throw new Error("illegal or unsupported padding mode");
          t = n.concat([p, t]);
          for (
            var g = y.modulus.byteLength(), m = [0, 1];
            t.length + m.length + 1 < g;

          )
            m.push(255);
          m.push(0);
          for (var b = -1; ++b < t.length; ) m.push(t[b]);
          return o(m, y);
        }),
          (t.exports.getKey = f),
          (t.exports.makeKey = l);
      },
      74847: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(39404),
          o = r(86729).ec,
          s = r(78170),
          a = r(64589);
        function u(t, e) {
          if (t.cmpn(0) <= 0) throw new Error("invalid sig");
          if (t.cmp(e) >= 0) throw new Error("invalid sig");
        }
        t.exports = function (t, e, r, c, f) {
          var h = s(r);
          if ("ec" === h.type) {
            if ("ecdsa" !== c && "ecdsa/rsa" !== c)
              throw new Error("wrong public key type");
            return (function (t, e, r) {
              var n = a[r.data.algorithm.curve.join(".")];
              if (!n)
                throw new Error(
                  "unknown curve " + r.data.algorithm.curve.join("."),
                );
              var i = new o(n),
                s = r.data.subjectPrivateKey.data;
              return i.verify(e, t, s);
            })(t, e, h);
          }
          if ("dsa" === h.type) {
            if ("dsa" !== c) throw new Error("wrong public key type");
            return (function (t, e, r) {
              var n = r.data.p,
                o = r.data.q,
                a = r.data.g,
                c = r.data.pub_key,
                f = s.signature.decode(t, "der"),
                h = f.s,
                l = f.r;
              u(h, o), u(l, o);
              var d = i.mont(n),
                p = h.invm(o),
                y = a
                  .toRed(d)
                  .redPow(new i(e).mul(p).mod(o))
                  .fromRed()
                  .mul(c.toRed(d).redPow(l.mul(p).mod(o)).fromRed())
                  .mod(n)
                  .mod(o);
              return 0 === y.cmp(l);
            })(t, e, h);
          }
          if ("rsa" !== c && "ecdsa/rsa" !== c)
            throw new Error("wrong public key type");
          e = n.concat([f, e]);
          for (
            var l = h.modulus.byteLength(), d = [1], p = 0;
            e.length + d.length + 2 < l;

          )
            d.push(255), (p += 1);
          d.push(0);
          for (var y = -1; ++y < e.length; ) d.push(e[y]);
          d = n.from(d);
          var g = i.mont(h.modulus);
          (t = (t = new i(t).toRed(g)).redPow(new i(h.publicExponent))),
            (t = n.from(t.fromRed().toArray()));
          var m = p < 8 ? 1 : 0;
          for (
            l = Math.min(t.length, d.length),
              t.length !== d.length && (m = 1),
              y = -1;
            ++y < l;

          )
            m |= t[y] ^ d[y];
          return 0 === m;
        };
      },
      16763: (t, e, r) => {
        const n = r(95364);
        t.exports = n(
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        );
      },
      59204: (t, e, r) => {
        "use strict";
        var n = r(1191),
          i = r(92861).Buffer;
        t.exports = function (t) {
          function e(e) {
            var r = e.slice(0, -4),
              n = e.slice(-4),
              i = t(r);
            if (
              !((n[0] ^ i[0]) | (n[1] ^ i[1]) | (n[2] ^ i[2]) | (n[3] ^ i[3]))
            )
              return r;
          }
          return {
            encode: function (e) {
              var r = t(e);
              return n.encode(i.concat([e, r], e.length + 4));
            },
            decode: function (t) {
              var r = e(n.decode(t));
              if (!r) throw new Error("Invalid checksum");
              return r;
            },
            decodeUnsafe: function (t) {
              var r = n.decodeUnsafe(t);
              if (r) return e(r);
            },
          };
        };
      },
      91889: (t, e, r) => {
        "use strict";
        var n = r(47108),
          i = r(59204);
        t.exports = i(function (t) {
          var e = n("sha256").update(t).digest();
          return n("sha256").update(e).digest();
        });
      },
      91648: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer;
        t.exports = function (t) {
          if (t.length >= 255) throw new TypeError("Alphabet too long");
          for (var e = new Uint8Array(256), r = 0; r < e.length; r++)
            e[r] = 255;
          for (var i = 0; i < t.length; i++) {
            var o = t.charAt(i),
              s = o.charCodeAt(0);
            if (255 !== e[s]) throw new TypeError(o + " is ambiguous");
            e[s] = i;
          }
          var a = t.length,
            u = t.charAt(0),
            c = Math.log(a) / Math.log(256),
            f = Math.log(256) / Math.log(a);
          function h(t) {
            if ("string" != typeof t) throw new TypeError("Expected String");
            if (0 === t.length) return n.alloc(0);
            for (var r = 0, i = 0, o = 0; t[r] === u; ) i++, r++;
            for (
              var s = ((t.length - r) * c + 1) >>> 0, f = new Uint8Array(s);
              r < t.length;

            ) {
              var h = e[t.charCodeAt(r)];
              if (255 === h) return;
              for (
                var l = 0, d = s - 1;
                (0 !== h || l < o) && -1 !== d;
                d--, l++
              )
                (h += (a * f[d]) >>> 0),
                  (f[d] = h % 256 >>> 0),
                  (h = (h / 256) >>> 0);
              if (0 !== h) throw new Error("Non-zero carry");
              (o = l), r++;
            }
            for (var p = s - o; p !== s && 0 === f[p]; ) p++;
            var y = n.allocUnsafe(i + (s - p));
            y.fill(0, 0, i);
            for (var g = i; p !== s; ) y[g++] = f[p++];
            return y;
          }
          return {
            encode: function (e) {
              if (
                ((Array.isArray(e) || e instanceof Uint8Array) &&
                  (e = n.from(e)),
                !n.isBuffer(e))
              )
                throw new TypeError("Expected Buffer");
              if (0 === e.length) return "";
              for (
                var r = 0, i = 0, o = 0, s = e.length;
                o !== s && 0 === e[o];

              )
                o++, r++;
              for (
                var c = ((s - o) * f + 1) >>> 0, h = new Uint8Array(c);
                o !== s;

              ) {
                for (
                  var l = e[o], d = 0, p = c - 1;
                  (0 !== l || d < i) && -1 !== p;
                  p--, d++
                )
                  (l += (256 * h[p]) >>> 0),
                    (h[p] = l % a >>> 0),
                    (l = (l / a) >>> 0);
                if (0 !== l) throw new Error("Non-zero carry");
                (i = d), o++;
              }
              for (var y = c - i; y !== c && 0 === h[y]; ) y++;
              for (var g = u.repeat(r); y < c; ++y) g += t.charAt(h[y]);
              return g;
            },
            decodeUnsafe: h,
            decode: function (t) {
              var e = h(t);
              if (e) return e;
              throw new Error("Non-base" + a + " character");
            },
          };
        };
      },
      1191: (t, e, r) => {
        var n = r(91648);
        t.exports = n(
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        );
      },
      65699: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        t.exports = function (t, e) {
          if (!n.isBuffer(t) || !n.isBuffer(e))
            throw new TypeError("Arguments must be Buffers");
          if (t === e) return !0;
          if ("function" == typeof t.equals) return t.equals(e);
          if (t.length !== e.length) return !1;
          for (var r = 0; r < t.length; r++) if (t[r] !== e[r]) return !1;
          return !0;
        };
      },
      30295: (t, e, r) => {
        var n = r(48287).Buffer;
        t.exports = function (t, e) {
          for (
            var r = Math.min(t.length, e.length), i = new n(r), o = 0;
            o < r;
            ++o
          )
            i[o] = t[o] ^ e[o];
          return i;
        };
      },
      48287: (t, e, r) => {
        "use strict";
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */ const n = r(67526),
          i = r(251),
          o =
            "function" == typeof Symbol && "function" == typeof Symbol.for
              ? Symbol.for("nodejs.util.inspect.custom")
              : null;
        (e.Buffer = u),
          (e.SlowBuffer = function (t) {
            +t != t && (t = 0);
            return u.alloc(+t);
          }),
          (e.INSPECT_MAX_BYTES = 50);
        const s = 2147483647;
        function a(t) {
          if (t > s)
            throw new RangeError(
              'The value "' + t + '" is invalid for option "size"',
            );
          const e = new Uint8Array(t);
          return Object.setPrototypeOf(e, u.prototype), e;
        }
        function u(t, e, r) {
          if ("number" == typeof t) {
            if ("string" == typeof e)
              throw new TypeError(
                'The "string" argument must be of type string. Received type number',
              );
            return h(t);
          }
          return c(t, e, r);
        }
        function c(t, e, r) {
          if ("string" == typeof t)
            return (function (t, e) {
              ("string" == typeof e && "" !== e) || (e = "utf8");
              if (!u.isEncoding(e))
                throw new TypeError("Unknown encoding: " + e);
              const r = 0 | y(t, e);
              let n = a(r);
              const i = n.write(t, e);
              i !== r && (n = n.slice(0, i));
              return n;
            })(t, e);
          if (ArrayBuffer.isView(t))
            return (function (t) {
              if (Y(t, Uint8Array)) {
                const e = new Uint8Array(t);
                return d(e.buffer, e.byteOffset, e.byteLength);
              }
              return l(t);
            })(t);
          if (null == t)
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof t,
            );
          if (Y(t, ArrayBuffer) || (t && Y(t.buffer, ArrayBuffer)))
            return d(t, e, r);
          if (
            "undefined" != typeof SharedArrayBuffer &&
            (Y(t, SharedArrayBuffer) || (t && Y(t.buffer, SharedArrayBuffer)))
          )
            return d(t, e, r);
          if ("number" == typeof t)
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number',
            );
          const n = t.valueOf && t.valueOf();
          if (null != n && n !== t) return u.from(n, e, r);
          const i = (function (t) {
            if (u.isBuffer(t)) {
              const e = 0 | p(t.length),
                r = a(e);
              return 0 === r.length || t.copy(r, 0, 0, e), r;
            }
            if (void 0 !== t.length)
              return "number" != typeof t.length || X(t.length) ? a(0) : l(t);
            if ("Buffer" === t.type && Array.isArray(t.data)) return l(t.data);
          })(t);
          if (i) return i;
          if (
            "undefined" != typeof Symbol &&
            null != Symbol.toPrimitive &&
            "function" == typeof t[Symbol.toPrimitive]
          )
            return u.from(t[Symbol.toPrimitive]("string"), e, r);
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof t,
          );
        }
        function f(t) {
          if ("number" != typeof t)
            throw new TypeError('"size" argument must be of type number');
          if (t < 0)
            throw new RangeError(
              'The value "' + t + '" is invalid for option "size"',
            );
        }
        function h(t) {
          return f(t), a(t < 0 ? 0 : 0 | p(t));
        }
        function l(t) {
          const e = t.length < 0 ? 0 : 0 | p(t.length),
            r = a(e);
          for (let n = 0; n < e; n += 1) r[n] = 255 & t[n];
          return r;
        }
        function d(t, e, r) {
          if (e < 0 || t.byteLength < e)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (t.byteLength < e + (r || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          let n;
          return (
            (n =
              void 0 === e && void 0 === r
                ? new Uint8Array(t)
                : void 0 === r
                  ? new Uint8Array(t, e)
                  : new Uint8Array(t, e, r)),
            Object.setPrototypeOf(n, u.prototype),
            n
          );
        }
        function p(t) {
          if (t >= s)
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum size: 0x" +
                s.toString(16) +
                " bytes",
            );
          return 0 | t;
        }
        function y(t, e) {
          if (u.isBuffer(t)) return t.length;
          if (ArrayBuffer.isView(t) || Y(t, ArrayBuffer)) return t.byteLength;
          if ("string" != typeof t)
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof t,
            );
          const r = t.length,
            n = arguments.length > 2 && !0 === arguments[2];
          if (!n && 0 === r) return 0;
          let i = !1;
          for (;;)
            switch (e) {
              case "ascii":
              case "latin1":
              case "binary":
                return r;
              case "utf8":
              case "utf-8":
                return $(t).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r;
              case "hex":
                return r >>> 1;
              case "base64":
                return G(t).length;
              default:
                if (i) return n ? -1 : $(t).length;
                (e = ("" + e).toLowerCase()), (i = !0);
            }
        }
        function g(t, e, r) {
          let n = !1;
          if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
          if (((void 0 === r || r > this.length) && (r = this.length), r <= 0))
            return "";
          if ((r >>>= 0) <= (e >>>= 0)) return "";
          for (t || (t = "utf8"); ; )
            switch (t) {
              case "hex":
                return x(this, e, r);
              case "utf8":
              case "utf-8":
                return A(this, e, r);
              case "ascii":
                return k(this, e, r);
              case "latin1":
              case "binary":
                return O(this, e, r);
              case "base64":
                return M(this, e, r);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return P(this, e, r);
              default:
                if (n) throw new TypeError("Unknown encoding: " + t);
                (t = (t + "").toLowerCase()), (n = !0);
            }
        }
        function m(t, e, r) {
          const n = t[e];
          (t[e] = t[r]), (t[r] = n);
        }
        function b(t, e, r, n, i) {
          if (0 === t.length) return -1;
          if (
            ("string" == typeof r
              ? ((n = r), (r = 0))
              : r > 2147483647
                ? (r = 2147483647)
                : r < -2147483648 && (r = -2147483648),
            X((r = +r)) && (r = i ? 0 : t.length - 1),
            r < 0 && (r = t.length + r),
            r >= t.length)
          ) {
            if (i) return -1;
            r = t.length - 1;
          } else if (r < 0) {
            if (!i) return -1;
            r = 0;
          }
          if (("string" == typeof e && (e = u.from(e, n)), u.isBuffer(e)))
            return 0 === e.length ? -1 : w(t, e, r, n, i);
          if ("number" == typeof e)
            return (
              (e &= 255),
              "function" == typeof Uint8Array.prototype.indexOf
                ? i
                  ? Uint8Array.prototype.indexOf.call(t, e, r)
                  : Uint8Array.prototype.lastIndexOf.call(t, e, r)
                : w(t, [e], r, n, i)
            );
          throw new TypeError("val must be string, number or Buffer");
        }
        function w(t, e, r, n, i) {
          let o,
            s = 1,
            a = t.length,
            u = e.length;
          if (
            void 0 !== n &&
            ("ucs2" === (n = String(n).toLowerCase()) ||
              "ucs-2" === n ||
              "utf16le" === n ||
              "utf-16le" === n)
          ) {
            if (t.length < 2 || e.length < 2) return -1;
            (s = 2), (a /= 2), (u /= 2), (r /= 2);
          }
          function c(t, e) {
            return 1 === s ? t[e] : t.readUInt16BE(e * s);
          }
          if (i) {
            let n = -1;
            for (o = r; o < a; o++)
              if (c(t, o) === c(e, -1 === n ? 0 : o - n)) {
                if ((-1 === n && (n = o), o - n + 1 === u)) return n * s;
              } else -1 !== n && (o -= o - n), (n = -1);
          } else
            for (r + u > a && (r = a - u), o = r; o >= 0; o--) {
              let r = !0;
              for (let n = 0; n < u; n++)
                if (c(t, o + n) !== c(e, n)) {
                  r = !1;
                  break;
                }
              if (r) return o;
            }
          return -1;
        }
        function v(t, e, r, n) {
          r = Number(r) || 0;
          const i = t.length - r;
          n ? (n = Number(n)) > i && (n = i) : (n = i);
          const o = e.length;
          let s;
          for (n > o / 2 && (n = o / 2), s = 0; s < n; ++s) {
            const n = parseInt(e.substr(2 * s, 2), 16);
            if (X(n)) return s;
            t[r + s] = n;
          }
          return s;
        }
        function _(t, e, r, n) {
          return W($(e, t.length - r), t, r, n);
        }
        function E(t, e, r, n) {
          return W(
            (function (t) {
              const e = [];
              for (let r = 0; r < t.length; ++r) e.push(255 & t.charCodeAt(r));
              return e;
            })(e),
            t,
            r,
            n,
          );
        }
        function S(t, e, r, n) {
          return W(G(e), t, r, n);
        }
        function I(t, e, r, n) {
          return W(
            (function (t, e) {
              let r, n, i;
              const o = [];
              for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
                (r = t.charCodeAt(s)),
                  (n = r >> 8),
                  (i = r % 256),
                  o.push(i),
                  o.push(n);
              return o;
            })(e, t.length - r),
            t,
            r,
            n,
          );
        }
        function M(t, e, r) {
          return 0 === e && r === t.length
            ? n.fromByteArray(t)
            : n.fromByteArray(t.slice(e, r));
        }
        function A(t, e, r) {
          r = Math.min(t.length, r);
          const n = [];
          let i = e;
          for (; i < r; ) {
            const e = t[i];
            let o = null,
              s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
            if (i + s <= r) {
              let r, n, a, u;
              switch (s) {
                case 1:
                  e < 128 && (o = e);
                  break;
                case 2:
                  (r = t[i + 1]),
                    128 == (192 & r) &&
                      ((u = ((31 & e) << 6) | (63 & r)), u > 127 && (o = u));
                  break;
                case 3:
                  (r = t[i + 1]),
                    (n = t[i + 2]),
                    128 == (192 & r) &&
                      128 == (192 & n) &&
                      ((u = ((15 & e) << 12) | ((63 & r) << 6) | (63 & n)),
                      u > 2047 && (u < 55296 || u > 57343) && (o = u));
                  break;
                case 4:
                  (r = t[i + 1]),
                    (n = t[i + 2]),
                    (a = t[i + 3]),
                    128 == (192 & r) &&
                      128 == (192 & n) &&
                      128 == (192 & a) &&
                      ((u =
                        ((15 & e) << 18) |
                        ((63 & r) << 12) |
                        ((63 & n) << 6) |
                        (63 & a)),
                      u > 65535 && u < 1114112 && (o = u));
              }
            }
            null === o
              ? ((o = 65533), (s = 1))
              : o > 65535 &&
                ((o -= 65536),
                n.push(((o >>> 10) & 1023) | 55296),
                (o = 56320 | (1023 & o))),
              n.push(o),
              (i += s);
          }
          return (function (t) {
            const e = t.length;
            if (e <= T) return String.fromCharCode.apply(String, t);
            let r = "",
              n = 0;
            for (; n < e; )
              r += String.fromCharCode.apply(String, t.slice(n, (n += T)));
            return r;
          })(n);
        }
        (e.kMaxLength = s),
          (u.TYPED_ARRAY_SUPPORT = (function () {
            try {
              const t = new Uint8Array(1),
                e = {
                  foo: function () {
                    return 42;
                  },
                };
              return (
                Object.setPrototypeOf(e, Uint8Array.prototype),
                Object.setPrototypeOf(t, e),
                42 === t.foo()
              );
            } catch (t) {
              return !1;
            }
          })()),
          u.TYPED_ARRAY_SUPPORT ||
            "undefined" == typeof console ||
            "function" != typeof console.error ||
            console.error(
              "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
            ),
          Object.defineProperty(u.prototype, "parent", {
            enumerable: !0,
            get: function () {
              if (u.isBuffer(this)) return this.buffer;
            },
          }),
          Object.defineProperty(u.prototype, "offset", {
            enumerable: !0,
            get: function () {
              if (u.isBuffer(this)) return this.byteOffset;
            },
          }),
          (u.poolSize = 8192),
          (u.from = function (t, e, r) {
            return c(t, e, r);
          }),
          Object.setPrototypeOf(u.prototype, Uint8Array.prototype),
          Object.setPrototypeOf(u, Uint8Array),
          (u.alloc = function (t, e, r) {
            return (function (t, e, r) {
              return (
                f(t),
                t <= 0
                  ? a(t)
                  : void 0 !== e
                    ? "string" == typeof r
                      ? a(t).fill(e, r)
                      : a(t).fill(e)
                    : a(t)
              );
            })(t, e, r);
          }),
          (u.allocUnsafe = function (t) {
            return h(t);
          }),
          (u.allocUnsafeSlow = function (t) {
            return h(t);
          }),
          (u.isBuffer = function (t) {
            return null != t && !0 === t._isBuffer && t !== u.prototype;
          }),
          (u.compare = function (t, e) {
            if (
              (Y(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
              Y(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)),
              !u.isBuffer(t) || !u.isBuffer(e))
            )
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
              );
            if (t === e) return 0;
            let r = t.length,
              n = e.length;
            for (let i = 0, o = Math.min(r, n); i < o; ++i)
              if (t[i] !== e[i]) {
                (r = t[i]), (n = e[i]);
                break;
              }
            return r < n ? -1 : n < r ? 1 : 0;
          }),
          (u.isEncoding = function (t) {
            switch (String(t).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }),
          (u.concat = function (t, e) {
            if (!Array.isArray(t))
              throw new TypeError(
                '"list" argument must be an Array of Buffers',
              );
            if (0 === t.length) return u.alloc(0);
            let r;
            if (void 0 === e)
              for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
            const n = u.allocUnsafe(e);
            let i = 0;
            for (r = 0; r < t.length; ++r) {
              let e = t[r];
              if (Y(e, Uint8Array))
                i + e.length > n.length
                  ? (u.isBuffer(e) || (e = u.from(e)), e.copy(n, i))
                  : Uint8Array.prototype.set.call(n, e, i);
              else {
                if (!u.isBuffer(e))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers',
                  );
                e.copy(n, i);
              }
              i += e.length;
            }
            return n;
          }),
          (u.byteLength = y),
          (u.prototype._isBuffer = !0),
          (u.prototype.swap16 = function () {
            const t = this.length;
            if (t % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let e = 0; e < t; e += 2) m(this, e, e + 1);
            return this;
          }),
          (u.prototype.swap32 = function () {
            const t = this.length;
            if (t % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let e = 0; e < t; e += 4)
              m(this, e, e + 3), m(this, e + 1, e + 2);
            return this;
          }),
          (u.prototype.swap64 = function () {
            const t = this.length;
            if (t % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let e = 0; e < t; e += 8)
              m(this, e, e + 7),
                m(this, e + 1, e + 6),
                m(this, e + 2, e + 5),
                m(this, e + 3, e + 4);
            return this;
          }),
          (u.prototype.toString = function () {
            const t = this.length;
            return 0 === t
              ? ""
              : 0 === arguments.length
                ? A(this, 0, t)
                : g.apply(this, arguments);
          }),
          (u.prototype.toLocaleString = u.prototype.toString),
          (u.prototype.equals = function (t) {
            if (!u.isBuffer(t))
              throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === u.compare(this, t);
          }),
          (u.prototype.inspect = function () {
            let t = "";
            const r = e.INSPECT_MAX_BYTES;
            return (
              (t = this.toString("hex", 0, r)
                .replace(/(.{2})/g, "$1 ")
                .trim()),
              this.length > r && (t += " ... "),
              "<Buffer " + t + ">"
            );
          }),
          o && (u.prototype[o] = u.prototype.inspect),
          (u.prototype.compare = function (t, e, r, n, i) {
            if (
              (Y(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
              !u.isBuffer(t))
            )
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                  typeof t,
              );
            if (
              (void 0 === e && (e = 0),
              void 0 === r && (r = t ? t.length : 0),
              void 0 === n && (n = 0),
              void 0 === i && (i = this.length),
              e < 0 || r > t.length || n < 0 || i > this.length)
            )
              throw new RangeError("out of range index");
            if (n >= i && e >= r) return 0;
            if (n >= i) return -1;
            if (e >= r) return 1;
            if (this === t) return 0;
            let o = (i >>>= 0) - (n >>>= 0),
              s = (r >>>= 0) - (e >>>= 0);
            const a = Math.min(o, s),
              c = this.slice(n, i),
              f = t.slice(e, r);
            for (let t = 0; t < a; ++t)
              if (c[t] !== f[t]) {
                (o = c[t]), (s = f[t]);
                break;
              }
            return o < s ? -1 : s < o ? 1 : 0;
          }),
          (u.prototype.includes = function (t, e, r) {
            return -1 !== this.indexOf(t, e, r);
          }),
          (u.prototype.indexOf = function (t, e, r) {
            return b(this, t, e, r, !0);
          }),
          (u.prototype.lastIndexOf = function (t, e, r) {
            return b(this, t, e, r, !1);
          }),
          (u.prototype.write = function (t, e, r, n) {
            if (void 0 === e) (n = "utf8"), (r = this.length), (e = 0);
            else if (void 0 === r && "string" == typeof e)
              (n = e), (r = this.length), (e = 0);
            else {
              if (!isFinite(e))
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported",
                );
              (e >>>= 0),
                isFinite(r)
                  ? ((r >>>= 0), void 0 === n && (n = "utf8"))
                  : ((n = r), (r = void 0));
            }
            const i = this.length - e;
            if (
              ((void 0 === r || r > i) && (r = i),
              (t.length > 0 && (r < 0 || e < 0)) || e > this.length)
            )
              throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            let o = !1;
            for (;;)
              switch (n) {
                case "hex":
                  return v(this, t, e, r);
                case "utf8":
                case "utf-8":
                  return _(this, t, e, r);
                case "ascii":
                case "latin1":
                case "binary":
                  return E(this, t, e, r);
                case "base64":
                  return S(this, t, e, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return I(this, t, e, r);
                default:
                  if (o) throw new TypeError("Unknown encoding: " + n);
                  (n = ("" + n).toLowerCase()), (o = !0);
              }
          }),
          (u.prototype.toJSON = function () {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0),
            };
          });
        const T = 4096;
        function k(t, e, r) {
          let n = "";
          r = Math.min(t.length, r);
          for (let i = e; i < r; ++i) n += String.fromCharCode(127 & t[i]);
          return n;
        }
        function O(t, e, r) {
          let n = "";
          r = Math.min(t.length, r);
          for (let i = e; i < r; ++i) n += String.fromCharCode(t[i]);
          return n;
        }
        function x(t, e, r) {
          const n = t.length;
          (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
          let i = "";
          for (let n = e; n < r; ++n) i += Z[t[n]];
          return i;
        }
        function P(t, e, r) {
          const n = t.slice(e, r);
          let i = "";
          for (let t = 0; t < n.length - 1; t += 2)
            i += String.fromCharCode(n[t] + 256 * n[t + 1]);
          return i;
        }
        function B(t, e, r) {
          if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
          if (t + e > r)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function C(t, e, r, n, i, o) {
          if (!u.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (e > i || e < o)
            throw new RangeError('"value" argument is out of bounds');
          if (r + n > t.length) throw new RangeError("Index out of range");
        }
        function R(t, e, r, n, i) {
          K(e, n, i, t, r, 7);
          let o = Number(e & BigInt(4294967295));
          (t[r++] = o),
            (o >>= 8),
            (t[r++] = o),
            (o >>= 8),
            (t[r++] = o),
            (o >>= 8),
            (t[r++] = o);
          let s = Number((e >> BigInt(32)) & BigInt(4294967295));
          return (
            (t[r++] = s),
            (s >>= 8),
            (t[r++] = s),
            (s >>= 8),
            (t[r++] = s),
            (s >>= 8),
            (t[r++] = s),
            r
          );
        }
        function N(t, e, r, n, i) {
          K(e, n, i, t, r, 7);
          let o = Number(e & BigInt(4294967295));
          (t[r + 7] = o),
            (o >>= 8),
            (t[r + 6] = o),
            (o >>= 8),
            (t[r + 5] = o),
            (o >>= 8),
            (t[r + 4] = o);
          let s = Number((e >> BigInt(32)) & BigInt(4294967295));
          return (
            (t[r + 3] = s),
            (s >>= 8),
            (t[r + 2] = s),
            (s >>= 8),
            (t[r + 1] = s),
            (s >>= 8),
            (t[r] = s),
            r + 8
          );
        }
        function U(t, e, r, n, i, o) {
          if (r + n > t.length) throw new RangeError("Index out of range");
          if (r < 0) throw new RangeError("Index out of range");
        }
        function D(t, e, r, n, o) {
          return (
            (e = +e),
            (r >>>= 0),
            o || U(t, 0, r, 4),
            i.write(t, e, r, n, 23, 4),
            r + 4
          );
        }
        function L(t, e, r, n, o) {
          return (
            (e = +e),
            (r >>>= 0),
            o || U(t, 0, r, 8),
            i.write(t, e, r, n, 52, 8),
            r + 8
          );
        }
        (u.prototype.slice = function (t, e) {
          const r = this.length;
          (t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            (e = void 0 === e ? r : ~~e) < 0
              ? (e += r) < 0 && (e = 0)
              : e > r && (e = r),
            e < t && (e = t);
          const n = this.subarray(t, e);
          return Object.setPrototypeOf(n, u.prototype), n;
        }),
          (u.prototype.readUintLE = u.prototype.readUIntLE =
            function (t, e, r) {
              (t >>>= 0), (e >>>= 0), r || B(t, e, this.length);
              let n = this[t],
                i = 1,
                o = 0;
              for (; ++o < e && (i *= 256); ) n += this[t + o] * i;
              return n;
            }),
          (u.prototype.readUintBE = u.prototype.readUIntBE =
            function (t, e, r) {
              (t >>>= 0), (e >>>= 0), r || B(t, e, this.length);
              let n = this[t + --e],
                i = 1;
              for (; e > 0 && (i *= 256); ) n += this[t + --e] * i;
              return n;
            }),
          (u.prototype.readUint8 = u.prototype.readUInt8 =
            function (t, e) {
              return (t >>>= 0), e || B(t, 1, this.length), this[t];
            }),
          (u.prototype.readUint16LE = u.prototype.readUInt16LE =
            function (t, e) {
              return (
                (t >>>= 0),
                e || B(t, 2, this.length),
                this[t] | (this[t + 1] << 8)
              );
            }),
          (u.prototype.readUint16BE = u.prototype.readUInt16BE =
            function (t, e) {
              return (
                (t >>>= 0),
                e || B(t, 2, this.length),
                (this[t] << 8) | this[t + 1]
              );
            }),
          (u.prototype.readUint32LE = u.prototype.readUInt32LE =
            function (t, e) {
              return (
                (t >>>= 0),
                e || B(t, 4, this.length),
                (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                  16777216 * this[t + 3]
              );
            }),
          (u.prototype.readUint32BE = u.prototype.readUInt32BE =
            function (t, e) {
              return (
                (t >>>= 0),
                e || B(t, 4, this.length),
                16777216 * this[t] +
                  ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
              );
            }),
          (u.prototype.readBigUInt64LE = J(function (t) {
            V((t >>>= 0), "offset");
            const e = this[t],
              r = this[t + 7];
            (void 0 !== e && void 0 !== r) || q(t, this.length - 8);
            const n =
                e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
              i = this[++t] + 256 * this[++t] + 65536 * this[++t] + r * 2 ** 24;
            return BigInt(n) + (BigInt(i) << BigInt(32));
          })),
          (u.prototype.readBigUInt64BE = J(function (t) {
            V((t >>>= 0), "offset");
            const e = this[t],
              r = this[t + 7];
            (void 0 !== e && void 0 !== r) || q(t, this.length - 8);
            const n =
                e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
              i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r;
            return (BigInt(n) << BigInt(32)) + BigInt(i);
          })),
          (u.prototype.readIntLE = function (t, e, r) {
            (t >>>= 0), (e >>>= 0), r || B(t, e, this.length);
            let n = this[t],
              i = 1,
              o = 0;
            for (; ++o < e && (i *= 256); ) n += this[t + o] * i;
            return (i *= 128), n >= i && (n -= Math.pow(2, 8 * e)), n;
          }),
          (u.prototype.readIntBE = function (t, e, r) {
            (t >>>= 0), (e >>>= 0), r || B(t, e, this.length);
            let n = e,
              i = 1,
              o = this[t + --n];
            for (; n > 0 && (i *= 256); ) o += this[t + --n] * i;
            return (i *= 128), o >= i && (o -= Math.pow(2, 8 * e)), o;
          }),
          (u.prototype.readInt8 = function (t, e) {
            return (
              (t >>>= 0),
              e || B(t, 1, this.length),
              128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            );
          }),
          (u.prototype.readInt16LE = function (t, e) {
            (t >>>= 0), e || B(t, 2, this.length);
            const r = this[t] | (this[t + 1] << 8);
            return 32768 & r ? 4294901760 | r : r;
          }),
          (u.prototype.readInt16BE = function (t, e) {
            (t >>>= 0), e || B(t, 2, this.length);
            const r = this[t + 1] | (this[t] << 8);
            return 32768 & r ? 4294901760 | r : r;
          }),
          (u.prototype.readInt32LE = function (t, e) {
            return (
              (t >>>= 0),
              e || B(t, 4, this.length),
              this[t] |
                (this[t + 1] << 8) |
                (this[t + 2] << 16) |
                (this[t + 3] << 24)
            );
          }),
          (u.prototype.readInt32BE = function (t, e) {
            return (
              (t >>>= 0),
              e || B(t, 4, this.length),
              (this[t] << 24) |
                (this[t + 1] << 16) |
                (this[t + 2] << 8) |
                this[t + 3]
            );
          }),
          (u.prototype.readBigInt64LE = J(function (t) {
            V((t >>>= 0), "offset");
            const e = this[t],
              r = this[t + 7];
            (void 0 !== e && void 0 !== r) || q(t, this.length - 8);
            const n =
              this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (r << 24);
            return (
              (BigInt(n) << BigInt(32)) +
              BigInt(
                e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
              )
            );
          })),
          (u.prototype.readBigInt64BE = J(function (t) {
            V((t >>>= 0), "offset");
            const e = this[t],
              r = this[t + 7];
            (void 0 !== e && void 0 !== r) || q(t, this.length - 8);
            const n =
              (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
            return (
              (BigInt(n) << BigInt(32)) +
              BigInt(
                this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r,
              )
            );
          })),
          (u.prototype.readFloatLE = function (t, e) {
            return (
              (t >>>= 0), e || B(t, 4, this.length), i.read(this, t, !0, 23, 4)
            );
          }),
          (u.prototype.readFloatBE = function (t, e) {
            return (
              (t >>>= 0), e || B(t, 4, this.length), i.read(this, t, !1, 23, 4)
            );
          }),
          (u.prototype.readDoubleLE = function (t, e) {
            return (
              (t >>>= 0), e || B(t, 8, this.length), i.read(this, t, !0, 52, 8)
            );
          }),
          (u.prototype.readDoubleBE = function (t, e) {
            return (
              (t >>>= 0), e || B(t, 8, this.length), i.read(this, t, !1, 52, 8)
            );
          }),
          (u.prototype.writeUintLE = u.prototype.writeUIntLE =
            function (t, e, r, n) {
              if (((t = +t), (e >>>= 0), (r >>>= 0), !n)) {
                C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
              }
              let i = 1,
                o = 0;
              for (this[e] = 255 & t; ++o < r && (i *= 256); )
                this[e + o] = (t / i) & 255;
              return e + r;
            }),
          (u.prototype.writeUintBE = u.prototype.writeUIntBE =
            function (t, e, r, n) {
              if (((t = +t), (e >>>= 0), (r >>>= 0), !n)) {
                C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
              }
              let i = r - 1,
                o = 1;
              for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); )
                this[e + i] = (t / o) & 255;
              return e + r;
            }),
          (u.prototype.writeUint8 = u.prototype.writeUInt8 =
            function (t, e, r) {
              return (
                (t = +t),
                (e >>>= 0),
                r || C(this, t, e, 1, 255, 0),
                (this[e] = 255 & t),
                e + 1
              );
            }),
          (u.prototype.writeUint16LE = u.prototype.writeUInt16LE =
            function (t, e, r) {
              return (
                (t = +t),
                (e >>>= 0),
                r || C(this, t, e, 2, 65535, 0),
                (this[e] = 255 & t),
                (this[e + 1] = t >>> 8),
                e + 2
              );
            }),
          (u.prototype.writeUint16BE = u.prototype.writeUInt16BE =
            function (t, e, r) {
              return (
                (t = +t),
                (e >>>= 0),
                r || C(this, t, e, 2, 65535, 0),
                (this[e] = t >>> 8),
                (this[e + 1] = 255 & t),
                e + 2
              );
            }),
          (u.prototype.writeUint32LE = u.prototype.writeUInt32LE =
            function (t, e, r) {
              return (
                (t = +t),
                (e >>>= 0),
                r || C(this, t, e, 4, 4294967295, 0),
                (this[e + 3] = t >>> 24),
                (this[e + 2] = t >>> 16),
                (this[e + 1] = t >>> 8),
                (this[e] = 255 & t),
                e + 4
              );
            }),
          (u.prototype.writeUint32BE = u.prototype.writeUInt32BE =
            function (t, e, r) {
              return (
                (t = +t),
                (e >>>= 0),
                r || C(this, t, e, 4, 4294967295, 0),
                (this[e] = t >>> 24),
                (this[e + 1] = t >>> 16),
                (this[e + 2] = t >>> 8),
                (this[e + 3] = 255 & t),
                e + 4
              );
            }),
          (u.prototype.writeBigUInt64LE = J(function (t, e = 0) {
            return R(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
          })),
          (u.prototype.writeBigUInt64BE = J(function (t, e = 0) {
            return N(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
          })),
          (u.prototype.writeIntLE = function (t, e, r, n) {
            if (((t = +t), (e >>>= 0), !n)) {
              const n = Math.pow(2, 8 * r - 1);
              C(this, t, e, r, n - 1, -n);
            }
            let i = 0,
              o = 1,
              s = 0;
            for (this[e] = 255 & t; ++i < r && (o *= 256); )
              t < 0 && 0 === s && 0 !== this[e + i - 1] && (s = 1),
                (this[e + i] = (((t / o) | 0) - s) & 255);
            return e + r;
          }),
          (u.prototype.writeIntBE = function (t, e, r, n) {
            if (((t = +t), (e >>>= 0), !n)) {
              const n = Math.pow(2, 8 * r - 1);
              C(this, t, e, r, n - 1, -n);
            }
            let i = r - 1,
              o = 1,
              s = 0;
            for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); )
              t < 0 && 0 === s && 0 !== this[e + i + 1] && (s = 1),
                (this[e + i] = (((t / o) | 0) - s) & 255);
            return e + r;
          }),
          (u.prototype.writeInt8 = function (t, e, r) {
            return (
              (t = +t),
              (e >>>= 0),
              r || C(this, t, e, 1, 127, -128),
              t < 0 && (t = 255 + t + 1),
              (this[e] = 255 & t),
              e + 1
            );
          }),
          (u.prototype.writeInt16LE = function (t, e, r) {
            return (
              (t = +t),
              (e >>>= 0),
              r || C(this, t, e, 2, 32767, -32768),
              (this[e] = 255 & t),
              (this[e + 1] = t >>> 8),
              e + 2
            );
          }),
          (u.prototype.writeInt16BE = function (t, e, r) {
            return (
              (t = +t),
              (e >>>= 0),
              r || C(this, t, e, 2, 32767, -32768),
              (this[e] = t >>> 8),
              (this[e + 1] = 255 & t),
              e + 2
            );
          }),
          (u.prototype.writeInt32LE = function (t, e, r) {
            return (
              (t = +t),
              (e >>>= 0),
              r || C(this, t, e, 4, 2147483647, -2147483648),
              (this[e] = 255 & t),
              (this[e + 1] = t >>> 8),
              (this[e + 2] = t >>> 16),
              (this[e + 3] = t >>> 24),
              e + 4
            );
          }),
          (u.prototype.writeInt32BE = function (t, e, r) {
            return (
              (t = +t),
              (e >>>= 0),
              r || C(this, t, e, 4, 2147483647, -2147483648),
              t < 0 && (t = 4294967295 + t + 1),
              (this[e] = t >>> 24),
              (this[e + 1] = t >>> 16),
              (this[e + 2] = t >>> 8),
              (this[e + 3] = 255 & t),
              e + 4
            );
          }),
          (u.prototype.writeBigInt64LE = J(function (t, e = 0) {
            return R(
              this,
              t,
              e,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff"),
            );
          })),
          (u.prototype.writeBigInt64BE = J(function (t, e = 0) {
            return N(
              this,
              t,
              e,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff"),
            );
          })),
          (u.prototype.writeFloatLE = function (t, e, r) {
            return D(this, t, e, !0, r);
          }),
          (u.prototype.writeFloatBE = function (t, e, r) {
            return D(this, t, e, !1, r);
          }),
          (u.prototype.writeDoubleLE = function (t, e, r) {
            return L(this, t, e, !0, r);
          }),
          (u.prototype.writeDoubleBE = function (t, e, r) {
            return L(this, t, e, !1, r);
          }),
          (u.prototype.copy = function (t, e, r, n) {
            if (!u.isBuffer(t))
              throw new TypeError("argument should be a Buffer");
            if (
              (r || (r = 0),
              n || 0 === n || (n = this.length),
              e >= t.length && (e = t.length),
              e || (e = 0),
              n > 0 && n < r && (n = r),
              n === r)
            )
              return 0;
            if (0 === t.length || 0 === this.length) return 0;
            if (e < 0) throw new RangeError("targetStart out of bounds");
            if (r < 0 || r >= this.length)
              throw new RangeError("Index out of range");
            if (n < 0) throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length),
              t.length - e < n - r && (n = t.length - e + r);
            const i = n - r;
            return (
              this === t && "function" == typeof Uint8Array.prototype.copyWithin
                ? this.copyWithin(e, r, n)
                : Uint8Array.prototype.set.call(t, this.subarray(r, n), e),
              i
            );
          }),
          (u.prototype.fill = function (t, e, r, n) {
            if ("string" == typeof t) {
              if (
                ("string" == typeof e
                  ? ((n = e), (e = 0), (r = this.length))
                  : "string" == typeof r && ((n = r), (r = this.length)),
                void 0 !== n && "string" != typeof n)
              )
                throw new TypeError("encoding must be a string");
              if ("string" == typeof n && !u.isEncoding(n))
                throw new TypeError("Unknown encoding: " + n);
              if (1 === t.length) {
                const e = t.charCodeAt(0);
                (("utf8" === n && e < 128) || "latin1" === n) && (t = e);
              }
            } else
              "number" == typeof t
                ? (t &= 255)
                : "boolean" == typeof t && (t = Number(t));
            if (e < 0 || this.length < e || this.length < r)
              throw new RangeError("Out of range index");
            if (r <= e) return this;
            let i;
            if (
              ((e >>>= 0),
              (r = void 0 === r ? this.length : r >>> 0),
              t || (t = 0),
              "number" == typeof t)
            )
              for (i = e; i < r; ++i) this[i] = t;
            else {
              const o = u.isBuffer(t) ? t : u.from(t, n),
                s = o.length;
              if (0 === s)
                throw new TypeError(
                  'The value "' + t + '" is invalid for argument "value"',
                );
              for (i = 0; i < r - e; ++i) this[i + e] = o[i % s];
            }
            return this;
          });
        const j = {};
        function F(t, e, r) {
          j[t] = class extends r {
            constructor() {
              super(),
                Object.defineProperty(this, "message", {
                  value: e.apply(this, arguments),
                  writable: !0,
                  configurable: !0,
                }),
                (this.name = `${this.name} [${t}]`),
                this.stack,
                delete this.name;
            }
            get code() {
              return t;
            }
            set code(t) {
              Object.defineProperty(this, "code", {
                configurable: !0,
                enumerable: !0,
                value: t,
                writable: !0,
              });
            }
            toString() {
              return `${this.name} [${t}]: ${this.message}`;
            }
          };
        }
        function H(t) {
          let e = "",
            r = t.length;
          const n = "-" === t[0] ? 1 : 0;
          for (; r >= n + 4; r -= 3) e = `_${t.slice(r - 3, r)}${e}`;
          return `${t.slice(0, r)}${e}`;
        }
        function K(t, e, r, n, i, o) {
          if (t > r || t < e) {
            const n = "bigint" == typeof e ? "n" : "";
            let i;
            throw (
              ((i =
                o > 3
                  ? 0 === e || e === BigInt(0)
                    ? `>= 0${n} and < 2${n} ** ${8 * (o + 1)}${n}`
                    : `>= -(2${n} ** ${8 * (o + 1) - 1}${n}) and < 2 ** ${8 * (o + 1) - 1}${n}`
                  : `>= ${e}${n} and <= ${r}${n}`),
              new j.ERR_OUT_OF_RANGE("value", i, t))
            );
          }
          !(function (t, e, r) {
            V(e, "offset"),
              (void 0 !== t[e] && void 0 !== t[e + r]) ||
                q(e, t.length - (r + 1));
          })(n, i, o);
        }
        function V(t, e) {
          if ("number" != typeof t)
            throw new j.ERR_INVALID_ARG_TYPE(e, "number", t);
        }
        function q(t, e, r) {
          if (Math.floor(t) !== t)
            throw (
              (V(t, r), new j.ERR_OUT_OF_RANGE(r || "offset", "an integer", t))
            );
          if (e < 0) throw new j.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new j.ERR_OUT_OF_RANGE(
            r || "offset",
            `>= ${r ? 1 : 0} and <= ${e}`,
            t,
          );
        }
        F(
          "ERR_BUFFER_OUT_OF_BOUNDS",
          function (t) {
            return t
              ? `${t} is outside of buffer bounds`
              : "Attempt to access memory outside buffer bounds";
          },
          RangeError,
        ),
          F(
            "ERR_INVALID_ARG_TYPE",
            function (t, e) {
              return `The "${t}" argument must be of type number. Received type ${typeof e}`;
            },
            TypeError,
          ),
          F(
            "ERR_OUT_OF_RANGE",
            function (t, e, r) {
              let n = `The value of "${t}" is out of range.`,
                i = r;
              return (
                Number.isInteger(r) && Math.abs(r) > 2 ** 32
                  ? (i = H(String(r)))
                  : "bigint" == typeof r &&
                    ((i = String(r)),
                    (r > BigInt(2) ** BigInt(32) ||
                      r < -(BigInt(2) ** BigInt(32))) &&
                      (i = H(i)),
                    (i += "n")),
                (n += ` It must be ${e}. Received ${i}`),
                n
              );
            },
            RangeError,
          );
        const z = /[^+/0-9A-Za-z-_]/g;
        function $(t, e) {
          let r;
          e = e || 1 / 0;
          const n = t.length;
          let i = null;
          const o = [];
          for (let s = 0; s < n; ++s) {
            if (((r = t.charCodeAt(s)), r > 55295 && r < 57344)) {
              if (!i) {
                if (r > 56319) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                if (s + 1 === n) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                i = r;
                continue;
              }
              if (r < 56320) {
                (e -= 3) > -1 && o.push(239, 191, 189), (i = r);
                continue;
              }
              r = 65536 + (((i - 55296) << 10) | (r - 56320));
            } else i && (e -= 3) > -1 && o.push(239, 191, 189);
            if (((i = null), r < 128)) {
              if ((e -= 1) < 0) break;
              o.push(r);
            } else if (r < 2048) {
              if ((e -= 2) < 0) break;
              o.push((r >> 6) | 192, (63 & r) | 128);
            } else if (r < 65536) {
              if ((e -= 3) < 0) break;
              o.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
            } else {
              if (!(r < 1114112)) throw new Error("Invalid code point");
              if ((e -= 4) < 0) break;
              o.push(
                (r >> 18) | 240,
                ((r >> 12) & 63) | 128,
                ((r >> 6) & 63) | 128,
                (63 & r) | 128,
              );
            }
          }
          return o;
        }
        function G(t) {
          return n.toByteArray(
            (function (t) {
              if ((t = (t = t.split("=")[0]).trim().replace(z, "")).length < 2)
                return "";
              for (; t.length % 4 != 0; ) t += "=";
              return t;
            })(t),
          );
        }
        function W(t, e, r, n) {
          let i;
          for (i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i)
            e[i + r] = t[i];
          return i;
        }
        function Y(t, e) {
          return (
            t instanceof e ||
            (null != t &&
              null != t.constructor &&
              null != t.constructor.name &&
              t.constructor.name === e.name)
          );
        }
        function X(t) {
          return t != t;
        }
        const Z = (function () {
          const t = "0123456789abcdef",
            e = new Array(256);
          for (let r = 0; r < 16; ++r) {
            const n = 16 * r;
            for (let i = 0; i < 16; ++i) e[n + i] = t[r] + t[i];
          }
          return e;
        })();
        function J(t) {
          return "undefined" == typeof BigInt ? Q : t;
        }
        function Q() {
          throw new Error("BigInt not supported");
        }
      },
      21225: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.c32ToB58 =
            e.b58ToC32 =
            e.c32addressDecode =
            e.c32address =
            e.versions =
              void 0);
        const n = r(58010),
          i = r(60785),
          o = r(99175);
        e.versions = {
          mainnet: { p2pkh: 22, p2sh: 20 },
          testnet: { p2pkh: 26, p2sh: 21 },
        };
        const s = {};
        (s[0] = e.versions.mainnet.p2pkh),
          (s[5] = e.versions.mainnet.p2sh),
          (s[111] = e.versions.testnet.p2pkh),
          (s[196] = e.versions.testnet.p2sh);
        const a = {};
        function u(t, e) {
          if (!e.match(/^[0-9a-fA-F]{40}$/))
            throw new Error("Invalid argument: not a hash160 hex string");
          return `S${(0, n.c32checkEncode)(t, e)}`;
        }
        function c(t) {
          if (t.length <= 5)
            throw new Error("Invalid c32 address: invalid length");
          if ("S" != t[0])
            throw new Error('Invalid c32 address: must start with "S"');
          return (0, n.c32checkDecode)(t.slice(1));
        }
        (a[e.versions.mainnet.p2pkh] = 0),
          (a[e.versions.mainnet.p2sh] = 5),
          (a[e.versions.testnet.p2pkh] = 111),
          (a[e.versions.testnet.p2sh] = 196),
          (e.c32address = u),
          (e.c32addressDecode = c),
          (e.b58ToC32 = function (t, e = -1) {
            const r = i.decode(t),
              n = (0, o.bytesToHex)(r.data),
              a = parseInt((0, o.bytesToHex)(r.prefix), 16);
            let c;
            return (
              e < 0 ? ((c = a), void 0 !== s[a] && (c = s[a])) : (c = e),
              u(c, n)
            );
          }),
          (e.c32ToB58 = function (t, e = -1) {
            const r = c(t),
              n = r[0],
              o = r[1];
            let s;
            e < 0 ? ((s = n), void 0 !== a[n] && (s = a[n])) : (s = e);
            let u = s.toString(16);
            return 1 === u.length && (u = `0${u}`), i.encode(o, u);
          });
      },
      60785: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = e.encode = void 0);
        const n = r(22623),
          i = r(99175),
          o = r(95364),
          s = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        (e.encode = function (t, e = "00") {
          const r = "string" == typeof t ? (0, i.hexToBytes)(t) : t,
            a = "string" == typeof e ? (0, i.hexToBytes)(e) : t;
          if (!(r instanceof Uint8Array && a instanceof Uint8Array))
            throw new TypeError(
              "Argument must be of type Uint8Array or string",
            );
          const u = (0, n.sha256)((0, n.sha256)(new Uint8Array([...a, ...r])));
          return o(s).encode([...a, ...r, ...u.slice(0, 4)]);
        }),
          (e.decode = function (t) {
            const e = o(s).decode(t),
              r = e.slice(0, 1),
              i = e.slice(1, -4),
              a = (0, n.sha256)((0, n.sha256)(new Uint8Array([...r, ...i])));
            return (
              e.slice(-4).forEach((t, e) => {
                if (t !== a[e]) throw new Error("Invalid checksum");
              }),
              { prefix: r, data: i }
            );
          });
      },
      58010: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.c32checkDecode = e.c32checkEncode = void 0);
        const n = r(22623),
          i = r(99175),
          o = r(91556);
        function s(t) {
          const e = (0, n.sha256)((0, n.sha256)((0, i.hexToBytes)(t)));
          return (0, i.bytesToHex)(e.slice(0, 4));
        }
        (e.c32checkEncode = function (t, e) {
          if (t < 0 || t >= 32)
            throw new Error("Invalid version (must be between 0 and 31)");
          if (!e.match(/^[0-9a-fA-F]*$/))
            throw new Error("Invalid data (not a hex string)");
          (e = e.toLowerCase()).length % 2 != 0 && (e = `0${e}`);
          let r = t.toString(16);
          1 === r.length && (r = `0${r}`);
          const n = s(`${r}${e}`),
            i = (0, o.c32encode)(`${e}${n}`);
          return `${o.c32[t]}${i}`;
        }),
          (e.c32checkDecode = function (t) {
            t = (0, o.c32normalize)(t);
            const e = (0, o.c32decode)(t.slice(1)),
              r = t[0],
              n = o.c32.indexOf(r),
              i = e.slice(-8);
            let a = n.toString(16);
            if (
              (1 === a.length && (a = `0${a}`),
              s(`${a}${e.substring(0, e.length - 8)}`) !== i)
            )
              throw new Error("Invalid c32check string: checksum mismatch");
            return [n, e.substring(0, e.length - 8)];
          });
      },
      91556: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.c32decode = e.c32normalize = e.c32encode = e.c32 = void 0);
        const n = r(99175);
        e.c32 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
        const i = "0123456789abcdef";
        function o(t) {
          return t.toUpperCase().replace(/O/g, "0").replace(/L|I/g, "1");
        }
        (e.c32encode = function (t, r) {
          if (!t.match(/^[0-9a-fA-F]*$/))
            throw new Error("Not a hex-encoded string");
          t.length % 2 != 0 && (t = `0${t}`);
          let o = [],
            s = 0;
          for (let r = (t = t.toLowerCase()).length - 1; r >= 0; r--)
            if (s < 4) {
              const n = i.indexOf(t[r]) >> s;
              let a = 0;
              0 !== r && (a = i.indexOf(t[r - 1]));
              const u = 1 + s,
                c = a % (1 << u) << (5 - u),
                f = e.c32[n + c];
              (s = u), o.unshift(f);
            } else s = 0;
          let a = 0;
          for (let t = 0; t < o.length && "0" === o[t]; t++) a++;
          o = o.slice(a);
          const u = new TextDecoder()
              .decode((0, n.hexToBytes)(t))
              .match(/^\u0000*/),
            c = u ? u[0].length : 0;
          for (let t = 0; t < c; t++) o.unshift(e.c32[0]);
          if (r) {
            const t = r - o.length;
            for (let r = 0; r < t; r++) o.unshift(e.c32[0]);
          }
          return o.join("");
        }),
          (e.c32normalize = o),
          (e.c32decode = function (t, r) {
            if (!(t = o(t)).match(`^[${e.c32}]*$`))
              throw new Error("Not a c32-encoded string");
            const n = t.match(`^${e.c32[0]}*`),
              s = n ? n[0].length : 0;
            let a = [],
              u = 0,
              c = 0;
            for (let r = t.length - 1; r >= 0; r--) {
              4 === c && (a.unshift(i[u]), (c = 0), (u = 0));
              const n = (e.c32.indexOf(t[r]) << c) + u,
                o = i[n % 16];
              if (((c += 1), (u = n >> 4), u > 1 << c))
                throw new Error("Panic error in decoding.");
              a.unshift(o);
            }
            a.unshift(i[u]), a.length % 2 == 1 && a.unshift("0");
            let f = 0;
            for (let t = 0; t < a.length && "0" === a[t]; t++) f++;
            a = a.slice(f - (f % 2));
            let h = a.join("");
            for (let t = 0; t < s; t++) h = `00${h}`;
            if (r) {
              const t = 2 * r - h.length;
              for (let e = 0; e < t; e += 2) h = `00${h}`;
            }
            return h;
          });
      },
      7581: (t, e, r) => {
        "use strict";
        e.ns = e.bJ = void 0;
        const n = r(91556);
        const i = r(58010);
        const o = r(21225);
        Object.defineProperty(e, "bJ", {
          enumerable: !0,
          get: function () {
            return o.c32address;
          },
        }),
          Object.defineProperty(e, "ns", {
            enumerable: !0,
            get: function () {
              return o.c32addressDecode;
            },
          });
      },
      13144: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(11002),
          o = r(10076),
          s = r(47119);
        t.exports = s || n.call(o, i);
      },
      11002: (t) => {
        "use strict";
        t.exports = Function.prototype.apply;
      },
      10076: (t) => {
        "use strict";
        t.exports = Function.prototype.call;
      },
      73126: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(69675),
          o = r(10076),
          s = r(13144);
        t.exports = function (t) {
          if (t.length < 1 || "function" != typeof t[0])
            throw new i("a function is required");
          return s(n, o, t);
        };
      },
      47119: (t) => {
        "use strict";
        t.exports = "undefined" != typeof Reflect && Reflect && Reflect.apply;
      },
      38075: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(10487),
          o = i(n("String.prototype.indexOf"));
        t.exports = function (t, e) {
          var r = n(t, !!e);
          return "function" == typeof r && o(t, ".prototype.") > -1 ? i(r) : r;
        };
      },
      10487: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(70453),
          o = r(96897),
          s = r(69675),
          a = i("%Function.prototype.apply%"),
          u = i("%Function.prototype.call%"),
          c = i("%Reflect.apply%", !0) || n.call(u, a),
          f = r(30655),
          h = i("%Math.max%");
        t.exports = function (t) {
          if ("function" != typeof t) throw new s("a function is required");
          var e = c(n, u, arguments);
          return o(e, 1 + h(0, t.length - (arguments.length - 1)), !0);
        };
        var l = function () {
          return c(n, a, arguments);
        };
        f ? f(t.exports, "apply", { value: l }) : (t.exports.apply = l);
      },
      36556: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(73126),
          o = i([n("%String.prototype.indexOf%")]);
        t.exports = function (t, e) {
          var r = n(t, !!e);
          return "function" == typeof r && o(t, ".prototype.") > -1
            ? i([r])
            : r;
        };
      },
      54362: function (t, e, r) {
        var n,
          i,
          o,
          s = r(48287).Buffer;
        (i = []),
          void 0 ===
            (o =
              "function" ==
              typeof (n = function () {
                var t = (function () {
                  function t(t) {
                    this.$hex = t;
                  }
                  (t.prototype = {
                    length: function () {
                      return this.$hex.length / 2;
                    },
                    toString: function (t) {
                      if (!t || "hex" === t || 16 === t) return this.$hex;
                      if ("utf-8" === t) {
                        for (var e = "", r = 0; r < this.$hex.length; r += 2)
                          e += "%" + this.$hex.substring(r, r + 2);
                        return decodeURIComponent(e);
                      }
                      if ("latin" === t) {
                        for (e = [], r = 0; r < this.$hex.length; r += 2)
                          e.push(parseInt(this.$hex.substring(r, r + 2), 16));
                        return String.fromCharCode.apply(String, e);
                      }
                      throw new Error("Unrecognised format: " + t);
                    },
                  }),
                    (t.fromLatinString = function (e) {
                      for (var r = "", n = 0; n < e.length; n++) {
                        var i = e.charCodeAt(n).toString(16);
                        1 === i.length && (i = "0" + i), (r += i);
                      }
                      return new t(r);
                    }),
                    (t.fromUtf8String = function (e) {
                      for (
                        var r = encodeURIComponent(e), n = "", i = 0;
                        i < r.length;
                        i++
                      )
                        if ("%" === r.charAt(i))
                          (n += r.substring(i + 1, i + 3)), (i += 2);
                        else {
                          var o = r.charCodeAt(i).toString(16);
                          o.length < 2 && (o = "0" + o), (n += o);
                        }
                      return new t(n);
                    });
                  var e = [],
                    r = {},
                    n = function (t) {
                      return function () {
                        throw new Error(t + " not implemented");
                      };
                    };
                  function i() {}
                  function o() {}
                  function a(t) {
                    var e = t.readByte();
                    return { type: e >> 5, value: 31 & e };
                  }
                  function u(t, e) {
                    var r = t.value;
                    return r < 24
                      ? r
                      : 24 == r
                        ? e.readByte()
                        : 25 == r
                          ? e.readUint16()
                          : 26 == r
                            ? e.readUint32()
                            : 27 == r
                              ? e.readUint64()
                              : 31 == r
                                ? null
                                : void n("Additional info: " + r)();
                  }
                  function c(t, e, r) {
                    r.writeByte((t << 5) | e);
                  }
                  function f(t, e, r) {
                    var n = t << 5;
                    e < 24
                      ? r.writeByte(n | e)
                      : e < 256
                        ? (r.writeByte(24 | n), r.writeByte(e))
                        : e < 65536
                          ? (r.writeByte(25 | n), r.writeUint16(e))
                          : e < 4294967296
                            ? (r.writeByte(26 | n), r.writeUint32(e))
                            : (r.writeByte(27 | n), r.writeUint64(e));
                  }
                  (i.prototype = {
                    peekByte: n("peekByte"),
                    readByte: n("readByte"),
                    readChunk: n("readChunk"),
                    readFloat16: function () {
                      var t = this.readUint16(),
                        e = (32767 & t) >> 10,
                        r = 1023 & t,
                        n = 32768 & t;
                      if (31 === e) return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 25) * (1024 + r)
                        : Math.pow(2, -24) * r;
                      return n ? -i : i;
                    },
                    readFloat32: function () {
                      var t = this.readUint32(),
                        e = (2147483647 & t) >> 23,
                        r = 8388607 & t,
                        n = 2147483648 & t;
                      if (255 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 23 - 127) * (8388608 + r)
                        : Math.pow(2, -149) * r;
                      return n ? -i : i;
                    },
                    readFloat64: function () {
                      var t = this.readUint32(),
                        e = (t >> 20) & 2047,
                        r = 4294967296 * (1048575 & t) + this.readUint32(),
                        n = 2147483648 & t;
                      if (2047 === e)
                        return 0 === r ? (n ? -1 / 0 : 1 / 0) : NaN;
                      var i = e
                        ? Math.pow(2, e - 52 - 1023) * (4503599627370496 + r)
                        : Math.pow(2, -1074) * r;
                      return n ? -i : i;
                    },
                    readUint16: function () {
                      return 256 * this.readByte() + this.readByte();
                    },
                    readUint32: function () {
                      return 65536 * this.readUint16() + this.readUint16();
                    },
                    readUint64: function () {
                      return 4294967296 * this.readUint32() + this.readUint32();
                    },
                  }),
                    (o.prototype = {
                      writeByte: n("writeByte"),
                      result: n("result"),
                      writeFloat16: n("writeFloat16"),
                      writeFloat32: n("writeFloat32"),
                      writeFloat64: n("writeFloat64"),
                      writeUint16: function (t) {
                        this.writeByte((t >> 8) & 255), this.writeByte(255 & t);
                      },
                      writeUint32: function (t) {
                        this.writeUint16((t >> 16) & 65535),
                          this.writeUint16(65535 & t);
                      },
                      writeUint64: function (t) {
                        if (t >= 9007199254740992 || t <= -9007199254740992)
                          throw new Error(
                            "Cannot encode Uint64 of: " +
                              t +
                              " magnitude to big (floating point errors)",
                          );
                        this.writeUint32(Math.floor(t / 4294967296)),
                          this.writeUint32(t % 4294967296);
                      },
                      writeString: n("writeString"),
                      canWriteBinary: function (t) {
                        return !1;
                      },
                      writeBinary: n("writeChunk"),
                    });
                  var h = new Error();
                  function l(t) {
                    var e = a(t);
                    switch (e.type) {
                      case 0:
                        return u(e, t);
                      case 1:
                        return -1 - u(e, t);
                      case 2:
                        return t.readChunk(u(e, t));
                      case 3:
                        return t.readChunk(u(e, t)).toString("utf-8");
                      case 4:
                      case 5:
                        var n = u(e, t),
                          i = [];
                        if (null !== n) {
                          5 === e.type && (n *= 2);
                          for (var o = 0; o < n; o++) i[o] = l(t);
                        } else for (var s; (s = l(t)) !== h; ) i.push(s);
                        if (5 === e.type) {
                          var c = {};
                          for (o = 0; o < i.length; o += 2) c[i[o]] = i[o + 1];
                          return c;
                        }
                        return i;
                      case 6:
                        var f = u(e, t),
                          d = r[f];
                        return (i = l(t)), d ? d(i) : i;
                      case 7:
                        if (25 === e.value) return t.readFloat16();
                        if (26 === e.value) return t.readFloat32();
                        if (27 === e.value) return t.readFloat64();
                        switch (u(e, t)) {
                          case 20:
                            return !1;
                          case 21:
                            return !0;
                          case 22:
                            return null;
                          case 23:
                            return;
                          case null:
                            return h;
                          default:
                            throw new Error("Unknown fixed value: " + e.value);
                        }
                      default:
                        throw new Error(
                          "Unsupported header: " + JSON.stringify(e),
                        );
                    }
                    throw new Error("not implemented yet");
                  }
                  function d(t, r) {
                    for (var n = 0; n < e.length; n++) {
                      var i = e[n].fn(t);
                      if (void 0 !== i) return f(6, e[n].tag, r), d(i, r);
                    }
                    if (
                      (t && "function" == typeof t.toCBOR && (t = t.toCBOR()),
                      !1 === t)
                    )
                      f(7, 20, r);
                    else if (!0 === t) f(7, 21, r);
                    else if (null === t) f(7, 22, r);
                    else if (void 0 === t) f(7, 23, r);
                    else if ("number" == typeof t)
                      Math.floor(t) === t &&
                      t < 9007199254740992 &&
                      t > -9007199254740992
                        ? t < 0
                          ? f(1, -1 - t, r)
                          : f(0, t, r)
                        : (c(7, 27, r), r.writeFloat64(t));
                    else if ("string" == typeof t)
                      r.writeString(t, function (t) {
                        f(3, t, r);
                      });
                    else if (r.canWriteBinary(t))
                      r.writeBinary(t, function (t) {
                        f(2, t, r);
                      });
                    else {
                      if ("object" != typeof t)
                        throw new Error("CBOR encoding not supported: " + t);
                      if (
                        (g.config.useToJSON &&
                          "function" == typeof t.toJSON &&
                          (t = t.toJSON()),
                        Array.isArray(t))
                      )
                        for (f(4, t.length, r), n = 0; n < t.length; n++)
                          d(t[n], r);
                      else {
                        var o = Object.keys(t);
                        for (f(5, o.length, r), n = 0; n < o.length; n++)
                          d(o[n], r), d(t[o[n]], r);
                      }
                    }
                  }
                  var p = [],
                    y = [],
                    g = {
                      config: { useToJSON: !0 },
                      addWriter: function (t, e) {
                        "string" == typeof t
                          ? y.push(function (r) {
                              if (t === r) return e(r);
                            })
                          : y.push(t);
                      },
                      addReader: function (t, e) {
                        "string" == typeof t
                          ? p.push(function (r, n) {
                              if (t === n) return e(r, n);
                            })
                          : p.push(t);
                      },
                      encode: function (t, e) {
                        for (var r = 0; r < y.length; r++) {
                          var n = (0, y[r])(e);
                          if (n) return d(t, n), n.result();
                        }
                        throw new Error("Unsupported output format: " + e);
                      },
                      decode: function (t, e) {
                        for (var r = 0; r < p.length; r++) {
                          var n = (0, p[r])(t, e);
                          if (n) return l(n);
                        }
                        throw new Error("Unsupported input format: " + e);
                      },
                      addSemanticEncode: function (t, r) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return e.push({ tag: t, fn: r }), this;
                      },
                      addSemanticDecode: function (t, e) {
                        if ("number" != typeof t || t % 1 != 0 || t < 0)
                          throw new Error("Tag must be a positive integer");
                        return (r[t] = e), this;
                      },
                      Reader: i,
                      Writer: o,
                    };
                  function m(t) {
                    (this.buffer = t), (this.pos = 0);
                  }
                  function b(t) {
                    (this.byteLength = 0),
                      (this.defaultBufferLength = 16384),
                      (this.latestBuffer = s.alloc(this.defaultBufferLength)),
                      (this.latestBufferOffset = 0),
                      (this.completeBuffers = []),
                      (this.stringFormat = t);
                  }
                  function w(t) {
                    (this.hex = t), (this.pos = 0);
                  }
                  function v(t) {
                    (this.$hex = ""), (this.finalFormat = t || "hex");
                  }
                  return (
                    (m.prototype = Object.create(i.prototype)),
                    (m.prototype.peekByte = function () {
                      return this.buffer[this.pos];
                    }),
                    (m.prototype.readByte = function () {
                      return this.buffer[this.pos++];
                    }),
                    (m.prototype.readUint16 = function () {
                      var t = this.buffer.readUInt16BE(this.pos);
                      return (this.pos += 2), t;
                    }),
                    (m.prototype.readUint32 = function () {
                      var t = this.buffer.readUInt32BE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (m.prototype.readFloat32 = function () {
                      var t = this.buffer.readFloatBE(this.pos);
                      return (this.pos += 4), t;
                    }),
                    (m.prototype.readFloat64 = function () {
                      var t = this.buffer.readDoubleBE(this.pos);
                      return (this.pos += 8), t;
                    }),
                    (m.prototype.readChunk = function (t) {
                      var e = s.alloc(t);
                      return (
                        this.buffer.copy(e, 0, this.pos, (this.pos += t)), e
                      );
                    }),
                    (b.prototype = Object.create(o.prototype)),
                    (b.prototype.writeByte = function (t) {
                      (this.latestBuffer[this.latestBufferOffset++] = t),
                        this.latestBufferOffset >= this.latestBuffer.length &&
                          (this.completeBuffers.push(this.latestBuffer),
                          (this.latestBuffer = s.alloc(
                            this.defaultBufferLength,
                          )),
                          (this.latestBufferOffset = 0)),
                        this.byteLength++;
                    }),
                    (b.prototype.writeFloat32 = function (t) {
                      var e = s.alloc(4);
                      e.writeFloatBE(t, 0), this.writeBuffer(e);
                    }),
                    (b.prototype.writeFloat64 = function (t) {
                      var e = s.alloc(8);
                      e.writeDoubleBE(t, 0), this.writeBuffer(e);
                    }),
                    (b.prototype.writeString = function (t, e) {
                      var r = s.from(t, "utf-8");
                      e(r.length), this.writeBuffer(r);
                    }),
                    (b.prototype.canWriteBinary = function (t) {
                      return t instanceof s;
                    }),
                    (b.prototype.writeBinary = function (t, e) {
                      e(t.length), this.writeBuffer(t);
                    }),
                    (b.prototype.writeBuffer = function (t) {
                      if (!(t instanceof s))
                        throw new TypeError(
                          "BufferWriter only accepts Buffers",
                        );
                      this.latestBufferOffset
                        ? this.latestBuffer.length - this.latestBufferOffset >=
                          t.length
                          ? (t.copy(this.latestBuffer, this.latestBufferOffset),
                            (this.latestBufferOffset += t.length),
                            this.latestBufferOffset >=
                              this.latestBuffer.length &&
                              (this.completeBuffers.push(this.latestBuffer),
                              (this.latestBuffer = s.alloc(
                                this.defaultBufferLength,
                              )),
                              (this.latestBufferOffset = 0)))
                          : (this.completeBuffers.push(
                              this.latestBuffer.slice(
                                0,
                                this.latestBufferOffset,
                              ),
                            ),
                            this.completeBuffers.push(t),
                            (this.latestBuffer = s.alloc(
                              this.defaultBufferLength,
                            )),
                            (this.latestBufferOffset = 0))
                        : this.completeBuffers.push(t),
                        (this.byteLength += t.length);
                    }),
                    (b.prototype.result = function () {
                      for (
                        var t = s.alloc(this.byteLength), e = 0, r = 0;
                        r < this.completeBuffers.length;
                        r++
                      ) {
                        var n = this.completeBuffers[r];
                        n.copy(t, e, 0, n.length), (e += n.length);
                      }
                      return (
                        this.latestBufferOffset &&
                          this.latestBuffer.copy(
                            t,
                            e,
                            0,
                            this.latestBufferOffset,
                          ),
                        this.stringFormat ? t.toString(this.stringFormat) : t
                      );
                    }),
                    "function" == typeof s &&
                      (g.addReader(function (t, e) {
                        return t instanceof s
                          ? new m(t)
                          : "hex" === e || "base64" === e
                            ? new m(s.from(t, e))
                            : void 0;
                      }),
                      g.addWriter(function (t) {
                        return t && "buffer" !== t
                          ? "hex" === t || "base64" === t
                            ? new b(t)
                            : void 0
                          : new b();
                      })),
                    (w.prototype = Object.create(i.prototype)),
                    (w.prototype.peekByte = function () {
                      var t = this.hex.substring(this.pos, 2);
                      return parseInt(t, 16);
                    }),
                    (w.prototype.readByte = function () {
                      var t = this.hex.substring(this.pos, this.pos + 2);
                      return (this.pos += 2), parseInt(t, 16);
                    }),
                    (w.prototype.readChunk = function (e) {
                      var r = this.hex.substring(this.pos, this.pos + 2 * e);
                      return (
                        (this.pos += 2 * e),
                        "function" == typeof s ? s.from(r, "hex") : new t(r)
                      );
                    }),
                    (v.prototype = Object.create(o.prototype)),
                    (v.prototype.writeByte = function (t) {
                      if (t < 0 || t > 255)
                        throw new Error("Byte value out of range: " + t);
                      var e = t.toString(16);
                      1 == e.length && (e = "0" + e), (this.$hex += e);
                    }),
                    (v.prototype.canWriteBinary = function (e) {
                      return (
                        e instanceof t ||
                        ("function" == typeof s && e instanceof s)
                      );
                    }),
                    (v.prototype.writeBinary = function (e, r) {
                      if (e instanceof t) r(e.length()), (this.$hex += e.$hex);
                      else {
                        if (!("function" == typeof s && e instanceof s))
                          throw new TypeError(
                            "HexWriter only accepts BinaryHex or Buffers",
                          );
                        r(e.length), (this.$hex += e.toString("hex"));
                      }
                    }),
                    (v.prototype.result = function () {
                      return "buffer" === this.finalFormat &&
                        "function" == typeof s
                        ? s.from(this.$hex, "hex")
                        : new t(this.$hex).toString(this.finalFormat);
                    }),
                    (v.prototype.writeString = function (e, r) {
                      var n = t.fromUtf8String(e);
                      r(n.length()), (this.$hex += n.$hex);
                    }),
                    g.addReader(function (e, r) {
                      return e instanceof t || e.$hex
                        ? new w(e.$hex)
                        : "hex" === r
                          ? new w(e)
                          : void 0;
                    }),
                    g.addWriter(function (t) {
                      if ("hex" === t) return new v();
                    }),
                    g
                  );
                })();
                return (
                  t
                    .addSemanticEncode(0, function (t) {
                      if (t instanceof Date) return t.toISOString();
                    })
                    .addSemanticDecode(0, function (t) {
                      return new Date(t);
                    })
                    .addSemanticDecode(1, function (t) {
                      return new Date(t);
                    }),
                  t
                );
              })
                ? n.apply(e, i)
                : n) || (t.exports = o);
      },
      56168: (t, e, r) => {
        var n = r(92861).Buffer,
          i = r(88310).Transform,
          o = r(83141).I;
        function s(t) {
          i.call(this),
            (this.hashMode = "string" == typeof t),
            this.hashMode
              ? (this[t] = this._finalOrDigest)
              : (this.final = this._finalOrDigest),
            this._final && ((this.__final = this._final), (this._final = null)),
            (this._decoder = null),
            (this._encoding = null);
        }
        r(56698)(s, i),
          (s.prototype.update = function (t, e, r) {
            "string" == typeof t && (t = n.from(t, e));
            var i = this._update(t);
            return this.hashMode ? this : (r && (i = this._toString(i, r)), i);
          }),
          (s.prototype.setAutoPadding = function () {}),
          (s.prototype.getAuthTag = function () {
            throw new Error("trying to get auth tag in unsupported state");
          }),
          (s.prototype.setAuthTag = function () {
            throw new Error("trying to set auth tag in unsupported state");
          }),
          (s.prototype.setAAD = function () {
            throw new Error("trying to set aad in unsupported state");
          }),
          (s.prototype._transform = function (t, e, r) {
            var n;
            try {
              this.hashMode ? this._update(t) : this.push(this._update(t));
            } catch (t) {
              n = t;
            } finally {
              r(n);
            }
          }),
          (s.prototype._flush = function (t) {
            var e;
            try {
              this.push(this.__final());
            } catch (t) {
              e = t;
            }
            t(e);
          }),
          (s.prototype._finalOrDigest = function (t) {
            var e = this.__final() || n.alloc(0);
            return t && (e = this._toString(e, t, !0)), e;
          }),
          (s.prototype._toString = function (t, e, r) {
            if (
              (this._decoder ||
                ((this._decoder = new o(e)), (this._encoding = e)),
              this._encoding !== e)
            )
              throw new Error("can't switch encodings");
            var n = this._decoder.write(t);
            return r && (n += this._decoder.end()), n;
          }),
          (t.exports = s);
      },
      70723: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            crc1: () => a,
            crc16: () => g,
            crc16ccitt: () => w,
            crc16kermit: () => T,
            crc16modbus: () => E,
            crc16xmodem: () => I,
            crc24: () => x,
            crc32: () => C,
            crc8: () => f,
            crc81wire: () => d,
            crcjam: () => U,
            default: () => D,
          });
        var n = r(48287);
        const i =
          n.Buffer.from &&
          n.Buffer.alloc &&
          n.Buffer.allocUnsafe &&
          n.Buffer.allocUnsafeSlow
            ? n.Buffer.from
            : (t) => new n.Buffer(t);
        function o(t, e) {
          const r = (t, r) => e(t, r) >>> 0;
          return (r.signed = e), (r.unsigned = r), (r.model = t), r;
        }
        const s = o("crc1", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = ~~e,
              o = 0;
            for (let e = 0; e < t.length; e++) {
              o += t[e];
            }
            return (r += o % 256), r % 256;
          }),
          a = s;
        let u = [
          0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119,
          126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231,
          238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205,
          144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179,
          186, 189, 199, 192, 201, 206, 219, 220, 213, 210, 255, 248, 241, 246,
          227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136,
          129, 134, 147, 148, 157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24,
          17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111, 104, 97,
          102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177,
          182, 191, 184, 173, 170, 163, 164, 249, 254, 247, 240, 229, 226, 235,
          236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117,
          114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2,
          11, 12, 33, 38, 47, 40, 61, 58, 51, 52, 78, 73, 64, 71, 82, 85, 92,
          91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44,
          43, 6, 1, 8, 15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188,
          187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217, 208, 215, 194,
          197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243,
        ];
        "undefined" != typeof Int32Array && (u = new Int32Array(u));
        const c = o("crc-8", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = ~~e;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 255 & u[255 & (r ^ n)];
            }
            return r;
          }),
          f = c;
        let h = [
          0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31,
          65, 157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130,
          220, 35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222,
          60, 98, 190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67,
          161, 255, 70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229,
          187, 89, 7, 219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120,
          38, 196, 154, 101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69,
          198, 152, 122, 36, 248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134,
          216, 91, 5, 231, 185, 140, 210, 48, 110, 237, 179, 81, 15, 78, 16,
          242, 172, 47, 113, 147, 205, 17, 79, 173, 243, 112, 46, 204, 146, 211,
          141, 111, 49, 178, 236, 14, 80, 175, 241, 19, 77, 206, 144, 114, 44,
          109, 51, 209, 143, 12, 82, 176, 238, 50, 108, 142, 208, 83, 13, 239,
          177, 240, 174, 76, 18, 145, 207, 45, 115, 202, 148, 118, 40, 171, 245,
          23, 73, 8, 86, 180, 234, 105, 55, 213, 139, 87, 9, 235, 181, 54, 104,
          138, 212, 149, 203, 41, 119, 244, 170, 72, 22, 233, 183, 85, 11, 136,
          214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168, 116, 42, 200, 150,
          21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53,
        ];
        "undefined" != typeof Int32Array && (h = new Int32Array(h));
        const l = o("dallas-1-wire", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = ~~e;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 255 & h[255 & (r ^ n)];
            }
            return r;
          }),
          d = l;
        let p = [
          0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920,
          51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840,
          53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176,
          51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680,
          57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440,
          55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697,
          53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864,
          13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705,
          64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321,
          14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200,
          10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328,
          58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049,
          58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281,
          25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048,
          25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609,
          43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297,
          47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961,
          32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041,
          46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121,
          20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208,
          22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257,
          24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976,
          22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008,
          19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985,
          34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601,
          16640, 33217, 32897, 16448,
        ];
        "undefined" != typeof Int32Array && (p = new Int32Array(p));
        const y = o("crc-16", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = ~~e;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 65535 & (p[255 & (r ^ n)] ^ (r >> 8));
            }
            return r;
          }),
          g = y;
        let m = [
          0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290,
          45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173,
          17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463,
          58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346,
          46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649,
          1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455,
          59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242,
          14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285,
          19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447,
          60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298,
          15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200,
          40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439,
          61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514,
          41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484,
          16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239,
          62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570,
          42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280,
          1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231,
          63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941,
          22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596,
          18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223,
          64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801,
          6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424,
          36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215,
          65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053,
          24180, 11923, 16050, 3793, 7920,
        ];
        "undefined" != typeof Int32Array && (m = new Int32Array(m));
        const b = o("ccitt", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = void 0 !== e ? ~~e : 65535;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 65535 & (m[255 & ((r >> 8) ^ n)] ^ (r << 8));
            }
            return r;
          }),
          w = b;
        let v = [
          0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920,
          51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840,
          53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176,
          51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680,
          57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440,
          55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697,
          53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864,
          13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705,
          64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321,
          14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200,
          10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328,
          58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049,
          58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281,
          25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048,
          25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609,
          43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297,
          47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961,
          32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041,
          46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121,
          20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208,
          22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257,
          24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976,
          22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008,
          19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985,
          34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601,
          16640, 33217, 32897, 16448,
        ];
        "undefined" != typeof Int32Array && (v = new Int32Array(v));
        const _ = o("crc-16-modbus", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = void 0 !== e ? ~~e : 65535;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 65535 & (v[255 & (r ^ n)] ^ (r >> 8));
            }
            return r;
          }),
          E = _,
          S = o("xmodem", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = void 0 !== e ? ~~e : 0;
            for (let e = 0; e < t.length; e++) {
              let n = (r >>> 8) & 255;
              (n ^= 255 & t[e]),
                (n ^= n >>> 4),
                (r = (r << 8) & 65535),
                (r ^= n),
                (n = (n << 5) & 65535),
                (r ^= n),
                (n = (n << 7) & 65535),
                (r ^= n);
            }
            return r;
          }),
          I = S;
        let M = [
          0, 4489, 8978, 12955, 17956, 22445, 25910, 29887, 35912, 40385, 44890,
          48851, 51820, 56293, 59774, 63735, 4225, 264, 13203, 8730, 22181,
          18220, 30135, 25662, 40137, 36160, 49115, 44626, 56045, 52068, 63999,
          59510, 8450, 12427, 528, 5017, 26406, 30383, 17460, 21949, 44362,
          48323, 36440, 40913, 60270, 64231, 51324, 55797, 12675, 8202, 4753,
          792, 30631, 26158, 21685, 17724, 48587, 44098, 40665, 36688, 64495,
          60006, 55549, 51572, 16900, 21389, 24854, 28831, 1056, 5545, 10034,
          14011, 52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859, 21125,
          17164, 29079, 24606, 5281, 1320, 14259, 9786, 57037, 53060, 64991,
          60502, 39145, 35168, 48123, 43634, 25350, 29327, 16404, 20893, 9506,
          13483, 1584, 6073, 61262, 65223, 52316, 56789, 43370, 47331, 35448,
          39921, 29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848, 65487,
          60998, 56541, 52564, 47595, 43106, 39673, 35696, 33800, 38273, 42778,
          46739, 49708, 54181, 57662, 61623, 2112, 6601, 11090, 15067, 20068,
          24557, 28022, 31999, 38025, 34048, 47003, 42514, 53933, 49956, 61887,
          57398, 6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774, 42250,
          46211, 34328, 38801, 58158, 62119, 49212, 53685, 10562, 14539, 2640,
          7129, 28518, 32495, 19572, 24061, 46475, 41986, 38553, 34576, 62383,
          57894, 53437, 49460, 14787, 10314, 6865, 2904, 32743, 28270, 23797,
          19836, 50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747, 19012,
          23501, 26966, 30943, 3168, 7657, 12146, 16123, 54925, 50948, 62879,
          58390, 37033, 33056, 46011, 41522, 23237, 19276, 31191, 26718, 7393,
          3432, 16371, 11898, 59150, 63111, 50204, 54677, 41258, 45219, 33336,
          37809, 27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185, 63375,
          58886, 54429, 50452, 45483, 40994, 37561, 33584, 31687, 27214, 22741,
          18780, 15843, 11370, 7921, 3960,
        ];
        "undefined" != typeof Int32Array && (M = new Int32Array(M));
        const A = o("kermit", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = void 0 !== e ? ~~e : 0;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 65535 & (M[255 & (r ^ n)] ^ (r >> 8));
            }
            return r;
          }),
          T = A;
        let k = [
          0, 8801531, 9098509, 825846, 9692897, 1419802, 1651692, 10452759,
          10584377, 2608578, 2839604, 11344079, 3303384, 11807523, 12104405,
          4128302, 12930697, 4391538, 5217156, 13227903, 5679208, 13690003,
          14450021, 5910942, 6606768, 14844747, 15604413, 6837830, 16197969,
          7431594, 8256604, 16494759, 840169, 9084178, 8783076, 18463, 10434312,
          1670131, 1434117, 9678590, 11358416, 2825259, 2590173, 10602790,
          4109873, 12122826, 11821884, 3289031, 13213536, 5231515, 4409965,
          12912278, 5929345, 14431610, 13675660, 5693559, 6823513, 15618722,
          14863188, 6588335, 16513208, 8238147, 7417269, 16212302, 1680338,
          10481449, 9664223, 1391140, 9061683, 788936, 36926, 8838341, 12067563,
          4091408, 3340262, 11844381, 2868234, 11372785, 10555655, 2579964,
          14478683, 5939616, 5650518, 13661357, 5180346, 13190977, 12967607,
          4428364, 8219746, 16457881, 16234863, 7468436, 15633027, 6866552,
          6578062, 14816117, 1405499, 9649856, 10463030, 1698765, 8819930,
          55329, 803287, 9047340, 11858690, 3325945, 4072975, 12086004, 2561507,
          10574104, 11387118, 2853909, 13647026, 5664841, 5958079, 14460228,
          4446803, 12949160, 13176670, 5194661, 7454091, 16249200, 16476294,
          8201341, 14834538, 6559633, 6852199, 15647388, 3360676, 11864927,
          12161705, 4185682, 10527045, 2551230, 2782280, 11286707, 9619101,
          1346150, 1577872, 10379115, 73852, 8875143, 9172337, 899466, 16124205,
          7357910, 8182816, 16421083, 6680524, 14918455, 15678145, 6911546,
          5736468, 13747439, 14507289, 5968354, 12873461, 4334094, 5159928,
          13170435, 4167245, 12180150, 11879232, 3346363, 11301036, 2767959,
          2532769, 10545498, 10360692, 1596303, 1360505, 9604738, 913813,
          9157998, 8856728, 92259, 16439492, 8164415, 7343561, 16138546,
          6897189, 15692510, 14936872, 6662099, 5986813, 14488838, 13733104,
          5750795, 13156124, 5174247, 4352529, 12855018, 2810998, 11315341,
          10498427, 2522496, 12124823, 4148844, 3397530, 11901793, 9135439,
          862644, 110658, 8912057, 1606574, 10407765, 9590435, 1317464,
          15706879, 6940164, 6651890, 14889737, 8145950, 16384229, 16161043,
          7394792, 5123014, 13133629, 12910283, 4370992, 14535975, 5997020,
          5707818, 13718737, 2504095, 10516836, 11329682, 2796649, 11916158,
          3383173, 4130419, 12143240, 8893606, 129117, 876971, 9121104, 1331783,
          9576124, 10389322, 1625009, 14908182, 6633453, 6925851, 15721184,
          7380471, 16175372, 16402682, 8127489, 4389423, 12891860, 13119266,
          5137369, 13704398, 5722165, 6015427, 14517560,
        ];
        "undefined" != typeof Int32Array && (k = new Int32Array(k));
        const O = o("crc-24", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = void 0 !== e ? ~~e : 11994318;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = 16777215 & (k[255 & ((r >> 16) ^ n)] ^ (r << 8));
            }
            return r;
          }),
          x = O;
        let P = [
          0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615,
          3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864,
          162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666,
          4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639,
          325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465,
          4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242,
          1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684,
          3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665,
          651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731,
          3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812,
          795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534,
          2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059,
          2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813,
          2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878,
          1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704,
          2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405,
          1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311,
          2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856,
          1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306,
          3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015,
          1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873,
          3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842,
          3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804,
          225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377,
          4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355,
          426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852,
          4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558,
          953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859,
          3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669,
          829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366,
          3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608,
          733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221,
          2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151,
          1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
          2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610,
          1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567,
          2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745,
          1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938,
          2808555105, 3495958263, 1231636301, 1047427035, 2932959818,
          3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863,
          817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493,
          3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
          711928724, 3020668471, 3272380065, 1510334235, 755167117,
        ];
        "undefined" != typeof Int32Array && (P = new Int32Array(P));
        const B = o("crc-32", function (t, e) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = 0 === e ? 0 : ~e;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = P[255 & (r ^ n)] ^ (r >>> 8);
            }
            return ~r;
          }),
          C = B;
        let R = [
          0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615,
          3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864,
          162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666,
          4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639,
          325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465,
          4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242,
          1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684,
          3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665,
          651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731,
          3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812,
          795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534,
          2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059,
          2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813,
          2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878,
          1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704,
          2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405,
          1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311,
          2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856,
          1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306,
          3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015,
          1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873,
          3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842,
          3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804,
          225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377,
          4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355,
          426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852,
          4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558,
          953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859,
          3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669,
          829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366,
          3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608,
          733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221,
          2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151,
          1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
          2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610,
          1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567,
          2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745,
          1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938,
          2808555105, 3495958263, 1231636301, 1047427035, 2932959818,
          3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863,
          817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493,
          3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
          711928724, 3020668471, 3272380065, 1510334235, 755167117,
        ];
        "undefined" != typeof Int32Array && (R = new Int32Array(R));
        const N = o("jam", function (t, e = -1) {
            n.Buffer.isBuffer(t) || (t = i(t));
            let r = 0 === e ? 0 : ~~e;
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              r = R[255 & (r ^ n)] ^ (r >>> 8);
            }
            return r;
          }),
          U = N,
          D = {
            crc1: a,
            crc8: f,
            crc81wire: d,
            crc16: g,
            crc16ccitt: w,
            crc16modbus: E,
            crc16xmodem: I,
            crc16kermit: T,
            crc24: x,
            crc32: C,
            crcjam: N,
          };
      },
      61324: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(86729),
          o = r(92801);
        t.exports = function (t) {
          return new a(t);
        };
        var s = {
          secp256k1: { name: "secp256k1", byteLength: 32 },
          secp224r1: { name: "p224", byteLength: 28 },
          prime256v1: { name: "p256", byteLength: 32 },
          prime192v1: { name: "p192", byteLength: 24 },
          ed25519: { name: "ed25519", byteLength: 32 },
          secp384r1: { name: "p384", byteLength: 48 },
          secp521r1: { name: "p521", byteLength: 66 },
        };
        function a(t) {
          (this.curveType = s[t]),
            this.curveType || (this.curveType = { name: t }),
            (this.curve = new i.ec(this.curveType.name)),
            (this.keys = void 0);
        }
        function u(t, e, r) {
          Array.isArray(t) || (t = t.toArray());
          var i = new n(t);
          if (r && i.length < r) {
            var o = new n(r - i.length);
            o.fill(0), (i = n.concat([o, i]));
          }
          return e ? i.toString(e) : i;
        }
        (s.p224 = s.secp224r1),
          (s.p256 = s.secp256r1 = s.prime256v1),
          (s.p192 = s.secp192r1 = s.prime192v1),
          (s.p384 = s.secp384r1),
          (s.p521 = s.secp521r1),
          (a.prototype.generateKeys = function (t, e) {
            return (
              (this.keys = this.curve.genKeyPair()), this.getPublicKey(t, e)
            );
          }),
          (a.prototype.computeSecret = function (t, e, r) {
            return (
              (e = e || "utf8"),
              n.isBuffer(t) || (t = new n(t, e)),
              u(
                this.curve
                  .keyFromPublic(t)
                  .getPublic()
                  .mul(this.keys.getPrivate())
                  .getX(),
                r,
                this.curveType.byteLength,
              )
            );
          }),
          (a.prototype.getPublicKey = function (t, e) {
            var r = this.keys.getPublic("compressed" === e, !0);
            return (
              "hybrid" === e && (r[r.length - 1] % 2 ? (r[0] = 7) : (r[0] = 6)),
              u(r, t)
            );
          }),
          (a.prototype.getPrivateKey = function (t) {
            return u(this.keys.getPrivate(), t);
          }),
          (a.prototype.setPublicKey = function (t, e) {
            return (
              (e = e || "utf8"),
              n.isBuffer(t) || (t = new n(t, e)),
              this.keys._importPublic(t),
              this
            );
          }),
          (a.prototype.setPrivateKey = function (t, e) {
            (e = e || "utf8"), n.isBuffer(t) || (t = new n(t, e));
            var r = new o(t);
            return (
              (r = r.toString(16)),
              (this.keys = this.curve.genKeyPair()),
              this.keys._importPrivate(r),
              this
            );
          });
      },
      92801: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(77965).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      47108: (t, e, r) => {
        "use strict";
        var n = r(56698),
          i = r(88276),
          o = r(66011),
          s = r(62802),
          a = r(56168);
        function u(t) {
          a.call(this, "digest"), (this._hash = t);
        }
        n(u, a),
          (u.prototype._update = function (t) {
            this._hash.update(t);
          }),
          (u.prototype._final = function () {
            return this._hash.digest();
          }),
          (t.exports = function (t) {
            return "md5" === (t = t.toLowerCase())
              ? new i()
              : "rmd160" === t || "ripemd160" === t
                ? new o()
                : new u(s(t));
          });
      },
      20320: (t, e, r) => {
        var n = r(88276);
        t.exports = function (t) {
          return new n().update(t).digest();
        };
      },
      83507: (t, e, r) => {
        "use strict";
        var n = r(56698),
          i = r(41800),
          o = r(56168),
          s = r(92861).Buffer,
          a = r(20320),
          u = r(66011),
          c = r(62802),
          f = s.alloc(128);
        function h(t, e) {
          o.call(this, "digest"), "string" == typeof e && (e = s.from(e));
          var r = "sha512" === t || "sha384" === t ? 128 : 64;
          ((this._alg = t), (this._key = e), e.length > r)
            ? (e = ("rmd160" === t ? new u() : c(t)).update(e).digest())
            : e.length < r && (e = s.concat([e, f], r));
          for (
            var n = (this._ipad = s.allocUnsafe(r)),
              i = (this._opad = s.allocUnsafe(r)),
              a = 0;
            a < r;
            a++
          )
            (n[a] = 54 ^ e[a]), (i[a] = 92 ^ e[a]);
          (this._hash = "rmd160" === t ? new u() : c(t)), this._hash.update(n);
        }
        n(h, o),
          (h.prototype._update = function (t) {
            this._hash.update(t);
          }),
          (h.prototype._final = function () {
            var t = this._hash.digest();
            return ("rmd160" === this._alg ? new u() : c(this._alg))
              .update(this._opad)
              .update(t)
              .digest();
          }),
          (t.exports = function (t, e) {
            return "rmd160" === (t = t.toLowerCase()) || "ripemd160" === t
              ? new h("rmd160", e)
              : "md5" === t
                ? new i(a, e)
                : new h(t, e);
          });
      },
      41800: (t, e, r) => {
        "use strict";
        var n = r(56698),
          i = r(92861).Buffer,
          o = r(56168),
          s = i.alloc(128),
          a = 64;
        function u(t, e) {
          o.call(this, "digest"),
            "string" == typeof e && (e = i.from(e)),
            (this._alg = t),
            (this._key = e),
            e.length > a
              ? (e = t(e))
              : e.length < a && (e = i.concat([e, s], a));
          for (
            var r = (this._ipad = i.allocUnsafe(a)),
              n = (this._opad = i.allocUnsafe(a)),
              u = 0;
            u < a;
            u++
          )
            (r[u] = 54 ^ e[u]), (n[u] = 92 ^ e[u]);
          this._hash = [r];
        }
        n(u, o),
          (u.prototype._update = function (t) {
            this._hash.push(t);
          }),
          (u.prototype._final = function () {
            var t = this._alg(i.concat(this._hash));
            return this._alg(i.concat([this._opad, t]));
          }),
          (t.exports = u);
      },
      86547: function () {
        !(function (t) {
          !(function (e) {
            var r = "URLSearchParams" in t,
              n = "Symbol" in t && "iterator" in Symbol,
              i =
                "FileReader" in t &&
                "Blob" in t &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (t) {
                    return !1;
                  }
                })(),
              o = "FormData" in t,
              s = "ArrayBuffer" in t;
            if (s)
              var a = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]",
                ],
                u =
                  ArrayBuffer.isView ||
                  function (t) {
                    return (
                      t && a.indexOf(Object.prototype.toString.call(t)) > -1
                    );
                  };
            function c(t) {
              if (
                ("string" != typeof t && (t = String(t)),
                /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t))
              )
                throw new TypeError("Invalid character in header field name");
              return t.toLowerCase();
            }
            function f(t) {
              return "string" != typeof t && (t = String(t)), t;
            }
            function h(t) {
              var e = {
                next: function () {
                  var e = t.shift();
                  return { done: void 0 === e, value: e };
                },
              };
              return (
                n &&
                  (e[Symbol.iterator] = function () {
                    return e;
                  }),
                e
              );
            }
            function l(t) {
              (this.map = {}),
                t instanceof l
                  ? t.forEach(function (t, e) {
                      this.append(e, t);
                    }, this)
                  : Array.isArray(t)
                    ? t.forEach(function (t) {
                        this.append(t[0], t[1]);
                      }, this)
                    : t &&
                      Object.getOwnPropertyNames(t).forEach(function (e) {
                        this.append(e, t[e]);
                      }, this);
            }
            function d(t) {
              if (t.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              t.bodyUsed = !0;
            }
            function p(t) {
              return new Promise(function (e, r) {
                (t.onload = function () {
                  e(t.result);
                }),
                  (t.onerror = function () {
                    r(t.error);
                  });
              });
            }
            function y(t) {
              var e = new FileReader(),
                r = p(e);
              return e.readAsArrayBuffer(t), r;
            }
            function g(t) {
              if (t.slice) return t.slice(0);
              var e = new Uint8Array(t.byteLength);
              return e.set(new Uint8Array(t)), e.buffer;
            }
            function m() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (t) {
                  var e;
                  (this._bodyInit = t),
                    t
                      ? "string" == typeof t
                        ? (this._bodyText = t)
                        : i && Blob.prototype.isPrototypeOf(t)
                          ? (this._bodyBlob = t)
                          : o && FormData.prototype.isPrototypeOf(t)
                            ? (this._bodyFormData = t)
                            : r && URLSearchParams.prototype.isPrototypeOf(t)
                              ? (this._bodyText = t.toString())
                              : s &&
                                  i &&
                                  (e = t) &&
                                  DataView.prototype.isPrototypeOf(e)
                                ? ((this._bodyArrayBuffer = g(t.buffer)),
                                  (this._bodyInit = new Blob([
                                    this._bodyArrayBuffer,
                                  ])))
                                : s &&
                                    (ArrayBuffer.prototype.isPrototypeOf(t) ||
                                      u(t))
                                  ? (this._bodyArrayBuffer = g(t))
                                  : (this._bodyText = t =
                                      Object.prototype.toString.call(t))
                      : (this._bodyText = ""),
                    this.headers.get("content-type") ||
                      ("string" == typeof t
                        ? this.headers.set(
                            "content-type",
                            "text/plain;charset=UTF-8",
                          )
                        : this._bodyBlob && this._bodyBlob.type
                          ? this.headers.set(
                              "content-type",
                              this._bodyBlob.type,
                            )
                          : r &&
                            URLSearchParams.prototype.isPrototypeOf(t) &&
                            this.headers.set(
                              "content-type",
                              "application/x-www-form-urlencoded;charset=UTF-8",
                            ));
                }),
                i &&
                  ((this.blob = function () {
                    var t = d(this);
                    if (t) return t;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                      throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]));
                  }),
                  (this.arrayBuffer = function () {
                    return this._bodyArrayBuffer
                      ? d(this) || Promise.resolve(this._bodyArrayBuffer)
                      : this.blob().then(y);
                  })),
                (this.text = function () {
                  var t,
                    e,
                    r,
                    n = d(this);
                  if (n) return n;
                  if (this._bodyBlob)
                    return (
                      (t = this._bodyBlob),
                      (e = new FileReader()),
                      (r = p(e)),
                      e.readAsText(t),
                      r
                    );
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(
                      (function (t) {
                        for (
                          var e = new Uint8Array(t),
                            r = new Array(e.length),
                            n = 0;
                          n < e.length;
                          n++
                        )
                          r[n] = String.fromCharCode(e[n]);
                        return r.join("");
                      })(this._bodyArrayBuffer),
                    );
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }),
                o &&
                  (this.formData = function () {
                    return this.text().then(v);
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse);
                }),
                this
              );
            }
            (l.prototype.append = function (t, e) {
              (t = c(t)), (e = f(e));
              var r = this.map[t];
              this.map[t] = r ? r + ", " + e : e;
            }),
              (l.prototype.delete = function (t) {
                delete this.map[c(t)];
              }),
              (l.prototype.get = function (t) {
                return (t = c(t)), this.has(t) ? this.map[t] : null;
              }),
              (l.prototype.has = function (t) {
                return this.map.hasOwnProperty(c(t));
              }),
              (l.prototype.set = function (t, e) {
                this.map[c(t)] = f(e);
              }),
              (l.prototype.forEach = function (t, e) {
                for (var r in this.map)
                  this.map.hasOwnProperty(r) && t.call(e, this.map[r], r, this);
              }),
              (l.prototype.keys = function () {
                var t = [];
                return (
                  this.forEach(function (e, r) {
                    t.push(r);
                  }),
                  h(t)
                );
              }),
              (l.prototype.values = function () {
                var t = [];
                return (
                  this.forEach(function (e) {
                    t.push(e);
                  }),
                  h(t)
                );
              }),
              (l.prototype.entries = function () {
                var t = [];
                return (
                  this.forEach(function (e, r) {
                    t.push([r, e]);
                  }),
                  h(t)
                );
              }),
              n && (l.prototype[Symbol.iterator] = l.prototype.entries);
            var b = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function w(t, e) {
              var r,
                n,
                i = (e = e || {}).body;
              if (t instanceof w) {
                if (t.bodyUsed) throw new TypeError("Already read");
                (this.url = t.url),
                  (this.credentials = t.credentials),
                  e.headers || (this.headers = new l(t.headers)),
                  (this.method = t.method),
                  (this.mode = t.mode),
                  (this.signal = t.signal),
                  i ||
                    null == t._bodyInit ||
                    ((i = t._bodyInit), (t.bodyUsed = !0));
              } else this.url = String(t);
              if (
                ((this.credentials =
                  e.credentials || this.credentials || "same-origin"),
                (!e.headers && this.headers) ||
                  (this.headers = new l(e.headers)),
                (this.method =
                  ((r = e.method || this.method || "GET"),
                  (n = r.toUpperCase()),
                  b.indexOf(n) > -1 ? n : r)),
                (this.mode = e.mode || this.mode || null),
                (this.signal = e.signal || this.signal),
                (this.referrer = null),
                ("GET" === this.method || "HEAD" === this.method) && i)
              )
                throw new TypeError(
                  "Body not allowed for GET or HEAD requests",
                );
              this._initBody(i);
            }
            function v(t) {
              var e = new FormData();
              return (
                t
                  .trim()
                  .split("&")
                  .forEach(function (t) {
                    if (t) {
                      var r = t.split("="),
                        n = r.shift().replace(/\+/g, " "),
                        i = r.join("=").replace(/\+/g, " ");
                      e.append(decodeURIComponent(n), decodeURIComponent(i));
                    }
                  }),
                e
              );
            }
            function _(t, e) {
              e || (e = {}),
                (this.type = "default"),
                (this.status = void 0 === e.status ? 200 : e.status),
                (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = "statusText" in e ? e.statusText : "OK"),
                (this.headers = new l(e.headers)),
                (this.url = e.url || ""),
                this._initBody(t);
            }
            (w.prototype.clone = function () {
              return new w(this, { body: this._bodyInit });
            }),
              m.call(w.prototype),
              m.call(_.prototype),
              (_.prototype.clone = function () {
                return new _(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new l(this.headers),
                  url: this.url,
                });
              }),
              (_.error = function () {
                var t = new _(null, { status: 0, statusText: "" });
                return (t.type = "error"), t;
              });
            var E = [301, 302, 303, 307, 308];
            (_.redirect = function (t, e) {
              if (-1 === E.indexOf(e))
                throw new RangeError("Invalid status code");
              return new _(null, { status: e, headers: { location: t } });
            }),
              (e.DOMException = t.DOMException);
            try {
              new e.DOMException();
            } catch (t) {
              (e.DOMException = function (t, e) {
                (this.message = t), (this.name = e);
                var r = Error(t);
                this.stack = r.stack;
              }),
                (e.DOMException.prototype = Object.create(Error.prototype)),
                (e.DOMException.prototype.constructor = e.DOMException);
            }
            function S(t, r) {
              return new Promise(function (n, o) {
                var s = new w(t, r);
                if (s.signal && s.signal.aborted)
                  return o(new e.DOMException("Aborted", "AbortError"));
                var a = new XMLHttpRequest();
                function u() {
                  a.abort();
                }
                (a.onload = function () {
                  var t,
                    e,
                    r = {
                      status: a.status,
                      statusText: a.statusText,
                      headers:
                        ((t = a.getAllResponseHeaders() || ""),
                        (e = new l()),
                        t
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split(/\r?\n/)
                          .forEach(function (t) {
                            var r = t.split(":"),
                              n = r.shift().trim();
                            if (n) {
                              var i = r.join(":").trim();
                              e.append(n, i);
                            }
                          }),
                        e),
                    };
                  r.url =
                    "responseURL" in a
                      ? a.responseURL
                      : r.headers.get("X-Request-URL");
                  var i = "response" in a ? a.response : a.responseText;
                  n(new _(i, r));
                }),
                  (a.onerror = function () {
                    o(new TypeError("Network request failed"));
                  }),
                  (a.ontimeout = function () {
                    o(new TypeError("Network request failed"));
                  }),
                  (a.onabort = function () {
                    o(new e.DOMException("Aborted", "AbortError"));
                  }),
                  a.open(s.method, s.url, !0),
                  "include" === s.credentials
                    ? (a.withCredentials = !0)
                    : "omit" === s.credentials && (a.withCredentials = !1),
                  "responseType" in a && i && (a.responseType = "blob"),
                  s.headers.forEach(function (t, e) {
                    a.setRequestHeader(e, t);
                  }),
                  s.signal &&
                    (s.signal.addEventListener("abort", u),
                    (a.onreadystatechange = function () {
                      4 === a.readyState &&
                        s.signal.removeEventListener("abort", u);
                    })),
                  a.send(void 0 === s._bodyInit ? null : s._bodyInit);
              });
            }
            (S.polyfill = !0),
              t.fetch ||
                ((t.fetch = S),
                (t.Headers = l),
                (t.Request = w),
                (t.Response = _)),
              (e.Headers = l),
              (e.Request = w),
              (e.Response = _),
              (e.fetch = S),
              Object.defineProperty(e, "__esModule", { value: !0 });
          })({});
        })("undefined" != typeof self ? self : this);
      },
      91565: (t, e, r) => {
        "use strict";
        r(53209), r(47108), r(83507);
        var n = r(55715),
          i = Object.keys(n),
          o = [
            "sha1",
            "sha224",
            "sha256",
            "sha384",
            "sha512",
            "md5",
            "rmd160",
          ].concat(i);
        var s = r(78396);
        s.pbkdf2, s.pbkdf2Sync;
        var a = r(30125);
        a.Cipher,
          a.createCipher,
          a.Cipheriv,
          a.createCipheriv,
          a.Decipher,
          a.createDecipher,
          a.Decipheriv,
          a.createDecipheriv,
          a.getCiphers,
          a.listCiphers;
        var u = r(15380);
        u.DiffieHellmanGroup,
          u.createDiffieHellmanGroup,
          u.getDiffieHellman,
          u.createDiffieHellman,
          u.DiffieHellman;
        var c = r(20);
        c.createSign, c.Sign, c.createVerify, c.Verify, r(61324);
        var f = r(97168);
        f.publicEncrypt, f.privateEncrypt, f.publicDecrypt, f.privateDecrypt;
        var h = r(76983);
        h.randomFill, h.randomFillSync;
      },
      30041: (t, e, r) => {
        "use strict";
        var n = r(30655),
          i = r(58068),
          o = r(69675),
          s = r(75795);
        t.exports = function (t, e, r) {
          if (!t || ("object" != typeof t && "function" != typeof t))
            throw new o("`obj` must be an object or a function`");
          if ("string" != typeof e && "symbol" != typeof e)
            throw new o("`property` must be a string or a symbol`");
          if (
            arguments.length > 3 &&
            "boolean" != typeof arguments[3] &&
            null !== arguments[3]
          )
            throw new o(
              "`nonEnumerable`, if provided, must be a boolean or null",
            );
          if (
            arguments.length > 4 &&
            "boolean" != typeof arguments[4] &&
            null !== arguments[4]
          )
            throw new o(
              "`nonWritable`, if provided, must be a boolean or null",
            );
          if (
            arguments.length > 5 &&
            "boolean" != typeof arguments[5] &&
            null !== arguments[5]
          )
            throw new o(
              "`nonConfigurable`, if provided, must be a boolean or null",
            );
          if (arguments.length > 6 && "boolean" != typeof arguments[6])
            throw new o("`loose`, if provided, must be a boolean");
          var a = arguments.length > 3 ? arguments[3] : null,
            u = arguments.length > 4 ? arguments[4] : null,
            c = arguments.length > 5 ? arguments[5] : null,
            f = arguments.length > 6 && arguments[6],
            h = !!s && s(t, e);
          if (n)
            n(t, e, {
              configurable: null === c && h ? h.configurable : !c,
              enumerable: null === a && h ? h.enumerable : !a,
              value: r,
              writable: null === u && h ? h.writable : !u,
            });
          else {
            if (!f && (a || u || c))
              throw new i(
                "This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.",
              );
            t[e] = r;
          }
        };
      },
      38452: (t, e, r) => {
        "use strict";
        var n = r(1189),
          i = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"),
          o = Object.prototype.toString,
          s = Array.prototype.concat,
          a = Object.defineProperty,
          u = r(30592)(),
          c = a && u,
          f = function (t, e, r, n) {
            if (e in t)
              if (!0 === n) {
                if (t[e] === r) return;
              } else if (
                "function" != typeof (i = n) ||
                "[object Function]" !== o.call(i) ||
                !n()
              )
                return;
            var i;
            c
              ? a(t, e, {
                  configurable: !0,
                  enumerable: !1,
                  value: r,
                  writable: !0,
                })
              : (t[e] = r);
          },
          h = function (t, e) {
            var r = arguments.length > 2 ? arguments[2] : {},
              o = n(e);
            i && (o = s.call(o, Object.getOwnPropertySymbols(e)));
            for (var a = 0; a < o.length; a += 1) f(t, o[a], e[o[a]], r[o[a]]);
          };
        (h.supportsDescriptors = !!c), (t.exports = h);
      },
      29560: (t, e, r) => {
        "use strict";
        (e.utils = r(87626)),
          (e.Cipher = r(82808)),
          (e.DES = r(82211)),
          (e.CBC = r(3389)),
          (e.EDE = r(65279));
      },
      3389: (t, e, r) => {
        "use strict";
        var n = r(43349),
          i = r(56698),
          o = {};
        function s(t) {
          n.equal(t.length, 8, "Invalid IV length"), (this.iv = new Array(8));
          for (var e = 0; e < this.iv.length; e++) this.iv[e] = t[e];
        }
        (e.instantiate = function (t) {
          function e(e) {
            t.call(this, e), this._cbcInit();
          }
          i(e, t);
          for (var r = Object.keys(o), n = 0; n < r.length; n++) {
            var s = r[n];
            e.prototype[s] = o[s];
          }
          return (
            (e.create = function (t) {
              return new e(t);
            }),
            e
          );
        }),
          (o._cbcInit = function () {
            var t = new s(this.options.iv);
            this._cbcState = t;
          }),
          (o._update = function (t, e, r, n) {
            var i = this._cbcState,
              o = this.constructor.super_.prototype,
              s = i.iv;
            if ("encrypt" === this.type) {
              for (var a = 0; a < this.blockSize; a++) s[a] ^= t[e + a];
              o._update.call(this, s, 0, r, n);
              for (a = 0; a < this.blockSize; a++) s[a] = r[n + a];
            } else {
              o._update.call(this, t, e, r, n);
              for (a = 0; a < this.blockSize; a++) r[n + a] ^= s[a];
              for (a = 0; a < this.blockSize; a++) s[a] = t[e + a];
            }
          });
      },
      82808: (t, e, r) => {
        "use strict";
        var n = r(43349);
        function i(t) {
          (this.options = t),
            (this.type = this.options.type),
            (this.blockSize = 8),
            this._init(),
            (this.buffer = new Array(this.blockSize)),
            (this.bufferOff = 0),
            (this.padding = !1 !== t.padding);
        }
        (t.exports = i),
          (i.prototype._init = function () {}),
          (i.prototype.update = function (t) {
            return 0 === t.length
              ? []
              : "decrypt" === this.type
                ? this._updateDecrypt(t)
                : this._updateEncrypt(t);
          }),
          (i.prototype._buffer = function (t, e) {
            for (
              var r = Math.min(
                  this.buffer.length - this.bufferOff,
                  t.length - e,
                ),
                n = 0;
              n < r;
              n++
            )
              this.buffer[this.bufferOff + n] = t[e + n];
            return (this.bufferOff += r), r;
          }),
          (i.prototype._flushBuffer = function (t, e) {
            return (
              this._update(this.buffer, 0, t, e),
              (this.bufferOff = 0),
              this.blockSize
            );
          }),
          (i.prototype._updateEncrypt = function (t) {
            var e = 0,
              r = 0,
              n = ((this.bufferOff + t.length) / this.blockSize) | 0,
              i = new Array(n * this.blockSize);
            0 !== this.bufferOff &&
              ((e += this._buffer(t, e)),
              this.bufferOff === this.buffer.length &&
                (r += this._flushBuffer(i, r)));
            for (
              var o = t.length - ((t.length - e) % this.blockSize);
              e < o;
              e += this.blockSize
            )
              this._update(t, e, i, r), (r += this.blockSize);
            for (; e < t.length; e++, this.bufferOff++)
              this.buffer[this.bufferOff] = t[e];
            return i;
          }),
          (i.prototype._updateDecrypt = function (t) {
            for (
              var e = 0,
                r = 0,
                n = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1,
                i = new Array(n * this.blockSize);
              n > 0;
              n--
            )
              (e += this._buffer(t, e)), (r += this._flushBuffer(i, r));
            return (e += this._buffer(t, e)), i;
          }),
          (i.prototype.final = function (t) {
            var e, r;
            return (
              t && (e = this.update(t)),
              (r =
                "encrypt" === this.type
                  ? this._finalEncrypt()
                  : this._finalDecrypt()),
              e ? e.concat(r) : r
            );
          }),
          (i.prototype._pad = function (t, e) {
            if (0 === e) return !1;
            for (; e < t.length; ) t[e++] = 0;
            return !0;
          }),
          (i.prototype._finalEncrypt = function () {
            if (!this._pad(this.buffer, this.bufferOff)) return [];
            var t = new Array(this.blockSize);
            return this._update(this.buffer, 0, t, 0), t;
          }),
          (i.prototype._unpad = function (t) {
            return t;
          }),
          (i.prototype._finalDecrypt = function () {
            n.equal(
              this.bufferOff,
              this.blockSize,
              "Not enough data to decrypt",
            );
            var t = new Array(this.blockSize);
            return this._flushBuffer(t, 0), this._unpad(t);
          });
      },
      82211: (t, e, r) => {
        "use strict";
        var n = r(43349),
          i = r(56698),
          o = r(87626),
          s = r(82808);
        function a() {
          (this.tmp = new Array(2)), (this.keys = null);
        }
        function u(t) {
          s.call(this, t);
          var e = new a();
          (this._desState = e), this.deriveKeys(e, t.key);
        }
        i(u, s),
          (t.exports = u),
          (u.create = function (t) {
            return new u(t);
          });
        var c = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
        (u.prototype.deriveKeys = function (t, e) {
          (t.keys = new Array(32)),
            n.equal(e.length, this.blockSize, "Invalid key length");
          var r = o.readUInt32BE(e, 0),
            i = o.readUInt32BE(e, 4);
          o.pc1(r, i, t.tmp, 0), (r = t.tmp[0]), (i = t.tmp[1]);
          for (var s = 0; s < t.keys.length; s += 2) {
            var a = c[s >>> 1];
            (r = o.r28shl(r, a)), (i = o.r28shl(i, a)), o.pc2(r, i, t.keys, s);
          }
        }),
          (u.prototype._update = function (t, e, r, n) {
            var i = this._desState,
              s = o.readUInt32BE(t, e),
              a = o.readUInt32BE(t, e + 4);
            o.ip(s, a, i.tmp, 0),
              (s = i.tmp[0]),
              (a = i.tmp[1]),
              "encrypt" === this.type
                ? this._encrypt(i, s, a, i.tmp, 0)
                : this._decrypt(i, s, a, i.tmp, 0),
              (s = i.tmp[0]),
              (a = i.tmp[1]),
              o.writeUInt32BE(r, s, n),
              o.writeUInt32BE(r, a, n + 4);
          }),
          (u.prototype._pad = function (t, e) {
            if (!1 === this.padding) return !1;
            for (var r = t.length - e, n = e; n < t.length; n++) t[n] = r;
            return !0;
          }),
          (u.prototype._unpad = function (t) {
            if (!1 === this.padding) return t;
            for (var e = t[t.length - 1], r = t.length - e; r < t.length; r++)
              n.equal(t[r], e);
            return t.slice(0, t.length - e);
          }),
          (u.prototype._encrypt = function (t, e, r, n, i) {
            for (var s = e, a = r, u = 0; u < t.keys.length; u += 2) {
              var c = t.keys[u],
                f = t.keys[u + 1];
              o.expand(a, t.tmp, 0), (c ^= t.tmp[0]), (f ^= t.tmp[1]);
              var h = o.substitute(c, f),
                l = a;
              (a = (s ^ o.permute(h)) >>> 0), (s = l);
            }
            o.rip(a, s, n, i);
          }),
          (u.prototype._decrypt = function (t, e, r, n, i) {
            for (var s = r, a = e, u = t.keys.length - 2; u >= 0; u -= 2) {
              var c = t.keys[u],
                f = t.keys[u + 1];
              o.expand(s, t.tmp, 0), (c ^= t.tmp[0]), (f ^= t.tmp[1]);
              var h = o.substitute(c, f),
                l = s;
              (s = (a ^ o.permute(h)) >>> 0), (a = l);
            }
            o.rip(s, a, n, i);
          });
      },
      65279: (t, e, r) => {
        "use strict";
        var n = r(43349),
          i = r(56698),
          o = r(82808),
          s = r(82211);
        function a(t, e) {
          n.equal(e.length, 24, "Invalid key length");
          var r = e.slice(0, 8),
            i = e.slice(8, 16),
            o = e.slice(16, 24);
          this.ciphers =
            "encrypt" === t
              ? [
                  s.create({ type: "encrypt", key: r }),
                  s.create({ type: "decrypt", key: i }),
                  s.create({ type: "encrypt", key: o }),
                ]
              : [
                  s.create({ type: "decrypt", key: o }),
                  s.create({ type: "encrypt", key: i }),
                  s.create({ type: "decrypt", key: r }),
                ];
        }
        function u(t) {
          o.call(this, t);
          var e = new a(this.type, this.options.key);
          this._edeState = e;
        }
        i(u, o),
          (t.exports = u),
          (u.create = function (t) {
            return new u(t);
          }),
          (u.prototype._update = function (t, e, r, n) {
            var i = this._edeState;
            i.ciphers[0]._update(t, e, r, n),
              i.ciphers[1]._update(r, n, r, n),
              i.ciphers[2]._update(r, n, r, n);
          }),
          (u.prototype._pad = s.prototype._pad),
          (u.prototype._unpad = s.prototype._unpad);
      },
      87626: (t, e) => {
        "use strict";
        (e.readUInt32BE = function (t, e) {
          return (
            ((t[0 + e] << 24) |
              (t[1 + e] << 16) |
              (t[2 + e] << 8) |
              t[3 + e]) >>>
            0
          );
        }),
          (e.writeUInt32BE = function (t, e, r) {
            (t[0 + r] = e >>> 24),
              (t[1 + r] = (e >>> 16) & 255),
              (t[2 + r] = (e >>> 8) & 255),
              (t[3 + r] = 255 & e);
          }),
          (e.ip = function (t, e, r, n) {
            for (var i = 0, o = 0, s = 6; s >= 0; s -= 2) {
              for (var a = 0; a <= 24; a += 8)
                (i <<= 1), (i |= (e >>> (a + s)) & 1);
              for (a = 0; a <= 24; a += 8)
                (i <<= 1), (i |= (t >>> (a + s)) & 1);
            }
            for (s = 6; s >= 0; s -= 2) {
              for (a = 1; a <= 25; a += 8)
                (o <<= 1), (o |= (e >>> (a + s)) & 1);
              for (a = 1; a <= 25; a += 8)
                (o <<= 1), (o |= (t >>> (a + s)) & 1);
            }
            (r[n + 0] = i >>> 0), (r[n + 1] = o >>> 0);
          }),
          (e.rip = function (t, e, r, n) {
            for (var i = 0, o = 0, s = 0; s < 4; s++)
              for (var a = 24; a >= 0; a -= 8)
                (i <<= 1),
                  (i |= (e >>> (a + s)) & 1),
                  (i <<= 1),
                  (i |= (t >>> (a + s)) & 1);
            for (s = 4; s < 8; s++)
              for (a = 24; a >= 0; a -= 8)
                (o <<= 1),
                  (o |= (e >>> (a + s)) & 1),
                  (o <<= 1),
                  (o |= (t >>> (a + s)) & 1);
            (r[n + 0] = i >>> 0), (r[n + 1] = o >>> 0);
          }),
          (e.pc1 = function (t, e, r, n) {
            for (var i = 0, o = 0, s = 7; s >= 5; s--) {
              for (var a = 0; a <= 24; a += 8)
                (i <<= 1), (i |= (e >> (a + s)) & 1);
              for (a = 0; a <= 24; a += 8) (i <<= 1), (i |= (t >> (a + s)) & 1);
            }
            for (a = 0; a <= 24; a += 8) (i <<= 1), (i |= (e >> (a + s)) & 1);
            for (s = 1; s <= 3; s++) {
              for (a = 0; a <= 24; a += 8) (o <<= 1), (o |= (e >> (a + s)) & 1);
              for (a = 0; a <= 24; a += 8) (o <<= 1), (o |= (t >> (a + s)) & 1);
            }
            for (a = 0; a <= 24; a += 8) (o <<= 1), (o |= (t >> (a + s)) & 1);
            (r[n + 0] = i >>> 0), (r[n + 1] = o >>> 0);
          }),
          (e.r28shl = function (t, e) {
            return ((t << e) & 268435455) | (t >>> (28 - e));
          });
        var r = [
          14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12,
          21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7,
          17, 0, 22, 3, 10, 14, 6, 20, 27, 24,
        ];
        (e.pc2 = function (t, e, n, i) {
          for (var o = 0, s = 0, a = r.length >>> 1, u = 0; u < a; u++)
            (o <<= 1), (o |= (t >>> r[u]) & 1);
          for (u = a; u < r.length; u++) (s <<= 1), (s |= (e >>> r[u]) & 1);
          (n[i + 0] = o >>> 0), (n[i + 1] = s >>> 0);
        }),
          (e.expand = function (t, e, r) {
            var n = 0,
              i = 0;
            n = ((1 & t) << 5) | (t >>> 27);
            for (var o = 23; o >= 15; o -= 4) (n <<= 6), (n |= (t >>> o) & 63);
            for (o = 11; o >= 3; o -= 4) (i |= (t >>> o) & 63), (i <<= 6);
            (i |= ((31 & t) << 1) | (t >>> 31)),
              (e[r + 0] = n >>> 0),
              (e[r + 1] = i >>> 0);
          });
        var n = [
          14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6,
          6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13,
          4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6,
          0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7,
          0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11,
          1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5,
          2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1,
          2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4,
          13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11,
          10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0,
          10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6,
          15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14,
          11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7,
          11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4,
          11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12,
          0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7,
          2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11,
          8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14,
          4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7,
          15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6,
          8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9,
          15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4,
          8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14,
          12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0,
          15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11,
        ];
        e.substitute = function (t, e) {
          for (var r = 0, i = 0; i < 4; i++) {
            (r <<= 4), (r |= n[64 * i + ((t >>> (18 - 6 * i)) & 63)]);
          }
          for (i = 0; i < 4; i++) {
            (r <<= 4), (r |= n[256 + 64 * i + ((e >>> (18 - 6 * i)) & 63)]);
          }
          return r >>> 0;
        };
        var i = [
          16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8,
          18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7,
        ];
        (e.permute = function (t) {
          for (var e = 0, r = 0; r < i.length; r++)
            (e <<= 1), (e |= (t >>> i[r]) & 1);
          return e >>> 0;
        }),
          (e.padSplit = function (t, e, r) {
            for (var n = t.toString(2); n.length < e; ) n = "0" + n;
            for (var i = [], o = 0; o < e; o += r) i.push(n.slice(o, o + r));
            return i.join(" ");
          });
      },
      74021: (t) => {
        t.exports = !1;
      },
      15380: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(4934),
          o = r(23241),
          s = r(14910);
        var a = { binary: !0, hex: !0, base64: !0 };
        (e.DiffieHellmanGroup =
          e.createDiffieHellmanGroup =
          e.getDiffieHellman =
            function (t) {
              var e = new n(o[t].prime, "hex"),
                r = new n(o[t].gen, "hex");
              return new s(e, r);
            }),
          (e.createDiffieHellman = e.DiffieHellman =
            function t(e, r, o, u) {
              return n.isBuffer(r) || void 0 === a[r]
                ? t(e, "binary", r, o)
                : ((r = r || "binary"),
                  (u = u || "binary"),
                  (o = o || new n([2])),
                  n.isBuffer(o) || (o = new n(o, u)),
                  "number" == typeof e
                    ? new s(i(e, o), o, !0)
                    : (n.isBuffer(e) || (e = new n(e, r)), new s(e, o, !0)));
            });
      },
      14910: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(66473),
          o = new (r(52244))(),
          s = new i(24),
          a = new i(11),
          u = new i(10),
          c = new i(3),
          f = new i(7),
          h = r(4934),
          l = r(53209);
        function d(t, e) {
          return (
            (e = e || "utf8"),
            n.isBuffer(t) || (t = new n(t, e)),
            (this._pub = new i(t)),
            this
          );
        }
        function p(t, e) {
          return (
            (e = e || "utf8"),
            n.isBuffer(t) || (t = new n(t, e)),
            (this._priv = new i(t)),
            this
          );
        }
        t.exports = g;
        var y = {};
        function g(t, e, r) {
          this.setGenerator(e),
            (this.__prime = new i(t)),
            (this._prime = i.mont(this.__prime)),
            (this._primeLen = t.length),
            (this._pub = void 0),
            (this._priv = void 0),
            (this._primeCode = void 0),
            r
              ? ((this.setPublicKey = d), (this.setPrivateKey = p))
              : (this._primeCode = 8);
        }
        function m(t, e) {
          var r = new n(t.toArray());
          return e ? r.toString(e) : r;
        }
        Object.defineProperty(g.prototype, "verifyError", {
          enumerable: !0,
          get: function () {
            return (
              "number" != typeof this._primeCode &&
                (this._primeCode = (function (t, e) {
                  var r = e.toString("hex"),
                    n = [r, t.toString(16)].join("_");
                  if (n in y) return y[n];
                  var i,
                    l = 0;
                  if (
                    t.isEven() ||
                    !h.simpleSieve ||
                    !h.fermatTest(t) ||
                    !o.test(t)
                  )
                    return (
                      (l += 1),
                      (l += "02" === r || "05" === r ? 8 : 4),
                      (y[n] = l),
                      l
                    );
                  switch ((o.test(t.shrn(1)) || (l += 2), r)) {
                    case "02":
                      t.mod(s).cmp(a) && (l += 8);
                      break;
                    case "05":
                      (i = t.mod(u)).cmp(c) && i.cmp(f) && (l += 8);
                      break;
                    default:
                      l += 4;
                  }
                  return (y[n] = l), l;
                })(this.__prime, this.__gen)),
              this._primeCode
            );
          },
        }),
          (g.prototype.generateKeys = function () {
            return (
              this._priv || (this._priv = new i(l(this._primeLen))),
              (this._pub = this._gen
                .toRed(this._prime)
                .redPow(this._priv)
                .fromRed()),
              this.getPublicKey()
            );
          }),
          (g.prototype.computeSecret = function (t) {
            var e = (t = (t = new i(t)).toRed(this._prime))
                .redPow(this._priv)
                .fromRed(),
              r = new n(e.toArray()),
              o = this.getPrime();
            if (r.length < o.length) {
              var s = new n(o.length - r.length);
              s.fill(0), (r = n.concat([s, r]));
            }
            return r;
          }),
          (g.prototype.getPublicKey = function (t) {
            return m(this._pub, t);
          }),
          (g.prototype.getPrivateKey = function (t) {
            return m(this._priv, t);
          }),
          (g.prototype.getPrime = function (t) {
            return m(this.__prime, t);
          }),
          (g.prototype.getGenerator = function (t) {
            return m(this._gen, t);
          }),
          (g.prototype.setGenerator = function (t, e) {
            return (
              (e = e || "utf8"),
              n.isBuffer(t) || (t = new n(t, e)),
              (this.__gen = t),
              (this._gen = new i(t)),
              this
            );
          });
      },
      4934: (t, e, r) => {
        var n = r(53209);
        (t.exports = b), (b.simpleSieve = g), (b.fermatTest = m);
        var i = r(66473),
          o = new i(24),
          s = new (r(52244))(),
          a = new i(1),
          u = new i(2),
          c = new i(5),
          f = (new i(16), new i(8), new i(10)),
          h = new i(3),
          l = (new i(7), new i(11)),
          d = new i(4),
          p = (new i(12), null);
        function y() {
          if (null !== p) return p;
          var t = [];
          t[0] = 2;
          for (var e = 1, r = 3; r < 1048576; r += 2) {
            for (
              var n = Math.ceil(Math.sqrt(r)), i = 0;
              i < e && t[i] <= n && r % t[i] != 0;
              i++
            );
            (e !== i && t[i] <= n) || (t[e++] = r);
          }
          return (p = t), t;
        }
        function g(t) {
          for (var e = y(), r = 0; r < e.length; r++)
            if (0 === t.modn(e[r])) return 0 === t.cmpn(e[r]);
          return !0;
        }
        function m(t) {
          var e = i.mont(t);
          return 0 === u.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1);
        }
        function b(t, e) {
          if (t < 16) return new i(2 === e || 5 === e ? [140, 123] : [140, 39]);
          var r, p;
          for (e = new i(e); ; ) {
            for (r = new i(n(Math.ceil(t / 8))); r.bitLength() > t; )
              r.ishrn(1);
            if ((r.isEven() && r.iadd(a), r.testn(1) || r.iadd(u), e.cmp(u))) {
              if (!e.cmp(c)) for (; r.mod(f).cmp(h); ) r.iadd(d);
            } else for (; r.mod(o).cmp(l); ) r.iadd(d);
            if (
              g((p = r.shrn(1))) &&
              g(r) &&
              m(p) &&
              m(r) &&
              s.test(p) &&
              s.test(r)
            )
              return r;
          }
        }
      },
      66473: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(66089).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      7176: (t, e, r) => {
        "use strict";
        var n,
          i = r(73126),
          o = r(75795);
        try {
          n = [].__proto__ === Array.prototype;
        } catch (t) {
          if (
            !t ||
            "object" != typeof t ||
            !("code" in t) ||
            "ERR_PROTO_ACCESS" !== t.code
          )
            throw t;
        }
        var s = !!n && o && o(Object.prototype, "__proto__"),
          a = Object,
          u = a.getPrototypeOf;
        t.exports =
          s && "function" == typeof s.get
            ? i([s.get])
            : "function" == typeof u &&
              function (t) {
                return u(null == t ? t : a(t));
              };
      },
      22010: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(3527),
          o = 128;
        function s(t) {
          if (n.isBuffer(t)) return t;
          if ("string" == typeof t) return n.from(t, "base64");
          throw new TypeError(
            "ECDSA signature must be a Base64 string or a Buffer",
          );
        }
        function a(t, e, r) {
          for (var n = 0; e + n < r && 0 === t[e + n]; ) ++n;
          return t[e + n] >= o && --n, n;
        }
        t.exports = {
          derToJose: function (t, e) {
            t = s(t);
            var r = i(e),
              o = r + 1,
              a = t.length,
              u = 0;
            if (48 !== t[u++]) throw new Error('Could not find expected "seq"');
            var c = t[u++];
            if ((129 === c && (c = t[u++]), a - u < c))
              throw new Error(
                '"seq" specified length of "' +
                  c +
                  '", only "' +
                  (a - u) +
                  '" remaining',
              );
            if (2 !== t[u++])
              throw new Error('Could not find expected "int" for "r"');
            var f = t[u++];
            if (a - u - 2 < f)
              throw new Error(
                '"r" specified length of "' +
                  f +
                  '", only "' +
                  (a - u - 2) +
                  '" available',
              );
            if (o < f)
              throw new Error(
                '"r" specified length of "' +
                  f +
                  '", max of "' +
                  o +
                  '" is acceptable',
              );
            var h = u;
            if (((u += f), 2 !== t[u++]))
              throw new Error('Could not find expected "int" for "s"');
            var l = t[u++];
            if (a - u !== l)
              throw new Error(
                '"s" specified length of "' +
                  l +
                  '", expected "' +
                  (a - u) +
                  '"',
              );
            if (o < l)
              throw new Error(
                '"s" specified length of "' +
                  l +
                  '", max of "' +
                  o +
                  '" is acceptable',
              );
            var d = u;
            if ((u += l) !== a)
              throw new Error(
                'Expected to consume entire buffer, but "' +
                  (a - u) +
                  '" bytes remain',
              );
            var p = r - f,
              y = r - l,
              g = n.allocUnsafe(p + f + y + l);
            for (u = 0; u < p; ++u) g[u] = 0;
            t.copy(g, u, h + Math.max(-p, 0), h + f);
            for (var m = (u = r); u < m + y; ++u) g[u] = 0;
            return (
              t.copy(g, u, d + Math.max(-y, 0), d + l),
              (g = (function (t) {
                return t
                  .replace(/=/g, "")
                  .replace(/\+/g, "-")
                  .replace(/\//g, "_");
              })((g = g.toString("base64"))))
            );
          },
          joseToDer: function (t, e) {
            t = s(t);
            var r = i(e),
              u = t.length;
            if (u !== 2 * r)
              throw new TypeError(
                '"' +
                  e +
                  '" signatures must be "' +
                  2 * r +
                  '" bytes, saw "' +
                  u +
                  '"',
              );
            var c = a(t, 0, r),
              f = a(t, r, t.length),
              h = r - c,
              l = r - f,
              d = 2 + h + 1 + 1 + l,
              p = d < o,
              y = n.allocUnsafe((p ? 2 : 3) + d),
              g = 0;
            return (
              (y[g++] = 48),
              p ? (y[g++] = d) : ((y[g++] = 129), (y[g++] = 255 & d)),
              (y[g++] = 2),
              (y[g++] = h),
              c < 0
                ? ((y[g++] = 0), (g += t.copy(y, g, 0, r)))
                : (g += t.copy(y, g, c, r)),
              (y[g++] = 2),
              (y[g++] = l),
              f < 0 ? ((y[g++] = 0), t.copy(y, g, r)) : t.copy(y, g, r + f),
              y
            );
          },
        };
      },
      3527: (t) => {
        "use strict";
        function e(t) {
          return ((t / 8) | 0) + (t % 8 == 0 ? 0 : 1);
        }
        var r = { ES256: e(256), ES384: e(384), ES512: e(521) };
        t.exports = function (t) {
          var e = r[t];
          if (e) return e;
          throw new Error('Unknown algorithm "' + t + '"');
        };
      },
      25170: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ECPairFactory = e.networks = void 0);
        const i = r(95249);
        e.networks = i;
        const o = r(90953),
          s = r(53209),
          a = r(57513),
          u = r(80709),
          c = o.typeforce.maybe(
            o.typeforce.compile({
              compressed: o.maybe(o.Boolean),
              network: o.maybe(o.Network),
            }),
          );
        e.ECPairFactory = function (t) {
          function e(e, r) {
            if ((o.typeforce(o.Buffer256bit, e), !t.isPrivate(e)))
              throw new TypeError("Private key not in range [1, n)");
            return o.typeforce(c, r), new f(e, void 0, r);
          }
          function r(e, r) {
            return (
              o.typeforce(t.isPoint, e), o.typeforce(c, r), new f(void 0, e, r)
            );
          }
          (0, u.testEcc)(t);
          class f {
            __D;
            __Q;
            compressed;
            network;
            lowR;
            constructor(e, r, o) {
              (this.__D = e),
                (this.__Q = r),
                (this.lowR = !1),
                void 0 === o && (o = {}),
                (this.compressed = void 0 === o.compressed || o.compressed),
                (this.network = o.network || i.bitcoin),
                void 0 !== r &&
                  (this.__Q = n.from(t.pointCompress(r, this.compressed)));
            }
            get privateKey() {
              return this.__D;
            }
            get publicKey() {
              if (!this.__Q) {
                const e = t.pointFromScalar(this.__D, this.compressed);
                this.__Q = n.from(e);
              }
              return this.__Q;
            }
            toWIF() {
              if (!this.__D) throw new Error("Missing private key");
              return a.encode(this.network.wif, this.__D, this.compressed);
            }
            tweak(t) {
              return this.privateKey
                ? this.tweakFromPrivateKey(t)
                : this.tweakFromPublicKey(t);
            }
            sign(e, r) {
              if (!this.__D) throw new Error("Missing private key");
              if ((void 0 === r && (r = this.lowR), !1 === r))
                return n.from(t.sign(e, this.__D));
              {
                let r = t.sign(e, this.__D);
                const i = n.alloc(32, 0);
                let o = 0;
                for (; r[0] > 127; )
                  o++, i.writeUIntLE(o, 0, 6), (r = t.sign(e, this.__D, i));
                return n.from(r);
              }
            }
            signSchnorr(e) {
              if (!this.privateKey) throw new Error("Missing private key");
              if (!t.signSchnorr)
                throw new Error("signSchnorr not supported by ecc library");
              return n.from(t.signSchnorr(e, this.privateKey));
            }
            verify(e, r) {
              return t.verify(e, this.publicKey, r);
            }
            verifySchnorr(e, r) {
              if (!t.verifySchnorr)
                throw new Error("verifySchnorr not supported by ecc library");
              return t.verifySchnorr(e, this.publicKey.subarray(1, 33), r);
            }
            tweakFromPublicKey(e) {
              const i = 32 === (o = this.publicKey).length ? o : o.slice(1, 33);
              var o;
              const s = t.xOnlyPointAddTweak(i, e);
              if (!s || null === s.xOnlyPubkey)
                throw new Error("Cannot tweak public key!");
              const a = n.from([0 === s.parity ? 2 : 3]);
              return r(n.concat([a, s.xOnlyPubkey]), {
                network: this.network,
                compressed: this.compressed,
              });
            }
            tweakFromPrivateKey(r) {
              const i =
                  3 === this.publicKey[0] ||
                  (4 === this.publicKey[0] && !(1 & ~this.publicKey[64]))
                    ? t.privateNegate(this.privateKey)
                    : this.privateKey,
                o = t.privateAdd(i, r);
              if (!o) throw new Error("Invalid tweaked private key!");
              return e(n.from(o), {
                network: this.network,
                compressed: this.compressed,
              });
            }
          }
          return {
            isPoint: function (e) {
              return t.isPoint(e);
            },
            fromPrivateKey: e,
            fromPublicKey: r,
            fromWIF: function (t, r) {
              const n = a.decode(t),
                s = n.version;
              if (o.Array(r)) {
                if (!(r = r.filter((t) => s === t.wif).pop()))
                  throw new Error("Unknown network version");
              } else if (((r = r || i.bitcoin), s !== r.wif))
                throw new Error("Invalid network version");
              return e(n.privateKey, { compressed: n.compressed, network: r });
            },
            makeRandom: function (r) {
              o.typeforce(c, r), void 0 === r && (r = {});
              const n = r.rng || s;
              let i;
              do {
                (i = n(32)), o.typeforce(o.Buffer256bit, i);
              } while (!t.isPrivate(i));
              return e(i, r);
            },
          };
        };
      },
      38700: (t, e, r) => {
        "use strict";
        e.dg = void 0;
        var n = r(25170);
        Object.defineProperty(e, "dg", {
          enumerable: !0,
          get: function () {
            return n.ECPairFactory;
          },
        });
      },
      95249: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.testnet = e.bitcoin = void 0),
          (e.bitcoin = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "bc",
            bip32: { public: 76067358, private: 76066276 },
            pubKeyHash: 0,
            scriptHash: 5,
            wif: 128,
          }),
          (e.testnet = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "tb",
            bip32: { public: 70617039, private: 70615956 },
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239,
          });
      },
      80709: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.testEcc = void 0);
        const i = (t) => n.from(t, "hex");
        function o(t) {
          if (!t) throw new Error("ecc library invalid");
        }
        e.testEcc = function (t) {
          o(
            t.isPoint(
              i(
                "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
              ),
            ),
          ),
            o(
              !t.isPoint(
                i(
                  "030000000000000000000000000000000000000000000000000000000000000005",
                ),
              ),
            ),
            o(
              t.isPrivate(
                i(
                  "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                ),
              ),
            ),
            o(
              t.isPrivate(
                i(
                  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
                ),
              ),
            ),
            o(
              !t.isPrivate(
                i(
                  "0000000000000000000000000000000000000000000000000000000000000000",
                ),
              ),
            ),
            o(
              !t.isPrivate(
                i(
                  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
                ),
              ),
            ),
            o(
              !t.isPrivate(
                i(
                  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142",
                ),
              ),
            ),
            o(
              n
                .from(
                  t.privateAdd(
                    i(
                      "0000000000000000000000000000000000000000000000000000000000000001",
                    ),
                    i(
                      "0000000000000000000000000000000000000000000000000000000000000000",
                    ),
                  ),
                )
                .equals(
                  i(
                    "0000000000000000000000000000000000000000000000000000000000000001",
                  ),
                ),
            ),
            o(
              null ===
                t.privateAdd(
                  i(
                    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e",
                  ),
                  i(
                    "0000000000000000000000000000000000000000000000000000000000000003",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.privateAdd(
                    i(
                      "e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500",
                    ),
                    i(
                      "b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665",
                    ),
                  ),
                )
                .equals(
                  i(
                    "9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.privateNegate(
                    i(
                      "0000000000000000000000000000000000000000000000000000000000000001",
                    ),
                  ),
                )
                .equals(
                  i(
                    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.privateNegate(
                    i(
                      "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e",
                    ),
                  ),
                )
                .equals(
                  i(
                    "0000000000000000000000000000000000000000000000000000000000000003",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.privateNegate(
                    i(
                      "b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af",
                    ),
                  ),
                )
                .equals(
                  i(
                    "4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.pointCompress(
                    i(
                      "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                    ),
                    !0,
                  ),
                )
                .equals(
                  i(
                    "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.pointCompress(
                    i(
                      "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                    ),
                    !1,
                  ),
                )
                .equals(
                  i(
                    "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.pointCompress(
                    i(
                      "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                    ),
                    !0,
                  ),
                )
                .equals(
                  i(
                    "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.pointCompress(
                    i(
                      "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                    ),
                    !1,
                  ),
                )
                .equals(
                  i(
                    "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                  ),
                ),
            ),
            o(
              n
                .from(
                  t.pointFromScalar(
                    i(
                      "b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af",
                    ),
                  ),
                )
                .equals(
                  i(
                    "02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99",
                  ),
                ),
            ),
            o(
              null ===
                t.xOnlyPointAddTweak(
                  i(
                    "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                  ),
                  i(
                    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
                  ),
                ),
            );
          let e = t.xOnlyPointAddTweak(
            i(
              "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
            ),
            i(
              "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
            ),
          );
          o(
            n
              .from(e.xOnlyPubkey)
              .equals(
                i(
                  "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf",
                ),
              ) && 1 === e.parity,
          ),
            (e = t.xOnlyPointAddTweak(
              i(
                "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
              ),
              i(
                "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
              ),
            )),
            o(
              n
                .from(e.xOnlyPubkey)
                .equals(
                  i(
                    "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c",
                  ),
                ) && 0 === e.parity,
            ),
            o(
              n
                .from(
                  t.sign(
                    i(
                      "5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed",
                    ),
                    i(
                      "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
                    ),
                  ),
                )
                .equals(
                  i(
                    "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5",
                  ),
                ),
            ),
            o(
              t.verify(
                i(
                  "5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed",
                ),
                i(
                  "0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                ),
                i(
                  "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5",
                ),
              ),
            ),
            t.signSchnorr &&
              o(
                n
                  .from(
                    t.signSchnorr(
                      i(
                        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c",
                      ),
                      i(
                        "c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9",
                      ),
                      i(
                        "c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906",
                      ),
                    ),
                  )
                  .equals(
                    i(
                      "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7",
                    ),
                  ),
              ),
            t.verifySchnorr &&
              o(
                t.verifySchnorr(
                  i(
                    "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c",
                  ),
                  i(
                    "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8",
                  ),
                  i(
                    "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7",
                  ),
                ),
              );
        };
      },
      90953: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.maybe =
            e.Boolean =
            e.Array =
            e.Buffer256bit =
            e.Network =
            e.typeforce =
              void 0),
          (e.typeforce = r(8676)),
          (e.Network = e.typeforce.compile({
            messagePrefix: e.typeforce.oneOf(
              e.typeforce.Buffer,
              e.typeforce.String,
            ),
            bip32: { public: e.typeforce.UInt32, private: e.typeforce.UInt32 },
            pubKeyHash: e.typeforce.UInt8,
            scriptHash: e.typeforce.UInt8,
            wif: e.typeforce.UInt8,
          })),
          (e.Buffer256bit = e.typeforce.BufferN(32)),
          (e.Array = e.typeforce.Array),
          (e.Boolean = e.typeforce.Boolean),
          (e.maybe = e.typeforce.maybe);
      },
      86729: (t, e, r) => {
        "use strict";
        var n = e;
        (n.version = r(1636).rE),
          (n.utils = r(47011)),
          (n.rand = r(15037)),
          (n.curve = r(894)),
          (n.curves = r(60480)),
          (n.ec = r(57447)),
          (n.eddsa = r(8650));
      },
      36677: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(47011),
          o = i.getNAF,
          s = i.getJSF,
          a = i.assert;
        function u(t, e) {
          (this.type = t),
            (this.p = new n(e.p, 16)),
            (this.red = e.prime ? n.red(e.prime) : n.mont(this.p)),
            (this.zero = new n(0).toRed(this.red)),
            (this.one = new n(1).toRed(this.red)),
            (this.two = new n(2).toRed(this.red)),
            (this.n = e.n && new n(e.n, 16)),
            (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
            (this._wnafT1 = new Array(4)),
            (this._wnafT2 = new Array(4)),
            (this._wnafT3 = new Array(4)),
            (this._wnafT4 = new Array(4)),
            (this._bitLength = this.n ? this.n.bitLength() : 0);
          var r = this.n && this.p.div(this.n);
          !r || r.cmpn(100) > 0
            ? (this.redN = null)
            : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
        }
        function c(t, e) {
          (this.curve = t), (this.type = e), (this.precomputed = null);
        }
        (t.exports = u),
          (u.prototype.point = function () {
            throw new Error("Not implemented");
          }),
          (u.prototype.validate = function () {
            throw new Error("Not implemented");
          }),
          (u.prototype._fixedNafMul = function (t, e) {
            a(t.precomputed);
            var r = t._getDoubles(),
              n = o(e, 1, this._bitLength),
              i = (1 << (r.step + 1)) - (r.step % 2 == 0 ? 2 : 1);
            i /= 3;
            var s,
              u,
              c = [];
            for (s = 0; s < n.length; s += r.step) {
              u = 0;
              for (var f = s + r.step - 1; f >= s; f--) u = (u << 1) + n[f];
              c.push(u);
            }
            for (
              var h = this.jpoint(null, null, null),
                l = this.jpoint(null, null, null),
                d = i;
              d > 0;
              d--
            ) {
              for (s = 0; s < c.length; s++)
                (u = c[s]) === d
                  ? (l = l.mixedAdd(r.points[s]))
                  : u === -d && (l = l.mixedAdd(r.points[s].neg()));
              h = h.add(l);
            }
            return h.toP();
          }),
          (u.prototype._wnafMul = function (t, e) {
            var r = 4,
              n = t._getNAFPoints(r);
            r = n.wnd;
            for (
              var i = n.points,
                s = o(e, r, this._bitLength),
                u = this.jpoint(null, null, null),
                c = s.length - 1;
              c >= 0;
              c--
            ) {
              for (var f = 0; c >= 0 && 0 === s[c]; c--) f++;
              if ((c >= 0 && f++, (u = u.dblp(f)), c < 0)) break;
              var h = s[c];
              a(0 !== h),
                (u =
                  "affine" === t.type
                    ? h > 0
                      ? u.mixedAdd(i[(h - 1) >> 1])
                      : u.mixedAdd(i[(-h - 1) >> 1].neg())
                    : h > 0
                      ? u.add(i[(h - 1) >> 1])
                      : u.add(i[(-h - 1) >> 1].neg()));
            }
            return "affine" === t.type ? u.toP() : u;
          }),
          (u.prototype._wnafMulAdd = function (t, e, r, n, i) {
            var a,
              u,
              c,
              f = this._wnafT1,
              h = this._wnafT2,
              l = this._wnafT3,
              d = 0;
            for (a = 0; a < n; a++) {
              var p = (c = e[a])._getNAFPoints(t);
              (f[a] = p.wnd), (h[a] = p.points);
            }
            for (a = n - 1; a >= 1; a -= 2) {
              var y = a - 1,
                g = a;
              if (1 === f[y] && 1 === f[g]) {
                var m = [e[y], null, null, e[g]];
                0 === e[y].y.cmp(e[g].y)
                  ? ((m[1] = e[y].add(e[g])),
                    (m[2] = e[y].toJ().mixedAdd(e[g].neg())))
                  : 0 === e[y].y.cmp(e[g].y.redNeg())
                    ? ((m[1] = e[y].toJ().mixedAdd(e[g])),
                      (m[2] = e[y].add(e[g].neg())))
                    : ((m[1] = e[y].toJ().mixedAdd(e[g])),
                      (m[2] = e[y].toJ().mixedAdd(e[g].neg())));
                var b = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                  w = s(r[y], r[g]);
                for (
                  d = Math.max(w[0].length, d),
                    l[y] = new Array(d),
                    l[g] = new Array(d),
                    u = 0;
                  u < d;
                  u++
                ) {
                  var v = 0 | w[0][u],
                    _ = 0 | w[1][u];
                  (l[y][u] = b[3 * (v + 1) + (_ + 1)]),
                    (l[g][u] = 0),
                    (h[y] = m);
                }
              } else
                (l[y] = o(r[y], f[y], this._bitLength)),
                  (l[g] = o(r[g], f[g], this._bitLength)),
                  (d = Math.max(l[y].length, d)),
                  (d = Math.max(l[g].length, d));
            }
            var E = this.jpoint(null, null, null),
              S = this._wnafT4;
            for (a = d; a >= 0; a--) {
              for (var I = 0; a >= 0; ) {
                var M = !0;
                for (u = 0; u < n; u++)
                  (S[u] = 0 | l[u][a]), 0 !== S[u] && (M = !1);
                if (!M) break;
                I++, a--;
              }
              if ((a >= 0 && I++, (E = E.dblp(I)), a < 0)) break;
              for (u = 0; u < n; u++) {
                var A = S[u];
                0 !== A &&
                  (A > 0
                    ? (c = h[u][(A - 1) >> 1])
                    : A < 0 && (c = h[u][(-A - 1) >> 1].neg()),
                  (E = "affine" === c.type ? E.mixedAdd(c) : E.add(c)));
              }
            }
            for (a = 0; a < n; a++) h[a] = null;
            return i ? E : E.toP();
          }),
          (u.BasePoint = c),
          (c.prototype.eq = function () {
            throw new Error("Not implemented");
          }),
          (c.prototype.validate = function () {
            return this.curve.validate(this);
          }),
          (u.prototype.decodePoint = function (t, e) {
            t = i.toArray(t, e);
            var r = this.p.byteLength();
            if (
              (4 === t[0] || 6 === t[0] || 7 === t[0]) &&
              t.length - 1 == 2 * r
            )
              return (
                6 === t[0]
                  ? a(t[t.length - 1] % 2 == 0)
                  : 7 === t[0] && a(t[t.length - 1] % 2 == 1),
                this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r))
              );
            if ((2 === t[0] || 3 === t[0]) && t.length - 1 === r)
              return this.pointFromX(t.slice(1, 1 + r), 3 === t[0]);
            throw new Error("Unknown point format");
          }),
          (c.prototype.encodeCompressed = function (t) {
            return this.encode(t, !0);
          }),
          (c.prototype._encode = function (t) {
            var e = this.curve.p.byteLength(),
              r = this.getX().toArray("be", e);
            return t
              ? [this.getY().isEven() ? 2 : 3].concat(r)
              : [4].concat(r, this.getY().toArray("be", e));
          }),
          (c.prototype.encode = function (t, e) {
            return i.encode(this._encode(e), t);
          }),
          (c.prototype.precompute = function (t) {
            if (this.precomputed) return this;
            var e = { doubles: null, naf: null, beta: null };
            return (
              (e.naf = this._getNAFPoints(8)),
              (e.doubles = this._getDoubles(4, t)),
              (e.beta = this._getBeta()),
              (this.precomputed = e),
              this
            );
          }),
          (c.prototype._hasDoubles = function (t) {
            if (!this.precomputed) return !1;
            var e = this.precomputed.doubles;
            return (
              !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step)
            );
          }),
          (c.prototype._getDoubles = function (t, e) {
            if (this.precomputed && this.precomputed.doubles)
              return this.precomputed.doubles;
            for (var r = [this], n = this, i = 0; i < e; i += t) {
              for (var o = 0; o < t; o++) n = n.dbl();
              r.push(n);
            }
            return { step: t, points: r };
          }),
          (c.prototype._getNAFPoints = function (t) {
            if (this.precomputed && this.precomputed.naf)
              return this.precomputed.naf;
            for (
              var e = [this],
                r = (1 << t) - 1,
                n = 1 === r ? null : this.dbl(),
                i = 1;
              i < r;
              i++
            )
              e[i] = e[i - 1].add(n);
            return { wnd: t, points: e };
          }),
          (c.prototype._getBeta = function () {
            return null;
          }),
          (c.prototype.dblp = function (t) {
            for (var e = this, r = 0; r < t; r++) e = e.dbl();
            return e;
          });
      },
      31298: (t, e, r) => {
        "use strict";
        var n = r(47011),
          i = r(28490),
          o = r(56698),
          s = r(36677),
          a = n.assert;
        function u(t) {
          (this.twisted = 1 != (0 | t.a)),
            (this.mOneA = this.twisted && -1 == (0 | t.a)),
            (this.extended = this.mOneA),
            s.call(this, "edwards", t),
            (this.a = new i(t.a, 16).umod(this.red.m)),
            (this.a = this.a.toRed(this.red)),
            (this.c = new i(t.c, 16).toRed(this.red)),
            (this.c2 = this.c.redSqr()),
            (this.d = new i(t.d, 16).toRed(this.red)),
            (this.dd = this.d.redAdd(this.d)),
            a(!this.twisted || 0 === this.c.fromRed().cmpn(1)),
            (this.oneC = 1 == (0 | t.c));
        }
        function c(t, e, r, n, o) {
          s.BasePoint.call(this, t, "projective"),
            null === e && null === r && null === n
              ? ((this.x = this.curve.zero),
                (this.y = this.curve.one),
                (this.z = this.curve.one),
                (this.t = this.curve.zero),
                (this.zOne = !0))
              : ((this.x = new i(e, 16)),
                (this.y = new i(r, 16)),
                (this.z = n ? new i(n, 16) : this.curve.one),
                (this.t = o && new i(o, 16)),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)),
                this.t &&
                  !this.t.red &&
                  (this.t = this.t.toRed(this.curve.red)),
                (this.zOne = this.z === this.curve.one),
                this.curve.extended &&
                  !this.t &&
                  ((this.t = this.x.redMul(this.y)),
                  this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
        }
        o(u, s),
          (t.exports = u),
          (u.prototype._mulA = function (t) {
            return this.mOneA ? t.redNeg() : this.a.redMul(t);
          }),
          (u.prototype._mulC = function (t) {
            return this.oneC ? t : this.c.redMul(t);
          }),
          (u.prototype.jpoint = function (t, e, r, n) {
            return this.point(t, e, r, n);
          }),
          (u.prototype.pointFromX = function (t, e) {
            (t = new i(t, 16)).red || (t = t.toRed(this.red));
            var r = t.redSqr(),
              n = this.c2.redSub(this.a.redMul(r)),
              o = this.one.redSub(this.c2.redMul(this.d).redMul(r)),
              s = n.redMul(o.redInvm()),
              a = s.redSqrt();
            if (0 !== a.redSqr().redSub(s).cmp(this.zero))
              throw new Error("invalid point");
            var u = a.fromRed().isOdd();
            return (
              ((e && !u) || (!e && u)) && (a = a.redNeg()), this.point(t, a)
            );
          }),
          (u.prototype.pointFromY = function (t, e) {
            (t = new i(t, 16)).red || (t = t.toRed(this.red));
            var r = t.redSqr(),
              n = r.redSub(this.c2),
              o = r.redMul(this.d).redMul(this.c2).redSub(this.a),
              s = n.redMul(o.redInvm());
            if (0 === s.cmp(this.zero)) {
              if (e) throw new Error("invalid point");
              return this.point(this.zero, t);
            }
            var a = s.redSqrt();
            if (0 !== a.redSqr().redSub(s).cmp(this.zero))
              throw new Error("invalid point");
            return (
              a.fromRed().isOdd() !== e && (a = a.redNeg()), this.point(a, t)
            );
          }),
          (u.prototype.validate = function (t) {
            if (t.isInfinity()) return !0;
            t.normalize();
            var e = t.x.redSqr(),
              r = t.y.redSqr(),
              n = e.redMul(this.a).redAdd(r),
              i = this.c2.redMul(this.one.redAdd(this.d.redMul(e).redMul(r)));
            return 0 === n.cmp(i);
          }),
          o(c, s.BasePoint),
          (u.prototype.pointFromJSON = function (t) {
            return c.fromJSON(this, t);
          }),
          (u.prototype.point = function (t, e, r, n) {
            return new c(this, t, e, r, n);
          }),
          (c.fromJSON = function (t, e) {
            return new c(t, e[0], e[1], e[2]);
          }),
          (c.prototype.inspect = function () {
            return this.isInfinity()
              ? "<EC Point Infinity>"
              : "<EC Point x: " +
                  this.x.fromRed().toString(16, 2) +
                  " y: " +
                  this.y.fromRed().toString(16, 2) +
                  " z: " +
                  this.z.fromRed().toString(16, 2) +
                  ">";
          }),
          (c.prototype.isInfinity = function () {
            return (
              0 === this.x.cmpn(0) &&
              (0 === this.y.cmp(this.z) ||
                (this.zOne && 0 === this.y.cmp(this.curve.c)))
            );
          }),
          (c.prototype._extDbl = function () {
            var t = this.x.redSqr(),
              e = this.y.redSqr(),
              r = this.z.redSqr();
            r = r.redIAdd(r);
            var n = this.curve._mulA(t),
              i = this.x.redAdd(this.y).redSqr().redISub(t).redISub(e),
              o = n.redAdd(e),
              s = o.redSub(r),
              a = n.redSub(e),
              u = i.redMul(s),
              c = o.redMul(a),
              f = i.redMul(a),
              h = s.redMul(o);
            return this.curve.point(u, c, h, f);
          }),
          (c.prototype._projDbl = function () {
            var t,
              e,
              r,
              n,
              i,
              o,
              s = this.x.redAdd(this.y).redSqr(),
              a = this.x.redSqr(),
              u = this.y.redSqr();
            if (this.curve.twisted) {
              var c = (n = this.curve._mulA(a)).redAdd(u);
              this.zOne
                ? ((t = s.redSub(a).redSub(u).redMul(c.redSub(this.curve.two))),
                  (e = c.redMul(n.redSub(u))),
                  (r = c.redSqr().redSub(c).redSub(c)))
                : ((i = this.z.redSqr()),
                  (o = c.redSub(i).redISub(i)),
                  (t = s.redSub(a).redISub(u).redMul(o)),
                  (e = c.redMul(n.redSub(u))),
                  (r = c.redMul(o)));
            } else
              (n = a.redAdd(u)),
                (i = this.curve._mulC(this.z).redSqr()),
                (o = n.redSub(i).redSub(i)),
                (t = this.curve._mulC(s.redISub(n)).redMul(o)),
                (e = this.curve._mulC(n).redMul(a.redISub(u))),
                (r = n.redMul(o));
            return this.curve.point(t, e, r);
          }),
          (c.prototype.dbl = function () {
            return this.isInfinity()
              ? this
              : this.curve.extended
                ? this._extDbl()
                : this._projDbl();
          }),
          (c.prototype._extAdd = function (t) {
            var e = this.y.redSub(this.x).redMul(t.y.redSub(t.x)),
              r = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)),
              n = this.t.redMul(this.curve.dd).redMul(t.t),
              i = this.z.redMul(t.z.redAdd(t.z)),
              o = r.redSub(e),
              s = i.redSub(n),
              a = i.redAdd(n),
              u = r.redAdd(e),
              c = o.redMul(s),
              f = a.redMul(u),
              h = o.redMul(u),
              l = s.redMul(a);
            return this.curve.point(c, f, l, h);
          }),
          (c.prototype._projAdd = function (t) {
            var e,
              r,
              n = this.z.redMul(t.z),
              i = n.redSqr(),
              o = this.x.redMul(t.x),
              s = this.y.redMul(t.y),
              a = this.curve.d.redMul(o).redMul(s),
              u = i.redSub(a),
              c = i.redAdd(a),
              f = this.x
                .redAdd(this.y)
                .redMul(t.x.redAdd(t.y))
                .redISub(o)
                .redISub(s),
              h = n.redMul(u).redMul(f);
            return (
              this.curve.twisted
                ? ((e = n.redMul(c).redMul(s.redSub(this.curve._mulA(o)))),
                  (r = u.redMul(c)))
                : ((e = n.redMul(c).redMul(s.redSub(o))),
                  (r = this.curve._mulC(u).redMul(c))),
              this.curve.point(h, e, r)
            );
          }),
          (c.prototype.add = function (t) {
            return this.isInfinity()
              ? t
              : t.isInfinity()
                ? this
                : this.curve.extended
                  ? this._extAdd(t)
                  : this._projAdd(t);
          }),
          (c.prototype.mul = function (t) {
            return this._hasDoubles(t)
              ? this.curve._fixedNafMul(this, t)
              : this.curve._wnafMul(this, t);
          }),
          (c.prototype.mulAdd = function (t, e, r) {
            return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !1);
          }),
          (c.prototype.jmulAdd = function (t, e, r) {
            return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !0);
          }),
          (c.prototype.normalize = function () {
            if (this.zOne) return this;
            var t = this.z.redInvm();
            return (
              (this.x = this.x.redMul(t)),
              (this.y = this.y.redMul(t)),
              this.t && (this.t = this.t.redMul(t)),
              (this.z = this.curve.one),
              (this.zOne = !0),
              this
            );
          }),
          (c.prototype.neg = function () {
            return this.curve.point(
              this.x.redNeg(),
              this.y,
              this.z,
              this.t && this.t.redNeg(),
            );
          }),
          (c.prototype.getX = function () {
            return this.normalize(), this.x.fromRed();
          }),
          (c.prototype.getY = function () {
            return this.normalize(), this.y.fromRed();
          }),
          (c.prototype.eq = function (t) {
            return (
              this === t ||
              (0 === this.getX().cmp(t.getX()) &&
                0 === this.getY().cmp(t.getY()))
            );
          }),
          (c.prototype.eqXToP = function (t) {
            var e = t.toRed(this.curve.red).redMul(this.z);
            if (0 === this.x.cmp(e)) return !0;
            for (var r = t.clone(), n = this.curve.redN.redMul(this.z); ; ) {
              if ((r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0)) return !1;
              if ((e.redIAdd(n), 0 === this.x.cmp(e))) return !0;
            }
          }),
          (c.prototype.toP = c.prototype.normalize),
          (c.prototype.mixedAdd = c.prototype.add);
      },
      894: (t, e, r) => {
        "use strict";
        var n = e;
        (n.base = r(36677)),
          (n.short = r(39188)),
          (n.mont = r(30370)),
          (n.edwards = r(31298));
      },
      30370: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(56698),
          o = r(36677),
          s = r(47011);
        function a(t) {
          o.call(this, "mont", t),
            (this.a = new n(t.a, 16).toRed(this.red)),
            (this.b = new n(t.b, 16).toRed(this.red)),
            (this.i4 = new n(4).toRed(this.red).redInvm()),
            (this.two = new n(2).toRed(this.red)),
            (this.a24 = this.i4.redMul(this.a.redAdd(this.two)));
        }
        function u(t, e, r) {
          o.BasePoint.call(this, t, "projective"),
            null === e && null === r
              ? ((this.x = this.curve.one), (this.z = this.curve.zero))
              : ((this.x = new n(e, 16)),
                (this.z = new n(r, 16)),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)));
        }
        i(a, o),
          (t.exports = a),
          (a.prototype.validate = function (t) {
            var e = t.normalize().x,
              r = e.redSqr(),
              n = r.redMul(e).redAdd(r.redMul(this.a)).redAdd(e);
            return 0 === n.redSqrt().redSqr().cmp(n);
          }),
          i(u, o.BasePoint),
          (a.prototype.decodePoint = function (t, e) {
            return this.point(s.toArray(t, e), 1);
          }),
          (a.prototype.point = function (t, e) {
            return new u(this, t, e);
          }),
          (a.prototype.pointFromJSON = function (t) {
            return u.fromJSON(this, t);
          }),
          (u.prototype.precompute = function () {}),
          (u.prototype._encode = function () {
            return this.getX().toArray("be", this.curve.p.byteLength());
          }),
          (u.fromJSON = function (t, e) {
            return new u(t, e[0], e[1] || t.one);
          }),
          (u.prototype.inspect = function () {
            return this.isInfinity()
              ? "<EC Point Infinity>"
              : "<EC Point x: " +
                  this.x.fromRed().toString(16, 2) +
                  " z: " +
                  this.z.fromRed().toString(16, 2) +
                  ">";
          }),
          (u.prototype.isInfinity = function () {
            return 0 === this.z.cmpn(0);
          }),
          (u.prototype.dbl = function () {
            var t = this.x.redAdd(this.z).redSqr(),
              e = this.x.redSub(this.z).redSqr(),
              r = t.redSub(e),
              n = t.redMul(e),
              i = r.redMul(e.redAdd(this.curve.a24.redMul(r)));
            return this.curve.point(n, i);
          }),
          (u.prototype.add = function () {
            throw new Error("Not supported on Montgomery curve");
          }),
          (u.prototype.diffAdd = function (t, e) {
            var r = this.x.redAdd(this.z),
              n = this.x.redSub(this.z),
              i = t.x.redAdd(t.z),
              o = t.x.redSub(t.z).redMul(r),
              s = i.redMul(n),
              a = e.z.redMul(o.redAdd(s).redSqr()),
              u = e.x.redMul(o.redISub(s).redSqr());
            return this.curve.point(a, u);
          }),
          (u.prototype.mul = function (t) {
            for (
              var e = t.clone(),
                r = this,
                n = this.curve.point(null, null),
                i = [];
              0 !== e.cmpn(0);
              e.iushrn(1)
            )
              i.push(e.andln(1));
            for (var o = i.length - 1; o >= 0; o--)
              0 === i[o]
                ? ((r = r.diffAdd(n, this)), (n = n.dbl()))
                : ((n = r.diffAdd(n, this)), (r = r.dbl()));
            return n;
          }),
          (u.prototype.mulAdd = function () {
            throw new Error("Not supported on Montgomery curve");
          }),
          (u.prototype.jumlAdd = function () {
            throw new Error("Not supported on Montgomery curve");
          }),
          (u.prototype.eq = function (t) {
            return 0 === this.getX().cmp(t.getX());
          }),
          (u.prototype.normalize = function () {
            return (
              (this.x = this.x.redMul(this.z.redInvm())),
              (this.z = this.curve.one),
              this
            );
          }),
          (u.prototype.getX = function () {
            return this.normalize(), this.x.fromRed();
          });
      },
      39188: (t, e, r) => {
        "use strict";
        var n = r(47011),
          i = r(28490),
          o = r(56698),
          s = r(36677),
          a = n.assert;
        function u(t) {
          s.call(this, "short", t),
            (this.a = new i(t.a, 16).toRed(this.red)),
            (this.b = new i(t.b, 16).toRed(this.red)),
            (this.tinv = this.two.redInvm()),
            (this.zeroA = 0 === this.a.fromRed().cmpn(0)),
            (this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3)),
            (this.endo = this._getEndomorphism(t)),
            (this._endoWnafT1 = new Array(4)),
            (this._endoWnafT2 = new Array(4));
        }
        function c(t, e, r, n) {
          s.BasePoint.call(this, t, "affine"),
            null === e && null === r
              ? ((this.x = null), (this.y = null), (this.inf = !0))
              : ((this.x = new i(e, 16)),
                (this.y = new i(r, 16)),
                n &&
                  (this.x.forceRed(this.curve.red),
                  this.y.forceRed(this.curve.red)),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                (this.inf = !1));
        }
        function f(t, e, r, n) {
          s.BasePoint.call(this, t, "jacobian"),
            null === e && null === r && null === n
              ? ((this.x = this.curve.one),
                (this.y = this.curve.one),
                (this.z = new i(0)))
              : ((this.x = new i(e, 16)),
                (this.y = new i(r, 16)),
                (this.z = new i(n, 16))),
            this.x.red || (this.x = this.x.toRed(this.curve.red)),
            this.y.red || (this.y = this.y.toRed(this.curve.red)),
            this.z.red || (this.z = this.z.toRed(this.curve.red)),
            (this.zOne = this.z === this.curve.one);
        }
        o(u, s),
          (t.exports = u),
          (u.prototype._getEndomorphism = function (t) {
            if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
              var e, r;
              if (t.beta) e = new i(t.beta, 16).toRed(this.red);
              else {
                var n = this._getEndoRoots(this.p);
                e = (e = n[0].cmp(n[1]) < 0 ? n[0] : n[1]).toRed(this.red);
              }
              if (t.lambda) r = new i(t.lambda, 16);
              else {
                var o = this._getEndoRoots(this.n);
                0 === this.g.mul(o[0]).x.cmp(this.g.x.redMul(e))
                  ? (r = o[0])
                  : ((r = o[1]),
                    a(0 === this.g.mul(r).x.cmp(this.g.x.redMul(e))));
              }
              return {
                beta: e,
                lambda: r,
                basis: t.basis
                  ? t.basis.map(function (t) {
                      return { a: new i(t.a, 16), b: new i(t.b, 16) };
                    })
                  : this._getEndoBasis(r),
              };
            }
          }),
          (u.prototype._getEndoRoots = function (t) {
            var e = t === this.p ? this.red : i.mont(t),
              r = new i(2).toRed(e).redInvm(),
              n = r.redNeg(),
              o = new i(3).toRed(e).redNeg().redSqrt().redMul(r);
            return [n.redAdd(o).fromRed(), n.redSub(o).fromRed()];
          }),
          (u.prototype._getEndoBasis = function (t) {
            for (
              var e,
                r,
                n,
                o,
                s,
                a,
                u,
                c,
                f,
                h = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
                l = t,
                d = this.n.clone(),
                p = new i(1),
                y = new i(0),
                g = new i(0),
                m = new i(1),
                b = 0;
              0 !== l.cmpn(0);

            ) {
              var w = d.div(l);
              (c = d.sub(w.mul(l))), (f = g.sub(w.mul(p)));
              var v = m.sub(w.mul(y));
              if (!n && c.cmp(h) < 0)
                (e = u.neg()), (r = p), (n = c.neg()), (o = f);
              else if (n && 2 == ++b) break;
              (u = c), (d = l), (l = c), (g = p), (p = f), (m = y), (y = v);
            }
            (s = c.neg()), (a = f);
            var _ = n.sqr().add(o.sqr());
            return (
              s.sqr().add(a.sqr()).cmp(_) >= 0 && ((s = e), (a = r)),
              n.negative && ((n = n.neg()), (o = o.neg())),
              s.negative && ((s = s.neg()), (a = a.neg())),
              [
                { a: n, b: o },
                { a: s, b: a },
              ]
            );
          }),
          (u.prototype._endoSplit = function (t) {
            var e = this.endo.basis,
              r = e[0],
              n = e[1],
              i = n.b.mul(t).divRound(this.n),
              o = r.b.neg().mul(t).divRound(this.n),
              s = i.mul(r.a),
              a = o.mul(n.a),
              u = i.mul(r.b),
              c = o.mul(n.b);
            return { k1: t.sub(s).sub(a), k2: u.add(c).neg() };
          }),
          (u.prototype.pointFromX = function (t, e) {
            (t = new i(t, 16)).red || (t = t.toRed(this.red));
            var r = t
                .redSqr()
                .redMul(t)
                .redIAdd(t.redMul(this.a))
                .redIAdd(this.b),
              n = r.redSqrt();
            if (0 !== n.redSqr().redSub(r).cmp(this.zero))
              throw new Error("invalid point");
            var o = n.fromRed().isOdd();
            return (
              ((e && !o) || (!e && o)) && (n = n.redNeg()), this.point(t, n)
            );
          }),
          (u.prototype.validate = function (t) {
            if (t.inf) return !0;
            var e = t.x,
              r = t.y,
              n = this.a.redMul(e),
              i = e.redSqr().redMul(e).redIAdd(n).redIAdd(this.b);
            return 0 === r.redSqr().redISub(i).cmpn(0);
          }),
          (u.prototype._endoWnafMulAdd = function (t, e, r) {
            for (
              var n = this._endoWnafT1, i = this._endoWnafT2, o = 0;
              o < t.length;
              o++
            ) {
              var s = this._endoSplit(e[o]),
                a = t[o],
                u = a._getBeta();
              s.k1.negative && (s.k1.ineg(), (a = a.neg(!0))),
                s.k2.negative && (s.k2.ineg(), (u = u.neg(!0))),
                (n[2 * o] = a),
                (n[2 * o + 1] = u),
                (i[2 * o] = s.k1),
                (i[2 * o + 1] = s.k2);
            }
            for (
              var c = this._wnafMulAdd(1, n, i, 2 * o, r), f = 0;
              f < 2 * o;
              f++
            )
              (n[f] = null), (i[f] = null);
            return c;
          }),
          o(c, s.BasePoint),
          (u.prototype.point = function (t, e, r) {
            return new c(this, t, e, r);
          }),
          (u.prototype.pointFromJSON = function (t, e) {
            return c.fromJSON(this, t, e);
          }),
          (c.prototype._getBeta = function () {
            if (this.curve.endo) {
              var t = this.precomputed;
              if (t && t.beta) return t.beta;
              var e = this.curve.point(
                this.x.redMul(this.curve.endo.beta),
                this.y,
              );
              if (t) {
                var r = this.curve,
                  n = function (t) {
                    return r.point(t.x.redMul(r.endo.beta), t.y);
                  };
                (t.beta = e),
                  (e.precomputed = {
                    beta: null,
                    naf: t.naf && {
                      wnd: t.naf.wnd,
                      points: t.naf.points.map(n),
                    },
                    doubles: t.doubles && {
                      step: t.doubles.step,
                      points: t.doubles.points.map(n),
                    },
                  });
              }
              return e;
            }
          }),
          (c.prototype.toJSON = function () {
            return this.precomputed
              ? [
                  this.x,
                  this.y,
                  this.precomputed && {
                    doubles: this.precomputed.doubles && {
                      step: this.precomputed.doubles.step,
                      points: this.precomputed.doubles.points.slice(1),
                    },
                    naf: this.precomputed.naf && {
                      wnd: this.precomputed.naf.wnd,
                      points: this.precomputed.naf.points.slice(1),
                    },
                  },
                ]
              : [this.x, this.y];
          }),
          (c.fromJSON = function (t, e, r) {
            "string" == typeof e && (e = JSON.parse(e));
            var n = t.point(e[0], e[1], r);
            if (!e[2]) return n;
            function i(e) {
              return t.point(e[0], e[1], r);
            }
            var o = e[2];
            return (
              (n.precomputed = {
                beta: null,
                doubles: o.doubles && {
                  step: o.doubles.step,
                  points: [n].concat(o.doubles.points.map(i)),
                },
                naf: o.naf && {
                  wnd: o.naf.wnd,
                  points: [n].concat(o.naf.points.map(i)),
                },
              }),
              n
            );
          }),
          (c.prototype.inspect = function () {
            return this.isInfinity()
              ? "<EC Point Infinity>"
              : "<EC Point x: " +
                  this.x.fromRed().toString(16, 2) +
                  " y: " +
                  this.y.fromRed().toString(16, 2) +
                  ">";
          }),
          (c.prototype.isInfinity = function () {
            return this.inf;
          }),
          (c.prototype.add = function (t) {
            if (this.inf) return t;
            if (t.inf) return this;
            if (this.eq(t)) return this.dbl();
            if (this.neg().eq(t)) return this.curve.point(null, null);
            if (0 === this.x.cmp(t.x)) return this.curve.point(null, null);
            var e = this.y.redSub(t.y);
            0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(t.x).redInvm()));
            var r = e.redSqr().redISub(this.x).redISub(t.x),
              n = e.redMul(this.x.redSub(r)).redISub(this.y);
            return this.curve.point(r, n);
          }),
          (c.prototype.dbl = function () {
            if (this.inf) return this;
            var t = this.y.redAdd(this.y);
            if (0 === t.cmpn(0)) return this.curve.point(null, null);
            var e = this.curve.a,
              r = this.x.redSqr(),
              n = t.redInvm(),
              i = r.redAdd(r).redIAdd(r).redIAdd(e).redMul(n),
              o = i.redSqr().redISub(this.x.redAdd(this.x)),
              s = i.redMul(this.x.redSub(o)).redISub(this.y);
            return this.curve.point(o, s);
          }),
          (c.prototype.getX = function () {
            return this.x.fromRed();
          }),
          (c.prototype.getY = function () {
            return this.y.fromRed();
          }),
          (c.prototype.mul = function (t) {
            return (
              (t = new i(t, 16)),
              this.isInfinity()
                ? this
                : this._hasDoubles(t)
                  ? this.curve._fixedNafMul(this, t)
                  : this.curve.endo
                    ? this.curve._endoWnafMulAdd([this], [t])
                    : this.curve._wnafMul(this, t)
            );
          }),
          (c.prototype.mulAdd = function (t, e, r) {
            var n = [this, e],
              i = [t, r];
            return this.curve.endo
              ? this.curve._endoWnafMulAdd(n, i)
              : this.curve._wnafMulAdd(1, n, i, 2);
          }),
          (c.prototype.jmulAdd = function (t, e, r) {
            var n = [this, e],
              i = [t, r];
            return this.curve.endo
              ? this.curve._endoWnafMulAdd(n, i, !0)
              : this.curve._wnafMulAdd(1, n, i, 2, !0);
          }),
          (c.prototype.eq = function (t) {
            return (
              this === t ||
              (this.inf === t.inf &&
                (this.inf || (0 === this.x.cmp(t.x) && 0 === this.y.cmp(t.y))))
            );
          }),
          (c.prototype.neg = function (t) {
            if (this.inf) return this;
            var e = this.curve.point(this.x, this.y.redNeg());
            if (t && this.precomputed) {
              var r = this.precomputed,
                n = function (t) {
                  return t.neg();
                };
              e.precomputed = {
                naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(n) },
                doubles: r.doubles && {
                  step: r.doubles.step,
                  points: r.doubles.points.map(n),
                },
              };
            }
            return e;
          }),
          (c.prototype.toJ = function () {
            return this.inf
              ? this.curve.jpoint(null, null, null)
              : this.curve.jpoint(this.x, this.y, this.curve.one);
          }),
          o(f, s.BasePoint),
          (u.prototype.jpoint = function (t, e, r) {
            return new f(this, t, e, r);
          }),
          (f.prototype.toP = function () {
            if (this.isInfinity()) return this.curve.point(null, null);
            var t = this.z.redInvm(),
              e = t.redSqr(),
              r = this.x.redMul(e),
              n = this.y.redMul(e).redMul(t);
            return this.curve.point(r, n);
          }),
          (f.prototype.neg = function () {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
          }),
          (f.prototype.add = function (t) {
            if (this.isInfinity()) return t;
            if (t.isInfinity()) return this;
            var e = t.z.redSqr(),
              r = this.z.redSqr(),
              n = this.x.redMul(e),
              i = t.x.redMul(r),
              o = this.y.redMul(e.redMul(t.z)),
              s = t.y.redMul(r.redMul(this.z)),
              a = n.redSub(i),
              u = o.redSub(s);
            if (0 === a.cmpn(0))
              return 0 !== u.cmpn(0)
                ? this.curve.jpoint(null, null, null)
                : this.dbl();
            var c = a.redSqr(),
              f = c.redMul(a),
              h = n.redMul(c),
              l = u.redSqr().redIAdd(f).redISub(h).redISub(h),
              d = u.redMul(h.redISub(l)).redISub(o.redMul(f)),
              p = this.z.redMul(t.z).redMul(a);
            return this.curve.jpoint(l, d, p);
          }),
          (f.prototype.mixedAdd = function (t) {
            if (this.isInfinity()) return t.toJ();
            if (t.isInfinity()) return this;
            var e = this.z.redSqr(),
              r = this.x,
              n = t.x.redMul(e),
              i = this.y,
              o = t.y.redMul(e).redMul(this.z),
              s = r.redSub(n),
              a = i.redSub(o);
            if (0 === s.cmpn(0))
              return 0 !== a.cmpn(0)
                ? this.curve.jpoint(null, null, null)
                : this.dbl();
            var u = s.redSqr(),
              c = u.redMul(s),
              f = r.redMul(u),
              h = a.redSqr().redIAdd(c).redISub(f).redISub(f),
              l = a.redMul(f.redISub(h)).redISub(i.redMul(c)),
              d = this.z.redMul(s);
            return this.curve.jpoint(h, l, d);
          }),
          (f.prototype.dblp = function (t) {
            if (0 === t) return this;
            if (this.isInfinity()) return this;
            if (!t) return this.dbl();
            var e;
            if (this.curve.zeroA || this.curve.threeA) {
              var r = this;
              for (e = 0; e < t; e++) r = r.dbl();
              return r;
            }
            var n = this.curve.a,
              i = this.curve.tinv,
              o = this.x,
              s = this.y,
              a = this.z,
              u = a.redSqr().redSqr(),
              c = s.redAdd(s);
            for (e = 0; e < t; e++) {
              var f = o.redSqr(),
                h = c.redSqr(),
                l = h.redSqr(),
                d = f.redAdd(f).redIAdd(f).redIAdd(n.redMul(u)),
                p = o.redMul(h),
                y = d.redSqr().redISub(p.redAdd(p)),
                g = p.redISub(y),
                m = d.redMul(g);
              m = m.redIAdd(m).redISub(l);
              var b = c.redMul(a);
              e + 1 < t && (u = u.redMul(l)), (o = y), (a = b), (c = m);
            }
            return this.curve.jpoint(o, c.redMul(i), a);
          }),
          (f.prototype.dbl = function () {
            return this.isInfinity()
              ? this
              : this.curve.zeroA
                ? this._zeroDbl()
                : this.curve.threeA
                  ? this._threeDbl()
                  : this._dbl();
          }),
          (f.prototype._zeroDbl = function () {
            var t, e, r;
            if (this.zOne) {
              var n = this.x.redSqr(),
                i = this.y.redSqr(),
                o = i.redSqr(),
                s = this.x.redAdd(i).redSqr().redISub(n).redISub(o);
              s = s.redIAdd(s);
              var a = n.redAdd(n).redIAdd(n),
                u = a.redSqr().redISub(s).redISub(s),
                c = o.redIAdd(o);
              (c = (c = c.redIAdd(c)).redIAdd(c)),
                (t = u),
                (e = a.redMul(s.redISub(u)).redISub(c)),
                (r = this.y.redAdd(this.y));
            } else {
              var f = this.x.redSqr(),
                h = this.y.redSqr(),
                l = h.redSqr(),
                d = this.x.redAdd(h).redSqr().redISub(f).redISub(l);
              d = d.redIAdd(d);
              var p = f.redAdd(f).redIAdd(f),
                y = p.redSqr(),
                g = l.redIAdd(l);
              (g = (g = g.redIAdd(g)).redIAdd(g)),
                (t = y.redISub(d).redISub(d)),
                (e = p.redMul(d.redISub(t)).redISub(g)),
                (r = (r = this.y.redMul(this.z)).redIAdd(r));
            }
            return this.curve.jpoint(t, e, r);
          }),
          (f.prototype._threeDbl = function () {
            var t, e, r;
            if (this.zOne) {
              var n = this.x.redSqr(),
                i = this.y.redSqr(),
                o = i.redSqr(),
                s = this.x.redAdd(i).redSqr().redISub(n).redISub(o);
              s = s.redIAdd(s);
              var a = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a),
                u = a.redSqr().redISub(s).redISub(s);
              t = u;
              var c = o.redIAdd(o);
              (c = (c = c.redIAdd(c)).redIAdd(c)),
                (e = a.redMul(s.redISub(u)).redISub(c)),
                (r = this.y.redAdd(this.y));
            } else {
              var f = this.z.redSqr(),
                h = this.y.redSqr(),
                l = this.x.redMul(h),
                d = this.x.redSub(f).redMul(this.x.redAdd(f));
              d = d.redAdd(d).redIAdd(d);
              var p = l.redIAdd(l),
                y = (p = p.redIAdd(p)).redAdd(p);
              (t = d.redSqr().redISub(y)),
                (r = this.y.redAdd(this.z).redSqr().redISub(h).redISub(f));
              var g = h.redSqr();
              (g = (g = (g = g.redIAdd(g)).redIAdd(g)).redIAdd(g)),
                (e = d.redMul(p.redISub(t)).redISub(g));
            }
            return this.curve.jpoint(t, e, r);
          }),
          (f.prototype._dbl = function () {
            var t = this.curve.a,
              e = this.x,
              r = this.y,
              n = this.z,
              i = n.redSqr().redSqr(),
              o = e.redSqr(),
              s = r.redSqr(),
              a = o.redAdd(o).redIAdd(o).redIAdd(t.redMul(i)),
              u = e.redAdd(e),
              c = (u = u.redIAdd(u)).redMul(s),
              f = a.redSqr().redISub(c.redAdd(c)),
              h = c.redISub(f),
              l = s.redSqr();
            l = (l = (l = l.redIAdd(l)).redIAdd(l)).redIAdd(l);
            var d = a.redMul(h).redISub(l),
              p = r.redAdd(r).redMul(n);
            return this.curve.jpoint(f, d, p);
          }),
          (f.prototype.trpl = function () {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var t = this.x.redSqr(),
              e = this.y.redSqr(),
              r = this.z.redSqr(),
              n = e.redSqr(),
              i = t.redAdd(t).redIAdd(t),
              o = i.redSqr(),
              s = this.x.redAdd(e).redSqr().redISub(t).redISub(n),
              a = (s = (s = (s = s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(
                o,
              )).redSqr(),
              u = n.redIAdd(n);
            u = (u = (u = u.redIAdd(u)).redIAdd(u)).redIAdd(u);
            var c = i.redIAdd(s).redSqr().redISub(o).redISub(a).redISub(u),
              f = e.redMul(c);
            f = (f = f.redIAdd(f)).redIAdd(f);
            var h = this.x.redMul(a).redISub(f);
            h = (h = h.redIAdd(h)).redIAdd(h);
            var l = this.y.redMul(c.redMul(u.redISub(c)).redISub(s.redMul(a)));
            l = (l = (l = l.redIAdd(l)).redIAdd(l)).redIAdd(l);
            var d = this.z.redAdd(s).redSqr().redISub(r).redISub(a);
            return this.curve.jpoint(h, l, d);
          }),
          (f.prototype.mul = function (t, e) {
            return (t = new i(t, e)), this.curve._wnafMul(this, t);
          }),
          (f.prototype.eq = function (t) {
            if ("affine" === t.type) return this.eq(t.toJ());
            if (this === t) return !0;
            var e = this.z.redSqr(),
              r = t.z.redSqr();
            if (0 !== this.x.redMul(r).redISub(t.x.redMul(e)).cmpn(0))
              return !1;
            var n = e.redMul(this.z),
              i = r.redMul(t.z);
            return 0 === this.y.redMul(i).redISub(t.y.redMul(n)).cmpn(0);
          }),
          (f.prototype.eqXToP = function (t) {
            var e = this.z.redSqr(),
              r = t.toRed(this.curve.red).redMul(e);
            if (0 === this.x.cmp(r)) return !0;
            for (var n = t.clone(), i = this.curve.redN.redMul(e); ; ) {
              if ((n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)) return !1;
              if ((r.redIAdd(i), 0 === this.x.cmp(r))) return !0;
            }
          }),
          (f.prototype.inspect = function () {
            return this.isInfinity()
              ? "<EC JPoint Infinity>"
              : "<EC JPoint x: " +
                  this.x.toString(16, 2) +
                  " y: " +
                  this.y.toString(16, 2) +
                  " z: " +
                  this.z.toString(16, 2) +
                  ">";
          }),
          (f.prototype.isInfinity = function () {
            return 0 === this.z.cmpn(0);
          });
      },
      60480: (t, e, r) => {
        "use strict";
        var n,
          i = e,
          o = r(77952),
          s = r(894),
          a = r(47011).assert;
        function u(t) {
          "short" === t.type
            ? (this.curve = new s.short(t))
            : "edwards" === t.type
              ? (this.curve = new s.edwards(t))
              : (this.curve = new s.mont(t)),
            (this.g = this.curve.g),
            (this.n = this.curve.n),
            (this.hash = t.hash),
            a(this.g.validate(), "Invalid curve"),
            a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        function c(t, e) {
          Object.defineProperty(i, t, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              var r = new u(e);
              return (
                Object.defineProperty(i, t, {
                  configurable: !0,
                  enumerable: !0,
                  value: r,
                }),
                r
              );
            },
          });
        }
        (i.PresetCurve = u),
          c("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: o.sha256,
            gRed: !1,
            g: [
              "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
              "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811",
            ],
          }),
          c("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: o.sha256,
            gRed: !1,
            g: [
              "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
              "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
            ],
          }),
          c("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: o.sha256,
            gRed: !1,
            g: [
              "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
              "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
            ],
          }),
          c("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: o.sha384,
            gRed: !1,
            g: [
              "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
              "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
            ],
          }),
          c("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: o.sha512,
            gRed: !1,
            g: [
              "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
              "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
            ],
          }),
          c("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: o.sha256,
            gRed: !1,
            g: ["9"],
          }),
          c("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: o.sha256,
            gRed: !1,
            g: [
              "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
              "6666666666666666666666666666666666666666666666666666666666666658",
            ],
          });
        try {
          n = r(74011);
        } catch (t) {
          n = void 0;
        }
        c("secp256k1", {
          type: "short",
          prime: "k256",
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
          a: "0",
          b: "7",
          n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
          h: "1",
          hash: o.sha256,
          beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
          lambda:
            "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3",
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15",
            },
          ],
          gRed: !1,
          g: [
            "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
            n,
          ],
        });
      },
      57447: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(32723),
          o = r(47011),
          s = r(60480),
          a = r(15037),
          u = o.assert,
          c = r(61200),
          f = r(28545);
        function h(t) {
          if (!(this instanceof h)) return new h(t);
          "string" == typeof t &&
            (u(
              Object.prototype.hasOwnProperty.call(s, t),
              "Unknown curve " + t,
            ),
            (t = s[t])),
            t instanceof s.PresetCurve && (t = { curve: t }),
            (this.curve = t.curve.curve),
            (this.n = this.curve.n),
            (this.nh = this.n.ushrn(1)),
            (this.g = this.curve.g),
            (this.g = t.curve.g),
            this.g.precompute(t.curve.n.bitLength() + 1),
            (this.hash = t.hash || t.curve.hash);
        }
        (t.exports = h),
          (h.prototype.keyPair = function (t) {
            return new c(this, t);
          }),
          (h.prototype.keyFromPrivate = function (t, e) {
            return c.fromPrivate(this, t, e);
          }),
          (h.prototype.keyFromPublic = function (t, e) {
            return c.fromPublic(this, t, e);
          }),
          (h.prototype.genKeyPair = function (t) {
            t || (t = {});
            for (
              var e = new i({
                  hash: this.hash,
                  pers: t.pers,
                  persEnc: t.persEnc || "utf8",
                  entropy: t.entropy || a(this.hash.hmacStrength),
                  entropyEnc: (t.entropy && t.entropyEnc) || "utf8",
                  nonce: this.n.toArray(),
                }),
                r = this.n.byteLength(),
                o = this.n.sub(new n(2));
              ;

            ) {
              var s = new n(e.generate(r));
              if (!(s.cmp(o) > 0)) return s.iaddn(1), this.keyFromPrivate(s);
            }
          }),
          (h.prototype._truncateToN = function (t, e, r) {
            var i;
            if (n.isBN(t) || "number" == typeof t)
              i = (t = new n(t, 16)).byteLength();
            else if ("object" == typeof t) (i = t.length), (t = new n(t, 16));
            else {
              var o = t.toString();
              (i = (o.length + 1) >>> 1), (t = new n(o, 16));
            }
            "number" != typeof r && (r = 8 * i);
            var s = r - this.n.bitLength();
            return (
              s > 0 && (t = t.ushrn(s)),
              !e && t.cmp(this.n) >= 0 ? t.sub(this.n) : t
            );
          }),
          (h.prototype.sign = function (t, e, r, o) {
            "object" == typeof r && ((o = r), (r = null)),
              o || (o = {}),
              (e = this.keyFromPrivate(e, r)),
              (t = this._truncateToN(t, !1, o.msgBitLength));
            for (
              var s = this.n.byteLength(),
                a = e.getPrivate().toArray("be", s),
                u = t.toArray("be", s),
                c = new i({
                  hash: this.hash,
                  entropy: a,
                  nonce: u,
                  pers: o.pers,
                  persEnc: o.persEnc || "utf8",
                }),
                h = this.n.sub(new n(1)),
                l = 0;
              ;
              l++
            ) {
              var d = o.k ? o.k(l) : new n(c.generate(this.n.byteLength()));
              if (
                !((d = this._truncateToN(d, !0)).cmpn(1) <= 0 || d.cmp(h) >= 0)
              ) {
                var p = this.g.mul(d);
                if (!p.isInfinity()) {
                  var y = p.getX(),
                    g = y.umod(this.n);
                  if (0 !== g.cmpn(0)) {
                    var m = d.invm(this.n).mul(g.mul(e.getPrivate()).iadd(t));
                    if (0 !== (m = m.umod(this.n)).cmpn(0)) {
                      var b =
                        (p.getY().isOdd() ? 1 : 0) | (0 !== y.cmp(g) ? 2 : 0);
                      return (
                        o.canonical &&
                          m.cmp(this.nh) > 0 &&
                          ((m = this.n.sub(m)), (b ^= 1)),
                        new f({ r: g, s: m, recoveryParam: b })
                      );
                    }
                  }
                }
              }
            }
          }),
          (h.prototype.verify = function (t, e, r, n, i) {
            i || (i = {}),
              (t = this._truncateToN(t, !1, i.msgBitLength)),
              (r = this.keyFromPublic(r, n));
            var o = (e = new f(e, "hex")).r,
              s = e.s;
            if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
            if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
            var a,
              u = s.invm(this.n),
              c = u.mul(t).umod(this.n),
              h = u.mul(o).umod(this.n);
            return this.curve._maxwellTrick
              ? !(a = this.g.jmulAdd(c, r.getPublic(), h)).isInfinity() &&
                  a.eqXToP(o)
              : !(a = this.g.mulAdd(c, r.getPublic(), h)).isInfinity() &&
                  0 === a.getX().umod(this.n).cmp(o);
          }),
          (h.prototype.recoverPubKey = function (t, e, r, i) {
            u((3 & r) === r, "The recovery param is more than two bits"),
              (e = new f(e, i));
            var o = this.n,
              s = new n(t),
              a = e.r,
              c = e.s,
              h = 1 & r,
              l = r >> 1;
            if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
              throw new Error("Unable to find sencond key candinate");
            a = l
              ? this.curve.pointFromX(a.add(this.curve.n), h)
              : this.curve.pointFromX(a, h);
            var d = e.r.invm(o),
              p = o.sub(s).mul(d).umod(o),
              y = c.mul(d).umod(o);
            return this.g.mulAdd(p, a, y);
          }),
          (h.prototype.getKeyRecoveryParam = function (t, e, r, n) {
            if (null !== (e = new f(e, n)).recoveryParam)
              return e.recoveryParam;
            for (var i = 0; i < 4; i++) {
              var o;
              try {
                o = this.recoverPubKey(t, e, i);
              } catch (t) {
                continue;
              }
              if (o.eq(r)) return i;
            }
            throw new Error("Unable to find valid recovery factor");
          });
      },
      61200: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(47011).assert;
        function o(t, e) {
          (this.ec = t),
            (this.priv = null),
            (this.pub = null),
            e.priv && this._importPrivate(e.priv, e.privEnc),
            e.pub && this._importPublic(e.pub, e.pubEnc);
        }
        (t.exports = o),
          (o.fromPublic = function (t, e, r) {
            return e instanceof o ? e : new o(t, { pub: e, pubEnc: r });
          }),
          (o.fromPrivate = function (t, e, r) {
            return e instanceof o ? e : new o(t, { priv: e, privEnc: r });
          }),
          (o.prototype.validate = function () {
            var t = this.getPublic();
            return t.isInfinity()
              ? { result: !1, reason: "Invalid public key" }
              : t.validate()
                ? t.mul(this.ec.curve.n).isInfinity()
                  ? { result: !0, reason: null }
                  : { result: !1, reason: "Public key * N != O" }
                : { result: !1, reason: "Public key is not a point" };
          }),
          (o.prototype.getPublic = function (t, e) {
            return (
              "string" == typeof t && ((e = t), (t = null)),
              this.pub || (this.pub = this.ec.g.mul(this.priv)),
              e ? this.pub.encode(e, t) : this.pub
            );
          }),
          (o.prototype.getPrivate = function (t) {
            return "hex" === t ? this.priv.toString(16, 2) : this.priv;
          }),
          (o.prototype._importPrivate = function (t, e) {
            (this.priv = new n(t, e || 16)),
              (this.priv = this.priv.umod(this.ec.curve.n));
          }),
          (o.prototype._importPublic = function (t, e) {
            if (t.x || t.y)
              return (
                "mont" === this.ec.curve.type
                  ? i(t.x, "Need x coordinate")
                  : ("short" !== this.ec.curve.type &&
                      "edwards" !== this.ec.curve.type) ||
                    i(t.x && t.y, "Need both x and y coordinate"),
                void (this.pub = this.ec.curve.point(t.x, t.y))
              );
            this.pub = this.ec.curve.decodePoint(t, e);
          }),
          (o.prototype.derive = function (t) {
            return (
              t.validate() || i(t.validate(), "public point not validated"),
              t.mul(this.priv).getX()
            );
          }),
          (o.prototype.sign = function (t, e, r) {
            return this.ec.sign(t, this, e, r);
          }),
          (o.prototype.verify = function (t, e, r) {
            return this.ec.verify(t, e, this, void 0, r);
          }),
          (o.prototype.inspect = function () {
            return (
              "<Key priv: " +
              (this.priv && this.priv.toString(16, 2)) +
              " pub: " +
              (this.pub && this.pub.inspect()) +
              " >"
            );
          });
      },
      28545: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(47011),
          o = i.assert;
        function s(t, e) {
          if (t instanceof s) return t;
          this._importDER(t, e) ||
            (o(t.r && t.s, "Signature without r or s"),
            (this.r = new n(t.r, 16)),
            (this.s = new n(t.s, 16)),
            void 0 === t.recoveryParam
              ? (this.recoveryParam = null)
              : (this.recoveryParam = t.recoveryParam));
        }
        function a() {
          this.place = 0;
        }
        function u(t, e) {
          var r = t[e.place++];
          if (!(128 & r)) return r;
          var n = 15 & r;
          if (0 === n || n > 4) return !1;
          if (0 === t[e.place]) return !1;
          for (var i = 0, o = 0, s = e.place; o < n; o++, s++)
            (i <<= 8), (i |= t[s]), (i >>>= 0);
          return !(i <= 127) && ((e.place = s), i);
        }
        function c(t) {
          for (
            var e = 0, r = t.length - 1;
            !t[e] && !(128 & t[e + 1]) && e < r;

          )
            e++;
          return 0 === e ? t : t.slice(e);
        }
        function f(t, e) {
          if (e < 128) t.push(e);
          else {
            var r = 1 + ((Math.log(e) / Math.LN2) >>> 3);
            for (t.push(128 | r); --r; ) t.push((e >>> (r << 3)) & 255);
            t.push(e);
          }
        }
        (t.exports = s),
          (s.prototype._importDER = function (t, e) {
            t = i.toArray(t, e);
            var r = new a();
            if (48 !== t[r.place++]) return !1;
            var o = u(t, r);
            if (!1 === o) return !1;
            if (o + r.place !== t.length) return !1;
            if (2 !== t[r.place++]) return !1;
            var s = u(t, r);
            if (!1 === s) return !1;
            if (128 & t[r.place]) return !1;
            var c = t.slice(r.place, s + r.place);
            if (((r.place += s), 2 !== t[r.place++])) return !1;
            var f = u(t, r);
            if (!1 === f) return !1;
            if (t.length !== f + r.place) return !1;
            if (128 & t[r.place]) return !1;
            var h = t.slice(r.place, f + r.place);
            if (0 === c[0]) {
              if (!(128 & c[1])) return !1;
              c = c.slice(1);
            }
            if (0 === h[0]) {
              if (!(128 & h[1])) return !1;
              h = h.slice(1);
            }
            return (
              (this.r = new n(c)),
              (this.s = new n(h)),
              (this.recoveryParam = null),
              !0
            );
          }),
          (s.prototype.toDER = function (t) {
            var e = this.r.toArray(),
              r = this.s.toArray();
            for (
              128 & e[0] && (e = [0].concat(e)),
                128 & r[0] && (r = [0].concat(r)),
                e = c(e),
                r = c(r);
              !(r[0] || 128 & r[1]);

            )
              r = r.slice(1);
            var n = [2];
            f(n, e.length), (n = n.concat(e)).push(2), f(n, r.length);
            var o = n.concat(r),
              s = [48];
            return f(s, o.length), (s = s.concat(o)), i.encode(s, t);
          });
      },
      8650: (t, e, r) => {
        "use strict";
        var n = r(77952),
          i = r(60480),
          o = r(47011),
          s = o.assert,
          a = o.parseBytes,
          u = r(46661),
          c = r(90220);
        function f(t) {
          if (
            (s("ed25519" === t, "only tested with ed25519 so far"),
            !(this instanceof f))
          )
            return new f(t);
          (t = i[t].curve),
            (this.curve = t),
            (this.g = t.g),
            this.g.precompute(t.n.bitLength() + 1),
            (this.pointClass = t.point().constructor),
            (this.encodingLength = Math.ceil(t.n.bitLength() / 8)),
            (this.hash = n.sha512);
        }
        (t.exports = f),
          (f.prototype.sign = function (t, e) {
            t = a(t);
            var r = this.keyFromSecret(e),
              n = this.hashInt(r.messagePrefix(), t),
              i = this.g.mul(n),
              o = this.encodePoint(i),
              s = this.hashInt(o, r.pubBytes(), t).mul(r.priv()),
              u = n.add(s).umod(this.curve.n);
            return this.makeSignature({ R: i, S: u, Rencoded: o });
          }),
          (f.prototype.verify = function (t, e, r) {
            if (
              ((t = a(t)),
              (e = this.makeSignature(e)).S().gte(e.eddsa.curve.n) ||
                e.S().isNeg())
            )
              return !1;
            var n = this.keyFromPublic(r),
              i = this.hashInt(e.Rencoded(), n.pubBytes(), t),
              o = this.g.mul(e.S());
            return e.R().add(n.pub().mul(i)).eq(o);
          }),
          (f.prototype.hashInt = function () {
            for (var t = this.hash(), e = 0; e < arguments.length; e++)
              t.update(arguments[e]);
            return o.intFromLE(t.digest()).umod(this.curve.n);
          }),
          (f.prototype.keyFromPublic = function (t) {
            return u.fromPublic(this, t);
          }),
          (f.prototype.keyFromSecret = function (t) {
            return u.fromSecret(this, t);
          }),
          (f.prototype.makeSignature = function (t) {
            return t instanceof c ? t : new c(this, t);
          }),
          (f.prototype.encodePoint = function (t) {
            var e = t.getY().toArray("le", this.encodingLength);
            return (
              (e[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0), e
            );
          }),
          (f.prototype.decodePoint = function (t) {
            var e = (t = o.parseBytes(t)).length - 1,
              r = t.slice(0, e).concat(-129 & t[e]),
              n = !!(128 & t[e]),
              i = o.intFromLE(r);
            return this.curve.pointFromY(i, n);
          }),
          (f.prototype.encodeInt = function (t) {
            return t.toArray("le", this.encodingLength);
          }),
          (f.prototype.decodeInt = function (t) {
            return o.intFromLE(t);
          }),
          (f.prototype.isPoint = function (t) {
            return t instanceof this.pointClass;
          });
      },
      46661: (t, e, r) => {
        "use strict";
        var n = r(47011),
          i = n.assert,
          o = n.parseBytes,
          s = n.cachedProperty;
        function a(t, e) {
          (this.eddsa = t),
            (this._secret = o(e.secret)),
            t.isPoint(e.pub)
              ? (this._pub = e.pub)
              : (this._pubBytes = o(e.pub));
        }
        (a.fromPublic = function (t, e) {
          return e instanceof a ? e : new a(t, { pub: e });
        }),
          (a.fromSecret = function (t, e) {
            return e instanceof a ? e : new a(t, { secret: e });
          }),
          (a.prototype.secret = function () {
            return this._secret;
          }),
          s(a, "pubBytes", function () {
            return this.eddsa.encodePoint(this.pub());
          }),
          s(a, "pub", function () {
            return this._pubBytes
              ? this.eddsa.decodePoint(this._pubBytes)
              : this.eddsa.g.mul(this.priv());
          }),
          s(a, "privBytes", function () {
            var t = this.eddsa,
              e = this.hash(),
              r = t.encodingLength - 1,
              n = e.slice(0, t.encodingLength);
            return (n[0] &= 248), (n[r] &= 127), (n[r] |= 64), n;
          }),
          s(a, "priv", function () {
            return this.eddsa.decodeInt(this.privBytes());
          }),
          s(a, "hash", function () {
            return this.eddsa.hash().update(this.secret()).digest();
          }),
          s(a, "messagePrefix", function () {
            return this.hash().slice(this.eddsa.encodingLength);
          }),
          (a.prototype.sign = function (t) {
            return (
              i(this._secret, "KeyPair can only verify"),
              this.eddsa.sign(t, this)
            );
          }),
          (a.prototype.verify = function (t, e) {
            return this.eddsa.verify(t, e, this);
          }),
          (a.prototype.getSecret = function (t) {
            return (
              i(this._secret, "KeyPair is public only"),
              n.encode(this.secret(), t)
            );
          }),
          (a.prototype.getPublic = function (t) {
            return n.encode(this.pubBytes(), t);
          }),
          (t.exports = a);
      },
      90220: (t, e, r) => {
        "use strict";
        var n = r(28490),
          i = r(47011),
          o = i.assert,
          s = i.cachedProperty,
          a = i.parseBytes;
        function u(t, e) {
          (this.eddsa = t),
            "object" != typeof e && (e = a(e)),
            Array.isArray(e) &&
              (o(
                e.length === 2 * t.encodingLength,
                "Signature has invalid size",
              ),
              (e = {
                R: e.slice(0, t.encodingLength),
                S: e.slice(t.encodingLength),
              })),
            o(e.R && e.S, "Signature without R or S"),
            t.isPoint(e.R) && (this._R = e.R),
            e.S instanceof n && (this._S = e.S),
            (this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded),
            (this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded);
        }
        s(u, "S", function () {
          return this.eddsa.decodeInt(this.Sencoded());
        }),
          s(u, "R", function () {
            return this.eddsa.decodePoint(this.Rencoded());
          }),
          s(u, "Rencoded", function () {
            return this.eddsa.encodePoint(this.R());
          }),
          s(u, "Sencoded", function () {
            return this.eddsa.encodeInt(this.S());
          }),
          (u.prototype.toBytes = function () {
            return this.Rencoded().concat(this.Sencoded());
          }),
          (u.prototype.toHex = function () {
            return i.encode(this.toBytes(), "hex").toUpperCase();
          }),
          (t.exports = u);
      },
      74011: (t) => {
        t.exports = {
          doubles: {
            step: 4,
            points: [
              [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821",
              ],
              [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf",
              ],
              [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695",
              ],
              [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9",
              ],
              [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36",
              ],
              [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f",
              ],
              [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999",
              ],
              [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09",
              ],
              [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d",
              ],
              [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088",
              ],
              [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d",
              ],
              [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8",
              ],
              [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a",
              ],
              [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453",
              ],
              [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160",
              ],
              [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0",
              ],
              [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6",
              ],
              [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589",
              ],
              [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17",
              ],
              [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda",
              ],
              [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd",
              ],
              [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2",
              ],
              [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6",
              ],
              [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f",
              ],
              [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01",
              ],
              [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3",
              ],
              [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f",
              ],
              [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7",
              ],
              [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78",
              ],
              [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1",
              ],
              [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150",
              ],
              [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82",
              ],
              [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc",
              ],
              [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b",
              ],
              [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51",
              ],
              [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45",
              ],
              [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120",
              ],
              [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84",
              ],
              [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d",
              ],
              [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d",
              ],
              [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8",
              ],
              [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8",
              ],
              [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac",
              ],
              [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f",
              ],
              [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962",
              ],
              [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907",
              ],
              [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec",
              ],
              [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d",
              ],
              [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414",
              ],
              [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd",
              ],
              [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0",
              ],
              [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811",
              ],
              [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1",
              ],
              [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c",
              ],
              [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73",
              ],
              [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd",
              ],
              [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405",
              ],
              [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589",
              ],
              [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e",
              ],
              [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27",
              ],
              [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1",
              ],
              [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482",
              ],
              [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945",
              ],
              [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573",
              ],
              [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82",
              ],
            ],
          },
          naf: {
            wnd: 7,
            points: [
              [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672",
              ],
              [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6",
              ],
              [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da",
              ],
              [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37",
              ],
              [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b",
              ],
              [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81",
              ],
              [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58",
              ],
              [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77",
              ],
              [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a",
              ],
              [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c",
              ],
              [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67",
              ],
              [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402",
              ],
              [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55",
              ],
              [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482",
              ],
              [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82",
              ],
              [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396",
              ],
              [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49",
              ],
              [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf",
              ],
              [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a",
              ],
              [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7",
              ],
              [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933",
              ],
              [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a",
              ],
              [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6",
              ],
              [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37",
              ],
              [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e",
              ],
              [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6",
              ],
              [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476",
              ],
              [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40",
              ],
              [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61",
              ],
              [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683",
              ],
              [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5",
              ],
              [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b",
              ],
              [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417",
              ],
              [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868",
              ],
              [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a",
              ],
              [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6",
              ],
              [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996",
              ],
              [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e",
              ],
              [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d",
              ],
              [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2",
              ],
              [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e",
              ],
              [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437",
              ],
              [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311",
              ],
              [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4",
              ],
              [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575",
              ],
              [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d",
              ],
              [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d",
              ],
              [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629",
              ],
              [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06",
              ],
              [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374",
              ],
              [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee",
              ],
              [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1",
              ],
              [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b",
              ],
              [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661",
              ],
              [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6",
              ],
              [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e",
              ],
              [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d",
              ],
              [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc",
              ],
              [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4",
              ],
              [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c",
              ],
              [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b",
              ],
              [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913",
              ],
              [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154",
              ],
              [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865",
              ],
              [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc",
              ],
              [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224",
              ],
              [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e",
              ],
              [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6",
              ],
              [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511",
              ],
              [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b",
              ],
              [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2",
              ],
              [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c",
              ],
              [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3",
              ],
              [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d",
              ],
              [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700",
              ],
              [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4",
              ],
              [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196",
              ],
              [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4",
              ],
              [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257",
              ],
              [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13",
              ],
              [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096",
              ],
              [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38",
              ],
              [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f",
              ],
              [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448",
              ],
              [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a",
              ],
              [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4",
              ],
              [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437",
              ],
              [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7",
              ],
              [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d",
              ],
              [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a",
              ],
              [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54",
              ],
              [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77",
              ],
              [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517",
              ],
              [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10",
              ],
              [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125",
              ],
              [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e",
              ],
              [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1",
              ],
              [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2",
              ],
              [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423",
              ],
              [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8",
              ],
              [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758",
              ],
              [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375",
              ],
              [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d",
              ],
              [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec",
              ],
              [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0",
              ],
              [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c",
              ],
              [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4",
              ],
              [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f",
              ],
              [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649",
              ],
              [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826",
              ],
              [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5",
              ],
              [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87",
              ],
              [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b",
              ],
              [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc",
              ],
              [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c",
              ],
              [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f",
              ],
              [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a",
              ],
              [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46",
              ],
              [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f",
              ],
              [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03",
              ],
              [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08",
              ],
              [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8",
              ],
              [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373",
              ],
              [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3",
              ],
              [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8",
              ],
              [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1",
              ],
              [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9",
              ],
            ],
          },
        };
      },
      47011: (t, e, r) => {
        "use strict";
        var n = e,
          i = r(28490),
          o = r(43349),
          s = r(64367);
        (n.assert = o),
          (n.toArray = s.toArray),
          (n.zero2 = s.zero2),
          (n.toHex = s.toHex),
          (n.encode = s.encode),
          (n.getNAF = function (t, e, r) {
            var n,
              i = new Array(Math.max(t.bitLength(), r) + 1);
            for (n = 0; n < i.length; n += 1) i[n] = 0;
            var o = 1 << (e + 1),
              s = t.clone();
            for (n = 0; n < i.length; n++) {
              var a,
                u = s.andln(o - 1);
              s.isOdd()
                ? ((a = u > (o >> 1) - 1 ? (o >> 1) - u : u), s.isubn(a))
                : (a = 0),
                (i[n] = a),
                s.iushrn(1);
            }
            return i;
          }),
          (n.getJSF = function (t, e) {
            var r = [[], []];
            (t = t.clone()), (e = e.clone());
            for (var n, i = 0, o = 0; t.cmpn(-i) > 0 || e.cmpn(-o) > 0; ) {
              var s,
                a,
                u = (t.andln(3) + i) & 3,
                c = (e.andln(3) + o) & 3;
              3 === u && (u = -1),
                3 === c && (c = -1),
                (s =
                  1 & u
                    ? (3 !== (n = (t.andln(7) + i) & 7) && 5 !== n) || 2 !== c
                      ? u
                      : -u
                    : 0),
                r[0].push(s),
                (a =
                  1 & c
                    ? (3 !== (n = (e.andln(7) + o) & 7) && 5 !== n) || 2 !== u
                      ? c
                      : -c
                    : 0),
                r[1].push(a),
                2 * i === s + 1 && (i = 1 - i),
                2 * o === a + 1 && (o = 1 - o),
                t.iushrn(1),
                e.iushrn(1);
            }
            return r;
          }),
          (n.cachedProperty = function (t, e, r) {
            var n = "_" + e;
            t.prototype[e] = function () {
              return void 0 !== this[n] ? this[n] : (this[n] = r.call(this));
            };
          }),
          (n.parseBytes = function (t) {
            return "string" == typeof t ? n.toArray(t, "hex") : t;
          }),
          (n.intFromLE = function (t) {
            return new i(t, "hex", "le");
          });
      },
      28490: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(79368).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      30655: (t) => {
        "use strict";
        var e = Object.defineProperty || !1;
        if (e)
          try {
            e({}, "a", { value: 1 });
          } catch (t) {
            e = !1;
          }
        t.exports = e;
      },
      41237: (t) => {
        "use strict";
        t.exports = EvalError;
      },
      69383: (t) => {
        "use strict";
        t.exports = Error;
      },
      79290: (t) => {
        "use strict";
        t.exports = RangeError;
      },
      79538: (t) => {
        "use strict";
        t.exports = ReferenceError;
      },
      58068: (t) => {
        "use strict";
        t.exports = SyntaxError;
      },
      69675: (t) => {
        "use strict";
        t.exports = TypeError;
      },
      35345: (t) => {
        "use strict";
        t.exports = URIError;
      },
      79612: (t) => {
        "use strict";
        t.exports = Object;
      },
      37007: (t) => {
        "use strict";
        var e,
          r = "object" == typeof Reflect ? Reflect : null,
          n =
            r && "function" == typeof r.apply
              ? r.apply
              : function (t, e, r) {
                  return Function.prototype.apply.call(t, e, r);
                };
        e =
          r && "function" == typeof r.ownKeys
            ? r.ownKeys
            : Object.getOwnPropertySymbols
              ? function (t) {
                  return Object.getOwnPropertyNames(t).concat(
                    Object.getOwnPropertySymbols(t),
                  );
                }
              : function (t) {
                  return Object.getOwnPropertyNames(t);
                };
        var i =
          Number.isNaN ||
          function (t) {
            return t != t;
          };
        function o() {
          o.init.call(this);
        }
        (t.exports = o),
          (t.exports.once = function (t, e) {
            return new Promise(function (r, n) {
              function i(r) {
                t.removeListener(e, o), n(r);
              }
              function o() {
                "function" == typeof t.removeListener &&
                  t.removeListener("error", i),
                  r([].slice.call(arguments));
              }
              y(t, e, o, { once: !0 }),
                "error" !== e &&
                  (function (t, e, r) {
                    "function" == typeof t.on && y(t, "error", e, r);
                  })(t, i, { once: !0 });
            });
          }),
          (o.EventEmitter = o),
          (o.prototype._events = void 0),
          (o.prototype._eventsCount = 0),
          (o.prototype._maxListeners = void 0);
        var s = 10;
        function a(t) {
          if ("function" != typeof t)
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof t,
            );
        }
        function u(t) {
          return void 0 === t._maxListeners
            ? o.defaultMaxListeners
            : t._maxListeners;
        }
        function c(t, e, r, n) {
          var i, o, s, c;
          if (
            (a(r),
            void 0 === (o = t._events)
              ? ((o = t._events = Object.create(null)), (t._eventsCount = 0))
              : (void 0 !== o.newListener &&
                  (t.emit("newListener", e, r.listener ? r.listener : r),
                  (o = t._events)),
                (s = o[e])),
            void 0 === s)
          )
            (s = o[e] = r), ++t._eventsCount;
          else if (
            ("function" == typeof s
              ? (s = o[e] = n ? [r, s] : [s, r])
              : n
                ? s.unshift(r)
                : s.push(r),
            (i = u(t)) > 0 && s.length > i && !s.warned)
          ) {
            s.warned = !0;
            var f = new Error(
              "Possible EventEmitter memory leak detected. " +
                s.length +
                " " +
                String(e) +
                " listeners added. Use emitter.setMaxListeners() to increase limit",
            );
            (f.name = "MaxListenersExceededWarning"),
              (f.emitter = t),
              (f.type = e),
              (f.count = s.length),
              (c = f),
              console && console.warn && console.warn(c);
          }
          return t;
        }
        function f() {
          if (!this.fired)
            return (
              this.target.removeListener(this.type, this.wrapFn),
              (this.fired = !0),
              0 === arguments.length
                ? this.listener.call(this.target)
                : this.listener.apply(this.target, arguments)
            );
        }
        function h(t, e, r) {
          var n = {
              fired: !1,
              wrapFn: void 0,
              target: t,
              type: e,
              listener: r,
            },
            i = f.bind(n);
          return (i.listener = r), (n.wrapFn = i), i;
        }
        function l(t, e, r) {
          var n = t._events;
          if (void 0 === n) return [];
          var i = n[e];
          return void 0 === i
            ? []
            : "function" == typeof i
              ? r
                ? [i.listener || i]
                : [i]
              : r
                ? (function (t) {
                    for (var e = new Array(t.length), r = 0; r < e.length; ++r)
                      e[r] = t[r].listener || t[r];
                    return e;
                  })(i)
                : p(i, i.length);
        }
        function d(t) {
          var e = this._events;
          if (void 0 !== e) {
            var r = e[t];
            if ("function" == typeof r) return 1;
            if (void 0 !== r) return r.length;
          }
          return 0;
        }
        function p(t, e) {
          for (var r = new Array(e), n = 0; n < e; ++n) r[n] = t[n];
          return r;
        }
        function y(t, e, r, n) {
          if ("function" == typeof t.on) n.once ? t.once(e, r) : t.on(e, r);
          else {
            if ("function" != typeof t.addEventListener)
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof t,
              );
            t.addEventListener(e, function i(o) {
              n.once && t.removeEventListener(e, i), r(o);
            });
          }
        }
        Object.defineProperty(o, "defaultMaxListeners", {
          enumerable: !0,
          get: function () {
            return s;
          },
          set: function (t) {
            if ("number" != typeof t || t < 0 || i(t))
              throw new RangeError(
                'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                  t +
                  ".",
              );
            s = t;
          },
        }),
          (o.init = function () {
            (void 0 !== this._events &&
              this._events !== Object.getPrototypeOf(this)._events) ||
              ((this._events = Object.create(null)), (this._eventsCount = 0)),
              (this._maxListeners = this._maxListeners || void 0);
          }),
          (o.prototype.setMaxListeners = function (t) {
            if ("number" != typeof t || t < 0 || i(t))
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  t +
                  ".",
              );
            return (this._maxListeners = t), this;
          }),
          (o.prototype.getMaxListeners = function () {
            return u(this);
          }),
          (o.prototype.emit = function (t) {
            for (var e = [], r = 1; r < arguments.length; r++)
              e.push(arguments[r]);
            var i = "error" === t,
              o = this._events;
            if (void 0 !== o) i = i && void 0 === o.error;
            else if (!i) return !1;
            if (i) {
              var s;
              if ((e.length > 0 && (s = e[0]), s instanceof Error)) throw s;
              var a = new Error(
                "Unhandled error." + (s ? " (" + s.message + ")" : ""),
              );
              throw ((a.context = s), a);
            }
            var u = o[t];
            if (void 0 === u) return !1;
            if ("function" == typeof u) n(u, this, e);
            else {
              var c = u.length,
                f = p(u, c);
              for (r = 0; r < c; ++r) n(f[r], this, e);
            }
            return !0;
          }),
          (o.prototype.addListener = function (t, e) {
            return c(this, t, e, !1);
          }),
          (o.prototype.on = o.prototype.addListener),
          (o.prototype.prependListener = function (t, e) {
            return c(this, t, e, !0);
          }),
          (o.prototype.once = function (t, e) {
            return a(e), this.on(t, h(this, t, e)), this;
          }),
          (o.prototype.prependOnceListener = function (t, e) {
            return a(e), this.prependListener(t, h(this, t, e)), this;
          }),
          (o.prototype.removeListener = function (t, e) {
            var r, n, i, o, s;
            if ((a(e), void 0 === (n = this._events))) return this;
            if (void 0 === (r = n[t])) return this;
            if (r === e || r.listener === e)
              0 == --this._eventsCount
                ? (this._events = Object.create(null))
                : (delete n[t],
                  n.removeListener &&
                    this.emit("removeListener", t, r.listener || e));
            else if ("function" != typeof r) {
              for (i = -1, o = r.length - 1; o >= 0; o--)
                if (r[o] === e || r[o].listener === e) {
                  (s = r[o].listener), (i = o);
                  break;
                }
              if (i < 0) return this;
              0 === i
                ? r.shift()
                : (function (t, e) {
                    for (; e + 1 < t.length; e++) t[e] = t[e + 1];
                    t.pop();
                  })(r, i),
                1 === r.length && (n[t] = r[0]),
                void 0 !== n.removeListener &&
                  this.emit("removeListener", t, s || e);
            }
            return this;
          }),
          (o.prototype.off = o.prototype.removeListener),
          (o.prototype.removeAllListeners = function (t) {
            var e, r, n;
            if (void 0 === (r = this._events)) return this;
            if (void 0 === r.removeListener)
              return (
                0 === arguments.length
                  ? ((this._events = Object.create(null)),
                    (this._eventsCount = 0))
                  : void 0 !== r[t] &&
                    (0 == --this._eventsCount
                      ? (this._events = Object.create(null))
                      : delete r[t]),
                this
              );
            if (0 === arguments.length) {
              var i,
                o = Object.keys(r);
              for (n = 0; n < o.length; ++n)
                "removeListener" !== (i = o[n]) && this.removeAllListeners(i);
              return (
                this.removeAllListeners("removeListener"),
                (this._events = Object.create(null)),
                (this._eventsCount = 0),
                this
              );
            }
            if ("function" == typeof (e = r[t])) this.removeListener(t, e);
            else if (void 0 !== e)
              for (n = e.length - 1; n >= 0; n--) this.removeListener(t, e[n]);
            return this;
          }),
          (o.prototype.listeners = function (t) {
            return l(this, t, !0);
          }),
          (o.prototype.rawListeners = function (t) {
            return l(this, t, !1);
          }),
          (o.listenerCount = function (t, e) {
            return "function" == typeof t.listenerCount
              ? t.listenerCount(e)
              : d.call(t, e);
          }),
          (o.prototype.listenerCount = d),
          (o.prototype.eventNames = function () {
            return this._eventsCount > 0 ? e(this._events) : [];
          });
      },
      68078: (t, e, r) => {
        var n = r(92861).Buffer,
          i = r(88276);
        t.exports = function (t, e, r, o) {
          if (
            (n.isBuffer(t) || (t = n.from(t, "binary")),
            e && (n.isBuffer(e) || (e = n.from(e, "binary")), 8 !== e.length))
          )
            throw new RangeError("salt should be Buffer with 8 byte length");
          for (
            var s = r / 8, a = n.alloc(s), u = n.alloc(o || 0), c = n.alloc(0);
            s > 0 || o > 0;

          ) {
            var f = new i();
            f.update(c), f.update(t), e && f.update(e), (c = f.digest());
            var h = 0;
            if (s > 0) {
              var l = a.length - s;
              (h = Math.min(s, c.length)), c.copy(a, l, 0, h), (s -= h);
            }
            if (h < c.length && o > 0) {
              var d = u.length - o,
                p = Math.min(o, c.length - h);
              c.copy(u, d, h, h + p), (o -= p);
            }
          }
          return c.fill(0), { key: a, iv: u };
        };
      },
      82682: (t, e, r) => {
        "use strict";
        var n = r(69600),
          i = Object.prototype.toString,
          o = Object.prototype.hasOwnProperty;
        t.exports = function (t, e, r) {
          if (!n(e)) throw new TypeError("iterator must be a function");
          var s;
          arguments.length >= 3 && (s = r),
            "[object Array]" === i.call(t)
              ? (function (t, e, r) {
                  for (var n = 0, i = t.length; n < i; n++)
                    o.call(t, n) &&
                      (null == r ? e(t[n], n, t) : e.call(r, t[n], n, t));
                })(t, e, s)
              : "string" == typeof t
                ? (function (t, e, r) {
                    for (var n = 0, i = t.length; n < i; n++)
                      null == r
                        ? e(t.charAt(n), n, t)
                        : e.call(r, t.charAt(n), n, t);
                  })(t, e, s)
                : (function (t, e, r) {
                    for (var n in t)
                      o.call(t, n) &&
                        (null == r ? e(t[n], n, t) : e.call(r, t[n], n, t));
                  })(t, e, s);
        };
      },
      89353: (t) => {
        "use strict";
        var e = Object.prototype.toString,
          r = Math.max,
          n = function (t, e) {
            for (var r = [], n = 0; n < t.length; n += 1) r[n] = t[n];
            for (var i = 0; i < e.length; i += 1) r[i + t.length] = e[i];
            return r;
          };
        t.exports = function (t) {
          var i = this;
          if ("function" != typeof i || "[object Function]" !== e.apply(i))
            throw new TypeError(
              "Function.prototype.bind called on incompatible " + i,
            );
          for (
            var o,
              s = (function (t, e) {
                for (
                  var r = [], n = e || 0, i = 0;
                  n < t.length;
                  n += 1, i += 1
                )
                  r[i] = t[n];
                return r;
              })(arguments, 1),
              a = r(0, i.length - s.length),
              u = [],
              c = 0;
            c < a;
            c++
          )
            u[c] = "$" + c;
          if (
            ((o = Function(
              "binder",
              "return function (" +
                (function (t, e) {
                  for (var r = "", n = 0; n < t.length; n += 1)
                    (r += t[n]), n + 1 < t.length && (r += e);
                  return r;
                })(u, ",") +
                "){ return binder.apply(this,arguments); }",
            )(function () {
              if (this instanceof o) {
                var e = i.apply(this, n(s, arguments));
                return Object(e) === e ? e : this;
              }
              return i.apply(t, n(s, arguments));
            })),
            i.prototype)
          ) {
            var f = function () {};
            (f.prototype = i.prototype),
              (o.prototype = new f()),
              (f.prototype = null);
          }
          return o;
        };
      },
      66743: (t, e, r) => {
        "use strict";
        var n = r(89353);
        t.exports = Function.prototype.bind || n;
      },
      70453: (t, e, r) => {
        "use strict";
        var n,
          i = r(79612),
          o = r(69383),
          s = r(41237),
          a = r(79290),
          u = r(79538),
          c = r(58068),
          f = r(69675),
          h = r(35345),
          l = r(71514),
          d = r(58968),
          p = r(6188),
          y = r(68002),
          g = r(75880),
          m = r(70414),
          b = r(73093),
          w = Function,
          v = function (t) {
            try {
              return w('"use strict"; return (' + t + ").constructor;")();
            } catch (t) {}
          },
          _ = r(75795),
          E = r(30655),
          S = function () {
            throw new f();
          },
          I = _
            ? (function () {
                try {
                  return S;
                } catch (t) {
                  try {
                    return _(arguments, "callee").get;
                  } catch (t) {
                    return S;
                  }
                }
              })()
            : S,
          M = r(64039)(),
          A = r(93628),
          T = r(71064),
          k = r(48648),
          O = r(11002),
          x = r(10076),
          P = {},
          B = "undefined" != typeof Uint8Array && A ? A(Uint8Array) : n,
          C = {
            __proto__: null,
            "%AggregateError%":
              "undefined" == typeof AggregateError ? n : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%":
              "undefined" == typeof ArrayBuffer ? n : ArrayBuffer,
            "%ArrayIteratorPrototype%": M && A ? A([][Symbol.iterator]()) : n,
            "%AsyncFromSyncIteratorPrototype%": n,
            "%AsyncFunction%": P,
            "%AsyncGenerator%": P,
            "%AsyncGeneratorFunction%": P,
            "%AsyncIteratorPrototype%": P,
            "%Atomics%": "undefined" == typeof Atomics ? n : Atomics,
            "%BigInt%": "undefined" == typeof BigInt ? n : BigInt,
            "%BigInt64Array%":
              "undefined" == typeof BigInt64Array ? n : BigInt64Array,
            "%BigUint64Array%":
              "undefined" == typeof BigUint64Array ? n : BigUint64Array,
            "%Boolean%": Boolean,
            "%DataView%": "undefined" == typeof DataView ? n : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": o,
            "%eval%": eval,
            "%EvalError%": s,
            "%Float32Array%":
              "undefined" == typeof Float32Array ? n : Float32Array,
            "%Float64Array%":
              "undefined" == typeof Float64Array ? n : Float64Array,
            "%FinalizationRegistry%":
              "undefined" == typeof FinalizationRegistry
                ? n
                : FinalizationRegistry,
            "%Function%": w,
            "%GeneratorFunction%": P,
            "%Int8Array%": "undefined" == typeof Int8Array ? n : Int8Array,
            "%Int16Array%": "undefined" == typeof Int16Array ? n : Int16Array,
            "%Int32Array%": "undefined" == typeof Int32Array ? n : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": M && A ? A(A([][Symbol.iterator]())) : n,
            "%JSON%": "object" == typeof JSON ? JSON : n,
            "%Map%": "undefined" == typeof Map ? n : Map,
            "%MapIteratorPrototype%":
              "undefined" != typeof Map && M && A
                ? A(new Map()[Symbol.iterator]())
                : n,
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": i,
            "%Object.getOwnPropertyDescriptor%": _,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": "undefined" == typeof Promise ? n : Promise,
            "%Proxy%": "undefined" == typeof Proxy ? n : Proxy,
            "%RangeError%": a,
            "%ReferenceError%": u,
            "%Reflect%": "undefined" == typeof Reflect ? n : Reflect,
            "%RegExp%": RegExp,
            "%Set%": "undefined" == typeof Set ? n : Set,
            "%SetIteratorPrototype%":
              "undefined" != typeof Set && M && A
                ? A(new Set()[Symbol.iterator]())
                : n,
            "%SharedArrayBuffer%":
              "undefined" == typeof SharedArrayBuffer ? n : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": M && A ? A(""[Symbol.iterator]()) : n,
            "%Symbol%": M ? Symbol : n,
            "%SyntaxError%": c,
            "%ThrowTypeError%": I,
            "%TypedArray%": B,
            "%TypeError%": f,
            "%Uint8Array%": "undefined" == typeof Uint8Array ? n : Uint8Array,
            "%Uint8ClampedArray%":
              "undefined" == typeof Uint8ClampedArray ? n : Uint8ClampedArray,
            "%Uint16Array%":
              "undefined" == typeof Uint16Array ? n : Uint16Array,
            "%Uint32Array%":
              "undefined" == typeof Uint32Array ? n : Uint32Array,
            "%URIError%": h,
            "%WeakMap%": "undefined" == typeof WeakMap ? n : WeakMap,
            "%WeakRef%": "undefined" == typeof WeakRef ? n : WeakRef,
            "%WeakSet%": "undefined" == typeof WeakSet ? n : WeakSet,
            "%Function.prototype.call%": x,
            "%Function.prototype.apply%": O,
            "%Object.defineProperty%": E,
            "%Object.getPrototypeOf%": T,
            "%Math.abs%": l,
            "%Math.floor%": d,
            "%Math.max%": p,
            "%Math.min%": y,
            "%Math.pow%": g,
            "%Math.round%": m,
            "%Math.sign%": b,
            "%Reflect.getPrototypeOf%": k,
          };
        if (A)
          try {
            null.error;
          } catch (t) {
            var R = A(A(t));
            C["%Error.prototype%"] = R;
          }
        var N = function t(e) {
            var r;
            if ("%AsyncFunction%" === e) r = v("async function () {}");
            else if ("%GeneratorFunction%" === e) r = v("function* () {}");
            else if ("%AsyncGeneratorFunction%" === e)
              r = v("async function* () {}");
            else if ("%AsyncGenerator%" === e) {
              var n = t("%AsyncGeneratorFunction%");
              n && (r = n.prototype);
            } else if ("%AsyncIteratorPrototype%" === e) {
              var i = t("%AsyncGenerator%");
              i && A && (r = A(i.prototype));
            }
            return (C[e] = r), r;
          },
          U = {
            __proto__: null,
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": [
              "AsyncGeneratorFunction",
              "prototype",
              "prototype",
            ],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": [
              "GeneratorFunction",
              "prototype",
              "prototype",
            ],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"],
          },
          D = r(66743),
          L = r(9957),
          j = D.call(x, Array.prototype.concat),
          F = D.call(O, Array.prototype.splice),
          H = D.call(x, String.prototype.replace),
          K = D.call(x, String.prototype.slice),
          V = D.call(x, RegExp.prototype.exec),
          q =
            /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
          z = /\\(\\)?/g,
          $ = function (t, e) {
            var r,
              n = t;
            if ((L(U, n) && (n = "%" + (r = U[n])[0] + "%"), L(C, n))) {
              var i = C[n];
              if ((i === P && (i = N(n)), void 0 === i && !e))
                throw new f(
                  "intrinsic " +
                    t +
                    " exists, but is not available. Please file an issue!",
                );
              return { alias: r, name: n, value: i };
            }
            throw new c("intrinsic " + t + " does not exist!");
          };
        t.exports = function (t, e) {
          if ("string" != typeof t || 0 === t.length)
            throw new f("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && "boolean" != typeof e)
            throw new f('"allowMissing" argument must be a boolean');
          if (null === V(/^%?[^%]*%?$/, t))
            throw new c(
              "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
            );
          var r = (function (t) {
              var e = K(t, 0, 1),
                r = K(t, -1);
              if ("%" === e && "%" !== r)
                throw new c("invalid intrinsic syntax, expected closing `%`");
              if ("%" === r && "%" !== e)
                throw new c("invalid intrinsic syntax, expected opening `%`");
              var n = [];
              return (
                H(t, q, function (t, e, r, i) {
                  n[n.length] = r ? H(i, z, "$1") : e || t;
                }),
                n
              );
            })(t),
            n = r.length > 0 ? r[0] : "",
            i = $("%" + n + "%", e),
            o = i.name,
            s = i.value,
            a = !1,
            u = i.alias;
          u && ((n = u[0]), F(r, j([0, 1], u)));
          for (var h = 1, l = !0; h < r.length; h += 1) {
            var d = r[h],
              p = K(d, 0, 1),
              y = K(d, -1);
            if (
              ('"' === p ||
                "'" === p ||
                "`" === p ||
                '"' === y ||
                "'" === y ||
                "`" === y) &&
              p !== y
            )
              throw new c(
                "property names with quotes must have matching quotes",
              );
            if (
              (("constructor" !== d && l) || (a = !0),
              L(C, (o = "%" + (n += "." + d) + "%")))
            )
              s = C[o];
            else if (null != s) {
              if (!(d in s)) {
                if (!e)
                  throw new f(
                    "base intrinsic for " +
                      t +
                      " exists, but the property is not available.",
                  );
                return;
              }
              if (_ && h + 1 >= r.length) {
                var g = _(s, d);
                s =
                  (l = !!g) && "get" in g && !("originalValue" in g.get)
                    ? g.get
                    : s[d];
              } else (l = L(s, d)), (s = s[d]);
              l && !a && (C[o] = s);
            }
          }
          return s;
        };
      },
      71064: (t, e, r) => {
        "use strict";
        var n = r(79612);
        t.exports = n.getPrototypeOf || null;
      },
      48648: (t) => {
        "use strict";
        t.exports =
          ("undefined" != typeof Reflect && Reflect.getPrototypeOf) || null;
      },
      93628: (t, e, r) => {
        "use strict";
        var n = r(48648),
          i = r(71064),
          o = r(7176);
        t.exports = n
          ? function (t) {
              return n(t);
            }
          : i
            ? function (t) {
                if (!t || ("object" != typeof t && "function" != typeof t))
                  throw new TypeError("getProto: not an object");
                return i(t);
              }
            : o
              ? function (t) {
                  return o(t);
                }
              : null;
      },
      6549: (t) => {
        "use strict";
        t.exports = Object.getOwnPropertyDescriptor;
      },
      75795: (t, e, r) => {
        "use strict";
        var n = r(6549);
        if (n)
          try {
            n([], "length");
          } catch (t) {
            n = null;
          }
        t.exports = n;
      },
      30592: (t, e, r) => {
        "use strict";
        var n = r(30655),
          i = function () {
            return !!n;
          };
        (i.hasArrayLengthDefineBug = function () {
          if (!n) return null;
          try {
            return 1 !== n([], "length", { value: 1 }).length;
          } catch (t) {
            return !0;
          }
        }),
          (t.exports = i);
      },
      64039: (t, e, r) => {
        "use strict";
        var n = "undefined" != typeof Symbol && Symbol,
          i = r(41333);
        t.exports = function () {
          return (
            "function" == typeof n &&
            "function" == typeof Symbol &&
            "symbol" == typeof n("foo") &&
            "symbol" == typeof Symbol("bar") &&
            i()
          );
        };
      },
      41333: (t) => {
        "use strict";
        t.exports = function () {
          if (
            "function" != typeof Symbol ||
            "function" != typeof Object.getOwnPropertySymbols
          )
            return !1;
          if ("symbol" == typeof Symbol.iterator) return !0;
          var t = {},
            e = Symbol("test"),
            r = Object(e);
          if ("string" == typeof e) return !1;
          if ("[object Symbol]" !== Object.prototype.toString.call(e))
            return !1;
          if ("[object Symbol]" !== Object.prototype.toString.call(r))
            return !1;
          for (var n in ((t[e] = 42), t)) return !1;
          if ("function" == typeof Object.keys && 0 !== Object.keys(t).length)
            return !1;
          if (
            "function" == typeof Object.getOwnPropertyNames &&
            0 !== Object.getOwnPropertyNames(t).length
          )
            return !1;
          var i = Object.getOwnPropertySymbols(t);
          if (1 !== i.length || i[0] !== e) return !1;
          if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
          if ("function" == typeof Object.getOwnPropertyDescriptor) {
            var o = Object.getOwnPropertyDescriptor(t, e);
            if (42 !== o.value || !0 !== o.enumerable) return !1;
          }
          return !0;
        };
      },
      49092: (t, e, r) => {
        "use strict";
        var n = r(41333);
        t.exports = function () {
          return n() && !!Symbol.toStringTag;
        };
      },
      4729: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(28399).Transform;
        function o(t) {
          i.call(this),
            (this._block = n.allocUnsafe(t)),
            (this._blockSize = t),
            (this._blockOffset = 0),
            (this._length = [0, 0, 0, 0]),
            (this._finalized = !1);
        }
        r(56698)(o, i),
          (o.prototype._transform = function (t, e, r) {
            var n = null;
            try {
              this.update(t, e);
            } catch (t) {
              n = t;
            }
            r(n);
          }),
          (o.prototype._flush = function (t) {
            var e = null;
            try {
              this.push(this.digest());
            } catch (t) {
              e = t;
            }
            t(e);
          }),
          (o.prototype.update = function (t, e) {
            if (
              ((function (t, e) {
                if (!n.isBuffer(t) && "string" != typeof t)
                  throw new TypeError(e + " must be a string or a buffer");
              })(t, "Data"),
              this._finalized)
            )
              throw new Error("Digest already called");
            n.isBuffer(t) || (t = n.from(t, e));
            for (
              var r = this._block, i = 0;
              this._blockOffset + t.length - i >= this._blockSize;

            ) {
              for (var o = this._blockOffset; o < this._blockSize; )
                r[o++] = t[i++];
              this._update(), (this._blockOffset = 0);
            }
            for (; i < t.length; ) r[this._blockOffset++] = t[i++];
            for (var s = 0, a = 8 * t.length; a > 0; ++s)
              (this._length[s] += a),
                (a = (this._length[s] / 4294967296) | 0) > 0 &&
                  (this._length[s] -= 4294967296 * a);
            return this;
          }),
          (o.prototype._update = function () {
            throw new Error("_update is not implemented");
          }),
          (o.prototype.digest = function (t) {
            if (this._finalized) throw new Error("Digest already called");
            this._finalized = !0;
            var e = this._digest();
            void 0 !== t && (e = e.toString(t)),
              this._block.fill(0),
              (this._blockOffset = 0);
            for (var r = 0; r < 4; ++r) this._length[r] = 0;
            return e;
          }),
          (o.prototype._digest = function () {
            throw new Error("_digest is not implemented");
          }),
          (t.exports = o);
      },
      77952: (t, e, r) => {
        var n = e;
        (n.utils = r(67426)),
          (n.common = r(66166)),
          (n.sha = r(46229)),
          (n.ripemd = r(46784)),
          (n.hmac = r(28948)),
          (n.sha1 = n.sha.sha1),
          (n.sha256 = n.sha.sha256),
          (n.sha224 = n.sha.sha224),
          (n.sha384 = n.sha.sha384),
          (n.sha512 = n.sha.sha512),
          (n.ripemd160 = n.ripemd.ripemd160);
      },
      66166: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(43349);
        function o() {
          (this.pending = null),
            (this.pendingTotal = 0),
            (this.blockSize = this.constructor.blockSize),
            (this.outSize = this.constructor.outSize),
            (this.hmacStrength = this.constructor.hmacStrength),
            (this.padLength = this.constructor.padLength / 8),
            (this.endian = "big"),
            (this._delta8 = this.blockSize / 8),
            (this._delta32 = this.blockSize / 32);
        }
        (e.BlockHash = o),
          (o.prototype.update = function (t, e) {
            if (
              ((t = n.toArray(t, e)),
              this.pending
                ? (this.pending = this.pending.concat(t))
                : (this.pending = t),
              (this.pendingTotal += t.length),
              this.pending.length >= this._delta8)
            ) {
              var r = (t = this.pending).length % this._delta8;
              (this.pending = t.slice(t.length - r, t.length)),
                0 === this.pending.length && (this.pending = null),
                (t = n.join32(t, 0, t.length - r, this.endian));
              for (var i = 0; i < t.length; i += this._delta32)
                this._update(t, i, i + this._delta32);
            }
            return this;
          }),
          (o.prototype.digest = function (t) {
            return (
              this.update(this._pad()),
              i(null === this.pending),
              this._digest(t)
            );
          }),
          (o.prototype._pad = function () {
            var t = this.pendingTotal,
              e = this._delta8,
              r = e - ((t + this.padLength) % e),
              n = new Array(r + this.padLength);
            n[0] = 128;
            for (var i = 1; i < r; i++) n[i] = 0;
            if (((t <<= 3), "big" === this.endian)) {
              for (var o = 8; o < this.padLength; o++) n[i++] = 0;
              (n[i++] = 0),
                (n[i++] = 0),
                (n[i++] = 0),
                (n[i++] = 0),
                (n[i++] = (t >>> 24) & 255),
                (n[i++] = (t >>> 16) & 255),
                (n[i++] = (t >>> 8) & 255),
                (n[i++] = 255 & t);
            } else
              for (
                n[i++] = 255 & t,
                  n[i++] = (t >>> 8) & 255,
                  n[i++] = (t >>> 16) & 255,
                  n[i++] = (t >>> 24) & 255,
                  n[i++] = 0,
                  n[i++] = 0,
                  n[i++] = 0,
                  n[i++] = 0,
                  o = 8;
                o < this.padLength;
                o++
              )
                n[i++] = 0;
            return n;
          });
      },
      28948: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(43349);
        function o(t, e, r) {
          if (!(this instanceof o)) return new o(t, e, r);
          (this.Hash = t),
            (this.blockSize = t.blockSize / 8),
            (this.outSize = t.outSize / 8),
            (this.inner = null),
            (this.outer = null),
            this._init(n.toArray(e, r));
        }
        (t.exports = o),
          (o.prototype._init = function (t) {
            t.length > this.blockSize &&
              (t = new this.Hash().update(t).digest()),
              i(t.length <= this.blockSize);
            for (var e = t.length; e < this.blockSize; e++) t.push(0);
            for (e = 0; e < t.length; e++) t[e] ^= 54;
            for (
              this.inner = new this.Hash().update(t), e = 0;
              e < t.length;
              e++
            )
              t[e] ^= 106;
            this.outer = new this.Hash().update(t);
          }),
          (o.prototype.update = function (t, e) {
            return this.inner.update(t, e), this;
          }),
          (o.prototype.digest = function (t) {
            return this.outer.update(this.inner.digest()), this.outer.digest(t);
          });
      },
      46784: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(66166),
          o = n.rotl32,
          s = n.sum32,
          a = n.sum32_3,
          u = n.sum32_4,
          c = i.BlockHash;
        function f() {
          if (!(this instanceof f)) return new f();
          c.call(this),
            (this.h = [
              1732584193, 4023233417, 2562383102, 271733878, 3285377520,
            ]),
            (this.endian = "little");
        }
        function h(t, e, r, n) {
          return t <= 15
            ? e ^ r ^ n
            : t <= 31
              ? (e & r) | (~e & n)
              : t <= 47
                ? (e | ~r) ^ n
                : t <= 63
                  ? (e & n) | (r & ~n)
                  : e ^ (r | ~n);
        }
        function l(t) {
          return t <= 15
            ? 0
            : t <= 31
              ? 1518500249
              : t <= 47
                ? 1859775393
                : t <= 63
                  ? 2400959708
                  : 2840853838;
        }
        function d(t) {
          return t <= 15
            ? 1352829926
            : t <= 31
              ? 1548603684
              : t <= 47
                ? 1836072691
                : t <= 63
                  ? 2053994217
                  : 0;
        }
        n.inherits(f, c),
          (e.ripemd160 = f),
          (f.blockSize = 512),
          (f.outSize = 160),
          (f.hmacStrength = 192),
          (f.padLength = 64),
          (f.prototype._update = function (t, e) {
            for (
              var r = this.h[0],
                n = this.h[1],
                i = this.h[2],
                c = this.h[3],
                f = this.h[4],
                b = r,
                w = n,
                v = i,
                _ = c,
                E = f,
                S = 0;
              S < 80;
              S++
            ) {
              var I = s(o(u(r, h(S, n, i, c), t[p[S] + e], l(S)), g[S]), f);
              (r = f),
                (f = c),
                (c = o(i, 10)),
                (i = n),
                (n = I),
                (I = s(
                  o(u(b, h(79 - S, w, v, _), t[y[S] + e], d(S)), m[S]),
                  E,
                )),
                (b = E),
                (E = _),
                (_ = o(v, 10)),
                (v = w),
                (w = I);
            }
            (I = a(this.h[1], i, _)),
              (this.h[1] = a(this.h[2], c, E)),
              (this.h[2] = a(this.h[3], f, b)),
              (this.h[3] = a(this.h[4], r, w)),
              (this.h[4] = a(this.h[0], n, v)),
              (this.h[0] = I);
          }),
          (f.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h, "little")
              : n.split32(this.h, "little");
          });
        var p = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1,
            10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1,
            2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15,
            14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
          ],
          y = [
            5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7,
            0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9,
            11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13,
            9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
          ],
          g = [
            11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13,
            11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
            15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14,
            5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8,
            5, 6,
          ],
          m = [
            8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15,
            7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
            14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9,
            12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
            11, 11,
          ];
      },
      46229: (t, e, r) => {
        "use strict";
        (e.sha1 = r(43917)),
          (e.sha224 = r(47714)),
          (e.sha256 = r(2287)),
          (e.sha384 = r(21911)),
          (e.sha512 = r(57766));
      },
      43917: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(66166),
          o = r(66225),
          s = n.rotl32,
          a = n.sum32,
          u = n.sum32_5,
          c = o.ft_1,
          f = i.BlockHash,
          h = [1518500249, 1859775393, 2400959708, 3395469782];
        function l() {
          if (!(this instanceof l)) return new l();
          f.call(this),
            (this.h = [
              1732584193, 4023233417, 2562383102, 271733878, 3285377520,
            ]),
            (this.W = new Array(80));
        }
        n.inherits(l, f),
          (t.exports = l),
          (l.blockSize = 512),
          (l.outSize = 160),
          (l.hmacStrength = 80),
          (l.padLength = 64),
          (l.prototype._update = function (t, e) {
            for (var r = this.W, n = 0; n < 16; n++) r[n] = t[e + n];
            for (; n < r.length; n++)
              r[n] = s(r[n - 3] ^ r[n - 8] ^ r[n - 14] ^ r[n - 16], 1);
            var i = this.h[0],
              o = this.h[1],
              f = this.h[2],
              l = this.h[3],
              d = this.h[4];
            for (n = 0; n < r.length; n++) {
              var p = ~~(n / 20),
                y = u(s(i, 5), c(p, o, f, l), d, r[n], h[p]);
              (d = l), (l = f), (f = s(o, 30)), (o = i), (i = y);
            }
            (this.h[0] = a(this.h[0], i)),
              (this.h[1] = a(this.h[1], o)),
              (this.h[2] = a(this.h[2], f)),
              (this.h[3] = a(this.h[3], l)),
              (this.h[4] = a(this.h[4], d));
          }),
          (l.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h, "big")
              : n.split32(this.h, "big");
          });
      },
      47714: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(2287);
        function o() {
          if (!(this instanceof o)) return new o();
          i.call(this),
            (this.h = [
              3238371032, 914150663, 812702999, 4144912697, 4290775857,
              1750603025, 1694076839, 3204075428,
            ]);
        }
        n.inherits(o, i),
          (t.exports = o),
          (o.blockSize = 512),
          (o.outSize = 224),
          (o.hmacStrength = 192),
          (o.padLength = 64),
          (o.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h.slice(0, 7), "big")
              : n.split32(this.h.slice(0, 7), "big");
          });
      },
      2287: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(66166),
          o = r(66225),
          s = r(43349),
          a = n.sum32,
          u = n.sum32_4,
          c = n.sum32_5,
          f = o.ch32,
          h = o.maj32,
          l = o.s0_256,
          d = o.s1_256,
          p = o.g0_256,
          y = o.g1_256,
          g = i.BlockHash,
          m = [
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ];
        function b() {
          if (!(this instanceof b)) return new b();
          g.call(this),
            (this.h = [
              1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
              2600822924, 528734635, 1541459225,
            ]),
            (this.k = m),
            (this.W = new Array(64));
        }
        n.inherits(b, g),
          (t.exports = b),
          (b.blockSize = 512),
          (b.outSize = 256),
          (b.hmacStrength = 192),
          (b.padLength = 64),
          (b.prototype._update = function (t, e) {
            for (var r = this.W, n = 0; n < 16; n++) r[n] = t[e + n];
            for (; n < r.length; n++)
              r[n] = u(y(r[n - 2]), r[n - 7], p(r[n - 15]), r[n - 16]);
            var i = this.h[0],
              o = this.h[1],
              g = this.h[2],
              m = this.h[3],
              b = this.h[4],
              w = this.h[5],
              v = this.h[6],
              _ = this.h[7];
            for (s(this.k.length === r.length), n = 0; n < r.length; n++) {
              var E = c(_, d(b), f(b, w, v), this.k[n], r[n]),
                S = a(l(i), h(i, o, g));
              (_ = v),
                (v = w),
                (w = b),
                (b = a(m, E)),
                (m = g),
                (g = o),
                (o = i),
                (i = a(E, S));
            }
            (this.h[0] = a(this.h[0], i)),
              (this.h[1] = a(this.h[1], o)),
              (this.h[2] = a(this.h[2], g)),
              (this.h[3] = a(this.h[3], m)),
              (this.h[4] = a(this.h[4], b)),
              (this.h[5] = a(this.h[5], w)),
              (this.h[6] = a(this.h[6], v)),
              (this.h[7] = a(this.h[7], _));
          }),
          (b.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h, "big")
              : n.split32(this.h, "big");
          });
      },
      21911: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(57766);
        function o() {
          if (!(this instanceof o)) return new o();
          i.call(this),
            (this.h = [
              3418070365, 3238371032, 1654270250, 914150663, 2438529370,
              812702999, 355462360, 4144912697, 1731405415, 4290775857,
              2394180231, 1750603025, 3675008525, 1694076839, 1203062813,
              3204075428,
            ]);
        }
        n.inherits(o, i),
          (t.exports = o),
          (o.blockSize = 1024),
          (o.outSize = 384),
          (o.hmacStrength = 192),
          (o.padLength = 128),
          (o.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h.slice(0, 12), "big")
              : n.split32(this.h.slice(0, 12), "big");
          });
      },
      57766: (t, e, r) => {
        "use strict";
        var n = r(67426),
          i = r(66166),
          o = r(43349),
          s = n.rotr64_hi,
          a = n.rotr64_lo,
          u = n.shr64_hi,
          c = n.shr64_lo,
          f = n.sum64,
          h = n.sum64_hi,
          l = n.sum64_lo,
          d = n.sum64_4_hi,
          p = n.sum64_4_lo,
          y = n.sum64_5_hi,
          g = n.sum64_5_lo,
          m = i.BlockHash,
          b = [
            1116352408, 3609767458, 1899447441, 602891725, 3049323471,
            3964484399, 3921009573, 2173295548, 961987163, 4081628472,
            1508970993, 3053834265, 2453635748, 2937671579, 2870763221,
            3664609560, 3624381080, 2734883394, 310598401, 1164996542,
            607225278, 1323610764, 1426881987, 3590304994, 1925078388,
            4068182383, 2162078206, 991336113, 2614888103, 633803317,
            3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
            944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983,
            1495990901, 1249150122, 1856431235, 1555081692, 3175218132,
            1996064986, 2198950837, 2554220882, 3999719339, 2821834349,
            766784016, 2952996808, 2566594879, 3210313671, 3203337956,
            3336571891, 1034457026, 3584528711, 2466948901, 113926993,
            3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912,
            1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
            1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
            1206759142, 2456956037, 344077627, 2730485921, 1290863460,
            2820302411, 3158454273, 3259730800, 3505952657, 3345764771,
            106217008, 3516065817, 3606008344, 3600352804, 1432725776,
            4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752,
            506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
            958139571, 3318307427, 1322822218, 3812723403, 1537002063,
            2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
            2024104815, 1125592928, 2227730452, 2716904306, 2361852424,
            442776044, 2428436474, 593698344, 2756734187, 3733110249,
            3204031479, 2999351573, 3329325298, 3815920427, 3391569614,
            3928383900, 3515267271, 566280711, 3940187606, 3454069534,
            4118630271, 4000239992, 116418474, 1914138554, 174292421,
            2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733,
            587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580,
            2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
            1607167915, 987167468, 1816402316, 1246189591,
          ];
        function w() {
          if (!(this instanceof w)) return new w();
          m.call(this),
            (this.h = [
              1779033703, 4089235720, 3144134277, 2227873595, 1013904242,
              4271175723, 2773480762, 1595750129, 1359893119, 2917565137,
              2600822924, 725511199, 528734635, 4215389547, 1541459225,
              327033209,
            ]),
            (this.k = b),
            (this.W = new Array(160));
        }
        function v(t, e, r, n, i) {
          var o = (t & r) ^ (~t & i);
          return o < 0 && (o += 4294967296), o;
        }
        function _(t, e, r, n, i, o) {
          var s = (e & n) ^ (~e & o);
          return s < 0 && (s += 4294967296), s;
        }
        function E(t, e, r, n, i) {
          var o = (t & r) ^ (t & i) ^ (r & i);
          return o < 0 && (o += 4294967296), o;
        }
        function S(t, e, r, n, i, o) {
          var s = (e & n) ^ (e & o) ^ (n & o);
          return s < 0 && (s += 4294967296), s;
        }
        function I(t, e) {
          var r = s(t, e, 28) ^ s(e, t, 2) ^ s(e, t, 7);
          return r < 0 && (r += 4294967296), r;
        }
        function M(t, e) {
          var r = a(t, e, 28) ^ a(e, t, 2) ^ a(e, t, 7);
          return r < 0 && (r += 4294967296), r;
        }
        function A(t, e) {
          var r = s(t, e, 14) ^ s(t, e, 18) ^ s(e, t, 9);
          return r < 0 && (r += 4294967296), r;
        }
        function T(t, e) {
          var r = a(t, e, 14) ^ a(t, e, 18) ^ a(e, t, 9);
          return r < 0 && (r += 4294967296), r;
        }
        function k(t, e) {
          var r = s(t, e, 1) ^ s(t, e, 8) ^ u(t, e, 7);
          return r < 0 && (r += 4294967296), r;
        }
        function O(t, e) {
          var r = a(t, e, 1) ^ a(t, e, 8) ^ c(t, e, 7);
          return r < 0 && (r += 4294967296), r;
        }
        function x(t, e) {
          var r = s(t, e, 19) ^ s(e, t, 29) ^ u(t, e, 6);
          return r < 0 && (r += 4294967296), r;
        }
        function P(t, e) {
          var r = a(t, e, 19) ^ a(e, t, 29) ^ c(t, e, 6);
          return r < 0 && (r += 4294967296), r;
        }
        n.inherits(w, m),
          (t.exports = w),
          (w.blockSize = 1024),
          (w.outSize = 512),
          (w.hmacStrength = 192),
          (w.padLength = 128),
          (w.prototype._prepareBlock = function (t, e) {
            for (var r = this.W, n = 0; n < 32; n++) r[n] = t[e + n];
            for (; n < r.length; n += 2) {
              var i = x(r[n - 4], r[n - 3]),
                o = P(r[n - 4], r[n - 3]),
                s = r[n - 14],
                a = r[n - 13],
                u = k(r[n - 30], r[n - 29]),
                c = O(r[n - 30], r[n - 29]),
                f = r[n - 32],
                h = r[n - 31];
              (r[n] = d(i, o, s, a, u, c, f, h)),
                (r[n + 1] = p(i, o, s, a, u, c, f, h));
            }
          }),
          (w.prototype._update = function (t, e) {
            this._prepareBlock(t, e);
            var r = this.W,
              n = this.h[0],
              i = this.h[1],
              s = this.h[2],
              a = this.h[3],
              u = this.h[4],
              c = this.h[5],
              d = this.h[6],
              p = this.h[7],
              m = this.h[8],
              b = this.h[9],
              w = this.h[10],
              k = this.h[11],
              O = this.h[12],
              x = this.h[13],
              P = this.h[14],
              B = this.h[15];
            o(this.k.length === r.length);
            for (var C = 0; C < r.length; C += 2) {
              var R = P,
                N = B,
                U = A(m, b),
                D = T(m, b),
                L = v(m, b, w, k, O),
                j = _(m, b, w, k, O, x),
                F = this.k[C],
                H = this.k[C + 1],
                K = r[C],
                V = r[C + 1],
                q = y(R, N, U, D, L, j, F, H, K, V),
                z = g(R, N, U, D, L, j, F, H, K, V);
              (R = I(n, i)),
                (N = M(n, i)),
                (U = E(n, i, s, a, u)),
                (D = S(n, i, s, a, u, c));
              var $ = h(R, N, U, D),
                G = l(R, N, U, D);
              (P = O),
                (B = x),
                (O = w),
                (x = k),
                (w = m),
                (k = b),
                (m = h(d, p, q, z)),
                (b = l(p, p, q, z)),
                (d = u),
                (p = c),
                (u = s),
                (c = a),
                (s = n),
                (a = i),
                (n = h(q, z, $, G)),
                (i = l(q, z, $, G));
            }
            f(this.h, 0, n, i),
              f(this.h, 2, s, a),
              f(this.h, 4, u, c),
              f(this.h, 6, d, p),
              f(this.h, 8, m, b),
              f(this.h, 10, w, k),
              f(this.h, 12, O, x),
              f(this.h, 14, P, B);
          }),
          (w.prototype._digest = function (t) {
            return "hex" === t
              ? n.toHex32(this.h, "big")
              : n.split32(this.h, "big");
          });
      },
      66225: (t, e, r) => {
        "use strict";
        var n = r(67426).rotr32;
        function i(t, e, r) {
          return (t & e) ^ (~t & r);
        }
        function o(t, e, r) {
          return (t & e) ^ (t & r) ^ (e & r);
        }
        function s(t, e, r) {
          return t ^ e ^ r;
        }
        (e.ft_1 = function (t, e, r, n) {
          return 0 === t
            ? i(e, r, n)
            : 1 === t || 3 === t
              ? s(e, r, n)
              : 2 === t
                ? o(e, r, n)
                : void 0;
        }),
          (e.ch32 = i),
          (e.maj32 = o),
          (e.p32 = s),
          (e.s0_256 = function (t) {
            return n(t, 2) ^ n(t, 13) ^ n(t, 22);
          }),
          (e.s1_256 = function (t) {
            return n(t, 6) ^ n(t, 11) ^ n(t, 25);
          }),
          (e.g0_256 = function (t) {
            return n(t, 7) ^ n(t, 18) ^ (t >>> 3);
          }),
          (e.g1_256 = function (t) {
            return n(t, 17) ^ n(t, 19) ^ (t >>> 10);
          });
      },
      67426: (t, e, r) => {
        "use strict";
        var n = r(43349),
          i = r(56698);
        function o(t, e) {
          return (
            55296 == (64512 & t.charCodeAt(e)) &&
            !(e < 0 || e + 1 >= t.length) &&
            56320 == (64512 & t.charCodeAt(e + 1))
          );
        }
        function s(t) {
          return (
            ((t >>> 24) |
              ((t >>> 8) & 65280) |
              ((t << 8) & 16711680) |
              ((255 & t) << 24)) >>>
            0
          );
        }
        function a(t) {
          return 1 === t.length ? "0" + t : t;
        }
        function u(t) {
          return 7 === t.length
            ? "0" + t
            : 6 === t.length
              ? "00" + t
              : 5 === t.length
                ? "000" + t
                : 4 === t.length
                  ? "0000" + t
                  : 3 === t.length
                    ? "00000" + t
                    : 2 === t.length
                      ? "000000" + t
                      : 1 === t.length
                        ? "0000000" + t
                        : t;
        }
        (e.inherits = i),
          (e.toArray = function (t, e) {
            if (Array.isArray(t)) return t.slice();
            if (!t) return [];
            var r = [];
            if ("string" == typeof t)
              if (e) {
                if ("hex" === e)
                  for (
                    (t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 &&
                      (t = "0" + t),
                      i = 0;
                    i < t.length;
                    i += 2
                  )
                    r.push(parseInt(t[i] + t[i + 1], 16));
              } else
                for (var n = 0, i = 0; i < t.length; i++) {
                  var s = t.charCodeAt(i);
                  s < 128
                    ? (r[n++] = s)
                    : s < 2048
                      ? ((r[n++] = (s >> 6) | 192), (r[n++] = (63 & s) | 128))
                      : o(t, i)
                        ? ((s =
                            65536 +
                            ((1023 & s) << 10) +
                            (1023 & t.charCodeAt(++i))),
                          (r[n++] = (s >> 18) | 240),
                          (r[n++] = ((s >> 12) & 63) | 128),
                          (r[n++] = ((s >> 6) & 63) | 128),
                          (r[n++] = (63 & s) | 128))
                        : ((r[n++] = (s >> 12) | 224),
                          (r[n++] = ((s >> 6) & 63) | 128),
                          (r[n++] = (63 & s) | 128));
                }
            else for (i = 0; i < t.length; i++) r[i] = 0 | t[i];
            return r;
          }),
          (e.toHex = function (t) {
            for (var e = "", r = 0; r < t.length; r++)
              e += a(t[r].toString(16));
            return e;
          }),
          (e.htonl = s),
          (e.toHex32 = function (t, e) {
            for (var r = "", n = 0; n < t.length; n++) {
              var i = t[n];
              "little" === e && (i = s(i)), (r += u(i.toString(16)));
            }
            return r;
          }),
          (e.zero2 = a),
          (e.zero8 = u),
          (e.join32 = function (t, e, r, i) {
            var o = r - e;
            n(o % 4 == 0);
            for (
              var s = new Array(o / 4), a = 0, u = e;
              a < s.length;
              a++, u += 4
            ) {
              var c;
              (c =
                "big" === i
                  ? (t[u] << 24) | (t[u + 1] << 16) | (t[u + 2] << 8) | t[u + 3]
                  : (t[u + 3] << 24) |
                    (t[u + 2] << 16) |
                    (t[u + 1] << 8) |
                    t[u]),
                (s[a] = c >>> 0);
            }
            return s;
          }),
          (e.split32 = function (t, e) {
            for (
              var r = new Array(4 * t.length), n = 0, i = 0;
              n < t.length;
              n++, i += 4
            ) {
              var o = t[n];
              "big" === e
                ? ((r[i] = o >>> 24),
                  (r[i + 1] = (o >>> 16) & 255),
                  (r[i + 2] = (o >>> 8) & 255),
                  (r[i + 3] = 255 & o))
                : ((r[i + 3] = o >>> 24),
                  (r[i + 2] = (o >>> 16) & 255),
                  (r[i + 1] = (o >>> 8) & 255),
                  (r[i] = 255 & o));
            }
            return r;
          }),
          (e.rotr32 = function (t, e) {
            return (t >>> e) | (t << (32 - e));
          }),
          (e.rotl32 = function (t, e) {
            return (t << e) | (t >>> (32 - e));
          }),
          (e.sum32 = function (t, e) {
            return (t + e) >>> 0;
          }),
          (e.sum32_3 = function (t, e, r) {
            return (t + e + r) >>> 0;
          }),
          (e.sum32_4 = function (t, e, r, n) {
            return (t + e + r + n) >>> 0;
          }),
          (e.sum32_5 = function (t, e, r, n, i) {
            return (t + e + r + n + i) >>> 0;
          }),
          (e.sum64 = function (t, e, r, n) {
            var i = t[e],
              o = (n + t[e + 1]) >>> 0,
              s = (o < n ? 1 : 0) + r + i;
            (t[e] = s >>> 0), (t[e + 1] = o);
          }),
          (e.sum64_hi = function (t, e, r, n) {
            return (((e + n) >>> 0 < e ? 1 : 0) + t + r) >>> 0;
          }),
          (e.sum64_lo = function (t, e, r, n) {
            return (e + n) >>> 0;
          }),
          (e.sum64_4_hi = function (t, e, r, n, i, o, s, a) {
            var u = 0,
              c = e;
            return (
              (u += (c = (c + n) >>> 0) < e ? 1 : 0),
              (u += (c = (c + o) >>> 0) < o ? 1 : 0),
              (t + r + i + s + (u += (c = (c + a) >>> 0) < a ? 1 : 0)) >>> 0
            );
          }),
          (e.sum64_4_lo = function (t, e, r, n, i, o, s, a) {
            return (e + n + o + a) >>> 0;
          }),
          (e.sum64_5_hi = function (t, e, r, n, i, o, s, a, u, c) {
            var f = 0,
              h = e;
            return (
              (f += (h = (h + n) >>> 0) < e ? 1 : 0),
              (f += (h = (h + o) >>> 0) < o ? 1 : 0),
              (f += (h = (h + a) >>> 0) < a ? 1 : 0),
              (t + r + i + s + u + (f += (h = (h + c) >>> 0) < c ? 1 : 0)) >>> 0
            );
          }),
          (e.sum64_5_lo = function (t, e, r, n, i, o, s, a, u, c) {
            return (e + n + o + a + c) >>> 0;
          }),
          (e.rotr64_hi = function (t, e, r) {
            return ((e << (32 - r)) | (t >>> r)) >>> 0;
          }),
          (e.rotr64_lo = function (t, e, r) {
            return ((t << (32 - r)) | (e >>> r)) >>> 0;
          }),
          (e.shr64_hi = function (t, e, r) {
            return t >>> r;
          }),
          (e.shr64_lo = function (t, e, r) {
            return ((t << (32 - r)) | (e >>> r)) >>> 0;
          });
      },
      9957: (t, e, r) => {
        "use strict";
        var n = Function.prototype.call,
          i = Object.prototype.hasOwnProperty,
          o = r(66743);
        t.exports = o.call(n, i);
      },
      32723: (t, e, r) => {
        "use strict";
        var n = r(77952),
          i = r(64367),
          o = r(43349);
        function s(t) {
          if (!(this instanceof s)) return new s(t);
          (this.hash = t.hash),
            (this.predResist = !!t.predResist),
            (this.outLen = this.hash.outSize),
            (this.minEntropy = t.minEntropy || this.hash.hmacStrength),
            (this._reseed = null),
            (this.reseedInterval = null),
            (this.K = null),
            (this.V = null);
          var e = i.toArray(t.entropy, t.entropyEnc || "hex"),
            r = i.toArray(t.nonce, t.nonceEnc || "hex"),
            n = i.toArray(t.pers, t.persEnc || "hex");
          o(
            e.length >= this.minEntropy / 8,
            "Not enough entropy. Minimum is: " + this.minEntropy + " bits",
          ),
            this._init(e, r, n);
        }
        (t.exports = s),
          (s.prototype._init = function (t, e, r) {
            var n = t.concat(e).concat(r);
            (this.K = new Array(this.outLen / 8)),
              (this.V = new Array(this.outLen / 8));
            for (var i = 0; i < this.V.length; i++)
              (this.K[i] = 0), (this.V[i] = 1);
            this._update(n),
              (this._reseed = 1),
              (this.reseedInterval = 281474976710656);
          }),
          (s.prototype._hmac = function () {
            return new n.hmac(this.hash, this.K);
          }),
          (s.prototype._update = function (t) {
            var e = this._hmac().update(this.V).update([0]);
            t && (e = e.update(t)),
              (this.K = e.digest()),
              (this.V = this._hmac().update(this.V).digest()),
              t &&
                ((this.K = this._hmac()
                  .update(this.V)
                  .update([1])
                  .update(t)
                  .digest()),
                (this.V = this._hmac().update(this.V).digest()));
          }),
          (s.prototype.reseed = function (t, e, r, n) {
            "string" != typeof e && ((n = r), (r = e), (e = null)),
              (t = i.toArray(t, e)),
              (r = i.toArray(r, n)),
              o(
                t.length >= this.minEntropy / 8,
                "Not enough entropy. Minimum is: " + this.minEntropy + " bits",
              ),
              this._update(t.concat(r || [])),
              (this._reseed = 1);
          }),
          (s.prototype.generate = function (t, e, r, n) {
            if (this._reseed > this.reseedInterval)
              throw new Error("Reseed is required");
            "string" != typeof e && ((n = r), (r = e), (e = null)),
              r && ((r = i.toArray(r, n || "hex")), this._update(r));
            for (var o = []; o.length < t; )
              (this.V = this._hmac().update(this.V).digest()),
                (o = o.concat(this.V));
            var s = o.slice(0, t);
            return this._update(r), this._reseed++, i.encode(s, e);
          });
      },
      251: (t, e) => {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        (e.read = function (t, e, r, n, i) {
          var o,
            s,
            a = 8 * i - n - 1,
            u = (1 << a) - 1,
            c = u >> 1,
            f = -7,
            h = r ? i - 1 : 0,
            l = r ? -1 : 1,
            d = t[e + h];
          for (
            h += l, o = d & ((1 << -f) - 1), d >>= -f, f += a;
            f > 0;
            o = 256 * o + t[e + h], h += l, f -= 8
          );
          for (
            s = o & ((1 << -f) - 1), o >>= -f, f += n;
            f > 0;
            s = 256 * s + t[e + h], h += l, f -= 8
          );
          if (0 === o) o = 1 - c;
          else {
            if (o === u) return s ? NaN : (1 / 0) * (d ? -1 : 1);
            (s += Math.pow(2, n)), (o -= c);
          }
          return (d ? -1 : 1) * s * Math.pow(2, o - n);
        }),
          (e.write = function (t, e, r, n, i, o) {
            var s,
              a,
              u,
              c = 8 * o - i - 1,
              f = (1 << c) - 1,
              h = f >> 1,
              l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              d = n ? 0 : o - 1,
              p = n ? 1 : -1,
              y = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
            for (
              e = Math.abs(e),
                isNaN(e) || e === 1 / 0
                  ? ((a = isNaN(e) ? 1 : 0), (s = f))
                  : ((s = Math.floor(Math.log(e) / Math.LN2)),
                    e * (u = Math.pow(2, -s)) < 1 && (s--, (u *= 2)),
                    (e += s + h >= 1 ? l / u : l * Math.pow(2, 1 - h)) * u >=
                      2 && (s++, (u /= 2)),
                    s + h >= f
                      ? ((a = 0), (s = f))
                      : s + h >= 1
                        ? ((a = (e * u - 1) * Math.pow(2, i)), (s += h))
                        : ((a = e * Math.pow(2, h - 1) * Math.pow(2, i)),
                          (s = 0)));
              i >= 8;
              t[r + d] = 255 & a, d += p, a /= 256, i -= 8
            );
            for (
              s = (s << i) | a, c += i;
              c > 0;
              t[r + d] = 255 & s, d += p, s /= 256, c -= 8
            );
            t[r + d - p] |= 128 * y;
          });
      },
      56698: (t) => {
        "function" == typeof Object.create
          ? (t.exports = function (t, e) {
              e &&
                ((t.super_ = e),
                (t.prototype = Object.create(e.prototype, {
                  constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })));
            })
          : (t.exports = function (t, e) {
              if (e) {
                t.super_ = e;
                var r = function () {};
                (r.prototype = e.prototype),
                  (t.prototype = new r()),
                  (t.prototype.constructor = t);
              }
            });
      },
      47244: (t, e, r) => {
        "use strict";
        var n = r(49092)(),
          i = r(38075)("Object.prototype.toString"),
          o = function (t) {
            return (
              !(n && t && "object" == typeof t && Symbol.toStringTag in t) &&
              "[object Arguments]" === i(t)
            );
          },
          s = function (t) {
            return (
              !!o(t) ||
              (null !== t &&
                "object" == typeof t &&
                "number" == typeof t.length &&
                t.length >= 0 &&
                "[object Array]" !== i(t) &&
                "[object Function]" === i(t.callee))
            );
          },
          a = (function () {
            return o(arguments);
          })();
        (o.isLegacyArguments = s), (t.exports = a ? o : s);
      },
      69600: (t) => {
        "use strict";
        var e,
          r,
          n = Function.prototype.toString,
          i = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
        if (
          "function" == typeof i &&
          "function" == typeof Object.defineProperty
        )
          try {
            (e = Object.defineProperty({}, "length", {
              get: function () {
                throw r;
              },
            })),
              (r = {}),
              i(
                function () {
                  throw 42;
                },
                null,
                e,
              );
          } catch (t) {
            t !== r && (i = null);
          }
        else i = null;
        var o = /^\s*class\b/,
          s = function (t) {
            try {
              var e = n.call(t);
              return o.test(e);
            } catch (t) {
              return !1;
            }
          },
          a = function (t) {
            try {
              return !s(t) && (n.call(t), !0);
            } catch (t) {
              return !1;
            }
          },
          u = Object.prototype.toString,
          c = "function" == typeof Symbol && !!Symbol.toStringTag,
          f = !(0 in [,]),
          h = function () {
            return !1;
          };
        if ("object" == typeof document) {
          var l = document.all;
          u.call(l) === u.call(document.all) &&
            (h = function (t) {
              if ((f || !t) && (void 0 === t || "object" == typeof t))
                try {
                  var e = u.call(t);
                  return (
                    ("[object HTMLAllCollection]" === e ||
                      "[object HTML document.all class]" === e ||
                      "[object HTMLCollection]" === e ||
                      "[object Object]" === e) &&
                    null == t("")
                  );
                } catch (t) {}
              return !1;
            });
        }
        t.exports = i
          ? function (t) {
              if (h(t)) return !0;
              if (!t) return !1;
              if ("function" != typeof t && "object" != typeof t) return !1;
              try {
                i(t, null, e);
              } catch (t) {
                if (t !== r) return !1;
              }
              return !s(t) && a(t);
            }
          : function (t) {
              if (h(t)) return !0;
              if (!t) return !1;
              if ("function" != typeof t && "object" != typeof t) return !1;
              if (c) return a(t);
              if (s(t)) return !1;
              var e = u.call(t);
              return (
                !(
                  "[object Function]" !== e &&
                  "[object GeneratorFunction]" !== e &&
                  !/^\[object HTML/.test(e)
                ) && a(t)
              );
            };
      },
      48184: (t, e, r) => {
        "use strict";
        var n,
          i = r(36556),
          o = r(99721)(/^\s*(?:function)?\*/),
          s = r(49092)(),
          a = r(93628),
          u = i("Object.prototype.toString"),
          c = i("Function.prototype.toString");
        t.exports = function (t) {
          if ("function" != typeof t) return !1;
          if (o(c(t))) return !0;
          if (!s) return "[object GeneratorFunction]" === u(t);
          if (!a) return !1;
          if (void 0 === n) {
            var e = (function () {
              if (!s) return !1;
              try {
                return Function("return function*() {}")();
              } catch (t) {}
            })();
            n = !!e && a(e);
          }
          return a(t) === n;
        };
      },
      13003: (t) => {
        "use strict";
        t.exports = function (t) {
          return t != t;
        };
      },
      24133: (t, e, r) => {
        "use strict";
        var n = r(10487),
          i = r(38452),
          o = r(13003),
          s = r(76642),
          a = r(92464),
          u = n(s(), Number);
        i(u, { getPolyfill: s, implementation: o, shim: a }), (t.exports = u);
      },
      76642: (t, e, r) => {
        "use strict";
        var n = r(13003);
        t.exports = function () {
          return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")
            ? Number.isNaN
            : n;
        };
      },
      92464: (t, e, r) => {
        "use strict";
        var n = r(38452),
          i = r(76642);
        t.exports = function () {
          var t = i();
          return (
            n(
              Number,
              { isNaN: t },
              {
                isNaN: function () {
                  return Number.isNaN !== t;
                },
              },
            ),
            t
          );
        };
      },
      14035: (t, e, r) => {
        "use strict";
        var n,
          i = r(36556),
          o = r(49092)(),
          s = r(9957),
          a = r(75795);
        if (o) {
          var u = i("RegExp.prototype.exec"),
            c = {},
            f = function () {
              throw c;
            },
            h = { toString: f, valueOf: f };
          "symbol" == typeof Symbol.toPrimitive && (h[Symbol.toPrimitive] = f),
            (n = function (t) {
              if (!t || "object" != typeof t) return !1;
              var e = a(t, "lastIndex");
              if (!(e && s(e, "value"))) return !1;
              try {
                u(t, h);
              } catch (t) {
                return t === c;
              }
            });
        } else {
          var l = i("Object.prototype.toString");
          n = function (t) {
            return (
              !(!t || ("object" != typeof t && "function" != typeof t)) &&
              "[object RegExp]" === l(t)
            );
          };
        }
        t.exports = n;
      },
      51111: (t) => {
        "use strict";
        const e = new Set([
          "ENOTFOUND",
          "ENETUNREACH",
          "UNABLE_TO_GET_ISSUER_CERT",
          "UNABLE_TO_GET_CRL",
          "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
          "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
          "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
          "CERT_SIGNATURE_FAILURE",
          "CRL_SIGNATURE_FAILURE",
          "CERT_NOT_YET_VALID",
          "CERT_HAS_EXPIRED",
          "CRL_NOT_YET_VALID",
          "CRL_HAS_EXPIRED",
          "ERROR_IN_CERT_NOT_BEFORE_FIELD",
          "ERROR_IN_CERT_NOT_AFTER_FIELD",
          "ERROR_IN_CRL_LAST_UPDATE_FIELD",
          "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
          "OUT_OF_MEM",
          "DEPTH_ZERO_SELF_SIGNED_CERT",
          "SELF_SIGNED_CERT_IN_CHAIN",
          "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
          "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
          "CERT_CHAIN_TOO_LONG",
          "CERT_REVOKED",
          "INVALID_CA",
          "PATH_LENGTH_EXCEEDED",
          "INVALID_PURPOSE",
          "CERT_UNTRUSTED",
          "CERT_REJECTED",
          "HOSTNAME_MISMATCH",
        ]);
        t.exports = (t) => !e.has(t && t.code);
      },
      35680: (t, e, r) => {
        "use strict";
        var n = r(25767);
        t.exports = function (t) {
          return !!n(t);
        };
      },
      75951: function (t) {
        t.exports = (function () {
          "use strict";
          var t = Math.imul,
            e = Math.clz32,
            r = Math.abs,
            n = Math.max,
            i = Math.floor;
          class o extends Array {
            constructor(t, e) {
              if ((super(t), (this.sign = e), t > o.__kMaxLength))
                throw new RangeError("Maximum BigInt size exceeded");
            }
            static BigInt(t) {
              var e = Number.isFinite;
              if ("number" == typeof t) {
                if (0 === t) return o.__zero();
                if (o.__isOneDigitInt(t))
                  return 0 > t ? o.__oneDigit(-t, !0) : o.__oneDigit(t, !1);
                if (!e(t) || i(t) !== t)
                  throw new RangeError(
                    "The number " +
                      t +
                      " cannot be converted to BigInt because it is not an integer",
                  );
                return o.__fromDouble(t);
              }
              if ("string" == typeof t) {
                const e = o.__fromString(t);
                if (null === e)
                  throw new SyntaxError("Cannot convert " + t + " to a BigInt");
                return e;
              }
              if ("boolean" == typeof t)
                return !0 === t ? o.__oneDigit(1, !1) : o.__zero();
              if ("object" == typeof t) {
                if (t.constructor === o) return t;
                const e = o.__toPrimitive(t);
                return o.BigInt(e);
              }
              throw new TypeError("Cannot convert " + t + " to a BigInt");
            }
            toDebugString() {
              const t = ["BigInt["];
              for (const e of this)
                t.push((e ? (e >>> 0).toString(16) : e) + ", ");
              return t.push("]"), t.join("");
            }
            toString(t = 10) {
              if (2 > t || 36 < t)
                throw new RangeError(
                  "toString() radix argument must be between 2 and 36",
                );
              return 0 === this.length
                ? "0"
                : t & (t - 1)
                  ? o.__toStringGeneric(this, t, !1)
                  : o.__toStringBasePowerOfTwo(this, t);
            }
            static toNumber(t) {
              const e = t.length;
              if (0 === e) return 0;
              if (1 === e) {
                const e = t.__unsignedDigit(0);
                return t.sign ? -e : e;
              }
              const r = t.__digit(e - 1),
                n = o.__clz30(r),
                i = 30 * e - n;
              if (1024 < i) return t.sign ? -1 / 0 : 1 / 0;
              let s = i - 1,
                a = r,
                u = e - 1;
              const c = n + 3;
              let f = 32 === c ? 0 : a << c;
              f >>>= 12;
              const h = c - 12;
              let l = 12 <= c ? 0 : a << (20 + c),
                d = 20 + c;
              for (
                0 < h &&
                0 < u &&
                (u--,
                (a = t.__digit(u)),
                (f |= a >>> (30 - h)),
                (l = a << (h + 2)),
                (d = h + 2));
                0 < d && 0 < u;

              )
                u--,
                  (a = t.__digit(u)),
                  (l |= 30 <= d ? a << (d - 30) : a >>> (30 - d)),
                  (d -= 30);
              const p = o.__decideRounding(t, d, u, a);
              if (
                (1 === p || (0 === p && !(1 & ~l))) &&
                ((l = (l + 1) >>> 0),
                0 === l && (f++, 0 != f >>> 20 && ((f = 0), s++, 1023 < s)))
              )
                return t.sign ? -1 / 0 : 1 / 0;
              const y = t.sign ? -2147483648 : 0;
              return (
                (s = (s + 1023) << 20),
                (o.__kBitConversionInts[1] = y | s | f),
                (o.__kBitConversionInts[0] = l),
                o.__kBitConversionDouble[0]
              );
            }
            static unaryMinus(t) {
              if (0 === t.length) return t;
              const e = t.__copy();
              return (e.sign = !t.sign), e;
            }
            static bitwiseNot(t) {
              return t.sign
                ? o.__absoluteSubOne(t).__trim()
                : o.__absoluteAddOne(t, !0);
            }
            static exponentiate(t, e) {
              if (e.sign) throw new RangeError("Exponent must be positive");
              if (0 === e.length) return o.__oneDigit(1, !1);
              if (0 === t.length) return t;
              if (1 === t.length && 1 === t.__digit(0))
                return !t.sign || 1 & e.__digit(0) ? t : o.unaryMinus(t);
              if (1 < e.length) throw new RangeError("BigInt too big");
              let r = e.__unsignedDigit(0);
              if (1 === r) return t;
              if (r >= o.__kMaxLengthBits)
                throw new RangeError("BigInt too big");
              if (1 === t.length && 2 === t.__digit(0)) {
                const e = 1 + (0 | (r / 30)),
                  n = t.sign && !!(1 & r),
                  i = new o(e, n);
                i.__initializeDigits();
                const s = 1 << r % 30;
                return i.__setDigit(e - 1, s), i;
              }
              let n = null,
                i = t;
              for (!!(1 & r) && (n = t), r >>= 1; 0 !== r; r >>= 1)
                (i = o.multiply(i, i)),
                  1 & r && (n = null === n ? i : o.multiply(n, i));
              return n;
            }
            static multiply(t, e) {
              if (0 === t.length) return t;
              if (0 === e.length) return e;
              let r = t.length + e.length;
              30 <= t.__clzmsd() + e.__clzmsd() && r--;
              const n = new o(r, t.sign !== e.sign);
              n.__initializeDigits();
              for (let r = 0; r < t.length; r++)
                o.__multiplyAccumulate(e, t.__digit(r), n, r);
              return n.__trim();
            }
            static divide(t, e) {
              if (0 === e.length) throw new RangeError("Division by zero");
              if (0 > o.__absoluteCompare(t, e)) return o.__zero();
              const r = t.sign !== e.sign,
                n = e.__unsignedDigit(0);
              let i;
              if (1 === e.length && 32767 >= n) {
                if (1 === n) return r === t.sign ? t : o.unaryMinus(t);
                i = o.__absoluteDivSmall(t, n, null);
              } else i = o.__absoluteDivLarge(t, e, !0, !1);
              return (i.sign = r), i.__trim();
            }
            static remainder(t, e) {
              if (0 === e.length) throw new RangeError("Division by zero");
              if (0 > o.__absoluteCompare(t, e)) return t;
              const r = e.__unsignedDigit(0);
              if (1 === e.length && 32767 >= r) {
                if (1 === r) return o.__zero();
                const e = o.__absoluteModSmall(t, r);
                return 0 === e ? o.__zero() : o.__oneDigit(e, t.sign);
              }
              const n = o.__absoluteDivLarge(t, e, !1, !0);
              return (n.sign = t.sign), n.__trim();
            }
            static add(t, e) {
              const r = t.sign;
              return r === e.sign
                ? o.__absoluteAdd(t, e, r)
                : 0 <= o.__absoluteCompare(t, e)
                  ? o.__absoluteSub(t, e, r)
                  : o.__absoluteSub(e, t, !r);
            }
            static subtract(t, e) {
              const r = t.sign;
              return r === e.sign
                ? 0 <= o.__absoluteCompare(t, e)
                  ? o.__absoluteSub(t, e, r)
                  : o.__absoluteSub(e, t, !r)
                : o.__absoluteAdd(t, e, r);
            }
            static leftShift(t, e) {
              return 0 === e.length || 0 === t.length
                ? t
                : e.sign
                  ? o.__rightShiftByAbsolute(t, e)
                  : o.__leftShiftByAbsolute(t, e);
            }
            static signedRightShift(t, e) {
              return 0 === e.length || 0 === t.length
                ? t
                : e.sign
                  ? o.__leftShiftByAbsolute(t, e)
                  : o.__rightShiftByAbsolute(t, e);
            }
            static unsignedRightShift() {
              throw new TypeError(
                "BigInts have no unsigned right shift; use >> instead",
              );
            }
            static lessThan(t, e) {
              return 0 > o.__compareToBigInt(t, e);
            }
            static lessThanOrEqual(t, e) {
              return 0 >= o.__compareToBigInt(t, e);
            }
            static greaterThan(t, e) {
              return 0 < o.__compareToBigInt(t, e);
            }
            static greaterThanOrEqual(t, e) {
              return 0 <= o.__compareToBigInt(t, e);
            }
            static equal(t, e) {
              if (t.sign !== e.sign) return !1;
              if (t.length !== e.length) return !1;
              for (let r = 0; r < t.length; r++)
                if (t.__digit(r) !== e.__digit(r)) return !1;
              return !0;
            }
            static notEqual(t, e) {
              return !o.equal(t, e);
            }
            static bitwiseAnd(t, e) {
              if (!t.sign && !e.sign) return o.__absoluteAnd(t, e).__trim();
              if (t.sign && e.sign) {
                const r = n(t.length, e.length) + 1;
                let i = o.__absoluteSubOne(t, r);
                const s = o.__absoluteSubOne(e);
                return (
                  (i = o.__absoluteOr(i, s, i)),
                  o.__absoluteAddOne(i, !0, i).__trim()
                );
              }
              return (
                t.sign && ([t, e] = [e, t]),
                o.__absoluteAndNot(t, o.__absoluteSubOne(e)).__trim()
              );
            }
            static bitwiseXor(t, e) {
              if (!t.sign && !e.sign) return o.__absoluteXor(t, e).__trim();
              if (t.sign && e.sign) {
                const r = n(t.length, e.length),
                  i = o.__absoluteSubOne(t, r),
                  s = o.__absoluteSubOne(e);
                return o.__absoluteXor(i, s, i).__trim();
              }
              const r = n(t.length, e.length) + 1;
              t.sign && ([t, e] = [e, t]);
              let i = o.__absoluteSubOne(e, r);
              return (
                (i = o.__absoluteXor(i, t, i)),
                o.__absoluteAddOne(i, !0, i).__trim()
              );
            }
            static bitwiseOr(t, e) {
              const r = n(t.length, e.length);
              if (!t.sign && !e.sign) return o.__absoluteOr(t, e).__trim();
              if (t.sign && e.sign) {
                let n = o.__absoluteSubOne(t, r);
                const i = o.__absoluteSubOne(e);
                return (
                  (n = o.__absoluteAnd(n, i, n)),
                  o.__absoluteAddOne(n, !0, n).__trim()
                );
              }
              t.sign && ([t, e] = [e, t]);
              let i = o.__absoluteSubOne(e, r);
              return (
                (i = o.__absoluteAndNot(i, t, i)),
                o.__absoluteAddOne(i, !0, i).__trim()
              );
            }
            static asIntN(t, e) {
              if (0 === e.length) return e;
              if (0 > (t = i(t)))
                throw new RangeError(
                  "Invalid value: not (convertible to) a safe integer",
                );
              if (0 === t) return o.__zero();
              if (t >= o.__kMaxLengthBits) return e;
              const r = 0 | ((t + 29) / 30);
              if (e.length < r) return e;
              const n = e.__unsignedDigit(r - 1),
                s = 1 << (t - 1) % 30;
              if (e.length === r && n < s) return e;
              if ((n & s) !== s) return o.__truncateToNBits(t, e);
              if (!e.sign) return o.__truncateAndSubFromPowerOfTwo(t, e, !0);
              if (!(n & (s - 1))) {
                for (let n = r - 2; 0 <= n; n--)
                  if (0 !== e.__digit(n))
                    return o.__truncateAndSubFromPowerOfTwo(t, e, !1);
                return e.length === r && n === s
                  ? e
                  : o.__truncateToNBits(t, e);
              }
              return o.__truncateAndSubFromPowerOfTwo(t, e, !1);
            }
            static asUintN(t, e) {
              if (0 === e.length) return e;
              if (0 > (t = i(t)))
                throw new RangeError(
                  "Invalid value: not (convertible to) a safe integer",
                );
              if (0 === t) return o.__zero();
              if (e.sign) {
                if (t > o.__kMaxLengthBits)
                  throw new RangeError("BigInt too big");
                return o.__truncateAndSubFromPowerOfTwo(t, e, !1);
              }
              if (t >= o.__kMaxLengthBits) return e;
              const r = 0 | ((t + 29) / 30);
              if (e.length < r) return e;
              const n = t % 30;
              if (e.length == r) {
                if (0 === n) return e;
                if (0 == e.__digit(r - 1) >>> n) return e;
              }
              return o.__truncateToNBits(t, e);
            }
            static ADD(t, e) {
              if (
                ((t = o.__toPrimitive(t)),
                (e = o.__toPrimitive(e)),
                "string" == typeof t)
              )
                return "string" != typeof e && (e = e.toString()), t + e;
              if ("string" == typeof e) return t.toString() + e;
              if (
                ((t = o.__toNumeric(t)),
                (e = o.__toNumeric(e)),
                o.__isBigInt(t) && o.__isBigInt(e))
              )
                return o.add(t, e);
              if ("number" == typeof t && "number" == typeof e) return t + e;
              throw new TypeError(
                "Cannot mix BigInt and other types, use explicit conversions",
              );
            }
            static LT(t, e) {
              return o.__compare(t, e, 0);
            }
            static LE(t, e) {
              return o.__compare(t, e, 1);
            }
            static GT(t, e) {
              return o.__compare(t, e, 2);
            }
            static GE(t, e) {
              return o.__compare(t, e, 3);
            }
            static EQ(t, e) {
              for (;;) {
                if (o.__isBigInt(t))
                  return o.__isBigInt(e) ? o.equal(t, e) : o.EQ(e, t);
                if ("number" == typeof t) {
                  if (o.__isBigInt(e)) return o.__equalToNumber(e, t);
                  if ("object" != typeof e) return t == e;
                  e = o.__toPrimitive(e);
                } else if ("string" == typeof t) {
                  if (o.__isBigInt(e))
                    return null !== (t = o.__fromString(t)) && o.equal(t, e);
                  if ("object" != typeof e) return t == e;
                  e = o.__toPrimitive(e);
                } else if ("boolean" == typeof t) {
                  if (o.__isBigInt(e)) return o.__equalToNumber(e, +t);
                  if ("object" != typeof e) return t == e;
                  e = o.__toPrimitive(e);
                } else if ("symbol" == typeof t) {
                  if (o.__isBigInt(e)) return !1;
                  if ("object" != typeof e) return t == e;
                  e = o.__toPrimitive(e);
                } else {
                  if ("object" != typeof t) return t == e;
                  if ("object" == typeof e && e.constructor !== o)
                    return t == e;
                  t = o.__toPrimitive(t);
                }
              }
            }
            static NE(t, e) {
              return !o.EQ(t, e);
            }
            static __zero() {
              return new o(0, !1);
            }
            static __oneDigit(t, e) {
              const r = new o(1, e);
              return r.__setDigit(0, t), r;
            }
            __copy() {
              const t = new o(this.length, this.sign);
              for (let e = 0; e < this.length; e++) t[e] = this[e];
              return t;
            }
            __trim() {
              let t = this.length,
                e = this[t - 1];
              for (; 0 === e; ) t--, (e = this[t - 1]), this.pop();
              return 0 === t && (this.sign = !1), this;
            }
            __initializeDigits() {
              for (let t = 0; t < this.length; t++) this[t] = 0;
            }
            static __decideRounding(t, e, r, n) {
              if (0 < e) return -1;
              let i;
              if (0 > e) i = -e - 1;
              else {
                if (0 === r) return -1;
                r--, (n = t.__digit(r)), (i = 29);
              }
              let o = 1 << i;
              if (!(n & o)) return -1;
              if (((o -= 1), n & o)) return 1;
              for (; 0 < r; ) if ((r--, 0 !== t.__digit(r))) return 1;
              return 0;
            }
            static __fromDouble(t) {
              o.__kBitConversionDouble[0] = t;
              const e = (2047 & (o.__kBitConversionInts[1] >>> 20)) - 1023,
                r = 1 + (0 | (e / 30)),
                n = new o(r, 0 > t);
              let i = (1048575 & o.__kBitConversionInts[1]) | 1048576,
                s = o.__kBitConversionInts[0];
              const a = 20,
                u = e % 30;
              let c,
                f = 0;
              if (20 > u) {
                const t = a - u;
                (f = t + 32),
                  (c = i >>> t),
                  (i = (i << (32 - t)) | (s >>> t)),
                  (s <<= 32 - t);
              } else if (20 === u) (f = 32), (c = i), (i = s), (s = 0);
              else {
                const t = u - a;
                (f = 32 - t),
                  (c = (i << t) | (s >>> (32 - t))),
                  (i = s << t),
                  (s = 0);
              }
              n.__setDigit(r - 1, c);
              for (let t = r - 2; 0 <= t; t--)
                0 < f
                  ? ((f -= 30),
                    (c = i >>> 2),
                    (i = (i << 30) | (s >>> 2)),
                    (s <<= 30))
                  : (c = 0),
                  n.__setDigit(t, c);
              return n.__trim();
            }
            static __isWhitespace(t) {
              return (
                !!(13 >= t && 9 <= t) ||
                (159 >= t
                  ? 32 == t
                  : 131071 >= t
                    ? 160 == t || 5760 == t
                    : 196607 >= t
                      ? 10 >= (t &= 131071) ||
                        40 == t ||
                        41 == t ||
                        47 == t ||
                        95 == t ||
                        4096 == t
                      : 65279 == t)
              );
            }
            static __fromString(t, e = 0) {
              let r = 0;
              const n = t.length;
              let i = 0;
              if (i === n) return o.__zero();
              let s = t.charCodeAt(i);
              for (; o.__isWhitespace(s); ) {
                if (++i === n) return o.__zero();
                s = t.charCodeAt(i);
              }
              if (43 === s) {
                if (++i === n) return null;
                (s = t.charCodeAt(i)), (r = 1);
              } else if (45 === s) {
                if (++i === n) return null;
                (s = t.charCodeAt(i)), (r = -1);
              }
              if (0 === e) {
                if (((e = 10), 48 === s)) {
                  if (++i === n) return o.__zero();
                  if (((s = t.charCodeAt(i)), 88 === s || 120 === s)) {
                    if (((e = 16), ++i === n)) return null;
                    s = t.charCodeAt(i);
                  } else if (79 === s || 111 === s) {
                    if (((e = 8), ++i === n)) return null;
                    s = t.charCodeAt(i);
                  } else if (66 === s || 98 === s) {
                    if (((e = 2), ++i === n)) return null;
                    s = t.charCodeAt(i);
                  }
                }
              } else if (16 === e && 48 === s) {
                if (++i === n) return o.__zero();
                if (((s = t.charCodeAt(i)), 88 === s || 120 === s)) {
                  if (++i === n) return null;
                  s = t.charCodeAt(i);
                }
              }
              if (0 != r && 10 !== e) return null;
              for (; 48 === s; ) {
                if (++i === n) return o.__zero();
                s = t.charCodeAt(i);
              }
              const a = n - i;
              let u = o.__kMaxBitsPerChar[e],
                c = o.__kBitsPerCharTableMultiplier - 1;
              if (a > 1073741824 / u) return null;
              const f = (u * a + c) >>> o.__kBitsPerCharTableShift,
                h = new o(0 | ((f + 29) / 30), !1),
                l = 10 > e ? e : 10,
                d = 10 < e ? e - 10 : 0;
              if (e & (e - 1)) {
                h.__initializeDigits();
                let r = !1,
                  a = 0;
                do {
                  let f = 0,
                    p = 1;
                  for (;;) {
                    let o;
                    if ((s - 48) >>> 0 < l) o = s - 48;
                    else {
                      if (!(((32 | s) - 97) >>> 0 < d)) {
                        r = !0;
                        break;
                      }
                      o = (32 | s) - 87;
                    }
                    const u = p * e;
                    if (1073741823 < u) break;
                    if (((p = u), (f = f * e + o), a++, ++i === n)) {
                      r = !0;
                      break;
                    }
                    s = t.charCodeAt(i);
                  }
                  c = 30 * o.__kBitsPerCharTableMultiplier - 1;
                  const y =
                    0 | (((u * a + c) >>> o.__kBitsPerCharTableShift) / 30);
                  h.__inplaceMultiplyAdd(p, f, y);
                } while (!r);
              } else {
                u >>= o.__kBitsPerCharTableShift;
                const e = [],
                  r = [];
                let a = !1;
                do {
                  let o = 0,
                    c = 0;
                  for (;;) {
                    let e;
                    if ((s - 48) >>> 0 < l) e = s - 48;
                    else {
                      if (!(((32 | s) - 97) >>> 0 < d)) {
                        a = !0;
                        break;
                      }
                      e = (32 | s) - 87;
                    }
                    if (((c += u), (o = (o << u) | e), ++i === n)) {
                      a = !0;
                      break;
                    }
                    if (((s = t.charCodeAt(i)), 30 < c + u)) break;
                  }
                  e.push(o), r.push(c);
                } while (!a);
                o.__fillFromParts(h, e, r);
              }
              if (i !== n) {
                if (!o.__isWhitespace(s)) return null;
                for (i++; i < n; i++)
                  if (((s = t.charCodeAt(i)), !o.__isWhitespace(s)))
                    return null;
              }
              return (h.sign = -1 == r), h.__trim();
            }
            static __fillFromParts(t, e, r) {
              let n = 0,
                i = 0,
                o = 0;
              for (let s = e.length - 1; 0 <= s; s--) {
                const a = e[s],
                  u = r[s];
                (i |= a << o),
                  (o += u),
                  30 === o
                    ? (t.__setDigit(n++, i), (o = 0), (i = 0))
                    : 30 < o &&
                      (t.__setDigit(n++, 1073741823 & i),
                      (o -= 30),
                      (i = a >>> (u - o)));
              }
              if (0 !== i) {
                if (n >= t.length) throw new Error("implementation bug");
                t.__setDigit(n++, i);
              }
              for (; n < t.length; n++) t.__setDigit(n, 0);
            }
            static __toStringBasePowerOfTwo(t, e) {
              const r = t.length;
              let n = e - 1;
              (n = (85 & (n >>> 1)) + (85 & n)),
                (n = (51 & (n >>> 2)) + (51 & n)),
                (n = (15 & (n >>> 4)) + (15 & n));
              const i = n,
                s = e - 1,
                a = t.__digit(r - 1);
              let u = 0 | ((30 * r - o.__clz30(a) + i - 1) / i);
              if ((t.sign && u++, 268435456 < u))
                throw new Error("string too long");
              const c = Array(u);
              let f = u - 1,
                h = 0,
                l = 0;
              for (let e = 0; e < r - 1; e++) {
                const r = t.__digit(e),
                  n = (h | (r << l)) & s;
                c[f--] = o.__kConversionChars[n];
                const a = i - l;
                for (h = r >>> a, l = 30 - a; l >= i; )
                  (c[f--] = o.__kConversionChars[h & s]), (h >>>= i), (l -= i);
              }
              const d = (h | (a << l)) & s;
              for (
                c[f--] = o.__kConversionChars[d], h = a >>> (i - l);
                0 !== h;

              )
                (c[f--] = o.__kConversionChars[h & s]), (h >>>= i);
              if ((t.sign && (c[f--] = "-"), -1 != f))
                throw new Error("implementation bug");
              return c.join("");
            }
            static __toStringGeneric(t, e, r) {
              const n = t.length;
              if (0 === n) return "";
              if (1 === n) {
                let n = t.__unsignedDigit(0).toString(e);
                return !1 === r && t.sign && (n = "-" + n), n;
              }
              const i = 30 * n - o.__clz30(t.__digit(n - 1)),
                s = o.__kMaxBitsPerChar[e] - 1;
              let a = i * o.__kBitsPerCharTableMultiplier;
              (a += s - 1), (a = 0 | (a / s));
              const u = (a + 1) >> 1,
                c = o.exponentiate(o.__oneDigit(e, !1), o.__oneDigit(u, !1));
              let f, h;
              const l = c.__unsignedDigit(0);
              if (1 === c.length && 32767 >= l) {
                (f = new o(t.length, !1)), f.__initializeDigits();
                let r = 0;
                for (let e = 2 * t.length - 1; 0 <= e; e--) {
                  const n = (r << 15) | t.__halfDigit(e);
                  f.__setHalfDigit(e, 0 | (n / l)), (r = 0 | n % l);
                }
                h = r.toString(e);
              } else {
                const r = o.__absoluteDivLarge(t, c, !0, !0);
                f = r.quotient;
                const n = r.remainder.__trim();
                h = o.__toStringGeneric(n, e, !0);
              }
              f.__trim();
              let d = o.__toStringGeneric(f, e, !0);
              for (; h.length < u; ) h = "0" + h;
              return !1 === r && t.sign && (d = "-" + d), d + h;
            }
            static __unequalSign(t) {
              return t ? -1 : 1;
            }
            static __absoluteGreater(t) {
              return t ? -1 : 1;
            }
            static __absoluteLess(t) {
              return t ? 1 : -1;
            }
            static __compareToBigInt(t, e) {
              const r = t.sign;
              if (r !== e.sign) return o.__unequalSign(r);
              const n = o.__absoluteCompare(t, e);
              return 0 < n
                ? o.__absoluteGreater(r)
                : 0 > n
                  ? o.__absoluteLess(r)
                  : 0;
            }
            static __compareToNumber(t, e) {
              if (o.__isOneDigitInt(e)) {
                const n = t.sign,
                  i = 0 > e;
                if (n !== i) return o.__unequalSign(n);
                if (0 === t.length) {
                  if (i) throw new Error("implementation bug");
                  return 0 === e ? 0 : -1;
                }
                if (1 < t.length) return o.__absoluteGreater(n);
                const s = r(e),
                  a = t.__unsignedDigit(0);
                return a > s
                  ? o.__absoluteGreater(n)
                  : a < s
                    ? o.__absoluteLess(n)
                    : 0;
              }
              return o.__compareToDouble(t, e);
            }
            static __compareToDouble(t, e) {
              if (e != e) return e;
              if (e === 1 / 0) return -1;
              if (e === -1 / 0) return 1;
              const r = t.sign;
              if (r !== 0 > e) return o.__unequalSign(r);
              if (0 === e)
                throw new Error(
                  "implementation bug: should be handled elsewhere",
                );
              if (0 === t.length) return -1;
              o.__kBitConversionDouble[0] = e;
              const n = 2047 & (o.__kBitConversionInts[1] >>> 20);
              if (2047 == n)
                throw new Error("implementation bug: handled elsewhere");
              const i = n - 1023;
              if (0 > i) return o.__absoluteGreater(r);
              const s = t.length;
              let a = t.__digit(s - 1);
              const u = o.__clz30(a),
                c = 30 * s - u,
                f = i + 1;
              if (c < f) return o.__absoluteLess(r);
              if (c > f) return o.__absoluteGreater(r);
              let h = 1048576 | (1048575 & o.__kBitConversionInts[1]),
                l = o.__kBitConversionInts[0];
              const d = 20,
                p = 29 - u;
              if (p !== (0 | (c - 1) % 30))
                throw new Error("implementation bug");
              let y,
                g = 0;
              if (20 > p) {
                const t = d - p;
                (g = t + 32),
                  (y = h >>> t),
                  (h = (h << (32 - t)) | (l >>> t)),
                  (l <<= 32 - t);
              } else if (20 === p) (g = 32), (y = h), (h = l), (l = 0);
              else {
                const t = p - d;
                (g = 32 - t),
                  (y = (h << t) | (l >>> (32 - t))),
                  (h = l << t),
                  (l = 0);
              }
              if (((a >>>= 0), (y >>>= 0), a > y))
                return o.__absoluteGreater(r);
              if (a < y) return o.__absoluteLess(r);
              for (let e = s - 2; 0 <= e; e--) {
                0 < g
                  ? ((g -= 30),
                    (y = h >>> 2),
                    (h = (h << 30) | (l >>> 2)),
                    (l <<= 30))
                  : (y = 0);
                const n = t.__unsignedDigit(e);
                if (n > y) return o.__absoluteGreater(r);
                if (n < y) return o.__absoluteLess(r);
              }
              if (0 !== h || 0 !== l) {
                if (0 === g) throw new Error("implementation bug");
                return o.__absoluteLess(r);
              }
              return 0;
            }
            static __equalToNumber(t, e) {
              return o.__isOneDigitInt(e)
                ? 0 === e
                  ? 0 === t.length
                  : 1 === t.length &&
                    t.sign === 0 > e &&
                    t.__unsignedDigit(0) === r(e)
                : 0 === o.__compareToDouble(t, e);
            }
            static __comparisonResultToBool(t, e) {
              return 0 === e
                ? 0 > t
                : 1 === e
                  ? 0 >= t
                  : 2 === e
                    ? 0 < t
                    : 3 === e
                      ? 0 <= t
                      : void 0;
            }
            static __compare(t, e, r) {
              if (
                ((t = o.__toPrimitive(t)),
                (e = o.__toPrimitive(e)),
                "string" == typeof t && "string" == typeof e)
              )
                switch (r) {
                  case 0:
                    return t < e;
                  case 1:
                    return t <= e;
                  case 2:
                    return t > e;
                  case 3:
                    return t >= e;
                }
              if (o.__isBigInt(t) && "string" == typeof e)
                return (
                  null !== (e = o.__fromString(e)) &&
                  o.__comparisonResultToBool(o.__compareToBigInt(t, e), r)
                );
              if ("string" == typeof t && o.__isBigInt(e))
                return (
                  null !== (t = o.__fromString(t)) &&
                  o.__comparisonResultToBool(o.__compareToBigInt(t, e), r)
                );
              if (
                ((t = o.__toNumeric(t)),
                (e = o.__toNumeric(e)),
                o.__isBigInt(t))
              ) {
                if (o.__isBigInt(e))
                  return o.__comparisonResultToBool(
                    o.__compareToBigInt(t, e),
                    r,
                  );
                if ("number" != typeof e) throw new Error("implementation bug");
                return o.__comparisonResultToBool(o.__compareToNumber(t, e), r);
              }
              if ("number" != typeof t) throw new Error("implementation bug");
              if (o.__isBigInt(e))
                return o.__comparisonResultToBool(
                  o.__compareToNumber(e, t),
                  2 ^ r,
                );
              if ("number" != typeof e) throw new Error("implementation bug");
              return 0 === r
                ? t < e
                : 1 === r
                  ? t <= e
                  : 2 === r
                    ? t > e
                    : 3 === r
                      ? t >= e
                      : void 0;
            }
            __clzmsd() {
              return o.__clz30(this.__digit(this.length - 1));
            }
            static __absoluteAdd(t, e, r) {
              if (t.length < e.length) return o.__absoluteAdd(e, t, r);
              if (0 === t.length) return t;
              if (0 === e.length) return t.sign === r ? t : o.unaryMinus(t);
              let n = t.length;
              (0 === t.__clzmsd() ||
                (e.length === t.length && 0 === e.__clzmsd())) &&
                n++;
              const i = new o(n, r);
              let s = 0,
                a = 0;
              for (; a < e.length; a++) {
                const r = t.__digit(a) + e.__digit(a) + s;
                (s = r >>> 30), i.__setDigit(a, 1073741823 & r);
              }
              for (; a < t.length; a++) {
                const e = t.__digit(a) + s;
                (s = e >>> 30), i.__setDigit(a, 1073741823 & e);
              }
              return a < i.length && i.__setDigit(a, s), i.__trim();
            }
            static __absoluteSub(t, e, r) {
              if (0 === t.length) return t;
              if (0 === e.length) return t.sign === r ? t : o.unaryMinus(t);
              const n = new o(t.length, r);
              let i = 0,
                s = 0;
              for (; s < e.length; s++) {
                const r = t.__digit(s) - e.__digit(s) - i;
                (i = 1 & (r >>> 30)), n.__setDigit(s, 1073741823 & r);
              }
              for (; s < t.length; s++) {
                const e = t.__digit(s) - i;
                (i = 1 & (e >>> 30)), n.__setDigit(s, 1073741823 & e);
              }
              return n.__trim();
            }
            static __absoluteAddOne(t, e, r = null) {
              const n = t.length;
              null === r ? (r = new o(n, e)) : (r.sign = e);
              let i = 1;
              for (let e = 0; e < n; e++) {
                const n = t.__digit(e) + i;
                (i = n >>> 30), r.__setDigit(e, 1073741823 & n);
              }
              return 0 != i && r.__setDigitGrow(n, 1), r;
            }
            static __absoluteSubOne(t, e) {
              const r = t.length,
                n = new o((e = e || r), !1);
              let i = 1;
              for (let e = 0; e < r; e++) {
                const r = t.__digit(e) - i;
                (i = 1 & (r >>> 30)), n.__setDigit(e, 1073741823 & r);
              }
              if (0 != i) throw new Error("implementation bug");
              for (let t = r; t < e; t++) n.__setDigit(t, 0);
              return n;
            }
            static __absoluteAnd(t, e, r = null) {
              let n = t.length,
                i = e.length,
                s = i;
              if (n < i) {
                s = n;
                const r = t,
                  o = n;
                (t = e), (n = i), (e = r), (i = o);
              }
              let a = s;
              null === r ? (r = new o(a, !1)) : (a = r.length);
              let u = 0;
              for (; u < s; u++) r.__setDigit(u, t.__digit(u) & e.__digit(u));
              for (; u < a; u++) r.__setDigit(u, 0);
              return r;
            }
            static __absoluteAndNot(t, e, r = null) {
              const n = t.length,
                i = e.length;
              let s = i;
              n < i && (s = n);
              let a = n;
              null === r ? (r = new o(a, !1)) : (a = r.length);
              let u = 0;
              for (; u < s; u++) r.__setDigit(u, t.__digit(u) & ~e.__digit(u));
              for (; u < n; u++) r.__setDigit(u, t.__digit(u));
              for (; u < a; u++) r.__setDigit(u, 0);
              return r;
            }
            static __absoluteOr(t, e, r = null) {
              let n = t.length,
                i = e.length,
                s = i;
              if (n < i) {
                s = n;
                const r = t,
                  o = n;
                (t = e), (n = i), (e = r), (i = o);
              }
              let a = n;
              null === r ? (r = new o(a, !1)) : (a = r.length);
              let u = 0;
              for (; u < s; u++) r.__setDigit(u, t.__digit(u) | e.__digit(u));
              for (; u < n; u++) r.__setDigit(u, t.__digit(u));
              for (; u < a; u++) r.__setDigit(u, 0);
              return r;
            }
            static __absoluteXor(t, e, r = null) {
              let n = t.length,
                i = e.length,
                s = i;
              if (n < i) {
                s = n;
                const r = t,
                  o = n;
                (t = e), (n = i), (e = r), (i = o);
              }
              let a = n;
              null === r ? (r = new o(a, !1)) : (a = r.length);
              let u = 0;
              for (; u < s; u++) r.__setDigit(u, t.__digit(u) ^ e.__digit(u));
              for (; u < n; u++) r.__setDigit(u, t.__digit(u));
              for (; u < a; u++) r.__setDigit(u, 0);
              return r;
            }
            static __absoluteCompare(t, e) {
              const r = t.length - e.length;
              if (0 != r) return r;
              let n = t.length - 1;
              for (; 0 <= n && t.__digit(n) === e.__digit(n); ) n--;
              return 0 > n
                ? 0
                : t.__unsignedDigit(n) > e.__unsignedDigit(n)
                  ? 1
                  : -1;
            }
            static __multiplyAccumulate(t, e, r, n) {
              if (0 === e) return;
              const i = 32767 & e,
                s = e >>> 15;
              let a = 0,
                u = 0;
              for (let e, c = 0; c < t.length; c++, n++) {
                e = r.__digit(n);
                const f = t.__digit(c),
                  h = 32767 & f,
                  l = f >>> 15,
                  d = o.__imul(h, i),
                  p = o.__imul(h, s),
                  y = o.__imul(l, i);
                (e += u + d + a),
                  (a = e >>> 30),
                  (e &= 1073741823),
                  (e += ((32767 & p) << 15) + ((32767 & y) << 15)),
                  (a += e >>> 30),
                  (u = o.__imul(l, s) + (p >>> 15) + (y >>> 15)),
                  r.__setDigit(n, 1073741823 & e);
              }
              for (; 0 != a || 0 !== u; n++) {
                let t = r.__digit(n);
                (t += a + u),
                  (u = 0),
                  (a = t >>> 30),
                  r.__setDigit(n, 1073741823 & t);
              }
            }
            static __internalMultiplyAdd(t, e, r, n, i) {
              let s = r,
                a = 0;
              for (let r = 0; r < n; r++) {
                const n = t.__digit(r),
                  u = o.__imul(32767 & n, e),
                  c = o.__imul(n >>> 15, e),
                  f = u + ((32767 & c) << 15) + a + s;
                (s = f >>> 30), (a = c >>> 15), i.__setDigit(r, 1073741823 & f);
              }
              if (i.length > n)
                for (i.__setDigit(n++, s + a); n < i.length; )
                  i.__setDigit(n++, 0);
              else if (0 !== s + a) throw new Error("implementation bug");
            }
            __inplaceMultiplyAdd(t, e, r) {
              r > this.length && (r = this.length);
              const n = 32767 & t,
                i = t >>> 15;
              let s = 0,
                a = e;
              for (let t = 0; t < r; t++) {
                const e = this.__digit(t),
                  r = 32767 & e,
                  u = e >>> 15,
                  c = o.__imul(r, n),
                  f = o.__imul(r, i),
                  h = o.__imul(u, n);
                let l = a + c + s;
                (s = l >>> 30),
                  (l &= 1073741823),
                  (l += ((32767 & f) << 15) + ((32767 & h) << 15)),
                  (s += l >>> 30),
                  (a = o.__imul(u, i) + (f >>> 15) + (h >>> 15)),
                  this.__setDigit(t, 1073741823 & l);
              }
              if (0 != s || 0 !== a) throw new Error("implementation bug");
            }
            static __absoluteDivSmall(t, e, r = null) {
              null === r && (r = new o(t.length, !1));
              let n = 0;
              for (let i, o = 2 * t.length - 1; 0 <= o; o -= 2) {
                i = ((n << 15) | t.__halfDigit(o)) >>> 0;
                const s = 0 | (i / e);
                (n = 0 | i % e), (i = ((n << 15) | t.__halfDigit(o - 1)) >>> 0);
                const a = 0 | (i / e);
                (n = 0 | i % e), r.__setDigit(o >>> 1, (s << 15) | a);
              }
              return r;
            }
            static __absoluteModSmall(t, e) {
              let r = 0;
              for (let n = 2 * t.length - 1; 0 <= n; n--)
                r = 0 | (((r << 15) | t.__halfDigit(n)) >>> 0) % e;
              return r;
            }
            static __absoluteDivLarge(t, e, r, n) {
              const i = e.__halfDigitLength(),
                s = e.length,
                a = t.__halfDigitLength() - i;
              let u = null;
              r && ((u = new o((a + 2) >>> 1, !1)), u.__initializeDigits());
              const c = new o((i + 2) >>> 1, !1);
              c.__initializeDigits();
              const f = o.__clz15(e.__halfDigit(i - 1));
              0 < f && (e = o.__specialLeftShift(e, f, 0));
              const h = o.__specialLeftShift(t, f, 1),
                l = e.__halfDigit(i - 1);
              let d = 0;
              for (let t, n = a; 0 <= n; n--) {
                t = 32767;
                const a = h.__halfDigit(n + i);
                if (a !== l) {
                  const r = ((a << 15) | h.__halfDigit(n + i - 1)) >>> 0;
                  t = 0 | (r / l);
                  let s = 0 | r % l;
                  const u = e.__halfDigit(i - 2),
                    c = h.__halfDigit(n + i - 2);
                  for (
                    ;
                    o.__imul(t, u) >>> 0 > ((s << 16) | c) >>> 0 &&
                    (t--, (s += l), !(32767 < s));

                  );
                }
                o.__internalMultiplyAdd(e, t, 0, s, c);
                let f = h.__inplaceSub(c, n, i + 1);
                0 !== f &&
                  ((f = h.__inplaceAdd(e, n, i)),
                  h.__setHalfDigit(n + i, 32767 & (h.__halfDigit(n + i) + f)),
                  t--),
                  r && (1 & n ? (d = t << 15) : u.__setDigit(n >>> 1, d | t));
              }
              if (n)
                return (
                  h.__inplaceRightShift(f),
                  r ? { quotient: u, remainder: h } : h
                );
              if (r) return u;
              throw new Error("unreachable");
            }
            static __clz15(t) {
              return o.__clz30(t) - 15;
            }
            __inplaceAdd(t, e, r) {
              let n = 0;
              for (let i = 0; i < r; i++) {
                const r = this.__halfDigit(e + i) + t.__halfDigit(i) + n;
                (n = r >>> 15), this.__setHalfDigit(e + i, 32767 & r);
              }
              return n;
            }
            __inplaceSub(t, e, r) {
              let n = 0;
              if (1 & e) {
                e >>= 1;
                let i = this.__digit(e),
                  o = 32767 & i,
                  s = 0;
                for (; s < (r - 1) >>> 1; s++) {
                  const r = t.__digit(s),
                    a = (i >>> 15) - (32767 & r) - n;
                  (n = 1 & (a >>> 15)),
                    this.__setDigit(e + s, ((32767 & a) << 15) | (32767 & o)),
                    (i = this.__digit(e + s + 1)),
                    (o = (32767 & i) - (r >>> 15) - n),
                    (n = 1 & (o >>> 15));
                }
                const a = t.__digit(s),
                  u = (i >>> 15) - (32767 & a) - n;
                if (
                  ((n = 1 & (u >>> 15)),
                  this.__setDigit(e + s, ((32767 & u) << 15) | (32767 & o)),
                  e + s + 1 >= this.length)
                )
                  throw new RangeError("out of bounds");
                !(1 & r) &&
                  ((i = this.__digit(e + s + 1)),
                  (o = (32767 & i) - (a >>> 15) - n),
                  (n = 1 & (o >>> 15)),
                  this.__setDigit(
                    e + t.length,
                    (1073709056 & i) | (32767 & o),
                  ));
              } else {
                e >>= 1;
                let i = 0;
                for (; i < t.length - 1; i++) {
                  const r = this.__digit(e + i),
                    o = t.__digit(i),
                    s = (32767 & r) - (32767 & o) - n;
                  n = 1 & (s >>> 15);
                  const a = (r >>> 15) - (o >>> 15) - n;
                  (n = 1 & (a >>> 15)),
                    this.__setDigit(e + i, ((32767 & a) << 15) | (32767 & s));
                }
                const o = this.__digit(e + i),
                  s = t.__digit(i),
                  a = (32767 & o) - (32767 & s) - n;
                n = 1 & (a >>> 15);
                let u = 0;
                !(1 & r) &&
                  ((u = (o >>> 15) - (s >>> 15) - n), (n = 1 & (u >>> 15))),
                  this.__setDigit(e + i, ((32767 & u) << 15) | (32767 & a));
              }
              return n;
            }
            __inplaceRightShift(t) {
              if (0 === t) return;
              let e = this.__digit(0) >>> t;
              const r = this.length - 1;
              for (let n = 0; n < r; n++) {
                const r = this.__digit(n + 1);
                this.__setDigit(n, (1073741823 & (r << (30 - t))) | e),
                  (e = r >>> t);
              }
              this.__setDigit(r, e);
            }
            static __specialLeftShift(t, e, r) {
              const n = t.length,
                i = new o(n + r, !1);
              if (0 === e) {
                for (let e = 0; e < n; e++) i.__setDigit(e, t.__digit(e));
                return 0 < r && i.__setDigit(n, 0), i;
              }
              let s = 0;
              for (let r = 0; r < n; r++) {
                const n = t.__digit(r);
                i.__setDigit(r, (1073741823 & (n << e)) | s),
                  (s = n >>> (30 - e));
              }
              return 0 < r && i.__setDigit(n, s), i;
            }
            static __leftShiftByAbsolute(t, e) {
              const r = o.__toShiftAmount(e);
              if (0 > r) throw new RangeError("BigInt too big");
              const n = 0 | (r / 30),
                i = r % 30,
                s = t.length,
                a = 0 !== i && 0 != t.__digit(s - 1) >>> (30 - i),
                u = s + n + (a ? 1 : 0),
                c = new o(u, t.sign);
              if (0 === i) {
                let e = 0;
                for (; e < n; e++) c.__setDigit(e, 0);
                for (; e < u; e++) c.__setDigit(e, t.__digit(e - n));
              } else {
                let e = 0;
                for (let t = 0; t < n; t++) c.__setDigit(t, 0);
                for (let r = 0; r < s; r++) {
                  const o = t.__digit(r);
                  c.__setDigit(r + n, (1073741823 & (o << i)) | e),
                    (e = o >>> (30 - i));
                }
                if (a) c.__setDigit(s + n, e);
                else if (0 !== e) throw new Error("implementation bug");
              }
              return c.__trim();
            }
            static __rightShiftByAbsolute(t, e) {
              const r = t.length,
                n = t.sign,
                i = o.__toShiftAmount(e);
              if (0 > i) return o.__rightShiftByMaximum(n);
              const s = 0 | (i / 30),
                a = i % 30;
              let u = r - s;
              if (0 >= u) return o.__rightShiftByMaximum(n);
              let c = !1;
              if (n)
                if (t.__digit(s) & ((1 << a) - 1)) c = !0;
                else
                  for (let e = 0; e < s; e++)
                    if (0 !== t.__digit(e)) {
                      c = !0;
                      break;
                    }
              c && 0 === a && 0 == ~t.__digit(r - 1) && u++;
              let f = new o(u, n);
              if (0 === a) {
                f.__setDigit(u - 1, 0);
                for (let e = s; e < r; e++) f.__setDigit(e - s, t.__digit(e));
              } else {
                let e = t.__digit(s) >>> a;
                const n = r - s - 1;
                for (let r = 0; r < n; r++) {
                  const n = t.__digit(r + s + 1);
                  f.__setDigit(r, (1073741823 & (n << (30 - a))) | e),
                    (e = n >>> a);
                }
                f.__setDigit(n, e);
              }
              return c && (f = o.__absoluteAddOne(f, !0, f)), f.__trim();
            }
            static __rightShiftByMaximum(t) {
              return t ? o.__oneDigit(1, !0) : o.__zero();
            }
            static __toShiftAmount(t) {
              if (1 < t.length) return -1;
              const e = t.__unsignedDigit(0);
              return e > o.__kMaxLengthBits ? -1 : e;
            }
            static __toPrimitive(t, e = "default") {
              if ("object" != typeof t) return t;
              if (t.constructor === o) return t;
              if (
                "undefined" != typeof Symbol &&
                "symbol" == typeof Symbol.toPrimitive
              ) {
                const r = t[Symbol.toPrimitive];
                if (r) {
                  const t = r(e);
                  if ("object" != typeof t) return t;
                  throw new TypeError(
                    "Cannot convert object to primitive value",
                  );
                }
              }
              const r = t.valueOf;
              if (r) {
                const e = r.call(t);
                if ("object" != typeof e) return e;
              }
              const n = t.toString;
              if (n) {
                const e = n.call(t);
                if ("object" != typeof e) return e;
              }
              throw new TypeError("Cannot convert object to primitive value");
            }
            static __toNumeric(t) {
              return o.__isBigInt(t) ? t : +t;
            }
            static __isBigInt(t) {
              return "object" == typeof t && null !== t && t.constructor === o;
            }
            static __truncateToNBits(t, e) {
              const r = 0 | ((t + 29) / 30),
                n = new o(r, e.sign),
                i = r - 1;
              for (let t = 0; t < i; t++) n.__setDigit(t, e.__digit(t));
              let s = e.__digit(i);
              if (0 != t % 30) {
                const e = 32 - (t % 30);
                s = (s << e) >>> e;
              }
              return n.__setDigit(i, s), n.__trim();
            }
            static __truncateAndSubFromPowerOfTwo(t, e, r) {
              var n = Math.min;
              const i = 0 | ((t + 29) / 30),
                s = new o(i, r);
              let a = 0;
              const u = i - 1;
              let c = 0;
              for (const t = n(u, e.length); a < t; a++) {
                const t = 0 - e.__digit(a) - c;
                (c = 1 & (t >>> 30)), s.__setDigit(a, 1073741823 & t);
              }
              for (; a < u; a++) s.__setDigit(a, 1073741823 & -c);
              let f = u < e.length ? e.__digit(u) : 0;
              const h = t % 30;
              let l;
              if (0 == h) (l = 0 - f - c), (l &= 1073741823);
              else {
                const t = 32 - h;
                f = (f << t) >>> t;
                const e = 1 << (32 - t);
                (l = e - f - c), (l &= e - 1);
              }
              return s.__setDigit(u, l), s.__trim();
            }
            __digit(t) {
              return this[t];
            }
            __unsignedDigit(t) {
              return this[t] >>> 0;
            }
            __setDigit(t, e) {
              this[t] = 0 | e;
            }
            __setDigitGrow(t, e) {
              this[t] = 0 | e;
            }
            __halfDigitLength() {
              const t = this.length;
              return 32767 >= this.__unsignedDigit(t - 1) ? 2 * t - 1 : 2 * t;
            }
            __halfDigit(t) {
              return 32767 & (this[t >>> 1] >>> (15 * (1 & t)));
            }
            __setHalfDigit(t, e) {
              const r = t >>> 1,
                n = this.__digit(r),
                i =
                  1 & t
                    ? (32767 & n) | (e << 15)
                    : (1073709056 & n) | (32767 & e);
              this.__setDigit(r, i);
            }
            static __digitPow(t, e) {
              let r = 1;
              for (; 0 < e; ) 1 & e && (r *= t), (e >>>= 1), (t *= t);
              return r;
            }
            static __isOneDigitInt(t) {
              return (1073741823 & t) === t;
            }
          }
          return (
            (o.__kMaxLength = 33554432),
            (o.__kMaxLengthBits = o.__kMaxLength << 5),
            (o.__kMaxBitsPerChar = [
              0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122,
              126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153,
              154, 156, 158, 159, 160, 162, 163, 165, 166,
            ]),
            (o.__kBitsPerCharTableShift = 5),
            (o.__kBitsPerCharTableMultiplier = 1 << o.__kBitsPerCharTableShift),
            (o.__kConversionChars = [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "a",
              "b",
              "c",
              "d",
              "e",
              "f",
              "g",
              "h",
              "i",
              "j",
              "k",
              "l",
              "m",
              "n",
              "o",
              "p",
              "q",
              "r",
              "s",
              "t",
              "u",
              "v",
              "w",
              "x",
              "y",
              "z",
            ]),
            (o.__kBitConversionBuffer = new ArrayBuffer(8)),
            (o.__kBitConversionDouble = new Float64Array(
              o.__kBitConversionBuffer,
            )),
            (o.__kBitConversionInts = new Int32Array(o.__kBitConversionBuffer)),
            (o.__clz30 = e
              ? function (t) {
                  return e(t) - 2;
                }
              : function (t) {
                  var e = Math.LN2,
                    r = Math.log;
                  return 0 === t ? 30 : 0 | (29 - (0 | (r(t >>> 0) / e)));
                }),
            (o.__imul =
              t ||
              function (t, e) {
                return 0 | (t * e);
              }),
            o
          );
        })();
      },
      21013: (t, e, r) => {
        var n = r(67372).stringify,
          i = r(8146);
        (t.exports = function (t) {
          return { parse: i(t), stringify: n };
        }),
          (t.exports.parse = i()),
          (t.exports.stringify = n);
      },
      8146: (t, e, r) => {
        var n = null;
        const i =
            /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/,
          o =
            /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
        t.exports = function (t) {
          "use strict";
          var e = {
            strict: !1,
            storeAsString: !1,
            alwaysParseAsBig: !1,
            useNativeBigInt: !1,
            protoAction: "error",
            constructorAction: "error",
          };
          if (null != t) {
            if (
              (!0 === t.strict && (e.strict = !0),
              !0 === t.storeAsString && (e.storeAsString = !0),
              (e.alwaysParseAsBig =
                !0 === t.alwaysParseAsBig && t.alwaysParseAsBig),
              (e.useNativeBigInt =
                !0 === t.useNativeBigInt && t.useNativeBigInt),
              void 0 !== t.constructorAction)
            ) {
              if (
                "error" !== t.constructorAction &&
                "ignore" !== t.constructorAction &&
                "preserve" !== t.constructorAction
              )
                throw new Error(
                  `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${t.constructorAction}`,
                );
              e.constructorAction = t.constructorAction;
            }
            if (void 0 !== t.protoAction) {
              if (
                "error" !== t.protoAction &&
                "ignore" !== t.protoAction &&
                "preserve" !== t.protoAction
              )
                throw new Error(
                  `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${t.protoAction}`,
                );
              e.protoAction = t.protoAction;
            }
          }
          var s,
            a,
            u,
            c,
            f = {
              '"': '"',
              "\\": "\\",
              "/": "/",
              b: "\b",
              f: "\f",
              n: "\n",
              r: "\r",
              t: "\t",
            },
            h = function (t) {
              throw { name: "SyntaxError", message: t, at: s, text: u };
            },
            l = function (t) {
              return (
                t &&
                  t !== a &&
                  h("Expected '" + t + "' instead of '" + a + "'"),
                (a = u.charAt(s)),
                (s += 1),
                a
              );
            },
            d = function () {
              var t,
                i = "";
              for ("-" === a && ((i = "-"), l("-")); a >= "0" && a <= "9"; )
                (i += a), l();
              if ("." === a)
                for (i += "."; l() && a >= "0" && a <= "9"; ) i += a;
              if ("e" === a || "E" === a)
                for (
                  i += a, l(), ("-" !== a && "+" !== a) || ((i += a), l());
                  a >= "0" && a <= "9";

                )
                  (i += a), l();
              if (((t = +i), isFinite(t)))
                return (
                  null == n && (n = r(61594)),
                  i.length > 15
                    ? e.storeAsString
                      ? i
                      : e.useNativeBigInt
                        ? BigInt(i)
                        : new n(i)
                    : e.alwaysParseAsBig
                      ? e.useNativeBigInt
                        ? BigInt(t)
                        : new n(t)
                      : t
                );
              h("Bad number");
            },
            p = function () {
              var t,
                e,
                r,
                n = "";
              if ('"' === a)
                for (var i = s; l(); ) {
                  if ('"' === a)
                    return s - 1 > i && (n += u.substring(i, s - 1)), l(), n;
                  if ("\\" === a) {
                    if (
                      (s - 1 > i && (n += u.substring(i, s - 1)),
                      l(),
                      "u" === a)
                    ) {
                      for (
                        r = 0, e = 0;
                        e < 4 && ((t = parseInt(l(), 16)), isFinite(t));
                        e += 1
                      )
                        r = 16 * r + t;
                      n += String.fromCharCode(r);
                    } else {
                      if ("string" != typeof f[a]) break;
                      n += f[a];
                    }
                    i = s;
                  }
                }
              h("Bad string");
            },
            y = function () {
              for (; a && a <= " "; ) l();
            };
          return (
            (c = function () {
              switch ((y(), a)) {
                case "{":
                  return (function () {
                    var t,
                      r = Object.create(null);
                    if ("{" === a) {
                      if ((l("{"), y(), "}" === a)) return l("}"), r;
                      for (; a; ) {
                        if (
                          ((t = p()),
                          y(),
                          l(":"),
                          !0 === e.strict &&
                            Object.hasOwnProperty.call(r, t) &&
                            h('Duplicate key "' + t + '"'),
                          !0 === i.test(t)
                            ? "error" === e.protoAction
                              ? h(
                                  "Object contains forbidden prototype property",
                                )
                              : "ignore" === e.protoAction
                                ? c()
                                : (r[t] = c())
                            : !0 === o.test(t)
                              ? "error" === e.constructorAction
                                ? h(
                                    "Object contains forbidden constructor property",
                                  )
                                : "ignore" === e.constructorAction
                                  ? c()
                                  : (r[t] = c())
                              : (r[t] = c()),
                          y(),
                          "}" === a)
                        )
                          return l("}"), r;
                        l(","), y();
                      }
                    }
                    h("Bad object");
                  })();
                case "[":
                  return (function () {
                    var t = [];
                    if ("[" === a) {
                      if ((l("["), y(), "]" === a)) return l("]"), t;
                      for (; a; ) {
                        if ((t.push(c()), y(), "]" === a)) return l("]"), t;
                        l(","), y();
                      }
                    }
                    h("Bad array");
                  })();
                case '"':
                  return p();
                case "-":
                  return d();
                default:
                  return a >= "0" && a <= "9"
                    ? d()
                    : (function () {
                        switch (a) {
                          case "t":
                            return l("t"), l("r"), l("u"), l("e"), !0;
                          case "f":
                            return l("f"), l("a"), l("l"), l("s"), l("e"), !1;
                          case "n":
                            return l("n"), l("u"), l("l"), l("l"), null;
                        }
                        h("Unexpected '" + a + "'");
                      })();
              }
            }),
            function (t, e) {
              var r;
              return (
                (u = t + ""),
                (s = 0),
                (a = " "),
                (r = c()),
                y(),
                a && h("Syntax error"),
                "function" == typeof e
                  ? (function t(r, n) {
                      var i,
                        o = r[n];
                      return (
                        o &&
                          "object" == typeof o &&
                          Object.keys(o).forEach(function (e) {
                            void 0 !== (i = t(o, e)) ? (o[e] = i) : delete o[e];
                          }),
                        e.call(r, n, o)
                      );
                    })({ "": r }, "")
                  : r
              );
            }
          );
        };
      },
      67372: (t, e, r) => {
        var n = r(61594),
          i = t.exports;
        !(function () {
          "use strict";
          var t,
            e,
            r,
            o =
              /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            s = {
              "\b": "\\b",
              "\t": "\\t",
              "\n": "\\n",
              "\f": "\\f",
              "\r": "\\r",
              '"': '\\"',
              "\\": "\\\\",
            };
          function a(t) {
            return (
              (o.lastIndex = 0),
              o.test(t)
                ? '"' +
                  t.replace(o, function (t) {
                    var e = s[t];
                    return "string" == typeof e
                      ? e
                      : "\\u" +
                          ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
                  }) +
                  '"'
                : '"' + t + '"'
            );
          }
          function u(i, o) {
            var s,
              c,
              f,
              h,
              l,
              d = t,
              p = o[i],
              y = null != p && (p instanceof n || n.isBigNumber(p));
            switch (
              (p &&
                "object" == typeof p &&
                "function" == typeof p.toJSON &&
                (p = p.toJSON(i)),
              "function" == typeof r && (p = r.call(o, i, p)),
              typeof p)
            ) {
              case "string":
                return y ? p : a(p);
              case "number":
                return isFinite(p) ? String(p) : "null";
              case "boolean":
              case "null":
              case "bigint":
                return String(p);
              case "object":
                if (!p) return "null";
                if (
                  ((t += e),
                  (l = []),
                  "[object Array]" === Object.prototype.toString.apply(p))
                ) {
                  for (h = p.length, s = 0; s < h; s += 1)
                    l[s] = u(s, p) || "null";
                  return (
                    (f =
                      0 === l.length
                        ? "[]"
                        : t
                          ? "[\n" + t + l.join(",\n" + t) + "\n" + d + "]"
                          : "[" + l.join(",") + "]"),
                    (t = d),
                    f
                  );
                }
                if (r && "object" == typeof r)
                  for (h = r.length, s = 0; s < h; s += 1)
                    "string" == typeof r[s] &&
                      (f = u((c = r[s]), p)) &&
                      l.push(a(c) + (t ? ": " : ":") + f);
                else
                  Object.keys(p).forEach(function (e) {
                    var r = u(e, p);
                    r && l.push(a(e) + (t ? ": " : ":") + r);
                  });
                return (
                  (f =
                    0 === l.length
                      ? "{}"
                      : t
                        ? "{\n" + t + l.join(",\n" + t) + "\n" + d + "}"
                        : "{" + l.join(",") + "}"),
                  (t = d),
                  f
                );
            }
          }
          "function" != typeof i.stringify &&
            (i.stringify = function (n, i, o) {
              var s;
              if (((t = ""), (e = ""), "number" == typeof o))
                for (s = 0; s < o; s += 1) e += " ";
              else "string" == typeof o && (e = o);
              if (
                ((r = i),
                i &&
                  "function" != typeof i &&
                  ("object" != typeof i || "number" != typeof i.length))
              )
                throw new Error("JSON.stringify");
              return u("", { "": n });
            });
        })();
      },
      35921: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = e.encode = e.unescape = e.escape = e.pad = void 0);
        const n = r(67526);
        function i(t) {
          return `${t}${"=".repeat(4 - (t.length % 4 || 4))}`;
        }
        function o(t) {
          return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function s(t) {
          return i(t).replace(/-/g, "+").replace(/_/g, "/");
        }
        (e.pad = i),
          (e.escape = o),
          (e.unescape = s),
          (e.encode = function (t) {
            return o((0, n.fromByteArray)(new TextEncoder().encode(t)));
          }),
          (e.decode = function (t) {
            return new TextDecoder().decode((0, n.toByteArray)(i(s(t))));
          });
      },
      61161: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.cryptoClients = e.SECP256K1Client = void 0);
        const n = r(92485);
        Object.defineProperty(e, "SECP256K1Client", {
          enumerable: !0,
          get: function () {
            return n.SECP256K1Client;
          },
        });
        const i = { ES256K: n.SECP256K1Client };
        e.cryptoClients = i;
      },
      92485: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.SECP256K1Client = void 0);
        const n = r(39615),
          i = r(22623),
          o = r(9598),
          s = r(96216),
          a = r(68886),
          u = r(99175);
        o.utils.hmacSha256Sync = (t, ...e) => {
          const r = n.hmac.create(i.sha256, t);
          return e.forEach((t) => r.update(t)), r.digest();
        };
        class c {
          static derivePublicKey(t, e = !0) {
            return (
              66 === t.length && (t = t.slice(0, 64)),
              t.length < 64 && (t = t.padStart(64, "0")),
              (0, u.bytesToHex)(o.getPublicKey(t, e))
            );
          }
          static signHash(t, e, r = "jose") {
            if (!t || !e)
              throw new a.MissingParametersError(
                "a signing input hash and private key are all required",
              );
            const n = o.signSync(t, e.slice(0, 64), { der: !0, canonical: !1 });
            if ("der" === r) return (0, u.bytesToHex)(n);
            if ("jose" === r) return (0, s.derToJose)(n, "ES256");
            throw Error("Invalid signature format");
          }
          static loadSignature(t) {
            return (0, s.joseToDer)(t, "ES256");
          }
          static verifyHash(t, e, r) {
            if (!t || !e || !r)
              throw new a.MissingParametersError(
                "a signing input hash, der signature, and public key are all required",
              );
            return o.verify(e, t, r, { strict: !1 });
          }
        }
        (e.SECP256K1Client = c), (c.algorithmName = "ES256K");
      },
      97990: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (t, e, r, n) {
            return new (r || (r = Promise))(function (i, o) {
              function s(t) {
                try {
                  u(n.next(t));
                } catch (t) {
                  o(t);
                }
              }
              function a(t) {
                try {
                  u(n.throw(t));
                } catch (t) {
                  o(t);
                }
              }
              function u(t) {
                var e;
                t.done
                  ? i(t.value)
                  : ((e = t.value),
                    e instanceof r
                      ? e
                      : new r(function (t) {
                          t(e);
                        })).then(s, a);
              }
              u((n = n.apply(t, e || [])).next());
            });
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.hashSha256Async = e.hashSha256 = void 0);
        const i = r(22623);
        function o(t) {
          return (0, i.sha256)(t);
        }
        (e.hashSha256 = o),
          (e.hashSha256Async = function (t) {
            return n(this, void 0, void 0, function* () {
              try {
                if ("undefined" != typeof crypto && void 0 !== crypto.subtle) {
                  const e =
                      "string" == typeof t ? new TextEncoder().encode(t) : t,
                    r = yield crypto.subtle.digest("SHA-256", e);
                  return new Uint8Array(r);
                }
                {
                  const e = r(32632);
                  if (!e.createHash)
                    throw new Error(
                      "`crypto` module does not contain `createHash`",
                    );
                  return Promise.resolve(
                    e.createHash("sha256").update(t).digest(),
                  );
                }
              } catch (e) {
                return (
                  console.log(e),
                  console.log(
                    'Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.',
                  ),
                  Promise.resolve(o(t))
                );
              }
            });
          });
      },
      21827: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decodeToken = void 0);
        const n = r(35921);
        e.decodeToken = function (t) {
          if ("string" == typeof t) {
            const e = t.split(".");
            return {
              header: JSON.parse(n.decode(e[0])),
              payload: JSON.parse(n.decode(e[1])),
              signature: e[2],
            };
          }
          if ("object" == typeof t) {
            if ("string" != typeof t.payload)
              throw new Error(
                "Expected token payload to be a base64 or json string",
              );
            let e = t.payload;
            "{" !== t.payload[0] && (e = n.decode(e));
            const r = [];
            return (
              t.header.map((t) => {
                const e = JSON.parse(n.decode(t));
                r.push(e);
              }),
              { header: r, payload: JSON.parse(e), signature: t.signature }
            );
          }
        };
      },
      96216: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.joseToDer = e.derToJose = void 0);
        const n = r(67526),
          i = r(35921);
        function o(t) {
          return ((t / 8) | 0) + (t % 8 == 0 ? 0 : 1);
        }
        const s = { ES256: o(256), ES384: o(384), ES512: o(521) };
        function a(t) {
          const e = s[t];
          if (e) return e;
          throw new Error(`Unknown algorithm "${t}"`);
        }
        const u = 128;
        function c(t) {
          if (t instanceof Uint8Array) return t;
          if ("string" == typeof t) return (0, n.toByteArray)((0, i.pad)(t));
          throw new TypeError(
            "ECDSA signature must be a Base64 string or a Uint8Array",
          );
        }
        function f(t, e, r) {
          let n = 0;
          for (; e + n < r && 0 === t[e + n]; ) ++n;
          return t[e + n] >= u && --n, n;
        }
        (e.derToJose = function (t, e) {
          const r = c(t),
            o = a(e),
            s = o + 1,
            u = r.length;
          let f = 0;
          if (48 !== r[f++]) throw new Error('Could not find expected "seq"');
          let h = r[f++];
          if ((129 === h && (h = r[f++]), u - f < h))
            throw new Error(
              `"seq" specified length of "${h}", only "${u - f}" remaining`,
            );
          if (2 !== r[f++])
            throw new Error('Could not find expected "int" for "r"');
          const l = r[f++];
          if (u - f - 2 < l)
            throw new Error(
              `"r" specified length of "${l}", only "${u - f - 2}" available`,
            );
          if (s < l)
            throw new Error(
              `"r" specified length of "${l}", max of "${s}" is acceptable`,
            );
          const d = f;
          if (((f += l), 2 !== r[f++]))
            throw new Error('Could not find expected "int" for "s"');
          const p = r[f++];
          if (u - f !== p)
            throw new Error(
              `"s" specified length of "${p}", expected "${u - f}"`,
            );
          if (s < p)
            throw new Error(
              `"s" specified length of "${p}", max of "${s}" is acceptable`,
            );
          const y = f;
          if (((f += p), f !== u))
            throw new Error(
              `Expected to consume entire array, but "${u - f}" bytes remain`,
            );
          const g = o - l,
            m = o - p,
            b = new Uint8Array(g + l + m + p);
          for (f = 0; f < g; ++f) b[f] = 0;
          b.set(r.subarray(d + Math.max(-g, 0), d + l), f), (f = o);
          for (const t = f; f < t + m; ++f) b[f] = 0;
          return (
            b.set(r.subarray(y + Math.max(-m, 0), y + p), f),
            (0, i.escape)((0, n.fromByteArray)(b))
          );
        }),
          (e.joseToDer = function (t, e) {
            t = c(t);
            const r = a(e),
              n = t.length;
            if (n !== 2 * r)
              throw new TypeError(
                `"${e}" signatures must be "${2 * r}" bytes, saw "${n}"`,
              );
            const i = f(t, 0, r),
              o = f(t, r, t.length),
              s = r - i,
              h = r - o,
              l = 2 + s + 1 + 1 + h,
              d = l < u,
              p = new Uint8Array((d ? 2 : 3) + l);
            let y = 0;
            return (
              (p[y++] = 48),
              d ? (p[y++] = l) : ((p[y++] = 129), (p[y++] = 255 & l)),
              (p[y++] = 2),
              (p[y++] = s),
              i < 0
                ? ((p[y++] = 0), p.set(t.subarray(0, r), y), (y += r))
                : (p.set(t.subarray(i, r), y), (y += r - i)),
              (p[y++] = 2),
              (p[y++] = h),
              o < 0
                ? ((p[y++] = 0), p.set(t.subarray(r), y))
                : p.set(t.subarray(r + o), y),
              p
            );
          });
      },
      68886: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.InvalidTokenError = e.MissingParametersError = void 0);
        class r extends Error {
          constructor(t) {
            super(),
              (this.name = "MissingParametersError"),
              (this.message = t || "");
          }
        }
        e.MissingParametersError = r;
        class n extends Error {
          constructor(t) {
            super(),
              (this.name = "InvalidTokenError"),
              (this.message = t || "");
          }
        }
        e.InvalidTokenError = n;
      },
      69057: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (t, e) {
              for (var r in t)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(e, r) ||
                  n(e, t, r);
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          i(r(90675), e),
          i(r(2695), e),
          i(r(21827), e),
          i(r(68886), e),
          i(r(61161), e);
      },
      90675: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (t, e, r, n) {
            return new (r || (r = Promise))(function (i, o) {
              function s(t) {
                try {
                  u(n.next(t));
                } catch (t) {
                  o(t);
                }
              }
              function a(t) {
                try {
                  u(n.throw(t));
                } catch (t) {
                  o(t);
                }
              }
              function u(t) {
                var e;
                t.done
                  ? i(t.value)
                  : ((e = t.value),
                    e instanceof r
                      ? e
                      : new r(function (t) {
                          t(e);
                        })).then(s, a);
              }
              u((n = n.apply(t, e || [])).next());
            });
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.TokenSigner = e.createUnsecuredToken = void 0);
        const i = r(35921),
          o = r(61161),
          s = r(68886),
          a = r(97990);
        function u(t, e) {
          const r = [],
            n = i.encode(JSON.stringify(e));
          r.push(n);
          const o = i.encode(JSON.stringify(t));
          r.push(o);
          return r.join(".");
        }
        e.createUnsecuredToken = function (t) {
          return u(t, { typ: "JWT", alg: "none" }) + ".";
        };
        e.TokenSigner = class {
          constructor(t, e) {
            if (!t || !e)
              throw new s.MissingParametersError(
                "a signing algorithm and private key are required",
              );
            if ("string" != typeof t)
              throw new Error("signing algorithm parameter must be a string");
            if (((t = t.toUpperCase()), !o.cryptoClients.hasOwnProperty(t)))
              throw new Error("invalid signing algorithm");
            (this.tokenType = "JWT"),
              (this.cryptoClient = o.cryptoClients[t]),
              (this.rawPrivateKey = e);
          }
          header(t = {}) {
            const e = {
              typ: this.tokenType,
              alg: this.cryptoClient.algorithmName,
            };
            return Object.assign({}, e, t);
          }
          sign(t, e = !1, r = {}) {
            const n = this.header(r),
              i = u(t, n),
              o = (0, a.hashSha256)(i);
            return this.createWithSignedHash(t, e, n, i, o);
          }
          signAsync(t, e = !1, r = {}) {
            return n(this, void 0, void 0, function* () {
              const n = this.header(r),
                i = u(t, n),
                o = yield (0, a.hashSha256Async)(i);
              return this.createWithSignedHash(t, e, n, i, o);
            });
          }
          createWithSignedHash(t, e, r, n, o) {
            const s = this.cryptoClient.signHash(o, this.rawPrivateKey);
            if (e) {
              return {
                header: [i.encode(JSON.stringify(r))],
                payload: JSON.stringify(t),
                signature: [s],
              };
            }
            return [n, s].join(".");
          }
        };
      },
      2695: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.TokenVerifier = void 0);
        const n = r(35921),
          i = r(61161),
          o = r(68886),
          s = r(97990);
        e.TokenVerifier = class {
          constructor(t, e) {
            if (!t || !e)
              throw new o.MissingParametersError(
                "a signing algorithm and public key are required",
              );
            if ("string" != typeof t)
              throw "signing algorithm parameter must be a string";
            if (((t = t.toUpperCase()), !i.cryptoClients.hasOwnProperty(t)))
              throw "invalid signing algorithm";
            (this.tokenType = "JWT"),
              (this.cryptoClient = i.cryptoClients[t]),
              (this.rawPublicKey = e);
          }
          verify(t) {
            return "string" == typeof t
              ? this.verifyCompact(t, !1)
              : "object" == typeof t && this.verifyExpanded(t, !1);
          }
          verifyAsync(t) {
            return "string" == typeof t
              ? this.verifyCompact(t, !0)
              : "object" == typeof t
                ? this.verifyExpanded(t, !0)
                : Promise.resolve(!1);
          }
          verifyCompact(t, e) {
            const r = t.split("."),
              n = r[0] + "." + r[1],
              i = (t) => {
                const e = this.cryptoClient.loadSignature(r[2]);
                return this.cryptoClient.verifyHash(t, e, this.rawPublicKey);
              };
            if (e) return (0, s.hashSha256Async)(n).then((t) => i(t));
            {
              const t = (0, s.hashSha256)(n);
              return i(t);
            }
          }
          verifyExpanded(t, e) {
            const r = [t.header.join("."), n.encode(t.payload)].join(".");
            let i = !0;
            const o = (e) => (
              t.signature.map((t) => {
                const r = this.cryptoClient.loadSignature(t);
                this.cryptoClient.verifyHash(e, r, this.rawPublicKey) ||
                  (i = !1);
              }),
              i
            );
            if (e) return (0, s.hashSha256Async)(r).then((t) => o(t));
            {
              const t = (0, s.hashSha256)(r);
              return o(t);
            }
          }
        };
      },
      76464: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.WalletPolicy =
            e.DefaultWalletPolicy =
            e.PsbtV2 =
            e.AppClient =
              void 0);
        const i = n(r(20732));
        e.AppClient = i.default;
        const o = r(47800);
        Object.defineProperty(e, "DefaultWalletPolicy", {
          enumerable: !0,
          get: function () {
            return o.DefaultWalletPolicy;
          },
        }),
          Object.defineProperty(e, "WalletPolicy", {
            enumerable: !0,
            get: function () {
              return o.WalletPolicy;
            },
          });
        const s = r(26377);
        Object.defineProperty(e, "PsbtV2", {
          enumerable: !0,
          get: function () {
            return s.PsbtV2;
          },
        }),
          (e.default = i.default);
      },
      20732: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.AppClient = e.PartialSignature = void 0);
        const i = r(31098),
          o = r(68759),
          s = r(42659),
          a = r(19416),
          u = r(26377),
          c = r(38632);
        var f, h;
        !(function (t) {
          (t[(t.GET_PUBKEY = 0)] = "GET_PUBKEY"),
            (t[(t.REGISTER_WALLET = 2)] = "REGISTER_WALLET"),
            (t[(t.GET_WALLET_ADDRESS = 3)] = "GET_WALLET_ADDRESS"),
            (t[(t.SIGN_PSBT = 4)] = "SIGN_PSBT"),
            (t[(t.GET_MASTER_FINGERPRINT = 5)] = "GET_MASTER_FINGERPRINT"),
            (t[(t.SIGN_MESSAGE = 16)] = "SIGN_MESSAGE");
        })(f || (f = {})),
          (function (t) {
            t[(t.CONTINUE_INTERRUPTED = 1)] = "CONTINUE_INTERRUPTED";
          })(h || (h = {}));
        class l {
          constructor(t, e, r) {
            (this.pubkey = t), (this.signature = e), (this.tapleafHash = r);
          }
        }
        function d(t, e) {
          if (64 == t.length) return new l(t.slice(0, 32), e, t.slice(32, 64));
          if (32 == t.length || 33 == t.length) return new l(t, e);
          throw new Error(`Invalid length for pubkeyAugm: ${t.length} bytes.`);
        }
        e.PartialSignature = l;
        class p {
          constructor(t) {
            this.transport = t;
          }
          async makeRequest(t, e, r) {
            let n = await this.transport.send(225, t, 0, 1, e, [36864, 57344]);
            for (; 57344 === n.readUInt16BE(n.length - 2); ) {
              if (!r) throw new Error("Unexpected SW_INTERRUPTED_EXECUTION");
              const t = n.slice(0, -2),
                e = r.execute(t);
              n = await this.transport.send(
                248,
                h.CONTINUE_INTERRUPTED,
                0,
                0,
                e,
                [36864, 57344],
              );
            }
            return n.slice(0, -2);
          }
          async getAppAndVersion() {
            const t = await this.transport.send(176, 1, 0, 0);
            let e = 0;
            if (1 !== t[e++]) throw new Error("Unexpected response");
            const r = t[e++],
              n = t.slice(e, (e += r)).toString("ascii"),
              i = t[e++],
              o = t.slice(e, (e += i)).toString("ascii"),
              s = t[e++];
            return { name: n, version: o, flags: t.slice(e, (e += s)) };
          }
          async getExtendedPubkey(t, e = !1) {
            const r = (0, i.pathStringToArray)(t);
            if (r.length > 6)
              throw new Error("Path too long. At most 6 levels allowed.");
            return (
              await this.makeRequest(
                f.GET_PUBKEY,
                n.concat([
                  n.from(e ? [1] : [0]),
                  (0, i.pathElementsToBuffer)(r),
                ]),
              )
            ).toString("ascii");
          }
          async registerWallet(t) {
            await this.validatePolicy(t);
            const e = new o.ClientCommandInterpreter();
            e.addKnownWalletPolicy(t);
            const r = t.serialize(),
              i = await this.makeRequest(
                f.REGISTER_WALLET,
                n.concat([(0, c.createVarint)(r.length), r]),
                e,
              );
            if (64 != i.length)
              throw Error(
                `Invalid response length. Expected 64 bytes, got ${i.length}`,
              );
            return [i.subarray(0, 32), i.subarray(32)];
          }
          async getWalletAddress(t, e, r, i, s) {
            if (0 !== r && 1 !== r)
              throw new Error("Change can only be 0 or 1");
            if (i < 0 || !Number.isInteger(i))
              throw new Error("Invalid address index");
            if (null != e && 32 != e.length)
              throw new Error("Invalid HMAC length");
            await this.validatePolicy(t);
            const a = new o.ClientCommandInterpreter();
            a.addKnownWalletPolicy(t);
            const u = n.alloc(4);
            u.writeUInt32BE(i, 0);
            return (
              await this.makeRequest(
                f.GET_WALLET_ADDRESS,
                n.concat([
                  n.from(s ? [1] : [0]),
                  t.getId(),
                  e || n.alloc(32, 0),
                  n.from([r]),
                  u,
                ]),
                a,
              )
            ).toString("ascii");
          }
          async signPsbt(t, e, r, i) {
            if (
              (await this.validatePolicy(e),
              "string" == typeof t && (t = n.from(t, "base64")),
              n.isBuffer(t))
            ) {
              const e = new u.PsbtV2();
              e.deserialize(t), (t = e);
            }
            const h = new s.MerkelizedPsbt(t);
            if (null != r && 32 != r.length)
              throw new Error("Invalid HMAC length");
            const l = new o.ClientCommandInterpreter(i);
            l.addKnownWalletPolicy(e), l.addKnownMapping(h.globalMerkleMap);
            for (const t of h.inputMerkleMaps) l.addKnownMapping(t);
            for (const t of h.outputMerkleMaps) l.addKnownMapping(t);
            l.addKnownList(h.inputMapCommitments);
            const p = new a.Merkle(
              h.inputMapCommitments.map((t) => (0, a.hashLeaf)(t)),
            ).getRoot();
            l.addKnownList(h.outputMapCommitments);
            const y = new a.Merkle(
              h.outputMapCommitments.map((t) => (0, a.hashLeaf)(t)),
            ).getRoot();
            await this.makeRequest(
              f.SIGN_PSBT,
              n.concat([
                h.getGlobalKeysValuesRoot(),
                (0, c.createVarint)(h.getGlobalInputCount()),
                p,
                (0, c.createVarint)(h.getGlobalOutputCount()),
                y,
                e.getId(),
                r || n.alloc(32, 0),
              ]),
              l,
            );
            const g = l.getYielded(),
              m = [];
            for (const t of g) {
              const [e, r] = (0, c.parseVarint)(t, 0),
                n = t[r],
                i = d(t.subarray(r + 1, r + 1 + n), t.subarray(r + 1 + n));
              m.push([Number(e), i]);
            }
            return m;
          }
          async getMasterFingerprint() {
            return (
              await this.makeRequest(f.GET_MASTER_FINGERPRINT, n.from([]))
            ).toString("hex");
          }
          async signMessage(t, e) {
            const r = (0, i.pathStringToArray)(e),
              s = new o.ClientCommandInterpreter(),
              u = Math.ceil(t.length / 64),
              h = [];
            for (let e = 0; e < u; e++) h.push(t.subarray(64 * e, 64 * e + 64));
            s.addKnownList(h);
            const l = new a.Merkle(h.map((t) => (0, a.hashLeaf)(t))).getRoot();
            return (
              await this.makeRequest(
                f.SIGN_MESSAGE,
                n.concat([
                  (0, i.pathElementsToBuffer)(r),
                  (0, c.createVarint)(t.length),
                  l,
                ]),
                s,
              )
            ).toString("base64");
          }
          async validatePolicy(t) {
            if (
              (t.descriptorTemplate.match(/[asctdvjnlu]+:/g) || []).some((t) =>
                t.includes("a"),
              )
            ) {
              const t = await this.getAppAndVersion();
              if (["2.1.0", "2.1.1"].includes(t.version))
                throw new Error("Please update your Ledger Bitcoin app.");
            }
          }
        }
        (e.AppClient = p), (e.default = p);
      },
      31098: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.hardenedPathOf =
            e.getXpubComponents =
            e.pubkeyFromXpub =
            e.pathStringToArray =
            e.pathArrayToString =
            e.bip32asBuffer =
            e.pathElementsToBuffer =
              void 0);
        const o = i(r(99235)),
          s = i(r(91889));
        function a(t) {
          const e = n.alloc(1 + 4 * t.length);
          return (
            (e[0] = t.length),
            t.forEach((t, r) => {
              e.writeUInt32BE(t, 1 + 4 * r);
            }),
            e
          );
        }
        function u(t) {
          return "m" == t || "" == t
            ? []
            : o.default.fromString(t).toPathArray();
        }
        (e.pathElementsToBuffer = a),
          (e.bip32asBuffer = function (t) {
            return a(t ? u(t) : []);
          }),
          (e.pathArrayToString = function (t) {
            return 0 == t.length ? "m" : o.default.fromPathArray(t).toString();
          }),
          (e.pathStringToArray = u),
          (e.pubkeyFromXpub = function (t) {
            const e = s.default.decode(t);
            return e.slice(e.length - 33);
          }),
          (e.getXpubComponents = function (t) {
            const e = s.default.decode(t);
            return {
              chaincode: e.slice(13, 45),
              pubkey: e.slice(e.length - 33),
              version: e.readUInt32BE(0),
            };
          }),
          (e.hardenedPathOf = function (t) {
            for (let e = t.length - 1; e >= 0; e--)
              if (t[e] >= 2147483648) return t.slice(0, e + 1);
            return [];
          });
      },
      76337: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.BufferReader =
            e.BufferWriter =
            e.unsafeFrom64bitLE =
            e.unsafeTo64bitLE =
              void 0);
        const i = r(38632);
        function o(t) {
          if (t > Number.MAX_SAFE_INTEGER)
            throw new Error("Can't convert numbers > MAX_SAFE_INT");
          const e = n.alloc(8, 0);
          for (let r = 0; r < e.length; r++) {
            const n = 255 & t;
            (e[r] = n), (t = (t - n) / 256);
          }
          return e;
        }
        function s(t) {
          let e = 0;
          if (8 != t.length) throw new Error("Expected Bufffer of lenght 8");
          if (0 != t[7]) throw new Error("Can't encode numbers > MAX_SAFE_INT");
          if (t[6] > 31) throw new Error("Can't encode numbers > MAX_SAFE_INT");
          for (let r = t.length - 1; r >= 0; r--) e = 256 * e + t[r];
          return e;
        }
        (e.unsafeTo64bitLE = o), (e.unsafeFrom64bitLE = s);
        e.BufferWriter = class {
          constructor() {
            this.bufs = [];
          }
          write(t, e) {
            const r = n.alloc(t);
            e(r), this.bufs.push(r);
          }
          writeUInt8(t) {
            this.write(1, (e) => e.writeUInt8(t, 0));
          }
          writeInt32(t) {
            this.write(4, (e) => e.writeInt32LE(t, 0));
          }
          writeUInt32(t) {
            this.write(4, (e) => e.writeUInt32LE(t, 0));
          }
          writeUInt64(t) {
            const e = o(t);
            this.writeSlice(e);
          }
          writeVarInt(t) {
            this.bufs.push((0, i.createVarint)(t));
          }
          writeSlice(t) {
            this.bufs.push(n.from(t));
          }
          writeVarSlice(t) {
            this.writeVarInt(t.length), this.writeSlice(t);
          }
          buffer() {
            return n.concat(this.bufs);
          }
        };
        e.BufferReader = class {
          constructor(t, e = 0) {
            (this.buffer = t), (this.offset = e);
          }
          available() {
            return this.buffer.length - this.offset;
          }
          readUInt8() {
            const t = this.buffer.readUInt8(this.offset);
            return this.offset++, t;
          }
          readInt32() {
            const t = this.buffer.readInt32LE(this.offset);
            return (this.offset += 4), t;
          }
          readUInt32() {
            const t = this.buffer.readUInt32LE(this.offset);
            return (this.offset += 4), t;
          }
          readUInt64() {
            return s(this.readSlice(8));
          }
          readVarInt() {
            const [t, e] = (0, i.parseVarint)(this.buffer, this.offset);
            return (this.offset += e), t;
          }
          readSlice(t) {
            if (this.buffer.length < this.offset + t)
              throw new Error("Cannot read slice out of bounds");
            const e = this.buffer.slice(this.offset, this.offset + t);
            return (this.offset += t), e;
          }
          readVarSlice() {
            const t = (0, i.sanitizeBigintToNumber)(this.readVarInt());
            return this.readSlice(t);
          }
          readVector() {
            const t = this.readVarInt(),
              e = [];
            for (let r = 0; r < t; r++) e.push(this.readVarSlice());
            return e;
          }
        };
      },
      68759: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ClientCommandInterpreter =
            e.GetMoreElementsCommand =
            e.GetMerkleLeafIndexCommand =
            e.GetMerkleLeafProofCommand =
            e.GetPreimageCommand =
            e.YieldCommand =
              void 0);
        const i = r(21757),
          o = r(76337),
          s = r(19416),
          a = r(38632);
        var u;
        !(function (t) {
          (t[(t.YIELD = 16)] = "YIELD"),
            (t[(t.GET_PREIMAGE = 64)] = "GET_PREIMAGE"),
            (t[(t.GET_MERKLE_LEAF_PROOF = 65)] = "GET_MERKLE_LEAF_PROOF"),
            (t[(t.GET_MERKLE_LEAF_INDEX = 66)] = "GET_MERKLE_LEAF_INDEX"),
            (t[(t.GET_MORE_ELEMENTS = 160)] = "GET_MORE_ELEMENTS");
        })(u || (u = {}));
        class c {}
        class f extends c {
          constructor(t, e) {
            super(),
              (this.progressCallback = e),
              (this.code = u.YIELD),
              (this.results = t);
          }
          execute(t) {
            return (
              this.results.push(n.from(t.subarray(1))),
              this.progressCallback && this.progressCallback(),
              n.from("")
            );
          }
        }
        e.YieldCommand = f;
        class h extends c {
          constructor(t, e) {
            super(),
              (this.code = u.GET_PREIMAGE),
              (this.known_preimages = t),
              (this.queue = e);
          }
          execute(t) {
            const e = n.from(t.subarray(1));
            if (33 != e.length)
              throw new Error("Invalid request, unexpected trailing data");
            if (0 != e[0])
              throw new Error(
                "Unsupported request, the first byte should be 0",
              );
            const r = n.alloc(32);
            for (let t = 0; t < 32; t++) r[t] = e[1 + t];
            const i = r.toString("hex"),
              o = this.known_preimages.get(i);
            if (null != o) {
              const t = (0, a.createVarint)(o.length),
                e = 255 - t.length - 1,
                r = Math.min(e, o.length);
              if (r < o.length)
                for (let t = r; t < o.length; t++)
                  this.queue.push(n.from([o[t]]));
              return n.concat([t, n.from([r]), n.from(o.subarray(0, r))]);
            }
            throw Error(`Requested unknown preimage for: ${i}`);
          }
        }
        e.GetPreimageCommand = h;
        class l extends c {
          constructor(t, e) {
            super(),
              (this.code = u.GET_MERKLE_LEAF_PROOF),
              (this.known_trees = t),
              (this.queue = e);
          }
          execute(t) {
            const e = n.from(t.subarray(1));
            if (e.length < 34)
              throw new Error("Invalid request, expected at least 34 bytes");
            const r = new o.BufferReader(e),
              i = r.readSlice(32).toString("hex");
            let s, u;
            try {
              (s = (0, a.sanitizeBigintToNumber)(r.readVarInt())),
                (u = (0, a.sanitizeBigintToNumber)(r.readVarInt()));
            } catch (t) {
              throw new Error(
                "Invalid request, couldn't parse tree_size or leaf_index",
              );
            }
            const c = this.known_trees.get(i);
            if (!c)
              throw Error(`Requested Merkle leaf proof for unknown tree: ${i}`);
            if (u >= s || c.size() != s)
              throw Error("Invalid index or tree size.");
            if (0 != this.queue.length)
              throw Error(
                "This command should not execute when the queue is not empty.",
              );
            const f = c.getProof(u),
              h = Math.min(Math.floor(221 / 32), f.length),
              l = f.length - h;
            return (
              l > 0 && this.queue.push(...f.slice(-l)),
              n.concat([
                c.getLeafHash(u),
                n.from([f.length]),
                n.from([h]),
                ...f.slice(0, h),
              ])
            );
          }
        }
        e.GetMerkleLeafProofCommand = l;
        class d extends c {
          constructor(t) {
            super(),
              (this.code = u.GET_MERKLE_LEAF_INDEX),
              (this.known_trees = t);
          }
          execute(t) {
            const e = n.from(t.subarray(1));
            if (64 != e.length)
              throw new Error("Invalid request, unexpected trailing data");
            const r = n.alloc(32);
            for (let t = 0; t < 32; t++) r[t] = e.readUInt8(t);
            const i = r.toString("hex"),
              o = n.alloc(32);
            for (let t = 0; t < 32; t++) o[t] = e.readUInt8(32 + t);
            const s = o.toString("hex"),
              u = this.known_trees.get(i);
            if (!u)
              throw Error(`Requested Merkle leaf index for unknown root: ${i}`);
            let c = 0,
              f = 0;
            for (let t = 0; t < u.size(); t++)
              if (u.getLeafHash(t).toString("hex") == s) {
                (f = 1), (c = t);
                break;
              }
            return n.concat([n.from([f]), (0, a.createVarint)(c)]);
          }
        }
        e.GetMerkleLeafIndexCommand = d;
        class p extends c {
          constructor(t) {
            super(), (this.code = u.GET_MORE_ELEMENTS), (this.queue = t);
          }
          execute(t) {
            if (1 != t.length)
              throw new Error("Invalid request, unexpected trailing data");
            if (0 === this.queue.length) throw new Error("No elements to get");
            const e = this.queue[0].length;
            if (this.queue.some((t) => t.length != e))
              throw new Error(
                "The queue contains elements with different byte length, which is not expected",
              );
            const r = Math.floor(253 / e),
              i = Math.min(r, this.queue.length),
              o = this.queue.splice(0, i);
            return n.concat([n.from([i]), n.from([e]), ...o]);
          }
        }
        e.GetMoreElementsCommand = p;
        e.ClientCommandInterpreter = class {
          constructor(t) {
            (this.roots = new Map()),
              (this.preimages = new Map()),
              (this.yielded = []),
              (this.queue = []),
              (this.commands = new Map());
            const e = [
              new f(this.yielded, t),
              new h(this.preimages, this.queue),
              new d(this.roots),
              new l(this.roots, this.queue),
              new p(this.queue),
            ];
            for (const t of e) {
              if (this.commands.has(t.code))
                throw new Error(`Multiple commands with code ${t.code}`);
              this.commands.set(t.code, t);
            }
          }
          getYielded() {
            return this.yielded;
          }
          addKnownPreimage(t) {
            this.preimages.set(i.crypto.sha256(t).toString("hex"), t);
          }
          addKnownList(t) {
            for (const e of t) {
              const t = n.concat([n.from([0]), e]);
              this.addKnownPreimage(t);
            }
            const e = new s.Merkle(t.map((t) => (0, s.hashLeaf)(t)));
            this.roots.set(e.getRoot().toString("hex"), e);
          }
          addKnownMapping(t) {
            this.addKnownList(t.keys), this.addKnownList(t.values);
          }
          addKnownWalletPolicy(t) {
            this.addKnownPreimage(t.serialize()),
              this.addKnownList(t.keys.map((t) => n.from(t, "ascii"))),
              this.addKnownPreimage(n.from(t.descriptorTemplate));
          }
          execute(t) {
            if (0 == t.length) throw new Error("Unexpected empty command");
            const e = t[0],
              r = this.commands.get(e);
            if (!r) throw new Error(`Unexpected command code ${e}`);
            return r.execute(t);
          }
        };
      },
      42659: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.MerkelizedPsbt = void 0);
        const i = r(83480),
          o = r(26377);
        class s extends o.PsbtV2 {
          constructor(t) {
            super(),
              (this.inputMerkleMaps = []),
              (this.outputMerkleMaps = []),
              t.copy(this),
              (this.globalMerkleMap = s.createMerkleMap(this.globalMap));
            for (let t = 0; t < this.getGlobalInputCount(); t++)
              this.inputMerkleMaps.push(s.createMerkleMap(this.inputMaps[t]));
            this.inputMapCommitments = [...this.inputMerkleMaps.values()].map(
              (t) => t.commitment(),
            );
            for (let t = 0; t < this.getGlobalOutputCount(); t++)
              this.outputMerkleMaps.push(s.createMerkleMap(this.outputMaps[t]));
            this.outputMapCommitments = [...this.outputMerkleMaps.values()].map(
              (t) => t.commitment(),
            );
          }
          getGlobalSize() {
            return this.globalMap.size;
          }
          getGlobalKeysValuesRoot() {
            return this.globalMerkleMap.commitment();
          }
          static createMerkleMap(t) {
            const e = [...t.keys()].sort(),
              r = e.map((e) => {
                const r = t.get(e);
                if (!r) throw new Error("No value for key " + e);
                return r;
              }),
              o = e.map((t) => n.from(t, "hex"));
            return new i.MerkleMap(o, r);
          }
        }
        e.MerkelizedPsbt = s;
      },
      19416: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.hashLeaf = e.Merkle = void 0);
        const i = r(21757);
        (e.Merkle = class {
          constructor(t, e = i.crypto.sha256) {
            (this.leaves = t), (this.h = e);
            const r = this.calculateRoot(t);
            (this.rootNode = r.root), (this.leafNodes = r.leaves);
          }
          getRoot() {
            return this.rootNode.hash;
          }
          size() {
            return this.leaves.length;
          }
          getLeaves() {
            return this.leaves;
          }
          getLeafHash(t) {
            return this.leafNodes[t].hash;
          }
          getProof(t) {
            if (t >= this.leaves.length) throw Error("Index out of bounds");
            return s(this.leafNodes[t]);
          }
          calculateRoot(t) {
            const e = t.length;
            if (0 == e)
              return {
                root: new o(void 0, void 0, n.alloc(32, 0)),
                leaves: [],
              };
            if (1 == e) {
              const e = new o(void 0, void 0, t[0]);
              return { root: e, leaves: [e] };
            }
            const r = (function (t) {
                if (t < 2) throw Error("Expected n >= 2");
                if (
                  (function (t) {
                    return !(t & (t - 1));
                  })(t)
                )
                  return t / 2;
                return 1 << Math.floor(Math.log2(t));
              })(e),
              i = this.calculateRoot(t.slice(0, r)),
              s = this.calculateRoot(t.slice(r)),
              a = i.root,
              u = s.root,
              c = this.hashNode(a.hash, u.hash),
              f = new o(a, u, c);
            return (
              (a.parent = f),
              (u.parent = f),
              { root: f, leaves: i.leaves.concat(s.leaves) }
            );
          }
          hashNode(t, e) {
            return this.h(n.concat([n.from([1]), t, e]));
          }
        }),
          (e.hashLeaf = function (t, e = i.crypto.sha256) {
            return (function (t, e, r) {
              return r(n.concat([t, e]));
            })(n.from([0]), t, e);
          });
        class o {
          constructor(t, e, r) {
            (this.leftChild = t), (this.rightChild = e), (this.hash = r);
          }
          isLeaf() {
            return null == this.leftChild;
          }
        }
        function s(t) {
          if (!t.parent) return [];
          if (t.parent.leftChild == t) {
            if (!t.parent.rightChild)
              throw new Error("Expected right child to exist");
            return [t.parent.rightChild.hash, ...s(t.parent)];
          }
          if (!t.parent.leftChild)
            throw new Error("Expected left child to exist");
          return [t.parent.leftChild.hash, ...s(t.parent)];
        }
      },
      83480: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.MerkleMap = void 0);
        const i = r(19416),
          o = r(38632);
        e.MerkleMap = class {
          constructor(t, e) {
            if (t.length != e.length)
              throw new Error("keys and values should have the same length");
            for (let e = 0; e < t.length - 1; e++)
              if (t[e].toString("hex") >= t[e + 1].toString("hex"))
                throw new Error("keys must be in strictly increasing order");
            (this.keys = t),
              (this.keysTree = new i.Merkle(t.map((t) => (0, i.hashLeaf)(t)))),
              (this.values = e),
              (this.valuesTree = new i.Merkle(
                e.map((t) => (0, i.hashLeaf)(t)),
              ));
          }
          commitment() {
            return n.concat([
              (0, o.createVarint)(this.keys.length),
              this.keysTree.getRoot(),
              this.valuesTree.getRoot(),
            ]);
          }
        };
      },
      47800: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.DefaultWalletPolicy = e.WalletPolicy = void 0);
        const i = r(21757),
          o = r(76337),
          s = r(19416);
        class a {
          constructor(t, e, r) {
            (this.name = t), (this.descriptorTemplate = e), (this.keys = r);
          }
          getId() {
            return i.crypto.sha256(this.serialize());
          }
          serialize() {
            const t = this.keys.map((t) => n.from(t, "ascii")),
              e = new s.Merkle(t.map((t) => (0, s.hashLeaf)(t))),
              r = new o.BufferWriter();
            return (
              r.writeUInt8(2),
              r.writeVarSlice(n.from(this.name, "ascii")),
              r.writeVarInt(this.descriptorTemplate.length),
              r.writeSlice(i.crypto.sha256(n.from(this.descriptorTemplate))),
              r.writeVarInt(this.keys.length),
              r.writeSlice(e.getRoot()),
              r.buffer()
            );
          }
        }
        e.WalletPolicy = a;
        e.DefaultWalletPolicy = class extends a {
          constructor(t, e) {
            super("", t, [e]);
          }
        };
      },
      26377: function (t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          o =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    i(e, t, r);
              return o(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.PsbtV2 =
            e.NoSuchEntry =
            e.psbtOut =
            e.psbtIn =
            e.psbtGlobal =
              void 0);
        const a = s(r(21757)),
          u = r(76337),
          c = r(38632);
        var f, h, l;
        !(function (t) {
          (t[(t.UNSIGNED_TX = 0)] = "UNSIGNED_TX"),
            (t[(t.XPUB = 1)] = "XPUB"),
            (t[(t.TX_VERSION = 2)] = "TX_VERSION"),
            (t[(t.FALLBACK_LOCKTIME = 3)] = "FALLBACK_LOCKTIME"),
            (t[(t.INPUT_COUNT = 4)] = "INPUT_COUNT"),
            (t[(t.OUTPUT_COUNT = 5)] = "OUTPUT_COUNT"),
            (t[(t.TX_MODIFIABLE = 6)] = "TX_MODIFIABLE"),
            (t[(t.VERSION = 251)] = "VERSION");
        })((f = e.psbtGlobal || (e.psbtGlobal = {}))),
          (function (t) {
            (t[(t.NON_WITNESS_UTXO = 0)] = "NON_WITNESS_UTXO"),
              (t[(t.WITNESS_UTXO = 1)] = "WITNESS_UTXO"),
              (t[(t.PARTIAL_SIG = 2)] = "PARTIAL_SIG"),
              (t[(t.SIGHASH_TYPE = 3)] = "SIGHASH_TYPE"),
              (t[(t.REDEEM_SCRIPT = 4)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 5)] = "WITNESS_SCRIPT"),
              (t[(t.BIP32_DERIVATION = 6)] = "BIP32_DERIVATION"),
              (t[(t.FINAL_SCRIPTSIG = 7)] = "FINAL_SCRIPTSIG"),
              (t[(t.FINAL_SCRIPTWITNESS = 8)] = "FINAL_SCRIPTWITNESS"),
              (t[(t.PREVIOUS_TXID = 14)] = "PREVIOUS_TXID"),
              (t[(t.OUTPUT_INDEX = 15)] = "OUTPUT_INDEX"),
              (t[(t.SEQUENCE = 16)] = "SEQUENCE"),
              (t[(t.TAP_KEY_SIG = 19)] = "TAP_KEY_SIG"),
              (t[(t.TAP_BIP32_DERIVATION = 22)] = "TAP_BIP32_DERIVATION");
          })((h = e.psbtIn || (e.psbtIn = {}))),
          (function (t) {
            (t[(t.REDEEM_SCRIPT = 0)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 1)] = "WITNESS_SCRIPT"),
              (t[(t.BIP_32_DERIVATION = 2)] = "BIP_32_DERIVATION"),
              (t[(t.AMOUNT = 3)] = "AMOUNT"),
              (t[(t.SCRIPT = 4)] = "SCRIPT"),
              (t[(t.TAP_BIP32_DERIVATION = 7)] = "TAP_BIP32_DERIVATION");
          })((l = e.psbtOut || (e.psbtOut = {})));
        const d = n.from([112, 115, 98, 116, 255]);
        class p extends Error {}
        e.NoSuchEntry = p;
        function y(t, e, r, i) {
          if (!t) throw Error("No such map");
          const o = new g(e, r),
            s = t.get(o.toString());
          if (!s) {
            if (i) return;
            throw new p(o.toString());
          }
          return n.from(s);
        }
        e.PsbtV2 = class {
          constructor() {
            (this.globalMap = new Map()),
              (this.inputMaps = []),
              (this.outputMaps = []);
          }
          setGlobalTxVersion(t) {
            this.setGlobal(f.TX_VERSION, E(t));
          }
          getGlobalTxVersion() {
            return this.getGlobal(f.TX_VERSION).readUInt32LE(0);
          }
          setGlobalFallbackLocktime(t) {
            this.setGlobal(f.FALLBACK_LOCKTIME, E(t));
          }
          getGlobalFallbackLocktime() {
            var t;
            return null === (t = this.getGlobalOptional(f.FALLBACK_LOCKTIME)) ||
              void 0 === t
              ? void 0
              : t.readUInt32LE(0);
          }
          setGlobalInputCount(t) {
            this.setGlobal(f.INPUT_COUNT, I(t));
          }
          getGlobalInputCount() {
            return M(this.getGlobal(f.INPUT_COUNT));
          }
          setGlobalOutputCount(t) {
            this.setGlobal(f.OUTPUT_COUNT, I(t));
          }
          getGlobalOutputCount() {
            return M(this.getGlobal(f.OUTPUT_COUNT));
          }
          setGlobalTxModifiable(t) {
            this.setGlobal(f.TX_MODIFIABLE, t);
          }
          getGlobalTxModifiable() {
            return this.getGlobalOptional(f.TX_MODIFIABLE);
          }
          setGlobalPsbtVersion(t) {
            this.setGlobal(f.VERSION, E(t));
          }
          getGlobalPsbtVersion() {
            return this.getGlobal(f.VERSION).readUInt32LE(0);
          }
          setInputNonWitnessUtxo(t, e) {
            this.setInput(t, h.NON_WITNESS_UTXO, v(), e);
          }
          getInputNonWitnessUtxo(t) {
            return this.getInputOptional(t, h.NON_WITNESS_UTXO, v());
          }
          setInputWitnessUtxo(t, e, r) {
            const n = new u.BufferWriter();
            n.writeSlice(S(e)),
              n.writeVarSlice(r),
              this.setInput(t, h.WITNESS_UTXO, v(), n.buffer());
          }
          getInputWitnessUtxo(t) {
            const e = this.getInputOptional(t, h.WITNESS_UTXO, v());
            if (!e) return;
            const r = new u.BufferReader(e);
            return {
              amount: (0, u.unsafeFrom64bitLE)(r.readSlice(8)),
              scriptPubKey: r.readVarSlice(),
            };
          }
          setInputPartialSig(t, e, r) {
            this.setInput(t, h.PARTIAL_SIG, e, r);
          }
          getInputPartialSig(t, e) {
            return this.getInputOptional(t, h.PARTIAL_SIG, e);
          }
          setInputSighashType(t, e) {
            this.setInput(t, h.SIGHASH_TYPE, v(), E(e));
          }
          getInputSighashType(t) {
            const e = this.getInputOptional(t, h.SIGHASH_TYPE, v());
            if (e) return e.readUInt32LE(0);
          }
          setInputRedeemScript(t, e) {
            this.setInput(t, h.REDEEM_SCRIPT, v(), e);
          }
          getInputRedeemScript(t) {
            return this.getInputOptional(t, h.REDEEM_SCRIPT, v());
          }
          setInputWitnessScript(t, e) {
            this.setInput(t, h.WITNESS_SCRIPT, v(), e);
          }
          getInputWitnessScript(t) {
            return this.getInputOptional(t, h.WITNESS_SCRIPT, v());
          }
          setInputBip32Derivation(t, e, r, n) {
            if (33 != e.length)
              throw new Error("Invalid pubkey length: " + e.length);
            this.setInput(
              t,
              h.BIP32_DERIVATION,
              e,
              this.encodeBip32Derivation(r, n),
            );
          }
          getInputBip32Derivation(t, e) {
            const r = this.getInputOptional(t, h.BIP32_DERIVATION, e);
            if (r) return this.decodeBip32Derivation(r);
          }
          setInputFinalScriptsig(t, e) {
            this.setInput(t, h.FINAL_SCRIPTSIG, v(), e);
          }
          getInputFinalScriptsig(t) {
            return this.getInputOptional(t, h.FINAL_SCRIPTSIG, v());
          }
          setInputFinalScriptwitness(t, e) {
            this.setInput(t, h.FINAL_SCRIPTWITNESS, v(), e);
          }
          getInputFinalScriptwitness(t) {
            return this.getInput(t, h.FINAL_SCRIPTWITNESS, v());
          }
          setInputPreviousTxId(t, e) {
            this.setInput(t, h.PREVIOUS_TXID, v(), e);
          }
          getInputPreviousTxid(t) {
            return this.getInput(t, h.PREVIOUS_TXID, v());
          }
          setInputOutputIndex(t, e) {
            this.setInput(t, h.OUTPUT_INDEX, v(), E(e));
          }
          getInputOutputIndex(t) {
            return this.getInput(t, h.OUTPUT_INDEX, v()).readUInt32LE(0);
          }
          setInputSequence(t, e) {
            this.setInput(t, h.SEQUENCE, v(), E(e));
          }
          getInputSequence(t) {
            var e, r;
            return null !==
              (r =
                null === (e = this.getInputOptional(t, h.SEQUENCE, v())) ||
                void 0 === e
                  ? void 0
                  : e.readUInt32LE(0)) && void 0 !== r
              ? r
              : 4294967295;
          }
          setInputTapKeySig(t, e) {
            this.setInput(t, h.TAP_KEY_SIG, v(), e);
          }
          getInputTapKeySig(t) {
            return this.getInputOptional(t, h.TAP_KEY_SIG, v());
          }
          setInputTapBip32Derivation(t, e, r, n, i) {
            if (32 != e.length)
              throw new Error("Invalid pubkey length: " + e.length);
            const o = this.encodeTapBip32Derivation(r, n, i);
            this.setInput(t, h.TAP_BIP32_DERIVATION, e, o);
          }
          getInputTapBip32Derivation(t, e) {
            const r = this.getInput(t, h.TAP_BIP32_DERIVATION, e);
            return this.decodeTapBip32Derivation(r);
          }
          getInputKeyDatas(t, e) {
            return this.getKeyDatas(this.inputMaps[t], e);
          }
          setOutputRedeemScript(t, e) {
            this.setOutput(t, l.REDEEM_SCRIPT, v(), e);
          }
          getOutputRedeemScript(t) {
            return this.getOutput(t, l.REDEEM_SCRIPT, v());
          }
          setOutputBip32Derivation(t, e, r, n) {
            this.setOutput(
              t,
              l.BIP_32_DERIVATION,
              e,
              this.encodeBip32Derivation(r, n),
            );
          }
          getOutputBip32Derivation(t, e) {
            const r = this.getOutput(t, l.BIP_32_DERIVATION, e);
            return this.decodeBip32Derivation(r);
          }
          setOutputAmount(t, e) {
            this.setOutput(t, l.AMOUNT, v(), S(e));
          }
          getOutputAmount(t) {
            const e = this.getOutput(t, l.AMOUNT, v());
            return (0, u.unsafeFrom64bitLE)(e);
          }
          setOutputScript(t, e) {
            this.setOutput(t, l.SCRIPT, v(), e);
          }
          getOutputScript(t) {
            return this.getOutput(t, l.SCRIPT, v());
          }
          setOutputTapBip32Derivation(t, e, r, n, i) {
            const o = this.encodeTapBip32Derivation(r, n, i);
            this.setOutput(t, l.TAP_BIP32_DERIVATION, e, o);
          }
          getOutputTapBip32Derivation(t, e) {
            const r = this.getOutput(t, l.TAP_BIP32_DERIVATION, e);
            return this.decodeTapBip32Derivation(r);
          }
          deleteInputEntries(t, e) {
            this.inputMaps[t].forEach((t, r, n) => {
              this.isKeyType(r, e) && n.delete(r);
            });
          }
          copy(t) {
            this.copyMap(this.globalMap, t.globalMap),
              this.copyMaps(this.inputMaps, t.inputMaps),
              this.copyMaps(this.outputMaps, t.outputMaps);
          }
          copyMaps(t, e) {
            t.forEach((t, r) => {
              const n = new Map();
              this.copyMap(t, n), (e[r] = n);
            });
          }
          copyMap(t, e) {
            t.forEach((t, r) => e.set(r, n.from(t)));
          }
          serialize() {
            const t = new u.BufferWriter();
            return (
              t.writeSlice(n.from([112, 115, 98, 116, 255])),
              w(t, this.globalMap),
              this.inputMaps.forEach((e) => {
                w(t, e);
              }),
              this.outputMaps.forEach((e) => {
                w(t, e);
              }),
              t.buffer()
            );
          }
          deserialize(t) {
            const e = new u.BufferReader(t);
            if (!e.readSlice(5).equals(d))
              throw new Error("Invalid magic bytes");
            for (; this.readKeyPair(this.globalMap, e); );
            let r, n, i;
            try {
              r = this.getGlobalPsbtVersion();
            } catch (t) {
              r = 0;
            }
            if (0 !== r && 2 !== r)
              throw new Error("Only PSBTs of version 0 or 2 are supported");
            if (0 == r) {
              const t = this.getGlobal(f.UNSIGNED_TX),
                e = a.Transaction.fromBuffer(t);
              (n = e.ins.length), (i = e.outs.length);
            } else
              (n = this.getGlobalInputCount()),
                (i = this.getGlobalOutputCount());
            for (let t = 0; t < n; t++)
              for (
                this.inputMaps[t] = new Map();
                this.readKeyPair(this.inputMaps[t], e);

              );
            for (let t = 0; t < i; t++)
              for (
                this.outputMaps[t] = new Map();
                this.readKeyPair(this.outputMaps[t], e);

              );
            this.normalizeToV2();
          }
          normalizeToV2() {
            var t;
            const e =
              null === (t = this.getGlobalOptional(f.VERSION)) || void 0 === t
                ? void 0
                : t.readInt32LE(0);
            if (2 === e) return;
            if (void 0 !== e)
              throw new Error(
                "Invalid or unsupported value for PSBT_GLOBAL_VERSION",
              );
            const r = this.getGlobal(f.UNSIGNED_TX),
              n = a.Transaction.fromBuffer(r);
            this.setGlobalPsbtVersion(2),
              this.setGlobalTxVersion(n.version),
              this.setGlobalFallbackLocktime(n.locktime),
              this.setGlobalInputCount(n.ins.length),
              this.setGlobalOutputCount(n.outs.length);
            for (let t = 0; t < n.ins.length; t++)
              this.setInputPreviousTxId(t, n.ins[t].hash),
                this.setInputOutputIndex(t, n.ins[t].index),
                this.setInputSequence(t, n.ins[t].sequence);
            for (let t = 0; t < n.outs.length; t++)
              this.setOutputAmount(t, n.outs[t].value),
                this.setOutputScript(t, n.outs[t].script);
            this.globalMap.delete(f.UNSIGNED_TX.toString(16).padStart(2, "0"));
          }
          fromBitcoinJS(t) {
            return (
              this.setGlobalPsbtVersion(2),
              this.setGlobalTxVersion(t.version),
              this.setGlobalInputCount(t.data.inputs.length),
              this.setGlobalOutputCount(t.txOutputs.length),
              void 0 !== t.locktime &&
                this.setGlobalFallbackLocktime(t.locktime),
              t.data.inputs.forEach((e, r) => {
                if (
                  (function (t) {
                    let e;
                    try {
                      a.payments.p2tr({ output: t.witnessUtxo.script }),
                        (e = !0);
                    } catch (t) {
                      e = !1;
                    }
                    return (
                      t &&
                      !!(
                        t.tapInternalKey ||
                        t.tapMerkleRoot ||
                        (t.tapLeafScript && t.tapLeafScript.length) ||
                        (t.tapBip32Derivation && t.tapBip32Derivation.length) ||
                        e
                      )
                    );
                  })(e)
                )
                  throw new Error("Taproot inputs not supported");
                this.setInputPreviousTxId(r, t.txInputs[r].hash),
                  void 0 !== t.txInputs[r].sequence &&
                    this.setInputSequence(r, t.txInputs[r].sequence),
                  this.setInputOutputIndex(r, t.txInputs[r].index),
                  void 0 !== e.sighashType &&
                    this.setInputSighashType(r, e.sighashType),
                  e.nonWitnessUtxo &&
                    this.setInputNonWitnessUtxo(r, e.nonWitnessUtxo),
                  e.witnessUtxo &&
                    this.setInputWitnessUtxo(
                      r,
                      e.witnessUtxo.value,
                      e.witnessUtxo.script,
                    ),
                  e.witnessScript &&
                    this.setInputWitnessScript(r, e.witnessScript),
                  e.redeemScript &&
                    this.setInputRedeemScript(r, e.redeemScript),
                  t.data.inputs[r].bip32Derivation.forEach((t) => {
                    if (!/^m\//i.test(t.path))
                      throw new Error("Invalid input bip32 derivation");
                    const e = t.path
                      .replace(/m\//i, "")
                      .split("/")
                      .map((t) =>
                        t.match(/['h]/i) ? parseInt(t) + 2147483648 : Number(t),
                      );
                    this.setInputBip32Derivation(
                      r,
                      t.pubkey,
                      t.masterFingerprint,
                      e,
                    );
                  });
              }),
              t.txOutputs.forEach((t, e) => {
                this.setOutputAmount(e, t.value),
                  this.setOutputScript(e, t.script);
              }),
              this
            );
          }
          readKeyPair(t, e) {
            const r = (0, c.sanitizeBigintToNumber)(e.readVarInt());
            if (0 == r) return !1;
            return (
              _(t, e.readUInt8(), e.readSlice(r - 1), e.readVarSlice()), !0
            );
          }
          getKeyDatas(t, e) {
            const r = [];
            return (
              t.forEach((t, i) => {
                this.isKeyType(i, [e]) && r.push(n.from(i.substring(2), "hex"));
              }),
              r
            );
          }
          isKeyType(t, e) {
            const r = n.from(t.substring(0, 2), "hex").readUInt8(0);
            return e.some((t) => t == r);
          }
          setGlobal(t, e) {
            const r = new g(t, n.from([]));
            this.globalMap.set(r.toString(), e);
          }
          getGlobal(t) {
            return y(this.globalMap, t, v(), !1);
          }
          getGlobalOptional(t) {
            return y(this.globalMap, t, v(), !0);
          }
          setInput(t, e, r, n) {
            _(this.getMap(t, this.inputMaps), e, r, n);
          }
          getInput(t, e, r) {
            return y(this.inputMaps[t], e, r, !1);
          }
          getInputOptional(t, e, r) {
            return y(this.inputMaps[t], e, r, !0);
          }
          setOutput(t, e, r, n) {
            _(this.getMap(t, this.outputMaps), e, r, n);
          }
          getOutput(t, e, r) {
            return y(this.outputMaps[t], e, r, !1);
          }
          getMap(t, e) {
            return e[t] ? e[t] : (e[t] = new Map());
          }
          encodeBip32Derivation(t, e) {
            const r = new u.BufferWriter();
            return this.writeBip32Derivation(r, t, e), r.buffer();
          }
          decodeBip32Derivation(t) {
            const e = new u.BufferReader(t);
            return this.readBip32Derivation(e);
          }
          writeBip32Derivation(t, e, r) {
            t.writeSlice(e),
              r.forEach((e) => {
                t.writeUInt32(e);
              });
          }
          readBip32Derivation(t) {
            const e = t.readSlice(4),
              r = [];
            for (; t.offset < t.buffer.length; ) r.push(t.readUInt32());
            return { masterFingerprint: e, path: r };
          }
          encodeTapBip32Derivation(t, e, r) {
            const n = new u.BufferWriter();
            return (
              n.writeVarInt(t.length),
              t.forEach((t) => {
                n.writeSlice(t);
              }),
              this.writeBip32Derivation(n, e, r),
              n.buffer()
            );
          }
          decodeTapBip32Derivation(t) {
            const e = new u.BufferReader(t),
              r = (0, c.sanitizeBigintToNumber)(e.readVarInt()),
              n = [];
            for (let t = 0; t < r; t++) n.push(e.readSlice(32));
            const i = this.readBip32Derivation(e);
            return Object.assign({ hashes: n }, i);
          }
        };
        class g {
          constructor(t, e) {
            (this.keyType = t), (this.keyData = e);
          }
          toString() {
            const t = new u.BufferWriter();
            return this.toBuffer(t), t.buffer().toString("hex");
          }
          serialize(t) {
            t.writeVarInt(1 + this.keyData.length), this.toBuffer(t);
          }
          toBuffer(t) {
            t.writeUInt8(this.keyType), t.writeSlice(this.keyData);
          }
        }
        class m {
          constructor(t, e) {
            (this.key = t), (this.value = e);
          }
          serialize(t) {
            this.key.serialize(t), t.writeVarSlice(this.value);
          }
        }
        function b(t) {
          return new g(t.readUInt8(0), t.slice(1));
        }
        function w(t, e) {
          for (let [r, i] of [...e].sort(([t], [e]) => t.localeCompare(e))) {
            new m(b(n.from(r, "hex")), i).serialize(t);
          }
          t.writeUInt8(0);
        }
        function v() {
          return n.from([]);
        }
        function _(t, e, r, n) {
          const i = new g(e, r);
          t.set(i.toString(), n);
        }
        function E(t) {
          const e = n.alloc(4);
          return e.writeUInt32LE(t, 0), e;
        }
        function S(t) {
          return (0, u.unsafeTo64bitLE)(t);
        }
        function I(t) {
          const e = new u.BufferWriter();
          return e.writeVarInt(t), e.buffer();
        }
        function M(t) {
          return (0, c.sanitizeBigintToNumber)(
            new u.BufferReader(t).readVarInt(),
          );
        }
      },
      38632: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        function i(t, e, r) {
          let n = BigInt(0);
          for (let i = 0; i < r; i++) {
            if (null == t[i + e]) throw Error("Buffer too small");
            n += BigInt(t[i + e]) << BigInt(8 * i);
          }
          return n;
        }
        function o(t) {
          if (t < 0) throw RangeError("Negative bigint is not a valid varint");
          if (t > Number.MAX_SAFE_INTEGER)
            throw RangeError("Too large for a Number");
          return Number(t);
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.createVarint = e.parseVarint = e.sanitizeBigintToNumber = void 0),
          (e.sanitizeBigintToNumber = o),
          (e.parseVarint = function (t, e) {
            if (e < 0) throw RangeError("Negative offset is invalid");
            if (null == t[e]) throw Error("Buffer too small");
            if (t[e] < 253) return [BigInt(t[e]), 1];
            {
              let r;
              return (
                (r = 253 === t[e] ? 2 : 254 === t[e] ? 4 : 8),
                [i(t, e + 1, r), r + 1]
              );
            }
          }),
          (e.createVarint = function (t) {
            "number" == typeof t && (t = o(t));
            const e = (function (t) {
              if (("number" == typeof t && (t = o(t)), t < BigInt(0)))
                throw new RangeError("Negative numbers are not supported");
              if (t >= BigInt(1) << BigInt(64))
                throw new RangeError("Too large for a Bitcoin-style varint");
              return t < BigInt(253)
                ? 1
                : t <= BigInt(65535)
                  ? 3
                  : t <= BigInt(4294967295)
                    ? 5
                    : 9;
            })(t);
            t = BigInt(t);
            const r = n.alloc(e);
            return (
              1 == e
                ? (r[0] = Number(t))
                : ((r[0] = 3 == e ? 253 : 5 === e ? 254 : 255),
                  (function (t, e, r, n) {
                    for (let i = 0; i < e; i++) {
                      if (null == r[i + n]) throw Error("Buffer too small");
                      (r[i + n] = Number(t % BigInt(256))), (t >>= BigInt(8));
                    }
                  })(t, e - 1, r, 1)),
              r
            );
          });
      },
      67193: (t, e, r) => {
        t = r.nmd(t);
        var n = "__lodash_hash_undefined__",
          i = 9007199254740991,
          o = "[object Arguments]",
          s = "[object Boolean]",
          a = "[object Date]",
          u = "[object Function]",
          c = "[object GeneratorFunction]",
          f = "[object Map]",
          h = "[object Number]",
          l = "[object Object]",
          d = "[object Promise]",
          p = "[object RegExp]",
          y = "[object Set]",
          g = "[object String]",
          m = "[object Symbol]",
          b = "[object WeakMap]",
          w = "[object ArrayBuffer]",
          v = "[object DataView]",
          _ = "[object Float32Array]",
          E = "[object Float64Array]",
          S = "[object Int8Array]",
          I = "[object Int16Array]",
          M = "[object Int32Array]",
          A = "[object Uint8Array]",
          T = "[object Uint8ClampedArray]",
          k = "[object Uint16Array]",
          O = "[object Uint32Array]",
          x = /\w*$/,
          P = /^\[object .+?Constructor\]$/,
          B = /^(?:0|[1-9]\d*)$/,
          C = {};
        (C[o] =
          C["[object Array]"] =
          C[w] =
          C[v] =
          C[s] =
          C[a] =
          C[_] =
          C[E] =
          C[S] =
          C[I] =
          C[M] =
          C[f] =
          C[h] =
          C[l] =
          C[p] =
          C[y] =
          C[g] =
          C[m] =
          C[A] =
          C[T] =
          C[k] =
          C[O] =
            !0),
          (C["[object Error]"] = C[u] = C[b] = !1);
        var R = "object" == typeof r.g && r.g && r.g.Object === Object && r.g,
          N = "object" == typeof self && self && self.Object === Object && self,
          U = R || N || Function("return this")(),
          D = e && !e.nodeType && e,
          L = D && t && !t.nodeType && t,
          j = L && L.exports === D;
        function F(t, e) {
          return t.set(e[0], e[1]), t;
        }
        function H(t, e) {
          return t.add(e), t;
        }
        function K(t, e, r, n) {
          var i = -1,
            o = t ? t.length : 0;
          for (n && o && (r = t[++i]); ++i < o; ) r = e(r, t[i], i, t);
          return r;
        }
        function V(t) {
          var e = !1;
          if (null != t && "function" != typeof t.toString)
            try {
              e = !!(t + "");
            } catch (t) {}
          return e;
        }
        function q(t) {
          var e = -1,
            r = Array(t.size);
          return (
            t.forEach(function (t, n) {
              r[++e] = [n, t];
            }),
            r
          );
        }
        function z(t, e) {
          return function (r) {
            return t(e(r));
          };
        }
        function $(t) {
          var e = -1,
            r = Array(t.size);
          return (
            t.forEach(function (t) {
              r[++e] = t;
            }),
            r
          );
        }
        var G,
          W = Array.prototype,
          Y = Function.prototype,
          X = Object.prototype,
          Z = U["__core-js_shared__"],
          J = (G = /[^.]+$/.exec((Z && Z.keys && Z.keys.IE_PROTO) || ""))
            ? "Symbol(src)_1." + G
            : "",
          Q = Y.toString,
          tt = X.hasOwnProperty,
          et = X.toString,
          rt = RegExp(
            "^" +
              Q.call(tt)
                .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?",
                ) +
              "$",
          ),
          nt = j ? U.Buffer : void 0,
          it = U.Symbol,
          ot = U.Uint8Array,
          st = z(Object.getPrototypeOf, Object),
          at = Object.create,
          ut = X.propertyIsEnumerable,
          ct = W.splice,
          ft = Object.getOwnPropertySymbols,
          ht = nt ? nt.isBuffer : void 0,
          lt = z(Object.keys, Object),
          dt = Lt(U, "DataView"),
          pt = Lt(U, "Map"),
          yt = Lt(U, "Promise"),
          gt = Lt(U, "Set"),
          mt = Lt(U, "WeakMap"),
          bt = Lt(Object, "create"),
          wt = Vt(dt),
          vt = Vt(pt),
          _t = Vt(yt),
          Et = Vt(gt),
          St = Vt(mt),
          It = it ? it.prototype : void 0,
          Mt = It ? It.valueOf : void 0;
        function At(t) {
          var e = -1,
            r = t ? t.length : 0;
          for (this.clear(); ++e < r; ) {
            var n = t[e];
            this.set(n[0], n[1]);
          }
        }
        function Tt(t) {
          var e = -1,
            r = t ? t.length : 0;
          for (this.clear(); ++e < r; ) {
            var n = t[e];
            this.set(n[0], n[1]);
          }
        }
        function kt(t) {
          var e = -1,
            r = t ? t.length : 0;
          for (this.clear(); ++e < r; ) {
            var n = t[e];
            this.set(n[0], n[1]);
          }
        }
        function Ot(t) {
          this.__data__ = new Tt(t);
        }
        function xt(t, e) {
          var r =
              zt(t) ||
              (function (t) {
                return (
                  (function (t) {
                    return (
                      (function (t) {
                        return !!t && "object" == typeof t;
                      })(t) && $t(t)
                    );
                  })(t) &&
                  tt.call(t, "callee") &&
                  (!ut.call(t, "callee") || et.call(t) == o)
                );
              })(t)
                ? (function (t, e) {
                    for (var r = -1, n = Array(t); ++r < t; ) n[r] = e(r);
                    return n;
                  })(t.length, String)
                : [],
            n = r.length,
            i = !!n;
          for (var s in t)
            (!e && !tt.call(t, s)) ||
              (i && ("length" == s || Ht(s, n))) ||
              r.push(s);
          return r;
        }
        function Pt(t, e, r) {
          var n = t[e];
          (tt.call(t, e) && qt(n, r) && (void 0 !== r || e in t)) || (t[e] = r);
        }
        function Bt(t, e) {
          for (var r = t.length; r--; ) if (qt(t[r][0], e)) return r;
          return -1;
        }
        function Ct(t, e, r, n, i, d, b) {
          var P;
          if ((n && (P = d ? n(t, i, d, b) : n(t)), void 0 !== P)) return P;
          if (!Yt(t)) return t;
          var B = zt(t);
          if (B) {
            if (
              ((P = (function (t) {
                var e = t.length,
                  r = t.constructor(e);
                e &&
                  "string" == typeof t[0] &&
                  tt.call(t, "index") &&
                  ((r.index = t.index), (r.input = t.input));
                return r;
              })(t)),
              !e)
            )
              return (function (t, e) {
                var r = -1,
                  n = t.length;
                e || (e = Array(n));
                for (; ++r < n; ) e[r] = t[r];
                return e;
              })(t, P);
          } else {
            var R = Ft(t),
              N = R == u || R == c;
            if (Gt(t))
              return (function (t, e) {
                if (e) return t.slice();
                var r = new t.constructor(t.length);
                return t.copy(r), r;
              })(t, e);
            if (R == l || R == o || (N && !d)) {
              if (V(t)) return d ? t : {};
              if (
                ((P = (function (t) {
                  return "function" != typeof t.constructor || Kt(t)
                    ? {}
                    : ((e = st(t)), Yt(e) ? at(e) : {});
                  var e;
                })(N ? {} : t)),
                !e)
              )
                return (function (t, e) {
                  return Ut(t, jt(t), e);
                })(
                  t,
                  (function (t, e) {
                    return t && Ut(e, Xt(e), t);
                  })(P, t),
                );
            } else {
              if (!C[R]) return d ? t : {};
              P = (function (t, e, r, n) {
                var i = t.constructor;
                switch (e) {
                  case w:
                    return Nt(t);
                  case s:
                  case a:
                    return new i(+t);
                  case v:
                    return (function (t, e) {
                      var r = e ? Nt(t.buffer) : t.buffer;
                      return new t.constructor(r, t.byteOffset, t.byteLength);
                    })(t, n);
                  case _:
                  case E:
                  case S:
                  case I:
                  case M:
                  case A:
                  case T:
                  case k:
                  case O:
                    return (function (t, e) {
                      var r = e ? Nt(t.buffer) : t.buffer;
                      return new t.constructor(r, t.byteOffset, t.length);
                    })(t, n);
                  case f:
                    return (function (t, e, r) {
                      var n = e ? r(q(t), !0) : q(t);
                      return K(n, F, new t.constructor());
                    })(t, n, r);
                  case h:
                  case g:
                    return new i(t);
                  case p:
                    return (function (t) {
                      var e = new t.constructor(t.source, x.exec(t));
                      return (e.lastIndex = t.lastIndex), e;
                    })(t);
                  case y:
                    return (function (t, e, r) {
                      var n = e ? r($(t), !0) : $(t);
                      return K(n, H, new t.constructor());
                    })(t, n, r);
                  case m:
                    return (o = t), Mt ? Object(Mt.call(o)) : {};
                }
                var o;
              })(t, R, Ct, e);
            }
          }
          b || (b = new Ot());
          var U = b.get(t);
          if (U) return U;
          if ((b.set(t, P), !B))
            var D = r
              ? (function (t) {
                  return (function (t, e, r) {
                    var n = e(t);
                    return zt(t)
                      ? n
                      : (function (t, e) {
                          for (
                            var r = -1, n = e.length, i = t.length;
                            ++r < n;

                          )
                            t[i + r] = e[r];
                          return t;
                        })(n, r(t));
                  })(t, Xt, jt);
                })(t)
              : Xt(t);
          return (
            (function (t, e) {
              for (
                var r = -1, n = t ? t.length : 0;
                ++r < n && !1 !== e(t[r], r, t);

              );
            })(D || t, function (i, o) {
              D && (i = t[(o = i)]), Pt(P, o, Ct(i, e, r, n, o, t, b));
            }),
            P
          );
        }
        function Rt(t) {
          return (
            !(!Yt(t) || ((e = t), J && J in e)) &&
            (Wt(t) || V(t) ? rt : P).test(Vt(t))
          );
          var e;
        }
        function Nt(t) {
          var e = new t.constructor(t.byteLength);
          return new ot(e).set(new ot(t)), e;
        }
        function Ut(t, e, r, n) {
          r || (r = {});
          for (var i = -1, o = e.length; ++i < o; ) {
            var s = e[i],
              a = n ? n(r[s], t[s], s, r, t) : void 0;
            Pt(r, s, void 0 === a ? t[s] : a);
          }
          return r;
        }
        function Dt(t, e) {
          var r,
            n,
            i = t.__data__;
          return (
            "string" == (n = typeof (r = e)) ||
            "number" == n ||
            "symbol" == n ||
            "boolean" == n
              ? "__proto__" !== r
              : null === r
          )
            ? i["string" == typeof e ? "string" : "hash"]
            : i.map;
        }
        function Lt(t, e) {
          var r = (function (t, e) {
            return null == t ? void 0 : t[e];
          })(t, e);
          return Rt(r) ? r : void 0;
        }
        (At.prototype.clear = function () {
          this.__data__ = bt ? bt(null) : {};
        }),
          (At.prototype.delete = function (t) {
            return this.has(t) && delete this.__data__[t];
          }),
          (At.prototype.get = function (t) {
            var e = this.__data__;
            if (bt) {
              var r = e[t];
              return r === n ? void 0 : r;
            }
            return tt.call(e, t) ? e[t] : void 0;
          }),
          (At.prototype.has = function (t) {
            var e = this.__data__;
            return bt ? void 0 !== e[t] : tt.call(e, t);
          }),
          (At.prototype.set = function (t, e) {
            return (this.__data__[t] = bt && void 0 === e ? n : e), this;
          }),
          (Tt.prototype.clear = function () {
            this.__data__ = [];
          }),
          (Tt.prototype.delete = function (t) {
            var e = this.__data__,
              r = Bt(e, t);
            return (
              !(r < 0) && (r == e.length - 1 ? e.pop() : ct.call(e, r, 1), !0)
            );
          }),
          (Tt.prototype.get = function (t) {
            var e = this.__data__,
              r = Bt(e, t);
            return r < 0 ? void 0 : e[r][1];
          }),
          (Tt.prototype.has = function (t) {
            return Bt(this.__data__, t) > -1;
          }),
          (Tt.prototype.set = function (t, e) {
            var r = this.__data__,
              n = Bt(r, t);
            return n < 0 ? r.push([t, e]) : (r[n][1] = e), this;
          }),
          (kt.prototype.clear = function () {
            this.__data__ = {
              hash: new At(),
              map: new (pt || Tt)(),
              string: new At(),
            };
          }),
          (kt.prototype.delete = function (t) {
            return Dt(this, t).delete(t);
          }),
          (kt.prototype.get = function (t) {
            return Dt(this, t).get(t);
          }),
          (kt.prototype.has = function (t) {
            return Dt(this, t).has(t);
          }),
          (kt.prototype.set = function (t, e) {
            return Dt(this, t).set(t, e), this;
          }),
          (Ot.prototype.clear = function () {
            this.__data__ = new Tt();
          }),
          (Ot.prototype.delete = function (t) {
            return this.__data__.delete(t);
          }),
          (Ot.prototype.get = function (t) {
            return this.__data__.get(t);
          }),
          (Ot.prototype.has = function (t) {
            return this.__data__.has(t);
          }),
          (Ot.prototype.set = function (t, e) {
            var r = this.__data__;
            if (r instanceof Tt) {
              var n = r.__data__;
              if (!pt || n.length < 199) return n.push([t, e]), this;
              r = this.__data__ = new kt(n);
            }
            return r.set(t, e), this;
          });
        var jt = ft
            ? z(ft, Object)
            : function () {
                return [];
              },
          Ft = function (t) {
            return et.call(t);
          };
        function Ht(t, e) {
          return (
            !!(e = null == e ? i : e) &&
            ("number" == typeof t || B.test(t)) &&
            t > -1 &&
            t % 1 == 0 &&
            t < e
          );
        }
        function Kt(t) {
          var e = t && t.constructor;
          return t === (("function" == typeof e && e.prototype) || X);
        }
        function Vt(t) {
          if (null != t) {
            try {
              return Q.call(t);
            } catch (t) {}
            try {
              return t + "";
            } catch (t) {}
          }
          return "";
        }
        function qt(t, e) {
          return t === e || (t != t && e != e);
        }
        ((dt && Ft(new dt(new ArrayBuffer(1))) != v) ||
          (pt && Ft(new pt()) != f) ||
          (yt && Ft(yt.resolve()) != d) ||
          (gt && Ft(new gt()) != y) ||
          (mt && Ft(new mt()) != b)) &&
          (Ft = function (t) {
            var e = et.call(t),
              r = e == l ? t.constructor : void 0,
              n = r ? Vt(r) : void 0;
            if (n)
              switch (n) {
                case wt:
                  return v;
                case vt:
                  return f;
                case _t:
                  return d;
                case Et:
                  return y;
                case St:
                  return b;
              }
            return e;
          });
        var zt = Array.isArray;
        function $t(t) {
          return (
            null != t &&
            (function (t) {
              return "number" == typeof t && t > -1 && t % 1 == 0 && t <= i;
            })(t.length) &&
            !Wt(t)
          );
        }
        var Gt =
          ht ||
          function () {
            return !1;
          };
        function Wt(t) {
          var e = Yt(t) ? et.call(t) : "";
          return e == u || e == c;
        }
        function Yt(t) {
          var e = typeof t;
          return !!t && ("object" == e || "function" == e);
        }
        function Xt(t) {
          return $t(t)
            ? xt(t)
            : (function (t) {
                if (!Kt(t)) return lt(t);
                var e = [];
                for (var r in Object(t))
                  tt.call(t, r) && "constructor" != r && e.push(r);
                return e;
              })(t);
        }
        t.exports = function (t) {
          return Ct(t, !0, !0);
        };
      },
      71514: (t) => {
        "use strict";
        t.exports = Math.abs;
      },
      58968: (t) => {
        "use strict";
        t.exports = Math.floor;
      },
      94459: (t) => {
        "use strict";
        t.exports =
          Number.isNaN ||
          function (t) {
            return t != t;
          };
      },
      6188: (t) => {
        "use strict";
        t.exports = Math.max;
      },
      68002: (t) => {
        "use strict";
        t.exports = Math.min;
      },
      75880: (t) => {
        "use strict";
        t.exports = Math.pow;
      },
      70414: (t) => {
        "use strict";
        t.exports = Math.round;
      },
      73093: (t, e, r) => {
        "use strict";
        var n = r(94459);
        t.exports = function (t) {
          return n(t) || 0 === t ? t : t < 0 ? -1 : 1;
        };
      },
      88276: (t, e, r) => {
        "use strict";
        var n = r(56698),
          i = r(4729),
          o = r(92861).Buffer,
          s = new Array(16);
        function a() {
          i.call(this, 64),
            (this._a = 1732584193),
            (this._b = 4023233417),
            (this._c = 2562383102),
            (this._d = 271733878);
        }
        function u(t, e) {
          return (t << e) | (t >>> (32 - e));
        }
        function c(t, e, r, n, i, o, s) {
          return (u((t + ((e & r) | (~e & n)) + i + o) | 0, s) + e) | 0;
        }
        function f(t, e, r, n, i, o, s) {
          return (u((t + ((e & n) | (r & ~n)) + i + o) | 0, s) + e) | 0;
        }
        function h(t, e, r, n, i, o, s) {
          return (u((t + (e ^ r ^ n) + i + o) | 0, s) + e) | 0;
        }
        function l(t, e, r, n, i, o, s) {
          return (u((t + (r ^ (e | ~n)) + i + o) | 0, s) + e) | 0;
        }
        n(a, i),
          (a.prototype._update = function () {
            for (var t = s, e = 0; e < 16; ++e)
              t[e] = this._block.readInt32LE(4 * e);
            var r = this._a,
              n = this._b,
              i = this._c,
              o = this._d;
            (r = c(r, n, i, o, t[0], 3614090360, 7)),
              (o = c(o, r, n, i, t[1], 3905402710, 12)),
              (i = c(i, o, r, n, t[2], 606105819, 17)),
              (n = c(n, i, o, r, t[3], 3250441966, 22)),
              (r = c(r, n, i, o, t[4], 4118548399, 7)),
              (o = c(o, r, n, i, t[5], 1200080426, 12)),
              (i = c(i, o, r, n, t[6], 2821735955, 17)),
              (n = c(n, i, o, r, t[7], 4249261313, 22)),
              (r = c(r, n, i, o, t[8], 1770035416, 7)),
              (o = c(o, r, n, i, t[9], 2336552879, 12)),
              (i = c(i, o, r, n, t[10], 4294925233, 17)),
              (n = c(n, i, o, r, t[11], 2304563134, 22)),
              (r = c(r, n, i, o, t[12], 1804603682, 7)),
              (o = c(o, r, n, i, t[13], 4254626195, 12)),
              (i = c(i, o, r, n, t[14], 2792965006, 17)),
              (r = f(
                r,
                (n = c(n, i, o, r, t[15], 1236535329, 22)),
                i,
                o,
                t[1],
                4129170786,
                5,
              )),
              (o = f(o, r, n, i, t[6], 3225465664, 9)),
              (i = f(i, o, r, n, t[11], 643717713, 14)),
              (n = f(n, i, o, r, t[0], 3921069994, 20)),
              (r = f(r, n, i, o, t[5], 3593408605, 5)),
              (o = f(o, r, n, i, t[10], 38016083, 9)),
              (i = f(i, o, r, n, t[15], 3634488961, 14)),
              (n = f(n, i, o, r, t[4], 3889429448, 20)),
              (r = f(r, n, i, o, t[9], 568446438, 5)),
              (o = f(o, r, n, i, t[14], 3275163606, 9)),
              (i = f(i, o, r, n, t[3], 4107603335, 14)),
              (n = f(n, i, o, r, t[8], 1163531501, 20)),
              (r = f(r, n, i, o, t[13], 2850285829, 5)),
              (o = f(o, r, n, i, t[2], 4243563512, 9)),
              (i = f(i, o, r, n, t[7], 1735328473, 14)),
              (r = h(
                r,
                (n = f(n, i, o, r, t[12], 2368359562, 20)),
                i,
                o,
                t[5],
                4294588738,
                4,
              )),
              (o = h(o, r, n, i, t[8], 2272392833, 11)),
              (i = h(i, o, r, n, t[11], 1839030562, 16)),
              (n = h(n, i, o, r, t[14], 4259657740, 23)),
              (r = h(r, n, i, o, t[1], 2763975236, 4)),
              (o = h(o, r, n, i, t[4], 1272893353, 11)),
              (i = h(i, o, r, n, t[7], 4139469664, 16)),
              (n = h(n, i, o, r, t[10], 3200236656, 23)),
              (r = h(r, n, i, o, t[13], 681279174, 4)),
              (o = h(o, r, n, i, t[0], 3936430074, 11)),
              (i = h(i, o, r, n, t[3], 3572445317, 16)),
              (n = h(n, i, o, r, t[6], 76029189, 23)),
              (r = h(r, n, i, o, t[9], 3654602809, 4)),
              (o = h(o, r, n, i, t[12], 3873151461, 11)),
              (i = h(i, o, r, n, t[15], 530742520, 16)),
              (r = l(
                r,
                (n = h(n, i, o, r, t[2], 3299628645, 23)),
                i,
                o,
                t[0],
                4096336452,
                6,
              )),
              (o = l(o, r, n, i, t[7], 1126891415, 10)),
              (i = l(i, o, r, n, t[14], 2878612391, 15)),
              (n = l(n, i, o, r, t[5], 4237533241, 21)),
              (r = l(r, n, i, o, t[12], 1700485571, 6)),
              (o = l(o, r, n, i, t[3], 2399980690, 10)),
              (i = l(i, o, r, n, t[10], 4293915773, 15)),
              (n = l(n, i, o, r, t[1], 2240044497, 21)),
              (r = l(r, n, i, o, t[8], 1873313359, 6)),
              (o = l(o, r, n, i, t[15], 4264355552, 10)),
              (i = l(i, o, r, n, t[6], 2734768916, 15)),
              (n = l(n, i, o, r, t[13], 1309151649, 21)),
              (r = l(r, n, i, o, t[4], 4149444226, 6)),
              (o = l(o, r, n, i, t[11], 3174756917, 10)),
              (i = l(i, o, r, n, t[2], 718787259, 15)),
              (n = l(n, i, o, r, t[9], 3951481745, 21)),
              (this._a = (this._a + r) | 0),
              (this._b = (this._b + n) | 0),
              (this._c = (this._c + i) | 0),
              (this._d = (this._d + o) | 0);
          }),
          (a.prototype._digest = function () {
            (this._block[this._blockOffset++] = 128),
              this._blockOffset > 56 &&
                (this._block.fill(0, this._blockOffset, 64),
                this._update(),
                (this._blockOffset = 0)),
              this._block.fill(0, this._blockOffset, 56),
              this._block.writeUInt32LE(this._length[0], 56),
              this._block.writeUInt32LE(this._length[1], 60),
              this._update();
            var t = o.allocUnsafe(16);
            return (
              t.writeInt32LE(this._a, 0),
              t.writeInt32LE(this._b, 4),
              t.writeInt32LE(this._c, 8),
              t.writeInt32LE(this._d, 12),
              t
            );
          }),
          (t.exports = a);
      },
      52244: (t, e, r) => {
        var n = r(61158),
          i = r(15037);
        function o(t) {
          this.rand = t || new i.Rand();
        }
        (t.exports = o),
          (o.create = function (t) {
            return new o(t);
          }),
          (o.prototype._randbelow = function (t) {
            var e = t.bitLength(),
              r = Math.ceil(e / 8);
            do {
              var i = new n(this.rand.generate(r));
            } while (i.cmp(t) >= 0);
            return i;
          }),
          (o.prototype._randrange = function (t, e) {
            var r = e.sub(t);
            return t.add(this._randbelow(r));
          }),
          (o.prototype.test = function (t, e, r) {
            var i = t.bitLength(),
              o = n.mont(t),
              s = new n(1).toRed(o);
            e || (e = Math.max(1, (i / 48) | 0));
            for (var a = t.subn(1), u = 0; !a.testn(u); u++);
            for (var c = t.shrn(u), f = a.toRed(o); e > 0; e--) {
              var h = this._randrange(new n(2), a);
              r && r(h);
              var l = h.toRed(o).redPow(c);
              if (0 !== l.cmp(s) && 0 !== l.cmp(f)) {
                for (var d = 1; d < u; d++) {
                  if (0 === (l = l.redSqr()).cmp(s)) return !1;
                  if (0 === l.cmp(f)) break;
                }
                if (d === u) return !1;
              }
            }
            return !0;
          }),
          (o.prototype.getDivisor = function (t, e) {
            var r = t.bitLength(),
              i = n.mont(t),
              o = new n(1).toRed(i);
            e || (e = Math.max(1, (r / 48) | 0));
            for (var s = t.subn(1), a = 0; !s.testn(a); a++);
            for (var u = t.shrn(a), c = s.toRed(i); e > 0; e--) {
              var f = this._randrange(new n(2), s),
                h = t.gcd(f);
              if (0 !== h.cmpn(1)) return h;
              var l = f.toRed(i).redPow(u);
              if (0 !== l.cmp(o) && 0 !== l.cmp(c)) {
                for (var d = 1; d < a; d++) {
                  if (0 === (l = l.redSqr()).cmp(o))
                    return l.fromRed().subn(1).gcd(t);
                  if (0 === l.cmp(c)) break;
                }
                if (d === a) return (l = l.redSqr()).fromRed().subn(1).gcd(t);
              }
            }
            return !1;
          });
      },
      61158: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(64688).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      43349: (t) => {
        function e(t, e) {
          if (!t) throw new Error(e || "Assertion failed");
        }
        (t.exports = e),
          (e.equal = function (t, e, r) {
            if (t != e)
              throw new Error(r || "Assertion failed: " + t + " != " + e);
          });
      },
      64367: (t, e) => {
        "use strict";
        var r = e;
        function n(t) {
          return 1 === t.length ? "0" + t : t;
        }
        function i(t) {
          for (var e = "", r = 0; r < t.length; r++) e += n(t[r].toString(16));
          return e;
        }
        (r.toArray = function (t, e) {
          if (Array.isArray(t)) return t.slice();
          if (!t) return [];
          var r = [];
          if ("string" != typeof t) {
            for (var n = 0; n < t.length; n++) r[n] = 0 | t[n];
            return r;
          }
          if ("hex" === e) {
            (t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 &&
              (t = "0" + t);
            for (n = 0; n < t.length; n += 2)
              r.push(parseInt(t[n] + t[n + 1], 16));
          } else
            for (n = 0; n < t.length; n++) {
              var i = t.charCodeAt(n),
                o = i >> 8,
                s = 255 & i;
              o ? r.push(o, s) : r.push(s);
            }
          return r;
        }),
          (r.zero2 = n),
          (r.toHex = i),
          (r.encode = function (t, e) {
            return "hex" === e ? i(t) : t;
          });
      },
      89211: (t) => {
        "use strict";
        var e = function (t) {
          return t != t;
        };
        t.exports = function (t, r) {
          return 0 === t && 0 === r
            ? 1 / t == 1 / r
            : t === r || !(!e(t) || !e(r));
        };
      },
      37653: (t, e, r) => {
        "use strict";
        var n = r(38452),
          i = r(10487),
          o = r(89211),
          s = r(9394),
          a = r(36576),
          u = i(s(), Object);
        n(u, { getPolyfill: s, implementation: o, shim: a }), (t.exports = u);
      },
      9394: (t, e, r) => {
        "use strict";
        var n = r(89211);
        t.exports = function () {
          return "function" == typeof Object.is ? Object.is : n;
        };
      },
      36576: (t, e, r) => {
        "use strict";
        var n = r(9394),
          i = r(38452);
        t.exports = function () {
          var t = n();
          return (
            i(
              Object,
              { is: t },
              {
                is: function () {
                  return Object.is !== t;
                },
              },
            ),
            t
          );
        };
      },
      28875: (t, e, r) => {
        "use strict";
        var n;
        if (!Object.keys) {
          var i = Object.prototype.hasOwnProperty,
            o = Object.prototype.toString,
            s = r(1093),
            a = Object.prototype.propertyIsEnumerable,
            u = !a.call({ toString: null }, "toString"),
            c = a.call(function () {}, "prototype"),
            f = [
              "toString",
              "toLocaleString",
              "valueOf",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "constructor",
            ],
            h = function (t) {
              var e = t.constructor;
              return e && e.prototype === t;
            },
            l = {
              $applicationCache: !0,
              $console: !0,
              $external: !0,
              $frame: !0,
              $frameElement: !0,
              $frames: !0,
              $innerHeight: !0,
              $innerWidth: !0,
              $onmozfullscreenchange: !0,
              $onmozfullscreenerror: !0,
              $outerHeight: !0,
              $outerWidth: !0,
              $pageXOffset: !0,
              $pageYOffset: !0,
              $parent: !0,
              $scrollLeft: !0,
              $scrollTop: !0,
              $scrollX: !0,
              $scrollY: !0,
              $self: !0,
              $webkitIndexedDB: !0,
              $webkitStorageInfo: !0,
              $window: !0,
            },
            d = (function () {
              if ("undefined" == typeof window) return !1;
              for (var t in window)
                try {
                  if (
                    !l["$" + t] &&
                    i.call(window, t) &&
                    null !== window[t] &&
                    "object" == typeof window[t]
                  )
                    try {
                      h(window[t]);
                    } catch (t) {
                      return !0;
                    }
                } catch (t) {
                  return !0;
                }
              return !1;
            })();
          n = function (t) {
            var e = null !== t && "object" == typeof t,
              r = "[object Function]" === o.call(t),
              n = s(t),
              a = e && "[object String]" === o.call(t),
              l = [];
            if (!e && !r && !n)
              throw new TypeError("Object.keys called on a non-object");
            var p = c && r;
            if (a && t.length > 0 && !i.call(t, 0))
              for (var y = 0; y < t.length; ++y) l.push(String(y));
            if (n && t.length > 0)
              for (var g = 0; g < t.length; ++g) l.push(String(g));
            else
              for (var m in t)
                (p && "prototype" === m) || !i.call(t, m) || l.push(String(m));
            if (u)
              for (
                var b = (function (t) {
                    if ("undefined" == typeof window || !d) return h(t);
                    try {
                      return h(t);
                    } catch (t) {
                      return !1;
                    }
                  })(t),
                  w = 0;
                w < f.length;
                ++w
              )
                (b && "constructor" === f[w]) ||
                  !i.call(t, f[w]) ||
                  l.push(f[w]);
            return l;
          };
        }
        t.exports = n;
      },
      1189: (t, e, r) => {
        "use strict";
        var n = Array.prototype.slice,
          i = r(1093),
          o = Object.keys,
          s = o
            ? function (t) {
                return o(t);
              }
            : r(28875),
          a = Object.keys;
        (s.shim = function () {
          if (Object.keys) {
            var t = (function () {
              var t = Object.keys(arguments);
              return t && t.length === arguments.length;
            })(1, 2);
            t ||
              (Object.keys = function (t) {
                return i(t) ? a(n.call(t)) : a(t);
              });
          } else Object.keys = s;
          return Object.keys || s;
        }),
          (t.exports = s);
      },
      1093: (t) => {
        "use strict";
        var e = Object.prototype.toString;
        t.exports = function (t) {
          var r = e.call(t),
            n = "[object Arguments]" === r;
          return (
            n ||
              (n =
                "[object Array]" !== r &&
                null !== t &&
                "object" == typeof t &&
                "number" == typeof t.length &&
                t.length >= 0 &&
                "[object Function]" === e.call(t.callee)),
            n
          );
        };
      },
      38403: (t, e, r) => {
        "use strict";
        var n = r(1189),
          i = r(41333)(),
          o = r(38075),
          s = Object,
          a = o("Array.prototype.push"),
          u = o("Object.prototype.propertyIsEnumerable"),
          c = i ? Object.getOwnPropertySymbols : null;
        t.exports = function (t, e) {
          if (null == t) throw new TypeError("target must be an object");
          var r = s(t);
          if (1 === arguments.length) return r;
          for (var o = 1; o < arguments.length; ++o) {
            var f = s(arguments[o]),
              h = n(f),
              l = i && (Object.getOwnPropertySymbols || c);
            if (l)
              for (var d = l(f), p = 0; p < d.length; ++p) {
                var y = d[p];
                u(f, y) && a(h, y);
              }
            for (var g = 0; g < h.length; ++g) {
              var m = h[g];
              if (u(f, m)) {
                var b = f[m];
                r[m] = b;
              }
            }
          }
          return r;
        };
      },
      11514: (t, e, r) => {
        "use strict";
        var n = r(38403);
        t.exports = function () {
          return Object.assign
            ? (function () {
                if (!Object.assign) return !1;
                for (
                  var t = "abcdefghijklmnopqrst",
                    e = t.split(""),
                    r = {},
                    n = 0;
                  n < e.length;
                  ++n
                )
                  r[e[n]] = e[n];
                var i = Object.assign({}, r),
                  o = "";
                for (var s in i) o += s;
                return t !== o;
              })() ||
              (function () {
                if (!Object.assign || !Object.preventExtensions) return !1;
                var t = Object.preventExtensions({ 1: 2 });
                try {
                  Object.assign(t, "xy");
                } catch (e) {
                  return "y" === t[1];
                }
                return !1;
              })()
              ? n
              : Object.assign
            : n;
        };
      },
      21137: (t, e, r) => {
        "use strict";
        var n = r(87568);
        e.certificate = r(36413);
        var i = n.define("RSAPrivateKey", function () {
          this.seq().obj(
            this.key("version").int(),
            this.key("modulus").int(),
            this.key("publicExponent").int(),
            this.key("privateExponent").int(),
            this.key("prime1").int(),
            this.key("prime2").int(),
            this.key("exponent1").int(),
            this.key("exponent2").int(),
            this.key("coefficient").int(),
          );
        });
        e.RSAPrivateKey = i;
        var o = n.define("RSAPublicKey", function () {
          this.seq().obj(
            this.key("modulus").int(),
            this.key("publicExponent").int(),
          );
        });
        e.RSAPublicKey = o;
        var s = n.define("SubjectPublicKeyInfo", function () {
          this.seq().obj(
            this.key("algorithm").use(a),
            this.key("subjectPublicKey").bitstr(),
          );
        });
        e.PublicKey = s;
        var a = n.define("AlgorithmIdentifier", function () {
            this.seq().obj(
              this.key("algorithm").objid(),
              this.key("none").null_().optional(),
              this.key("curve").objid().optional(),
              this.key("params")
                .seq()
                .obj(
                  this.key("p").int(),
                  this.key("q").int(),
                  this.key("g").int(),
                )
                .optional(),
            );
          }),
          u = n.define("PrivateKeyInfo", function () {
            this.seq().obj(
              this.key("version").int(),
              this.key("algorithm").use(a),
              this.key("subjectPrivateKey").octstr(),
            );
          });
        e.PrivateKey = u;
        var c = n.define("EncryptedPrivateKeyInfo", function () {
          this.seq().obj(
            this.key("algorithm")
              .seq()
              .obj(
                this.key("id").objid(),
                this.key("decrypt")
                  .seq()
                  .obj(
                    this.key("kde")
                      .seq()
                      .obj(
                        this.key("id").objid(),
                        this.key("kdeparams")
                          .seq()
                          .obj(
                            this.key("salt").octstr(),
                            this.key("iters").int(),
                          ),
                      ),
                    this.key("cipher")
                      .seq()
                      .obj(this.key("algo").objid(), this.key("iv").octstr()),
                  ),
              ),
            this.key("subjectPrivateKey").octstr(),
          );
        });
        e.EncryptedPrivateKey = c;
        var f = n.define("DSAPrivateKey", function () {
          this.seq().obj(
            this.key("version").int(),
            this.key("p").int(),
            this.key("q").int(),
            this.key("g").int(),
            this.key("pub_key").int(),
            this.key("priv_key").int(),
          );
        });
        (e.DSAPrivateKey = f),
          (e.DSAparam = n.define("DSAparam", function () {
            this.int();
          }));
        var h = n.define("ECPrivateKey", function () {
          this.seq().obj(
            this.key("version").int(),
            this.key("privateKey").octstr(),
            this.key("parameters").optional().explicit(0).use(l),
            this.key("publicKey").optional().explicit(1).bitstr(),
          );
        });
        e.ECPrivateKey = h;
        var l = n.define("ECParameters", function () {
          this.choice({ namedCurve: this.objid() });
        });
        e.signature = n.define("signature", function () {
          this.seq().obj(this.key("r").int(), this.key("s").int());
        });
      },
      36413: (t, e, r) => {
        "use strict";
        var n = r(87568),
          i = n.define("Time", function () {
            this.choice({
              utcTime: this.utctime(),
              generalTime: this.gentime(),
            });
          }),
          o = n.define("AttributeTypeValue", function () {
            this.seq().obj(this.key("type").objid(), this.key("value").any());
          }),
          s = n.define("AlgorithmIdentifier", function () {
            this.seq().obj(
              this.key("algorithm").objid(),
              this.key("parameters").optional(),
              this.key("curve").objid().optional(),
            );
          }),
          a = n.define("SubjectPublicKeyInfo", function () {
            this.seq().obj(
              this.key("algorithm").use(s),
              this.key("subjectPublicKey").bitstr(),
            );
          }),
          u = n.define("RelativeDistinguishedName", function () {
            this.setof(o);
          }),
          c = n.define("RDNSequence", function () {
            this.seqof(u);
          }),
          f = n.define("Name", function () {
            this.choice({ rdnSequence: this.use(c) });
          }),
          h = n.define("Validity", function () {
            this.seq().obj(
              this.key("notBefore").use(i),
              this.key("notAfter").use(i),
            );
          }),
          l = n.define("Extension", function () {
            this.seq().obj(
              this.key("extnID").objid(),
              this.key("critical").bool().def(!1),
              this.key("extnValue").octstr(),
            );
          }),
          d = n.define("TBSCertificate", function () {
            this.seq().obj(
              this.key("version").explicit(0).int().optional(),
              this.key("serialNumber").int(),
              this.key("signature").use(s),
              this.key("issuer").use(f),
              this.key("validity").use(h),
              this.key("subject").use(f),
              this.key("subjectPublicKeyInfo").use(a),
              this.key("issuerUniqueID").implicit(1).bitstr().optional(),
              this.key("subjectUniqueID").implicit(2).bitstr().optional(),
              this.key("extensions").explicit(3).seqof(l).optional(),
            );
          }),
          p = n.define("X509Certificate", function () {
            this.seq().obj(
              this.key("tbsCertificate").use(d),
              this.key("signatureAlgorithm").use(s),
              this.key("signatureValue").bitstr(),
            );
          });
        t.exports = p;
      },
      24101: (t, e, r) => {
        var n =
            /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
          i = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
          o =
            /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
          s = r(68078),
          a = r(1241),
          u = r(92861).Buffer;
        t.exports = function (t, e) {
          var r,
            c = t.toString(),
            f = c.match(n);
          if (f) {
            var h = "aes" + f[1],
              l = u.from(f[2], "hex"),
              d = u.from(f[3].replace(/[\r\n]/g, ""), "base64"),
              p = s(e, l.slice(0, 8), parseInt(f[1], 10)).key,
              y = [],
              g = a.createDecipheriv(h, p, l);
            y.push(g.update(d)), y.push(g.final()), (r = u.concat(y));
          } else {
            var m = c.match(o);
            r = u.from(m[2].replace(/[\r\n]/g, ""), "base64");
          }
          return { tag: c.match(i)[1], data: r };
        };
      },
      78170: (t, e, r) => {
        var n = r(21137),
          i = r(15579),
          o = r(24101),
          s = r(1241),
          a = r(78396),
          u = r(92861).Buffer;
        function c(t) {
          var e;
          "object" != typeof t ||
            u.isBuffer(t) ||
            ((e = t.passphrase), (t = t.key)),
            "string" == typeof t && (t = u.from(t));
          var r,
            c,
            f = o(t, e),
            h = f.tag,
            l = f.data;
          switch (h) {
            case "CERTIFICATE":
              c = n.certificate.decode(l, "der").tbsCertificate
                .subjectPublicKeyInfo;
            case "PUBLIC KEY":
              switch (
                (c || (c = n.PublicKey.decode(l, "der")),
                (r = c.algorithm.algorithm.join(".")))
              ) {
                case "1.2.840.113549.1.1.1":
                  return n.RSAPublicKey.decode(c.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                  return (
                    (c.subjectPrivateKey = c.subjectPublicKey),
                    { type: "ec", data: c }
                  );
                case "1.2.840.10040.4.1":
                  return (
                    (c.algorithm.params.pub_key = n.DSAparam.decode(
                      c.subjectPublicKey.data,
                      "der",
                    )),
                    { type: "dsa", data: c.algorithm.params }
                  );
                default:
                  throw new Error("unknown key id " + r);
              }
            case "ENCRYPTED PRIVATE KEY":
              l = (function (t, e) {
                var r = t.algorithm.decrypt.kde.kdeparams.salt,
                  n = parseInt(
                    t.algorithm.decrypt.kde.kdeparams.iters.toString(),
                    10,
                  ),
                  o = i[t.algorithm.decrypt.cipher.algo.join(".")],
                  c = t.algorithm.decrypt.cipher.iv,
                  f = t.subjectPrivateKey,
                  h = parseInt(o.split("-")[1], 10) / 8,
                  l = a.pbkdf2Sync(e, r, n, h, "sha1"),
                  d = s.createDecipheriv(o, l, c),
                  p = [];
                return p.push(d.update(f)), p.push(d.final()), u.concat(p);
              })((l = n.EncryptedPrivateKey.decode(l, "der")), e);
            case "PRIVATE KEY":
              switch (
                (r = (c = n.PrivateKey.decode(
                  l,
                  "der",
                )).algorithm.algorithm.join("."))
              ) {
                case "1.2.840.113549.1.1.1":
                  return n.RSAPrivateKey.decode(c.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                  return {
                    curve: c.algorithm.curve,
                    privateKey: n.ECPrivateKey.decode(
                      c.subjectPrivateKey,
                      "der",
                    ).privateKey,
                  };
                case "1.2.840.10040.4.1":
                  return (
                    (c.algorithm.params.priv_key = n.DSAparam.decode(
                      c.subjectPrivateKey,
                      "der",
                    )),
                    { type: "dsa", params: c.algorithm.params }
                  );
                default:
                  throw new Error("unknown key id " + r);
              }
            case "RSA PUBLIC KEY":
              return n.RSAPublicKey.decode(l, "der");
            case "RSA PRIVATE KEY":
              return n.RSAPrivateKey.decode(l, "der");
            case "DSA PRIVATE KEY":
              return { type: "dsa", params: n.DSAPrivateKey.decode(l, "der") };
            case "EC PRIVATE KEY":
              return {
                curve: (l = n.ECPrivateKey.decode(l, "der")).parameters.value,
                privateKey: l.privateKey,
              };
            default:
              throw new Error("unknown key type " + h);
          }
        }
        (t.exports = c), (c.signature = n.signature);
      },
      78396: (t, e, r) => {
        (e.pbkdf2 = r(43832)), (e.pbkdf2Sync = r(21352));
      },
      43832: (t, e, r) => {
        var n,
          i,
          o = r(92861).Buffer,
          s = r(64196),
          a = r(2455),
          u = r(21352),
          c = r(93382),
          f = r.g.crypto && r.g.crypto.subtle,
          h = {
            sha: "SHA-1",
            "sha-1": "SHA-1",
            sha1: "SHA-1",
            sha256: "SHA-256",
            "sha-256": "SHA-256",
            sha384: "SHA-384",
            "sha-384": "SHA-384",
            "sha-512": "SHA-512",
            sha512: "SHA-512",
          },
          l = [];
        function d() {
          return (
            i ||
            (i =
              r.g.process && r.g.process.nextTick
                ? r.g.process.nextTick
                : r.g.queueMicrotask
                  ? r.g.queueMicrotask
                  : r.g.setImmediate
                    ? r.g.setImmediate
                    : r.g.setTimeout)
          );
        }
        function p(t, e, r, n, i) {
          return f
            .importKey("raw", t, { name: "PBKDF2" }, !1, ["deriveBits"])
            .then(function (t) {
              return f.deriveBits(
                { name: "PBKDF2", salt: e, iterations: r, hash: { name: i } },
                t,
                n << 3,
              );
            })
            .then(function (t) {
              return o.from(t);
            });
        }
        t.exports = function (t, e, i, y, g, m) {
          "function" == typeof g && ((m = g), (g = void 0));
          var b = h[(g = g || "sha1").toLowerCase()];
          if (b && "function" == typeof r.g.Promise) {
            if (
              (s(i, y),
              (t = c(t, a, "Password")),
              (e = c(e, a, "Salt")),
              "function" != typeof m)
            )
              throw new Error("No callback provided to pbkdf2");
            !(function (t, e) {
              t.then(
                function (t) {
                  d()(function () {
                    e(null, t);
                  });
                },
                function (t) {
                  d()(function () {
                    e(t);
                  });
                },
              );
            })(
              (function (t) {
                if (r.g.process && !r.g.process.browser)
                  return Promise.resolve(!1);
                if (!f || !f.importKey || !f.deriveBits)
                  return Promise.resolve(!1);
                if (void 0 !== l[t]) return l[t];
                var e = p((n = n || o.alloc(8)), n, 10, 128, t)
                  .then(function () {
                    return !0;
                  })
                  .catch(function () {
                    return !1;
                  });
                return (l[t] = e), e;
              })(b).then(function (r) {
                return r ? p(t, e, i, y, b) : u(t, e, i, y, g);
              }),
              m,
            );
          } else
            d()(function () {
              var r;
              try {
                r = u(t, e, i, y, g);
              } catch (t) {
                return m(t);
              }
              m(null, r);
            });
        };
      },
      2455: (t, e, r) => {
        var n,
          i = r(65606);
        if (r.g.process && r.g.process.browser) n = "utf-8";
        else if (r.g.process && r.g.process.version) {
          n =
            parseInt(i.version.split(".")[0].slice(1), 10) >= 6
              ? "utf-8"
              : "binary";
        } else n = "utf-8";
        t.exports = n;
      },
      64196: (t) => {
        var e = Math.pow(2, 30) - 1;
        t.exports = function (t, r) {
          if ("number" != typeof t)
            throw new TypeError("Iterations not a number");
          if (t < 0) throw new TypeError("Bad iterations");
          if ("number" != typeof r)
            throw new TypeError("Key length not a number");
          if (r < 0 || r > e || r != r) throw new TypeError("Bad key length");
        };
      },
      21352: (t, e, r) => {
        var n = r(20320),
          i = r(66011),
          o = r(62802),
          s = r(92861).Buffer,
          a = r(64196),
          u = r(2455),
          c = r(93382),
          f = s.alloc(128),
          h = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20,
          };
        function l(t, e, r) {
          var a = (function (t) {
              function e(e) {
                return o(t).update(e).digest();
              }
              function r(t) {
                return new i().update(t).digest();
              }
              return "rmd160" === t || "ripemd160" === t
                ? r
                : "md5" === t
                  ? n
                  : e;
            })(t),
            u = "sha512" === t || "sha384" === t ? 128 : 64;
          e.length > u ? (e = a(e)) : e.length < u && (e = s.concat([e, f], u));
          for (
            var c = s.allocUnsafe(u + h[t]), l = s.allocUnsafe(u + h[t]), d = 0;
            d < u;
            d++
          )
            (c[d] = 54 ^ e[d]), (l[d] = 92 ^ e[d]);
          var p = s.allocUnsafe(u + r + 4);
          c.copy(p, 0, 0, u),
            (this.ipad1 = p),
            (this.ipad2 = c),
            (this.opad = l),
            (this.alg = t),
            (this.blocksize = u),
            (this.hash = a),
            (this.size = h[t]);
        }
        (l.prototype.run = function (t, e) {
          return (
            t.copy(e, this.blocksize),
            this.hash(e).copy(this.opad, this.blocksize),
            this.hash(this.opad)
          );
        }),
          (t.exports = function (t, e, r, n, i) {
            a(r, n);
            var o = new l(
                (i = i || "sha1"),
                (t = c(t, u, "Password")),
                (e = c(e, u, "Salt")).length,
              ),
              f = s.allocUnsafe(n),
              d = s.allocUnsafe(e.length + 4);
            e.copy(d, 0, 0, e.length);
            for (
              var p = 0, y = h[i], g = Math.ceil(n / y), m = 1;
              m <= g;
              m++
            ) {
              d.writeUInt32BE(m, e.length);
              for (var b = o.run(d, o.ipad1), w = b, v = 1; v < r; v++) {
                w = o.run(w, o.ipad2);
                for (var _ = 0; _ < y; _++) b[_] ^= w[_];
              }
              b.copy(f, p), (p += y);
            }
            return f;
          });
      },
      93382: (t, e, r) => {
        var n = r(92861).Buffer;
        t.exports = function (t, e, r) {
          if (n.isBuffer(t)) return t;
          if ("string" == typeof t) return n.from(t, e);
          if (ArrayBuffer.isView(t)) return n.from(t.buffer);
          throw new TypeError(
            r + " must be a string, a Buffer, a typed array or a DataView",
          );
        };
      },
      65606: (t) => {
        var e,
          r,
          n = (t.exports = {});
        function i() {
          throw new Error("setTimeout has not been defined");
        }
        function o() {
          throw new Error("clearTimeout has not been defined");
        }
        function s(t) {
          if (e === setTimeout) return setTimeout(t, 0);
          if ((e === i || !e) && setTimeout)
            return (e = setTimeout), setTimeout(t, 0);
          try {
            return e(t, 0);
          } catch (r) {
            try {
              return e.call(null, t, 0);
            } catch (r) {
              return e.call(this, t, 0);
            }
          }
        }
        !(function () {
          try {
            e = "function" == typeof setTimeout ? setTimeout : i;
          } catch (t) {
            e = i;
          }
          try {
            r = "function" == typeof clearTimeout ? clearTimeout : o;
          } catch (t) {
            r = o;
          }
        })();
        var a,
          u = [],
          c = !1,
          f = -1;
        function h() {
          c &&
            a &&
            ((c = !1),
            a.length ? (u = a.concat(u)) : (f = -1),
            u.length && l());
        }
        function l() {
          if (!c) {
            var t = s(h);
            c = !0;
            for (var e = u.length; e; ) {
              for (a = u, u = []; ++f < e; ) a && a[f].run();
              (f = -1), (e = u.length);
            }
            (a = null),
              (c = !1),
              (function (t) {
                if (r === clearTimeout) return clearTimeout(t);
                if ((r === o || !r) && clearTimeout)
                  return (r = clearTimeout), clearTimeout(t);
                try {
                  return r(t);
                } catch (e) {
                  try {
                    return r.call(null, t);
                  } catch (e) {
                    return r.call(this, t);
                  }
                }
              })(t);
          }
        }
        function d(t, e) {
          (this.fun = t), (this.array = e);
        }
        function p() {}
        (n.nextTick = function (t) {
          var e = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
          u.push(new d(t, e)), 1 !== u.length || c || s(l);
        }),
          (d.prototype.run = function () {
            this.fun.apply(null, this.array);
          }),
          (n.title = "browser"),
          (n.browser = !0),
          (n.env = {}),
          (n.argv = []),
          (n.version = ""),
          (n.versions = {}),
          (n.on = p),
          (n.addListener = p),
          (n.once = p),
          (n.off = p),
          (n.removeListener = p),
          (n.removeAllListeners = p),
          (n.emit = p),
          (n.prependListener = p),
          (n.prependOnceListener = p),
          (n.listeners = function (t) {
            return [];
          }),
          (n.binding = function (t) {
            throw new Error("process.binding is not supported");
          }),
          (n.cwd = function () {
            return "/";
          }),
          (n.chdir = function (t) {
            throw new Error("process.chdir is not supported");
          }),
          (n.umask = function () {
            return 0;
          });
      },
      97168: (t, e, r) => {
        (e.publicEncrypt = r(28902)),
          (e.privateDecrypt = r(77362)),
          (e.privateEncrypt = function (t, r) {
            return e.publicEncrypt(t, r, !0);
          }),
          (e.publicDecrypt = function (t, r) {
            return e.privateDecrypt(t, r, !0);
          });
      },
      48206: (t, e, r) => {
        var n = r(47108),
          i = r(92861).Buffer;
        function o(t) {
          var e = i.allocUnsafe(4);
          return e.writeUInt32BE(t, 0), e;
        }
        t.exports = function (t, e) {
          for (var r, s = i.alloc(0), a = 0; s.length < e; )
            (r = o(a++)),
              (s = i.concat([s, n("sha1").update(t).update(r).digest()]));
          return s.slice(0, e);
        };
      },
      82509: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(51069).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (r =
                  0 !== (o = (a >>> (24 - i)) & 16777215) ||
                  s !== this.length - 1
                    ? f[6 - u.length] + u + r
                    : u + r),
                  (i += 2) >= 26 && ((i -= 26), s--);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      77362: (t, e, r) => {
        var n = r(78170),
          i = r(48206),
          o = r(52061),
          s = r(82509),
          a = r(67332),
          u = r(47108),
          c = r(99247),
          f = r(92861).Buffer;
        t.exports = function (t, e, r) {
          var h;
          h = t.padding ? t.padding : r ? 1 : 4;
          var l,
            d = n(t),
            p = d.modulus.byteLength();
          if (e.length > p || new s(e).cmp(d.modulus) >= 0)
            throw new Error("decryption error");
          l = r ? c(new s(e), d) : a(e, d);
          var y = f.alloc(p - l.length);
          if (((l = f.concat([y, l], p)), 4 === h))
            return (function (t, e) {
              var r = t.modulus.byteLength(),
                n = u("sha1").update(f.alloc(0)).digest(),
                s = n.length;
              if (0 !== e[0]) throw new Error("decryption error");
              var a = e.slice(1, s + 1),
                c = e.slice(s + 1),
                h = o(a, i(c, s)),
                l = o(c, i(h, r - s - 1));
              if (
                (function (t, e) {
                  (t = f.from(t)), (e = f.from(e));
                  var r = 0,
                    n = t.length;
                  t.length !== e.length &&
                    (r++, (n = Math.min(t.length, e.length)));
                  var i = -1;
                  for (; ++i < n; ) r += t[i] ^ e[i];
                  return r;
                })(n, l.slice(0, s))
              )
                throw new Error("decryption error");
              var d = s;
              for (; 0 === l[d]; ) d++;
              if (1 !== l[d++]) throw new Error("decryption error");
              return l.slice(d);
            })(d, l);
          if (1 === h)
            return (function (t, e, r) {
              var n = e.slice(0, 2),
                i = 2,
                o = 0;
              for (; 0 !== e[i++]; )
                if (i >= e.length) {
                  o++;
                  break;
                }
              var s = e.slice(2, i - 1);
              (("0002" !== n.toString("hex") && !r) ||
                ("0001" !== n.toString("hex") && r)) &&
                o++;
              s.length < 8 && o++;
              if (o) throw new Error("decryption error");
              return e.slice(i);
            })(0, l, r);
          if (3 === h) return l;
          throw new Error("unknown padding");
        };
      },
      28902: (t, e, r) => {
        var n = r(78170),
          i = r(53209),
          o = r(47108),
          s = r(48206),
          a = r(52061),
          u = r(82509),
          c = r(99247),
          f = r(67332),
          h = r(92861).Buffer;
        t.exports = function (t, e, r) {
          var l;
          l = t.padding ? t.padding : r ? 1 : 4;
          var d,
            p = n(t);
          if (4 === l)
            d = (function (t, e) {
              var r = t.modulus.byteLength(),
                n = e.length,
                c = o("sha1").update(h.alloc(0)).digest(),
                f = c.length,
                l = 2 * f;
              if (n > r - l - 2) throw new Error("message too long");
              var d = h.alloc(r - n - l - 2),
                p = r - f - 1,
                y = i(f),
                g = a(h.concat([c, d, h.alloc(1, 1), e], p), s(y, p)),
                m = a(y, s(g, f));
              return new u(h.concat([h.alloc(1), m, g], r));
            })(p, e);
          else if (1 === l)
            d = (function (t, e, r) {
              var n,
                o = e.length,
                s = t.modulus.byteLength();
              if (o > s - 11) throw new Error("message too long");
              n = r
                ? h.alloc(s - o - 3, 255)
                : (function (t) {
                    var e,
                      r = h.allocUnsafe(t),
                      n = 0,
                      o = i(2 * t),
                      s = 0;
                    for (; n < t; )
                      s === o.length && ((o = i(2 * t)), (s = 0)),
                        (e = o[s++]) && (r[n++] = e);
                    return r;
                  })(s - o - 3);
              return new u(
                h.concat([h.from([0, r ? 1 : 2]), n, h.alloc(1), e], s),
              );
            })(p, e, r);
          else {
            if (3 !== l) throw new Error("unknown padding");
            if ((d = new u(e)).cmp(p.modulus) >= 0)
              throw new Error("data too long for modulus");
          }
          return r ? f(d, p) : c(d, p);
        };
      },
      99247: (t, e, r) => {
        var n = r(82509),
          i = r(92861).Buffer;
        t.exports = function (t, e) {
          return i.from(
            t
              .toRed(n.mont(e.modulus))
              .redPow(new n(e.publicExponent))
              .fromRed()
              .toArray(),
          );
        };
      },
      52061: (t) => {
        t.exports = function (t, e) {
          for (var r = t.length, n = -1; ++n < r; ) t[n] ^= e[n];
          return t;
        };
      },
      53209: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i = 65536,
          o = 4294967295;
        var s = r(92861).Buffer,
          a = r.g.crypto || r.g.msCrypto;
        a && a.getRandomValues
          ? (t.exports = function (t, e) {
              if (t > o)
                throw new RangeError("requested too many random bytes");
              var r = s.allocUnsafe(t);
              if (t > 0)
                if (t > i)
                  for (var u = 0; u < t; u += i)
                    a.getRandomValues(r.slice(u, u + i));
                else a.getRandomValues(r);
              if ("function" == typeof e)
                return n.nextTick(function () {
                  e(null, r);
                });
              return r;
            })
          : (t.exports = function () {
              throw new Error(
                "Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11",
              );
            });
      },
      76983: (t, e, r) => {
        "use strict";
        var n = r(65606);
        function i() {
          throw new Error(
            "secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11",
          );
        }
        var o = r(92861),
          s = r(53209),
          a = o.Buffer,
          u = o.kMaxLength,
          c = r.g.crypto || r.g.msCrypto,
          f = Math.pow(2, 32) - 1;
        function h(t, e) {
          if ("number" != typeof t || t != t)
            throw new TypeError("offset must be a number");
          if (t > f || t < 0) throw new TypeError("offset must be a uint32");
          if (t > u || t > e) throw new RangeError("offset out of range");
        }
        function l(t, e, r) {
          if ("number" != typeof t || t != t)
            throw new TypeError("size must be a number");
          if (t > f || t < 0) throw new TypeError("size must be a uint32");
          if (t + e > r || t > u) throw new RangeError("buffer too small");
        }
        function d(t, e, r, i) {
          if (n.browser) {
            var o = t.buffer,
              a = new Uint8Array(o, e, r);
            return (
              c.getRandomValues(a),
              i
                ? void n.nextTick(function () {
                    i(null, t);
                  })
                : t
            );
          }
          if (!i) return s(r).copy(t, e), t;
          s(r, function (r, n) {
            if (r) return i(r);
            n.copy(t, e), i(null, t);
          });
        }
        (c && c.getRandomValues) || !n.browser
          ? ((e.randomFill = function (t, e, n, i) {
              if (!(a.isBuffer(t) || t instanceof r.g.Uint8Array))
                throw new TypeError(
                  '"buf" argument must be a Buffer or Uint8Array',
                );
              if ("function" == typeof e) (i = e), (e = 0), (n = t.length);
              else if ("function" == typeof n) (i = n), (n = t.length - e);
              else if ("function" != typeof i)
                throw new TypeError('"cb" argument must be a function');
              return h(e, t.length), l(n, e, t.length), d(t, e, n, i);
            }),
            (e.randomFillSync = function (t, e, n) {
              void 0 === e && (e = 0);
              if (!(a.isBuffer(t) || t instanceof r.g.Uint8Array))
                throw new TypeError(
                  '"buf" argument must be a Buffer or Uint8Array',
                );
              h(e, t.length), void 0 === n && (n = t.length - e);
              return l(n, e, t.length), d(t, e, n);
            }))
          : ((e.randomFill = i), (e.randomFillSync = i));
      },
      15287: (t, e) => {
        "use strict";
        var r = Symbol.for("react.element"),
          n = Symbol.for("react.portal"),
          i = Symbol.for("react.fragment"),
          o = Symbol.for("react.strict_mode"),
          s = Symbol.for("react.profiler"),
          a = Symbol.for("react.provider"),
          u = Symbol.for("react.context"),
          c = Symbol.for("react.forward_ref"),
          f = Symbol.for("react.suspense"),
          h = Symbol.for("react.memo"),
          l = Symbol.for("react.lazy"),
          d = Symbol.iterator;
        /**
         * @license React
         * react.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */ var p = {
            isMounted: function () {
              return !1;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {},
          },
          y = Object.assign,
          g = {};
        function m(t, e, r) {
          (this.props = t),
            (this.context = e),
            (this.refs = g),
            (this.updater = r || p);
        }
        function b() {}
        function w(t, e, r) {
          (this.props = t),
            (this.context = e),
            (this.refs = g),
            (this.updater = r || p);
        }
        (m.prototype.isReactComponent = {}),
          (m.prototype.setState = function (t, e) {
            if ("object" != typeof t && "function" != typeof t && null != t)
              throw Error(
                "setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
              );
            this.updater.enqueueSetState(this, t, e, "setState");
          }),
          (m.prototype.forceUpdate = function (t) {
            this.updater.enqueueForceUpdate(this, t, "forceUpdate");
          }),
          (b.prototype = m.prototype);
        var v = (w.prototype = new b());
        (v.constructor = w), y(v, m.prototype), (v.isPureReactComponent = !0);
        var _ = Array.isArray,
          E = Object.prototype.hasOwnProperty,
          S = { current: null },
          I = { key: !0, ref: !0, __self: !0, __source: !0 };
        function M(t, e, n) {
          var i,
            o = {},
            s = null,
            a = null;
          if (null != e)
            for (i in (void 0 !== e.ref && (a = e.ref),
            void 0 !== e.key && (s = "" + e.key),
            e))
              E.call(e, i) && !I.hasOwnProperty(i) && (o[i] = e[i]);
          var u = arguments.length - 2;
          if (1 === u) o.children = n;
          else if (1 < u) {
            for (var c = Array(u), f = 0; f < u; f++) c[f] = arguments[f + 2];
            o.children = c;
          }
          if (t && t.defaultProps)
            for (i in (u = t.defaultProps)) void 0 === o[i] && (o[i] = u[i]);
          return {
            $$typeof: r,
            type: t,
            key: s,
            ref: a,
            props: o,
            _owner: S.current,
          };
        }
        function A(t) {
          return "object" == typeof t && null !== t && t.$$typeof === r;
        }
        var T = /\/+/g;
        function k(t, e) {
          return "object" == typeof t && null !== t && null != t.key
            ? (function (t) {
                var e = { "=": "=0", ":": "=2" };
                return (
                  "$" +
                  t.replace(/[=:]/g, function (t) {
                    return e[t];
                  })
                );
              })("" + t.key)
            : e.toString(36);
        }
        function O(t, e, i, o, s) {
          var a = typeof t;
          ("undefined" !== a && "boolean" !== a) || (t = null);
          var u = !1;
          if (null === t) u = !0;
          else
            switch (a) {
              case "string":
              case "number":
                u = !0;
                break;
              case "object":
                switch (t.$$typeof) {
                  case r:
                  case n:
                    u = !0;
                }
            }
          if (u)
            return (
              (s = s((u = t))),
              (t = "" === o ? "." + k(u, 0) : o),
              _(s)
                ? ((i = ""),
                  null != t && (i = t.replace(T, "$&/") + "/"),
                  O(s, e, i, "", function (t) {
                    return t;
                  }))
                : null != s &&
                  (A(s) &&
                    (s = (function (t, e) {
                      return {
                        $$typeof: r,
                        type: t.type,
                        key: e,
                        ref: t.ref,
                        props: t.props,
                        _owner: t._owner,
                      };
                    })(
                      s,
                      i +
                        (!s.key || (u && u.key === s.key)
                          ? ""
                          : ("" + s.key).replace(T, "$&/") + "/") +
                        t,
                    )),
                  e.push(s)),
              1
            );
          if (((u = 0), (o = "" === o ? "." : o + ":"), _(t)))
            for (var c = 0; c < t.length; c++) {
              var f = o + k((a = t[c]), c);
              u += O(a, e, i, f, s);
            }
          else if (
            ((f = (function (t) {
              return null === t || "object" != typeof t
                ? null
                : "function" == typeof (t = (d && t[d]) || t["@@iterator"])
                  ? t
                  : null;
            })(t)),
            "function" == typeof f)
          )
            for (t = f.call(t), c = 0; !(a = t.next()).done; )
              u += O((a = a.value), e, i, (f = o + k(a, c++)), s);
          else if ("object" === a)
            throw (
              ((e = String(t)),
              Error(
                "Objects are not valid as a React child (found: " +
                  ("[object Object]" === e
                    ? "object with keys {" + Object.keys(t).join(", ") + "}"
                    : e) +
                  "). If you meant to render a collection of children, use an array instead.",
              ))
            );
          return u;
        }
        function x(t, e, r) {
          if (null == t) return t;
          var n = [],
            i = 0;
          return (
            O(t, n, "", "", function (t) {
              return e.call(r, t, i++);
            }),
            n
          );
        }
        function P(t) {
          if (-1 === t._status) {
            var e = t._result;
            (e = e()).then(
              function (e) {
                (0 !== t._status && -1 !== t._status) ||
                  ((t._status = 1), (t._result = e));
              },
              function (e) {
                (0 !== t._status && -1 !== t._status) ||
                  ((t._status = 2), (t._result = e));
              },
            ),
              -1 === t._status && ((t._status = 0), (t._result = e));
          }
          if (1 === t._status) return t._result.default;
          throw t._result;
        }
        var B = { current: null },
          C = { transition: null };
      },
      96540: (t, e, r) => {
        "use strict";
        r(15287);
      },
      86048: (t) => {
        "use strict";
        var e = {};
        function r(t, r, n) {
          n || (n = Error);
          var i = (function (t) {
            var e, n;
            function i(e, n, i) {
              return (
                t.call(
                  this,
                  (function (t, e, n) {
                    return "string" == typeof r ? r : r(t, e, n);
                  })(e, n, i),
                ) || this
              );
            }
            return (
              (n = t),
              ((e = i).prototype = Object.create(n.prototype)),
              (e.prototype.constructor = e),
              (e.__proto__ = n),
              i
            );
          })(n);
          (i.prototype.name = n.name), (i.prototype.code = t), (e[t] = i);
        }
        function n(t, e) {
          if (Array.isArray(t)) {
            var r = t.length;
            return (
              (t = t.map(function (t) {
                return String(t);
              })),
              r > 2
                ? "one of "
                    .concat(e, " ")
                    .concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1]
                : 2 === r
                  ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1])
                  : "of ".concat(e, " ").concat(t[0])
            );
          }
          return "of ".concat(e, " ").concat(String(t));
        }
        r(
          "ERR_INVALID_OPT_VALUE",
          function (t, e) {
            return 'The value "' + e + '" is invalid for option "' + t + '"';
          },
          TypeError,
        ),
          r(
            "ERR_INVALID_ARG_TYPE",
            function (t, e, r) {
              var i, o, s, a;
              if (
                ("string" == typeof e &&
                ((o = "not "), e.substr(!s || s < 0 ? 0 : +s, o.length) === o)
                  ? ((i = "must not be"), (e = e.replace(/^not /, "")))
                  : (i = "must be"),
                (function (t, e, r) {
                  return (
                    (void 0 === r || r > t.length) && (r = t.length),
                    t.substring(r - e.length, r) === e
                  );
                })(t, " argument"))
              )
                a = "The ".concat(t, " ").concat(i, " ").concat(n(e, "type"));
              else {
                var u = (function (t, e, r) {
                  return (
                    "number" != typeof r && (r = 0),
                    !(r + e.length > t.length) && -1 !== t.indexOf(e, r)
                  );
                })(t, ".")
                  ? "property"
                  : "argument";
                a = 'The "'
                  .concat(t, '" ')
                  .concat(u, " ")
                  .concat(i, " ")
                  .concat(n(e, "type"));
              }
              return (a += ". Received type ".concat(typeof r));
            },
            TypeError,
          ),
          r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
          r("ERR_METHOD_NOT_IMPLEMENTED", function (t) {
            return "The " + t + " method is not implemented";
          }),
          r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
          r("ERR_STREAM_DESTROYED", function (t) {
            return "Cannot call " + t + " after a stream was destroyed";
          }),
          r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
          r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
          r("ERR_STREAM_WRITE_AFTER_END", "write after end"),
          r(
            "ERR_STREAM_NULL_VALUES",
            "May not write null values to stream",
            TypeError,
          ),
          r(
            "ERR_UNKNOWN_ENCODING",
            function (t) {
              return "Unknown encoding: " + t;
            },
            TypeError,
          ),
          r(
            "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
            "stream.unshift() after end event",
          ),
          (t.exports.F = e);
      },
      25382: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i =
            Object.keys ||
            function (t) {
              var e = [];
              for (var r in t) e.push(r);
              return e;
            };
        t.exports = f;
        var o = r(45412),
          s = r(16708);
        r(56698)(f, o);
        for (var a = i(s.prototype), u = 0; u < a.length; u++) {
          var c = a[u];
          f.prototype[c] || (f.prototype[c] = s.prototype[c]);
        }
        function f(t) {
          if (!(this instanceof f)) return new f(t);
          o.call(this, t),
            s.call(this, t),
            (this.allowHalfOpen = !0),
            t &&
              (!1 === t.readable && (this.readable = !1),
              !1 === t.writable && (this.writable = !1),
              !1 === t.allowHalfOpen &&
                ((this.allowHalfOpen = !1), this.once("end", h)));
        }
        function h() {
          this._writableState.ended || n.nextTick(l, this);
        }
        function l(t) {
          t.end();
        }
        Object.defineProperty(f.prototype, "writableHighWaterMark", {
          enumerable: !1,
          get: function () {
            return this._writableState.highWaterMark;
          },
        }),
          Object.defineProperty(f.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
              return this._writableState && this._writableState.getBuffer();
            },
          }),
          Object.defineProperty(f.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
              return this._writableState.length;
            },
          }),
          Object.defineProperty(f.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return (
                void 0 !== this._readableState &&
                void 0 !== this._writableState &&
                this._readableState.destroyed &&
                this._writableState.destroyed
              );
            },
            set: function (t) {
              void 0 !== this._readableState &&
                void 0 !== this._writableState &&
                ((this._readableState.destroyed = t),
                (this._writableState.destroyed = t));
            },
          });
      },
      63600: (t, e, r) => {
        "use strict";
        t.exports = i;
        var n = r(74610);
        function i(t) {
          if (!(this instanceof i)) return new i(t);
          n.call(this, t);
        }
        r(56698)(i, n),
          (i.prototype._transform = function (t, e, r) {
            r(null, t);
          });
      },
      45412: (t, e, r) => {
        "use strict";
        var n,
          i = r(65606);
        (t.exports = M), (M.ReadableState = I);
        r(37007).EventEmitter;
        var o = function (t, e) {
            return t.listeners(e).length;
          },
          s = r(40345),
          a = r(48287).Buffer,
          u =
            (void 0 !== r.g
              ? r.g
              : "undefined" != typeof window
                ? window
                : "undefined" != typeof self
                  ? self
                  : {}
            ).Uint8Array || function () {};
        var c,
          f = r(79838);
        c = f && f.debuglog ? f.debuglog("stream") : function () {};
        var h,
          l,
          d,
          p = r(80345),
          y = r(75896),
          g = r(65291).getHighWaterMark,
          m = r(86048).F,
          b = m.ERR_INVALID_ARG_TYPE,
          w = m.ERR_STREAM_PUSH_AFTER_EOF,
          v = m.ERR_METHOD_NOT_IMPLEMENTED,
          _ = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        r(56698)(M, s);
        var E = y.errorOrDestroy,
          S = ["error", "close", "destroy", "pause", "resume"];
        function I(t, e, i) {
          (n = n || r(25382)),
            (t = t || {}),
            "boolean" != typeof i && (i = e instanceof n),
            (this.objectMode = !!t.objectMode),
            i && (this.objectMode = this.objectMode || !!t.readableObjectMode),
            (this.highWaterMark = g(this, t, "readableHighWaterMark", i)),
            (this.buffer = new p()),
            (this.length = 0),
            (this.pipes = null),
            (this.pipesCount = 0),
            (this.flowing = null),
            (this.ended = !1),
            (this.endEmitted = !1),
            (this.reading = !1),
            (this.sync = !0),
            (this.needReadable = !1),
            (this.emittedReadable = !1),
            (this.readableListening = !1),
            (this.resumeScheduled = !1),
            (this.paused = !0),
            (this.emitClose = !1 !== t.emitClose),
            (this.autoDestroy = !!t.autoDestroy),
            (this.destroyed = !1),
            (this.defaultEncoding = t.defaultEncoding || "utf8"),
            (this.awaitDrain = 0),
            (this.readingMore = !1),
            (this.decoder = null),
            (this.encoding = null),
            t.encoding &&
              (h || (h = r(83141).I),
              (this.decoder = new h(t.encoding)),
              (this.encoding = t.encoding));
        }
        function M(t) {
          if (((n = n || r(25382)), !(this instanceof M))) return new M(t);
          var e = this instanceof n;
          (this._readableState = new I(t, this, e)),
            (this.readable = !0),
            t &&
              ("function" == typeof t.read && (this._read = t.read),
              "function" == typeof t.destroy && (this._destroy = t.destroy)),
            s.call(this);
        }
        function A(t, e, r, n, i) {
          c("readableAddChunk", e);
          var o,
            s = t._readableState;
          if (null === e)
            (s.reading = !1),
              (function (t, e) {
                if ((c("onEofChunk"), e.ended)) return;
                if (e.decoder) {
                  var r = e.decoder.end();
                  r &&
                    r.length &&
                    (e.buffer.push(r),
                    (e.length += e.objectMode ? 1 : r.length));
                }
                (e.ended = !0),
                  e.sync
                    ? x(t)
                    : ((e.needReadable = !1),
                      e.emittedReadable || ((e.emittedReadable = !0), P(t)));
              })(t, s);
          else if (
            (i ||
              (o = (function (t, e) {
                var r;
                (n = e),
                  a.isBuffer(n) ||
                    n instanceof u ||
                    "string" == typeof e ||
                    void 0 === e ||
                    t.objectMode ||
                    (r = new b("chunk", ["string", "Buffer", "Uint8Array"], e));
                var n;
                return r;
              })(s, e)),
            o)
          )
            E(t, o);
          else if (s.objectMode || (e && e.length > 0))
            if (
              ("string" == typeof e ||
                s.objectMode ||
                Object.getPrototypeOf(e) === a.prototype ||
                (e = (function (t) {
                  return a.from(t);
                })(e)),
              n)
            )
              s.endEmitted ? E(t, new _()) : T(t, s, e, !0);
            else if (s.ended) E(t, new w());
            else {
              if (s.destroyed) return !1;
              (s.reading = !1),
                s.decoder && !r
                  ? ((e = s.decoder.write(e)),
                    s.objectMode || 0 !== e.length ? T(t, s, e, !1) : B(t, s))
                  : T(t, s, e, !1);
            }
          else n || ((s.reading = !1), B(t, s));
          return !s.ended && (s.length < s.highWaterMark || 0 === s.length);
        }
        function T(t, e, r, n) {
          e.flowing && 0 === e.length && !e.sync
            ? ((e.awaitDrain = 0), t.emit("data", r))
            : ((e.length += e.objectMode ? 1 : r.length),
              n ? e.buffer.unshift(r) : e.buffer.push(r),
              e.needReadable && x(t)),
            B(t, e);
        }
        Object.defineProperty(M.prototype, "destroyed", {
          enumerable: !1,
          get: function () {
            return (
              void 0 !== this._readableState && this._readableState.destroyed
            );
          },
          set: function (t) {
            this._readableState && (this._readableState.destroyed = t);
          },
        }),
          (M.prototype.destroy = y.destroy),
          (M.prototype._undestroy = y.undestroy),
          (M.prototype._destroy = function (t, e) {
            e(t);
          }),
          (M.prototype.push = function (t, e) {
            var r,
              n = this._readableState;
            return (
              n.objectMode
                ? (r = !0)
                : "string" == typeof t &&
                  ((e = e || n.defaultEncoding) !== n.encoding &&
                    ((t = a.from(t, e)), (e = "")),
                  (r = !0)),
              A(this, t, e, !1, r)
            );
          }),
          (M.prototype.unshift = function (t) {
            return A(this, t, null, !0, !1);
          }),
          (M.prototype.isPaused = function () {
            return !1 === this._readableState.flowing;
          }),
          (M.prototype.setEncoding = function (t) {
            h || (h = r(83141).I);
            var e = new h(t);
            (this._readableState.decoder = e),
              (this._readableState.encoding =
                this._readableState.decoder.encoding);
            for (var n = this._readableState.buffer.head, i = ""; null !== n; )
              (i += e.write(n.data)), (n = n.next);
            return (
              this._readableState.buffer.clear(),
              "" !== i && this._readableState.buffer.push(i),
              (this._readableState.length = i.length),
              this
            );
          });
        var k = 1073741824;
        function O(t, e) {
          return t <= 0 || (0 === e.length && e.ended)
            ? 0
            : e.objectMode
              ? 1
              : t != t
                ? e.flowing && e.length
                  ? e.buffer.head.data.length
                  : e.length
                : (t > e.highWaterMark &&
                    (e.highWaterMark = (function (t) {
                      return (
                        t >= k
                          ? (t = k)
                          : (t--,
                            (t |= t >>> 1),
                            (t |= t >>> 2),
                            (t |= t >>> 4),
                            (t |= t >>> 8),
                            (t |= t >>> 16),
                            t++),
                        t
                      );
                    })(t)),
                  t <= e.length
                    ? t
                    : e.ended
                      ? e.length
                      : ((e.needReadable = !0), 0));
        }
        function x(t) {
          var e = t._readableState;
          c("emitReadable", e.needReadable, e.emittedReadable),
            (e.needReadable = !1),
            e.emittedReadable ||
              (c("emitReadable", e.flowing),
              (e.emittedReadable = !0),
              i.nextTick(P, t));
        }
        function P(t) {
          var e = t._readableState;
          c("emitReadable_", e.destroyed, e.length, e.ended),
            e.destroyed ||
              (!e.length && !e.ended) ||
              (t.emit("readable"), (e.emittedReadable = !1)),
            (e.needReadable =
              !e.flowing && !e.ended && e.length <= e.highWaterMark),
            D(t);
        }
        function B(t, e) {
          e.readingMore || ((e.readingMore = !0), i.nextTick(C, t, e));
        }
        function C(t, e) {
          for (
            ;
            !e.reading &&
            !e.ended &&
            (e.length < e.highWaterMark || (e.flowing && 0 === e.length));

          ) {
            var r = e.length;
            if ((c("maybeReadMore read 0"), t.read(0), r === e.length)) break;
          }
          e.readingMore = !1;
        }
        function R(t) {
          var e = t._readableState;
          (e.readableListening = t.listenerCount("readable") > 0),
            e.resumeScheduled && !e.paused
              ? (e.flowing = !0)
              : t.listenerCount("data") > 0 && t.resume();
        }
        function N(t) {
          c("readable nexttick read 0"), t.read(0);
        }
        function U(t, e) {
          c("resume", e.reading),
            e.reading || t.read(0),
            (e.resumeScheduled = !1),
            t.emit("resume"),
            D(t),
            e.flowing && !e.reading && t.read(0);
        }
        function D(t) {
          var e = t._readableState;
          for (c("flow", e.flowing); e.flowing && null !== t.read(); );
        }
        function L(t, e) {
          return 0 === e.length
            ? null
            : (e.objectMode
                ? (r = e.buffer.shift())
                : !t || t >= e.length
                  ? ((r = e.decoder
                      ? e.buffer.join("")
                      : 1 === e.buffer.length
                        ? e.buffer.first()
                        : e.buffer.concat(e.length)),
                    e.buffer.clear())
                  : (r = e.buffer.consume(t, e.decoder)),
              r);
          var r;
        }
        function j(t) {
          var e = t._readableState;
          c("endReadable", e.endEmitted),
            e.endEmitted || ((e.ended = !0), i.nextTick(F, e, t));
        }
        function F(t, e) {
          if (
            (c("endReadableNT", t.endEmitted, t.length),
            !t.endEmitted &&
              0 === t.length &&
              ((t.endEmitted = !0),
              (e.readable = !1),
              e.emit("end"),
              t.autoDestroy))
          ) {
            var r = e._writableState;
            (!r || (r.autoDestroy && r.finished)) && e.destroy();
          }
        }
        function H(t, e) {
          for (var r = 0, n = t.length; r < n; r++) if (t[r] === e) return r;
          return -1;
        }
        (M.prototype.read = function (t) {
          c("read", t), (t = parseInt(t, 10));
          var e = this._readableState,
            r = t;
          if (
            (0 !== t && (e.emittedReadable = !1),
            0 === t &&
              e.needReadable &&
              ((0 !== e.highWaterMark
                ? e.length >= e.highWaterMark
                : e.length > 0) ||
                e.ended))
          )
            return (
              c("read: emitReadable", e.length, e.ended),
              0 === e.length && e.ended ? j(this) : x(this),
              null
            );
          if (0 === (t = O(t, e)) && e.ended)
            return 0 === e.length && j(this), null;
          var n,
            i = e.needReadable;
          return (
            c("need readable", i),
            (0 === e.length || e.length - t < e.highWaterMark) &&
              c("length less than watermark", (i = !0)),
            e.ended || e.reading
              ? c("reading or ended", (i = !1))
              : i &&
                (c("do read"),
                (e.reading = !0),
                (e.sync = !0),
                0 === e.length && (e.needReadable = !0),
                this._read(e.highWaterMark),
                (e.sync = !1),
                e.reading || (t = O(r, e))),
            null === (n = t > 0 ? L(t, e) : null)
              ? ((e.needReadable = e.length <= e.highWaterMark), (t = 0))
              : ((e.length -= t), (e.awaitDrain = 0)),
            0 === e.length &&
              (e.ended || (e.needReadable = !0), r !== t && e.ended && j(this)),
            null !== n && this.emit("data", n),
            n
          );
        }),
          (M.prototype._read = function (t) {
            E(this, new v("_read()"));
          }),
          (M.prototype.pipe = function (t, e) {
            var r = this,
              n = this._readableState;
            switch (n.pipesCount) {
              case 0:
                n.pipes = t;
                break;
              case 1:
                n.pipes = [n.pipes, t];
                break;
              default:
                n.pipes.push(t);
            }
            (n.pipesCount += 1), c("pipe count=%d opts=%j", n.pipesCount, e);
            var s =
              (!e || !1 !== e.end) && t !== i.stdout && t !== i.stderr ? u : g;
            function a(e, i) {
              c("onunpipe"),
                e === r &&
                  i &&
                  !1 === i.hasUnpiped &&
                  ((i.hasUnpiped = !0),
                  c("cleanup"),
                  t.removeListener("close", p),
                  t.removeListener("finish", y),
                  t.removeListener("drain", f),
                  t.removeListener("error", d),
                  t.removeListener("unpipe", a),
                  r.removeListener("end", u),
                  r.removeListener("end", g),
                  r.removeListener("data", l),
                  (h = !0),
                  !n.awaitDrain ||
                    (t._writableState && !t._writableState.needDrain) ||
                    f());
            }
            function u() {
              c("onend"), t.end();
            }
            n.endEmitted ? i.nextTick(s) : r.once("end", s), t.on("unpipe", a);
            var f = (function (t) {
              return function () {
                var e = t._readableState;
                c("pipeOnDrain", e.awaitDrain),
                  e.awaitDrain && e.awaitDrain--,
                  0 === e.awaitDrain &&
                    o(t, "data") &&
                    ((e.flowing = !0), D(t));
              };
            })(r);
            t.on("drain", f);
            var h = !1;
            function l(e) {
              c("ondata");
              var i = t.write(e);
              c("dest.write", i),
                !1 === i &&
                  (((1 === n.pipesCount && n.pipes === t) ||
                    (n.pipesCount > 1 && -1 !== H(n.pipes, t))) &&
                    !h &&
                    (c("false write response, pause", n.awaitDrain),
                    n.awaitDrain++),
                  r.pause());
            }
            function d(e) {
              c("onerror", e),
                g(),
                t.removeListener("error", d),
                0 === o(t, "error") && E(t, e);
            }
            function p() {
              t.removeListener("finish", y), g();
            }
            function y() {
              c("onfinish"), t.removeListener("close", p), g();
            }
            function g() {
              c("unpipe"), r.unpipe(t);
            }
            return (
              r.on("data", l),
              (function (t, e, r) {
                if ("function" == typeof t.prependListener)
                  return t.prependListener(e, r);
                t._events && t._events[e]
                  ? Array.isArray(t._events[e])
                    ? t._events[e].unshift(r)
                    : (t._events[e] = [r, t._events[e]])
                  : t.on(e, r);
              })(t, "error", d),
              t.once("close", p),
              t.once("finish", y),
              t.emit("pipe", r),
              n.flowing || (c("pipe resume"), r.resume()),
              t
            );
          }),
          (M.prototype.unpipe = function (t) {
            var e = this._readableState,
              r = { hasUnpiped: !1 };
            if (0 === e.pipesCount) return this;
            if (1 === e.pipesCount)
              return (
                (t && t !== e.pipes) ||
                  (t || (t = e.pipes),
                  (e.pipes = null),
                  (e.pipesCount = 0),
                  (e.flowing = !1),
                  t && t.emit("unpipe", this, r)),
                this
              );
            if (!t) {
              var n = e.pipes,
                i = e.pipesCount;
              (e.pipes = null), (e.pipesCount = 0), (e.flowing = !1);
              for (var o = 0; o < i; o++)
                n[o].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var s = H(e.pipes, t);
            return (
              -1 === s ||
                (e.pipes.splice(s, 1),
                (e.pipesCount -= 1),
                1 === e.pipesCount && (e.pipes = e.pipes[0]),
                t.emit("unpipe", this, r)),
              this
            );
          }),
          (M.prototype.on = function (t, e) {
            var r = s.prototype.on.call(this, t, e),
              n = this._readableState;
            return (
              "data" === t
                ? ((n.readableListening = this.listenerCount("readable") > 0),
                  !1 !== n.flowing && this.resume())
                : "readable" === t &&
                  (n.endEmitted ||
                    n.readableListening ||
                    ((n.readableListening = n.needReadable = !0),
                    (n.flowing = !1),
                    (n.emittedReadable = !1),
                    c("on readable", n.length, n.reading),
                    n.length ? x(this) : n.reading || i.nextTick(N, this))),
              r
            );
          }),
          (M.prototype.addListener = M.prototype.on),
          (M.prototype.removeListener = function (t, e) {
            var r = s.prototype.removeListener.call(this, t, e);
            return "readable" === t && i.nextTick(R, this), r;
          }),
          (M.prototype.removeAllListeners = function (t) {
            var e = s.prototype.removeAllListeners.apply(this, arguments);
            return ("readable" !== t && void 0 !== t) || i.nextTick(R, this), e;
          }),
          (M.prototype.resume = function () {
            var t = this._readableState;
            return (
              t.flowing ||
                (c("resume"),
                (t.flowing = !t.readableListening),
                (function (t, e) {
                  e.resumeScheduled ||
                    ((e.resumeScheduled = !0), i.nextTick(U, t, e));
                })(this, t)),
              (t.paused = !1),
              this
            );
          }),
          (M.prototype.pause = function () {
            return (
              c("call pause flowing=%j", this._readableState.flowing),
              !1 !== this._readableState.flowing &&
                (c("pause"),
                (this._readableState.flowing = !1),
                this.emit("pause")),
              (this._readableState.paused = !0),
              this
            );
          }),
          (M.prototype.wrap = function (t) {
            var e = this,
              r = this._readableState,
              n = !1;
            for (var i in (t.on("end", function () {
              if ((c("wrapped end"), r.decoder && !r.ended)) {
                var t = r.decoder.end();
                t && t.length && e.push(t);
              }
              e.push(null);
            }),
            t.on("data", function (i) {
              (c("wrapped data"),
              r.decoder && (i = r.decoder.write(i)),
              r.objectMode && null == i) ||
                ((r.objectMode || (i && i.length)) &&
                  (e.push(i) || ((n = !0), t.pause())));
            }),
            t))
              void 0 === this[i] &&
                "function" == typeof t[i] &&
                (this[i] = (function (e) {
                  return function () {
                    return t[e].apply(t, arguments);
                  };
                })(i));
            for (var o = 0; o < S.length; o++)
              t.on(S[o], this.emit.bind(this, S[o]));
            return (
              (this._read = function (e) {
                c("wrapped _read", e), n && ((n = !1), t.resume());
              }),
              this
            );
          }),
          "function" == typeof Symbol &&
            (M.prototype[Symbol.asyncIterator] = function () {
              return void 0 === l && (l = r(2955)), l(this);
            }),
          Object.defineProperty(M.prototype, "readableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._readableState.highWaterMark;
            },
          }),
          Object.defineProperty(M.prototype, "readableBuffer", {
            enumerable: !1,
            get: function () {
              return this._readableState && this._readableState.buffer;
            },
          }),
          Object.defineProperty(M.prototype, "readableFlowing", {
            enumerable: !1,
            get: function () {
              return this._readableState.flowing;
            },
            set: function (t) {
              this._readableState && (this._readableState.flowing = t);
            },
          }),
          (M._fromList = L),
          Object.defineProperty(M.prototype, "readableLength", {
            enumerable: !1,
            get: function () {
              return this._readableState.length;
            },
          }),
          "function" == typeof Symbol &&
            (M.from = function (t, e) {
              return void 0 === d && (d = r(55157)), d(M, t, e);
            });
      },
      74610: (t, e, r) => {
        "use strict";
        t.exports = f;
        var n = r(86048).F,
          i = n.ERR_METHOD_NOT_IMPLEMENTED,
          o = n.ERR_MULTIPLE_CALLBACK,
          s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
          a = n.ERR_TRANSFORM_WITH_LENGTH_0,
          u = r(25382);
        function c(t, e) {
          var r = this._transformState;
          r.transforming = !1;
          var n = r.writecb;
          if (null === n) return this.emit("error", new o());
          (r.writechunk = null),
            (r.writecb = null),
            null != e && this.push(e),
            n(t);
          var i = this._readableState;
          (i.reading = !1),
            (i.needReadable || i.length < i.highWaterMark) &&
              this._read(i.highWaterMark);
        }
        function f(t) {
          if (!(this instanceof f)) return new f(t);
          u.call(this, t),
            (this._transformState = {
              afterTransform: c.bind(this),
              needTransform: !1,
              transforming: !1,
              writecb: null,
              writechunk: null,
              writeencoding: null,
            }),
            (this._readableState.needReadable = !0),
            (this._readableState.sync = !1),
            t &&
              ("function" == typeof t.transform &&
                (this._transform = t.transform),
              "function" == typeof t.flush && (this._flush = t.flush)),
            this.on("prefinish", h);
        }
        function h() {
          var t = this;
          "function" != typeof this._flush || this._readableState.destroyed
            ? l(this, null, null)
            : this._flush(function (e, r) {
                l(t, e, r);
              });
        }
        function l(t, e, r) {
          if (e) return t.emit("error", e);
          if ((null != r && t.push(r), t._writableState.length)) throw new a();
          if (t._transformState.transforming) throw new s();
          return t.push(null);
        }
        r(56698)(f, u),
          (f.prototype.push = function (t, e) {
            return (
              (this._transformState.needTransform = !1),
              u.prototype.push.call(this, t, e)
            );
          }),
          (f.prototype._transform = function (t, e, r) {
            r(new i("_transform()"));
          }),
          (f.prototype._write = function (t, e, r) {
            var n = this._transformState;
            if (
              ((n.writecb = r),
              (n.writechunk = t),
              (n.writeencoding = e),
              !n.transforming)
            ) {
              var i = this._readableState;
              (n.needTransform ||
                i.needReadable ||
                i.length < i.highWaterMark) &&
                this._read(i.highWaterMark);
            }
          }),
          (f.prototype._read = function (t) {
            var e = this._transformState;
            null === e.writechunk || e.transforming
              ? (e.needTransform = !0)
              : ((e.transforming = !0),
                this._transform(
                  e.writechunk,
                  e.writeencoding,
                  e.afterTransform,
                ));
          }),
          (f.prototype._destroy = function (t, e) {
            u.prototype._destroy.call(this, t, function (t) {
              e(t);
            });
          });
      },
      16708: (t, e, r) => {
        "use strict";
        var n,
          i = r(65606);
        function o(t) {
          var e = this;
          (this.next = null),
            (this.entry = null),
            (this.finish = function () {
              !(function (t, e, r) {
                var n = t.entry;
                t.entry = null;
                for (; n; ) {
                  var i = n.callback;
                  e.pendingcb--, i(r), (n = n.next);
                }
                e.corkedRequestsFree.next = t;
              })(e, t);
            });
        }
        (t.exports = M), (M.WritableState = I);
        var s = { deprecate: r(94643) },
          a = r(40345),
          u = r(48287).Buffer,
          c =
            (void 0 !== r.g
              ? r.g
              : "undefined" != typeof window
                ? window
                : "undefined" != typeof self
                  ? self
                  : {}
            ).Uint8Array || function () {};
        var f,
          h = r(75896),
          l = r(65291).getHighWaterMark,
          d = r(86048).F,
          p = d.ERR_INVALID_ARG_TYPE,
          y = d.ERR_METHOD_NOT_IMPLEMENTED,
          g = d.ERR_MULTIPLE_CALLBACK,
          m = d.ERR_STREAM_CANNOT_PIPE,
          b = d.ERR_STREAM_DESTROYED,
          w = d.ERR_STREAM_NULL_VALUES,
          v = d.ERR_STREAM_WRITE_AFTER_END,
          _ = d.ERR_UNKNOWN_ENCODING,
          E = h.errorOrDestroy;
        function S() {}
        function I(t, e, s) {
          (n = n || r(25382)),
            (t = t || {}),
            "boolean" != typeof s && (s = e instanceof n),
            (this.objectMode = !!t.objectMode),
            s && (this.objectMode = this.objectMode || !!t.writableObjectMode),
            (this.highWaterMark = l(this, t, "writableHighWaterMark", s)),
            (this.finalCalled = !1),
            (this.needDrain = !1),
            (this.ending = !1),
            (this.ended = !1),
            (this.finished = !1),
            (this.destroyed = !1);
          var a = !1 === t.decodeStrings;
          (this.decodeStrings = !a),
            (this.defaultEncoding = t.defaultEncoding || "utf8"),
            (this.length = 0),
            (this.writing = !1),
            (this.corked = 0),
            (this.sync = !0),
            (this.bufferProcessing = !1),
            (this.onwrite = function (t) {
              !(function (t, e) {
                var r = t._writableState,
                  n = r.sync,
                  o = r.writecb;
                if ("function" != typeof o) throw new g();
                if (
                  ((function (t) {
                    (t.writing = !1),
                      (t.writecb = null),
                      (t.length -= t.writelen),
                      (t.writelen = 0);
                  })(r),
                  e)
                )
                  !(function (t, e, r, n, o) {
                    --e.pendingcb,
                      r
                        ? (i.nextTick(o, n),
                          i.nextTick(P, t, e),
                          (t._writableState.errorEmitted = !0),
                          E(t, n))
                        : (o(n),
                          (t._writableState.errorEmitted = !0),
                          E(t, n),
                          P(t, e));
                  })(t, r, n, e, o);
                else {
                  var s = O(r) || t.destroyed;
                  s ||
                    r.corked ||
                    r.bufferProcessing ||
                    !r.bufferedRequest ||
                    k(t, r),
                    n ? i.nextTick(T, t, r, s, o) : T(t, r, s, o);
                }
              })(e, t);
            }),
            (this.writecb = null),
            (this.writelen = 0),
            (this.bufferedRequest = null),
            (this.lastBufferedRequest = null),
            (this.pendingcb = 0),
            (this.prefinished = !1),
            (this.errorEmitted = !1),
            (this.emitClose = !1 !== t.emitClose),
            (this.autoDestroy = !!t.autoDestroy),
            (this.bufferedRequestCount = 0),
            (this.corkedRequestsFree = new o(this));
        }
        function M(t) {
          var e = this instanceof (n = n || r(25382));
          if (!e && !f.call(M, this)) return new M(t);
          (this._writableState = new I(t, this, e)),
            (this.writable = !0),
            t &&
              ("function" == typeof t.write && (this._write = t.write),
              "function" == typeof t.writev && (this._writev = t.writev),
              "function" == typeof t.destroy && (this._destroy = t.destroy),
              "function" == typeof t.final && (this._final = t.final)),
            a.call(this);
        }
        function A(t, e, r, n, i, o, s) {
          (e.writelen = n),
            (e.writecb = s),
            (e.writing = !0),
            (e.sync = !0),
            e.destroyed
              ? e.onwrite(new b("write"))
              : r
                ? t._writev(i, e.onwrite)
                : t._write(i, o, e.onwrite),
            (e.sync = !1);
        }
        function T(t, e, r, n) {
          r ||
            (function (t, e) {
              0 === e.length &&
                e.needDrain &&
                ((e.needDrain = !1), t.emit("drain"));
            })(t, e),
            e.pendingcb--,
            n(),
            P(t, e);
        }
        function k(t, e) {
          e.bufferProcessing = !0;
          var r = e.bufferedRequest;
          if (t._writev && r && r.next) {
            var n = e.bufferedRequestCount,
              i = new Array(n),
              s = e.corkedRequestsFree;
            s.entry = r;
            for (var a = 0, u = !0; r; )
              (i[a] = r), r.isBuf || (u = !1), (r = r.next), (a += 1);
            (i.allBuffers = u),
              A(t, e, !0, e.length, i, "", s.finish),
              e.pendingcb++,
              (e.lastBufferedRequest = null),
              s.next
                ? ((e.corkedRequestsFree = s.next), (s.next = null))
                : (e.corkedRequestsFree = new o(e)),
              (e.bufferedRequestCount = 0);
          } else {
            for (; r; ) {
              var c = r.chunk,
                f = r.encoding,
                h = r.callback;
              if (
                (A(t, e, !1, e.objectMode ? 1 : c.length, c, f, h),
                (r = r.next),
                e.bufferedRequestCount--,
                e.writing)
              )
                break;
            }
            null === r && (e.lastBufferedRequest = null);
          }
          (e.bufferedRequest = r), (e.bufferProcessing = !1);
        }
        function O(t) {
          return (
            t.ending &&
            0 === t.length &&
            null === t.bufferedRequest &&
            !t.finished &&
            !t.writing
          );
        }
        function x(t, e) {
          t._final(function (r) {
            e.pendingcb--,
              r && E(t, r),
              (e.prefinished = !0),
              t.emit("prefinish"),
              P(t, e);
          });
        }
        function P(t, e) {
          var r = O(e);
          if (
            r &&
            ((function (t, e) {
              e.prefinished ||
                e.finalCalled ||
                ("function" != typeof t._final || e.destroyed
                  ? ((e.prefinished = !0), t.emit("prefinish"))
                  : (e.pendingcb++, (e.finalCalled = !0), i.nextTick(x, t, e)));
            })(t, e),
            0 === e.pendingcb &&
              ((e.finished = !0), t.emit("finish"), e.autoDestroy))
          ) {
            var n = t._readableState;
            (!n || (n.autoDestroy && n.endEmitted)) && t.destroy();
          }
          return r;
        }
        r(56698)(M, a),
          (I.prototype.getBuffer = function () {
            for (var t = this.bufferedRequest, e = []; t; )
              e.push(t), (t = t.next);
            return e;
          }),
          (function () {
            try {
              Object.defineProperty(I.prototype, "buffer", {
                get: s.deprecate(
                  function () {
                    return this.getBuffer();
                  },
                  "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.",
                  "DEP0003",
                ),
              });
            } catch (t) {}
          })(),
          "function" == typeof Symbol &&
          Symbol.hasInstance &&
          "function" == typeof Function.prototype[Symbol.hasInstance]
            ? ((f = Function.prototype[Symbol.hasInstance]),
              Object.defineProperty(M, Symbol.hasInstance, {
                value: function (t) {
                  return (
                    !!f.call(this, t) ||
                    (this === M && t && t._writableState instanceof I)
                  );
                },
              }))
            : (f = function (t) {
                return t instanceof this;
              }),
          (M.prototype.pipe = function () {
            E(this, new m());
          }),
          (M.prototype.write = function (t, e, r) {
            var n,
              o = this._writableState,
              s = !1,
              a = !o.objectMode && ((n = t), u.isBuffer(n) || n instanceof c);
            return (
              a &&
                !u.isBuffer(t) &&
                (t = (function (t) {
                  return u.from(t);
                })(t)),
              "function" == typeof e && ((r = e), (e = null)),
              a ? (e = "buffer") : e || (e = o.defaultEncoding),
              "function" != typeof r && (r = S),
              o.ending
                ? (function (t, e) {
                    var r = new v();
                    E(t, r), i.nextTick(e, r);
                  })(this, r)
                : (a ||
                    (function (t, e, r, n) {
                      var o;
                      return (
                        null === r
                          ? (o = new w())
                          : "string" == typeof r ||
                            e.objectMode ||
                            (o = new p("chunk", ["string", "Buffer"], r)),
                        !o || (E(t, o), i.nextTick(n, o), !1)
                      );
                    })(this, o, t, r)) &&
                  (o.pendingcb++,
                  (s = (function (t, e, r, n, i, o) {
                    if (!r) {
                      var s = (function (t, e, r) {
                        t.objectMode ||
                          !1 === t.decodeStrings ||
                          "string" != typeof e ||
                          (e = u.from(e, r));
                        return e;
                      })(e, n, i);
                      n !== s && ((r = !0), (i = "buffer"), (n = s));
                    }
                    var a = e.objectMode ? 1 : n.length;
                    e.length += a;
                    var c = e.length < e.highWaterMark;
                    c || (e.needDrain = !0);
                    if (e.writing || e.corked) {
                      var f = e.lastBufferedRequest;
                      (e.lastBufferedRequest = {
                        chunk: n,
                        encoding: i,
                        isBuf: r,
                        callback: o,
                        next: null,
                      }),
                        f
                          ? (f.next = e.lastBufferedRequest)
                          : (e.bufferedRequest = e.lastBufferedRequest),
                        (e.bufferedRequestCount += 1);
                    } else A(t, e, !1, a, n, i, o);
                    return c;
                  })(this, o, a, t, e, r))),
              s
            );
          }),
          (M.prototype.cork = function () {
            this._writableState.corked++;
          }),
          (M.prototype.uncork = function () {
            var t = this._writableState;
            t.corked &&
              (t.corked--,
              t.writing ||
                t.corked ||
                t.bufferProcessing ||
                !t.bufferedRequest ||
                k(this, t));
          }),
          (M.prototype.setDefaultEncoding = function (t) {
            if (
              ("string" == typeof t && (t = t.toLowerCase()),
              !(
                [
                  "hex",
                  "utf8",
                  "utf-8",
                  "ascii",
                  "binary",
                  "base64",
                  "ucs2",
                  "ucs-2",
                  "utf16le",
                  "utf-16le",
                  "raw",
                ].indexOf((t + "").toLowerCase()) > -1
              ))
            )
              throw new _(t);
            return (this._writableState.defaultEncoding = t), this;
          }),
          Object.defineProperty(M.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
              return this._writableState && this._writableState.getBuffer();
            },
          }),
          Object.defineProperty(M.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._writableState.highWaterMark;
            },
          }),
          (M.prototype._write = function (t, e, r) {
            r(new y("_write()"));
          }),
          (M.prototype._writev = null),
          (M.prototype.end = function (t, e, r) {
            var n = this._writableState;
            return (
              "function" == typeof t
                ? ((r = t), (t = null), (e = null))
                : "function" == typeof e && ((r = e), (e = null)),
              null != t && this.write(t, e),
              n.corked && ((n.corked = 1), this.uncork()),
              n.ending ||
                (function (t, e, r) {
                  (e.ending = !0),
                    P(t, e),
                    r && (e.finished ? i.nextTick(r) : t.once("finish", r));
                  (e.ended = !0), (t.writable = !1);
                })(this, n, r),
              this
            );
          }),
          Object.defineProperty(M.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
              return this._writableState.length;
            },
          }),
          Object.defineProperty(M.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return (
                void 0 !== this._writableState && this._writableState.destroyed
              );
            },
            set: function (t) {
              this._writableState && (this._writableState.destroyed = t);
            },
          }),
          (M.prototype.destroy = h.destroy),
          (M.prototype._undestroy = h.undestroy),
          (M.prototype._destroy = function (t, e) {
            e(t);
          });
      },
      2955: (t, e, r) => {
        "use strict";
        var n,
          i = r(65606);
        function o(t, e, r) {
          return (
            (e = (function (t) {
              var e = (function (t, e) {
                if ("object" != typeof t || null === t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                  var n = r.call(t, e || "default");
                  if ("object" != typeof n) return n;
                  throw new TypeError(
                    "@@toPrimitive must return a primitive value.",
                  );
                }
                return ("string" === e ? String : Number)(t);
              })(t, "string");
              return "symbol" == typeof e ? e : String(e);
            })(e)) in t
              ? Object.defineProperty(t, e, {
                  value: r,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (t[e] = r),
            t
          );
        }
        var s = r(86238),
          a = Symbol("lastResolve"),
          u = Symbol("lastReject"),
          c = Symbol("error"),
          f = Symbol("ended"),
          h = Symbol("lastPromise"),
          l = Symbol("handlePromise"),
          d = Symbol("stream");
        function p(t, e) {
          return { value: t, done: e };
        }
        function y(t) {
          var e = t[a];
          if (null !== e) {
            var r = t[d].read();
            null !== r &&
              ((t[h] = null), (t[a] = null), (t[u] = null), e(p(r, !1)));
          }
        }
        function g(t) {
          i.nextTick(y, t);
        }
        var m = Object.getPrototypeOf(function () {}),
          b = Object.setPrototypeOf(
            (o(
              (n = {
                get stream() {
                  return this[d];
                },
                next: function () {
                  var t = this,
                    e = this[c];
                  if (null !== e) return Promise.reject(e);
                  if (this[f]) return Promise.resolve(p(void 0, !0));
                  if (this[d].destroyed)
                    return new Promise(function (e, r) {
                      i.nextTick(function () {
                        t[c] ? r(t[c]) : e(p(void 0, !0));
                      });
                    });
                  var r,
                    n = this[h];
                  if (n)
                    r = new Promise(
                      (function (t, e) {
                        return function (r, n) {
                          t.then(function () {
                            e[f] ? r(p(void 0, !0)) : e[l](r, n);
                          }, n);
                        };
                      })(n, this),
                    );
                  else {
                    var o = this[d].read();
                    if (null !== o) return Promise.resolve(p(o, !1));
                    r = new Promise(this[l]);
                  }
                  return (this[h] = r), r;
                },
              }),
              Symbol.asyncIterator,
              function () {
                return this;
              },
            ),
            o(n, "return", function () {
              var t = this;
              return new Promise(function (e, r) {
                t[d].destroy(null, function (t) {
                  t ? r(t) : e(p(void 0, !0));
                });
              });
            }),
            n),
            m,
          );
        t.exports = function (t) {
          var e,
            r = Object.create(
              b,
              (o((e = {}), d, { value: t, writable: !0 }),
              o(e, a, { value: null, writable: !0 }),
              o(e, u, { value: null, writable: !0 }),
              o(e, c, { value: null, writable: !0 }),
              o(e, f, { value: t._readableState.endEmitted, writable: !0 }),
              o(e, l, {
                value: function (t, e) {
                  var n = r[d].read();
                  n
                    ? ((r[h] = null), (r[a] = null), (r[u] = null), t(p(n, !1)))
                    : ((r[a] = t), (r[u] = e));
                },
                writable: !0,
              }),
              e),
            );
          return (
            (r[h] = null),
            s(t, function (t) {
              if (t && "ERR_STREAM_PREMATURE_CLOSE" !== t.code) {
                var e = r[u];
                return (
                  null !== e &&
                    ((r[h] = null), (r[a] = null), (r[u] = null), e(t)),
                  void (r[c] = t)
                );
              }
              var n = r[a];
              null !== n &&
                ((r[h] = null), (r[a] = null), (r[u] = null), n(p(void 0, !0))),
                (r[f] = !0);
            }),
            t.on("readable", g.bind(null, r)),
            r
          );
        };
      },
      80345: (t, e, r) => {
        "use strict";
        function n(t, e) {
          var r = Object.keys(t);
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(t);
            e &&
              (n = n.filter(function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable;
              })),
              r.push.apply(r, n);
          }
          return r;
        }
        function i(t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = null != arguments[e] ? arguments[e] : {};
            e % 2
              ? n(Object(r), !0).forEach(function (e) {
                  o(t, e, r[e]);
                })
              : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(r),
                  )
                : n(Object(r)).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(r, e),
                    );
                  });
          }
          return t;
        }
        function o(t, e, r) {
          return (
            (e = a(e)) in t
              ? Object.defineProperty(t, e, {
                  value: r,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (t[e] = r),
            t
          );
        }
        function s(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(t, a(n.key), n);
          }
        }
        function a(t) {
          var e = (function (t, e) {
            if ("object" != typeof t || null === t) return t;
            var r = t[Symbol.toPrimitive];
            if (void 0 !== r) {
              var n = r.call(t, e || "default");
              if ("object" != typeof n) return n;
              throw new TypeError(
                "@@toPrimitive must return a primitive value.",
              );
            }
            return ("string" === e ? String : Number)(t);
          })(t, "string");
          return "symbol" == typeof e ? e : String(e);
        }
        var u = r(48287).Buffer,
          c = r(15340).inspect,
          f = (c && c.custom) || "inspect";
        t.exports = (function () {
          function t() {
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, t),
              (this.head = null),
              (this.tail = null),
              (this.length = 0);
          }
          var e, r, n;
          return (
            (e = t),
            (r = [
              {
                key: "push",
                value: function (t) {
                  var e = { data: t, next: null };
                  this.length > 0 ? (this.tail.next = e) : (this.head = e),
                    (this.tail = e),
                    ++this.length;
                },
              },
              {
                key: "unshift",
                value: function (t) {
                  var e = { data: t, next: this.head };
                  0 === this.length && (this.tail = e),
                    (this.head = e),
                    ++this.length;
                },
              },
              {
                key: "shift",
                value: function () {
                  if (0 !== this.length) {
                    var t = this.head.data;
                    return (
                      1 === this.length
                        ? (this.head = this.tail = null)
                        : (this.head = this.head.next),
                      --this.length,
                      t
                    );
                  }
                },
              },
              {
                key: "clear",
                value: function () {
                  (this.head = this.tail = null), (this.length = 0);
                },
              },
              {
                key: "join",
                value: function (t) {
                  if (0 === this.length) return "";
                  for (var e = this.head, r = "" + e.data; (e = e.next); )
                    r += t + e.data;
                  return r;
                },
              },
              {
                key: "concat",
                value: function (t) {
                  if (0 === this.length) return u.alloc(0);
                  for (
                    var e,
                      r,
                      n,
                      i = u.allocUnsafe(t >>> 0),
                      o = this.head,
                      s = 0;
                    o;

                  )
                    (e = o.data),
                      (r = i),
                      (n = s),
                      u.prototype.copy.call(e, r, n),
                      (s += o.data.length),
                      (o = o.next);
                  return i;
                },
              },
              {
                key: "consume",
                value: function (t, e) {
                  var r;
                  return (
                    t < this.head.data.length
                      ? ((r = this.head.data.slice(0, t)),
                        (this.head.data = this.head.data.slice(t)))
                      : (r =
                          t === this.head.data.length
                            ? this.shift()
                            : e
                              ? this._getString(t)
                              : this._getBuffer(t)),
                    r
                  );
                },
              },
              {
                key: "first",
                value: function () {
                  return this.head.data;
                },
              },
              {
                key: "_getString",
                value: function (t) {
                  var e = this.head,
                    r = 1,
                    n = e.data;
                  for (t -= n.length; (e = e.next); ) {
                    var i = e.data,
                      o = t > i.length ? i.length : t;
                    if (
                      (o === i.length ? (n += i) : (n += i.slice(0, t)),
                      0 == (t -= o))
                    ) {
                      o === i.length
                        ? (++r,
                          e.next
                            ? (this.head = e.next)
                            : (this.head = this.tail = null))
                        : ((this.head = e), (e.data = i.slice(o)));
                      break;
                    }
                    ++r;
                  }
                  return (this.length -= r), n;
                },
              },
              {
                key: "_getBuffer",
                value: function (t) {
                  var e = u.allocUnsafe(t),
                    r = this.head,
                    n = 1;
                  for (r.data.copy(e), t -= r.data.length; (r = r.next); ) {
                    var i = r.data,
                      o = t > i.length ? i.length : t;
                    if ((i.copy(e, e.length - t, 0, o), 0 == (t -= o))) {
                      o === i.length
                        ? (++n,
                          r.next
                            ? (this.head = r.next)
                            : (this.head = this.tail = null))
                        : ((this.head = r), (r.data = i.slice(o)));
                      break;
                    }
                    ++n;
                  }
                  return (this.length -= n), e;
                },
              },
              {
                key: f,
                value: function (t, e) {
                  return c(
                    this,
                    i(i({}, e), {}, { depth: 0, customInspect: !1 }),
                  );
                },
              },
            ]) && s(e.prototype, r),
            n && s(e, n),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            t
          );
        })();
      },
      75896: (t, e, r) => {
        "use strict";
        var n = r(65606);
        function i(t, e) {
          s(t, e), o(t);
        }
        function o(t) {
          (t._writableState && !t._writableState.emitClose) ||
            (t._readableState && !t._readableState.emitClose) ||
            t.emit("close");
        }
        function s(t, e) {
          t.emit("error", e);
        }
        t.exports = {
          destroy: function (t, e) {
            var r = this,
              a = this._readableState && this._readableState.destroyed,
              u = this._writableState && this._writableState.destroyed;
            return a || u
              ? (e
                  ? e(t)
                  : t &&
                    (this._writableState
                      ? this._writableState.errorEmitted ||
                        ((this._writableState.errorEmitted = !0),
                        n.nextTick(s, this, t))
                      : n.nextTick(s, this, t)),
                this)
              : (this._readableState && (this._readableState.destroyed = !0),
                this._writableState && (this._writableState.destroyed = !0),
                this._destroy(t || null, function (t) {
                  !e && t
                    ? r._writableState
                      ? r._writableState.errorEmitted
                        ? n.nextTick(o, r)
                        : ((r._writableState.errorEmitted = !0),
                          n.nextTick(i, r, t))
                      : n.nextTick(i, r, t)
                    : e
                      ? (n.nextTick(o, r), e(t))
                      : n.nextTick(o, r);
                }),
                this);
          },
          undestroy: function () {
            this._readableState &&
              ((this._readableState.destroyed = !1),
              (this._readableState.reading = !1),
              (this._readableState.ended = !1),
              (this._readableState.endEmitted = !1)),
              this._writableState &&
                ((this._writableState.destroyed = !1),
                (this._writableState.ended = !1),
                (this._writableState.ending = !1),
                (this._writableState.finalCalled = !1),
                (this._writableState.prefinished = !1),
                (this._writableState.finished = !1),
                (this._writableState.errorEmitted = !1));
          },
          errorOrDestroy: function (t, e) {
            var r = t._readableState,
              n = t._writableState;
            (r && r.autoDestroy) || (n && n.autoDestroy)
              ? t.destroy(e)
              : t.emit("error", e);
          },
        };
      },
      86238: (t, e, r) => {
        "use strict";
        var n = r(86048).F.ERR_STREAM_PREMATURE_CLOSE;
        function i() {}
        t.exports = function t(e, r, o) {
          if ("function" == typeof r) return t(e, null, r);
          r || (r = {}),
            (o = (function (t) {
              var e = !1;
              return function () {
                if (!e) {
                  e = !0;
                  for (
                    var r = arguments.length, n = new Array(r), i = 0;
                    i < r;
                    i++
                  )
                    n[i] = arguments[i];
                  t.apply(this, n);
                }
              };
            })(o || i));
          var s = r.readable || (!1 !== r.readable && e.readable),
            a = r.writable || (!1 !== r.writable && e.writable),
            u = function () {
              e.writable || f();
            },
            c = e._writableState && e._writableState.finished,
            f = function () {
              (a = !1), (c = !0), s || o.call(e);
            },
            h = e._readableState && e._readableState.endEmitted,
            l = function () {
              (s = !1), (h = !0), a || o.call(e);
            },
            d = function (t) {
              o.call(e, t);
            },
            p = function () {
              var t;
              return s && !h
                ? ((e._readableState && e._readableState.ended) ||
                    (t = new n()),
                  o.call(e, t))
                : a && !c
                  ? ((e._writableState && e._writableState.ended) ||
                      (t = new n()),
                    o.call(e, t))
                  : void 0;
            },
            y = function () {
              e.req.on("finish", f);
            };
          return (
            !(function (t) {
              return t.setHeader && "function" == typeof t.abort;
            })(e)
              ? a && !e._writableState && (e.on("end", u), e.on("close", u))
              : (e.on("complete", f),
                e.on("abort", p),
                e.req ? y() : e.on("request", y)),
            e.on("end", l),
            e.on("finish", f),
            !1 !== r.error && e.on("error", d),
            e.on("close", p),
            function () {
              e.removeListener("complete", f),
                e.removeListener("abort", p),
                e.removeListener("request", y),
                e.req && e.req.removeListener("finish", f),
                e.removeListener("end", u),
                e.removeListener("close", u),
                e.removeListener("finish", f),
                e.removeListener("end", l),
                e.removeListener("error", d),
                e.removeListener("close", p);
            }
          );
        };
      },
      55157: (t) => {
        t.exports = function () {
          throw new Error("Readable.from is not available in the browser");
        };
      },
      57758: (t, e, r) => {
        "use strict";
        var n;
        var i = r(86048).F,
          o = i.ERR_MISSING_ARGS,
          s = i.ERR_STREAM_DESTROYED;
        function a(t) {
          if (t) throw t;
        }
        function u(t) {
          t();
        }
        function c(t, e) {
          return t.pipe(e);
        }
        t.exports = function () {
          for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
            e[i] = arguments[i];
          var f,
            h = (function (t) {
              return t.length
                ? "function" != typeof t[t.length - 1]
                  ? a
                  : t.pop()
                : a;
            })(e);
          if ((Array.isArray(e[0]) && (e = e[0]), e.length < 2))
            throw new o("streams");
          var l = e.map(function (t, i) {
            var o = i < e.length - 1;
            return (function (t, e, i, o) {
              o = (function (t) {
                var e = !1;
                return function () {
                  e || ((e = !0), t.apply(void 0, arguments));
                };
              })(o);
              var a = !1;
              t.on("close", function () {
                a = !0;
              }),
                void 0 === n && (n = r(86238)),
                n(t, { readable: e, writable: i }, function (t) {
                  if (t) return o(t);
                  (a = !0), o();
                });
              var u = !1;
              return function (e) {
                if (!a && !u)
                  return (
                    (u = !0),
                    (function (t) {
                      return t.setHeader && "function" == typeof t.abort;
                    })(t)
                      ? t.abort()
                      : "function" == typeof t.destroy
                        ? t.destroy()
                        : void o(e || new s("pipe"))
                  );
              };
            })(t, o, i > 0, function (t) {
              f || (f = t), t && l.forEach(u), o || (l.forEach(u), h(f));
            });
          });
          return e.reduce(c);
        };
      },
      65291: (t, e, r) => {
        "use strict";
        var n = r(86048).F.ERR_INVALID_OPT_VALUE;
        t.exports = {
          getHighWaterMark: function (t, e, r, i) {
            var o = (function (t, e, r) {
              return null != t.highWaterMark
                ? t.highWaterMark
                : e
                  ? t[r]
                  : null;
            })(e, i, r);
            if (null != o) {
              if (!isFinite(o) || Math.floor(o) !== o || o < 0)
                throw new n(i ? r : "highWaterMark", o);
              return Math.floor(o);
            }
            return t.objectMode ? 16 : 16384;
          },
        };
      },
      40345: (t, e, r) => {
        t.exports = r(37007).EventEmitter;
      },
      28399: (t, e, r) => {
        ((e = t.exports = r(45412)).Stream = e),
          (e.Readable = e),
          (e.Writable = r(16708)),
          (e.Duplex = r(25382)),
          (e.Transform = r(74610)),
          (e.PassThrough = r(63600)),
          (e.finished = r(86238)),
          (e.pipeline = r(57758));
      },
      93204: (t, e, r) => {
        "use strict";
        e.OV = e.PL = void 0;
        var n = r(67386),
          i = 0,
          o = "&_GET_INIT_STATE",
          s = "&_SEND_INIT_STATE",
          a = "&_RECEIVE_INIT_STATE",
          u = "&_INIT_MESSAGE_LISTENER",
          c = {
            channel: "redux_state_sync",
            predicate: null,
            blacklist: [],
            whitelist: [],
            broadcastChannelOption: void 0,
            prepareState: function (t) {
              return t;
            },
            receiveState: function (t, e) {
              return e;
            },
          },
          f = function () {
            return { type: s };
          },
          h = function (t) {
            return { type: a, payload: t };
          };
        function l() {
          return Math.floor(65536 * (1 + Math.random()))
            .toString(16)
            .substring(1);
        }
        function d() {
          return (
            "" +
            l() +
            l() +
            "-" +
            l() +
            "-" +
            l() +
            "-" +
            l() +
            "-" +
            l() +
            l() +
            l()
          );
        }
        var p = d();
        function y(t) {
          var e = t;
          return (e.$uuid = d()), (e.$wuid = p), e;
        }
        function g(t) {
          var e = t.predicate,
            r = t.blacklist,
            n = t.whitelist,
            i = function () {
              return !0;
            };
          return (
            e && "function" == typeof e
              ? (i = e)
              : Array.isArray(r)
                ? (i = function (t) {
                    return r.indexOf(t.type) < 0;
                  })
                : Array.isArray(n) &&
                  (i = function (t) {
                    return n.indexOf(t.type) >= 0;
                  }),
            i
          );
        }
        function m(t) {
          var e = t.channel,
            r = t.dispatch,
            n = t.allowed,
            u = !1,
            c = {};
          (this.handleOnMessage = function (t) {
            t.$wuid !== p &&
              t.type !== a &&
              t.$uuid &&
              t.$uuid !== i &&
              (t.type !== o || c[t.$wuid]
                ? t.type !== s || c[t.$wuid]
                  ? n(t) &&
                    ((i = t.$uuid), r(Object.assign(t, { $isSync: !0 })))
                  : u || ((u = !0), r(h(t.payload)))
                : ((c[t.$wuid] = !0), r(f())));
          }),
            (this.messageChannel = e),
            (this.messageChannel.onmessage = this.handleOnMessage);
        }
        e.PL = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : c,
            e = g(t),
            r = new n.BroadcastChannel(t.channel, t.broadcastChannelOption),
            a = t.prepareState || c.prepareState,
            u = null;
          return function (t) {
            var n = t.getState,
              c = t.dispatch;
            return function (t) {
              return function (f) {
                if (
                  (u || (u = new m({ channel: r, dispatch: c, allowed: e })),
                  f && !f.$uuid)
                ) {
                  var h = y(f);
                  i = h.$uuid;
                  try {
                    if (f.type === s)
                      return (
                        n() && ((h.payload = a(n())), r.postMessage(h)), t(f)
                      );
                    (e(h) || f.type === o) && r.postMessage(h);
                  } catch (t) {
                    console.error(
                      "Your browser doesn't support cross tab communication",
                    );
                  }
                }
                return t(
                  Object.assign(f, {
                    $isSync: void 0 !== f.$isSync && f.$isSync,
                  }),
                );
              };
            };
          };
        };
        var b = function (t) {
          var e =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : c.receiveState;
          return function (r, n) {
            var i = r;
            return n.type === a && (i = e(r, n.payload)), t(i, n);
          };
        };
        e.OV = function (t) {
          (0, t.dispatch)({ type: u });
        };
      },
      67386: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            BroadcastChannel: () => B,
            beLeader: () => Z,
            clearNodeFolder: () => C,
            createLeaderElection: () => J,
            enforceOptions: () => R,
          });
        var n = r(65606);
        function i(t) {
          return (
            t || (t = 0),
            new Promise(function (e) {
              return setTimeout(e, t);
            })
          );
        }
        function o() {
          return Math.random().toString(36).substring(2);
        }
        var s = 0,
          a = 0;
        function u() {
          var t = new Date().getTime();
          return t === s ? 1e3 * t + ++a : ((s = t), (a = 0), 1e3 * t);
        }
        var c =
          "[object process]" ===
          Object.prototype.toString.call(void 0 !== n ? n : 0);
        const f = {
          create: function (t) {
            var e = {
              messagesCallback: null,
              bc: new BroadcastChannel(t),
              subFns: [],
            };
            return (
              (e.bc.onmessage = function (t) {
                e.messagesCallback && e.messagesCallback(t.data);
              }),
              e
            );
          },
          close: function (t) {
            t.bc.close(), (t.subFns = []);
          },
          onMessage: function (t, e) {
            t.messagesCallback = e;
          },
          postMessage: function (t, e) {
            try {
              return t.bc.postMessage(e, !1), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          },
          canBeUsed: function () {
            if (c && "undefined" == typeof window) return !1;
            if ("function" == typeof BroadcastChannel) {
              if (BroadcastChannel._pubkey)
                throw new Error(
                  "BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill",
                );
              return !0;
            }
            return !1;
          },
          type: "native",
          averageResponseTime: function () {
            return 150;
          },
          microSeconds: u,
        };
        var h = (function () {
          function t(t) {
            (this.ttl = t), (this.set = new Set()), (this.timeMap = new Map());
          }
          return (
            (t.prototype.has = function (t) {
              return this.set.has(t);
            }),
            (t.prototype.add = function (t) {
              var e = this;
              this.timeMap.set(t, l()),
                this.set.add(t),
                setTimeout(function () {
                  !(function (t) {
                    var e = l() - t.ttl,
                      r = t.set[Symbol.iterator]();
                    for (;;) {
                      var n = r.next().value;
                      if (!n) return;
                      if (!(t.timeMap.get(n) < e)) return;
                      t.timeMap.delete(n), t.set.delete(n);
                    }
                  })(e);
                }, 0);
            }),
            (t.prototype.clear = function () {
              this.set.clear(), this.timeMap.clear();
            }),
            t
          );
        })();
        function l() {
          return new Date().getTime();
        }
        function d() {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            e = JSON.parse(JSON.stringify(t));
          return (
            void 0 === e.webWorkerSupport && (e.webWorkerSupport = !0),
            e.idb || (e.idb = {}),
            e.idb.ttl || (e.idb.ttl = 45e3),
            e.idb.fallbackInterval || (e.idb.fallbackInterval = 150),
            t.idb &&
              "function" == typeof t.idb.onclose &&
              (e.idb.onclose = t.idb.onclose),
            e.localstorage || (e.localstorage = {}),
            e.localstorage.removeTimeout ||
              (e.localstorage.removeTimeout = 6e4),
            t.methods && (e.methods = t.methods),
            e.node || (e.node = {}),
            e.node.ttl || (e.node.ttl = 12e4),
            void 0 === e.node.useFastPath && (e.node.useFastPath = !0),
            e
          );
        }
        var p = "messages";
        function y() {
          if ("undefined" != typeof indexedDB) return indexedDB;
          if ("undefined" != typeof window) {
            if (void 0 !== window.mozIndexedDB) return window.mozIndexedDB;
            if (void 0 !== window.webkitIndexedDB)
              return window.webkitIndexedDB;
            if (void 0 !== window.msIndexedDB) return window.msIndexedDB;
          }
          return !1;
        }
        function g(t, e) {
          var r = t.transaction(p).objectStore(p),
            n = [];
          return new Promise(function (t) {
            (function () {
              try {
                var t = IDBKeyRange.bound(e + 1, 1 / 0);
                return r.openCursor(t);
              } catch (t) {
                return r.openCursor();
              }
            })().onsuccess = function (r) {
              var i = r.target.result;
              i
                ? i.value.id < e + 1
                  ? i.continue(e + 1)
                  : (n.push(i.value), i.continue())
                : t(n);
            };
          });
        }
        function m(t, e) {
          return (function (t, e) {
            var r = new Date().getTime() - e,
              n = t.transaction(p).objectStore(p),
              i = [];
            return new Promise(function (t) {
              n.openCursor().onsuccess = function (e) {
                var n = e.target.result;
                if (n) {
                  var o = n.value;
                  if (!(o.time < r)) return void t(i);
                  i.push(o), n.continue();
                } else t(i);
              };
            });
          })(t, e).then(function (e) {
            return Promise.all(
              e.map(function (e) {
                return (function (t, e) {
                  var r = t
                    .transaction([p], "readwrite")
                    .objectStore(p)
                    .delete(e);
                  return new Promise(function (t) {
                    r.onsuccess = function () {
                      return t();
                    };
                  });
                })(t, e.id);
              }),
            );
          });
        }
        function b(t) {
          t.closed ||
            w(t)
              .then(function () {
                return i(t.options.idb.fallbackInterval);
              })
              .then(function () {
                return b(t);
              });
        }
        function w(t) {
          return t.closed
            ? Promise.resolve()
            : t.messagesCallback
              ? g(t.db, t.lastCursorId).then(function (e) {
                  var r = e
                    .filter(function (t) {
                      return !!t;
                    })
                    .map(function (e) {
                      return (
                        e.id > t.lastCursorId && (t.lastCursorId = e.id), e
                      );
                    })
                    .filter(function (e) {
                      return (function (t, e) {
                        return !(
                          t.uuid === e.uuid ||
                          e.eMIs.has(t.id) ||
                          t.data.time < e.messagesCallbackTime
                        );
                      })(e, t);
                    })
                    .sort(function (t, e) {
                      return t.time - e.time;
                    });
                  return (
                    r.forEach(function (e) {
                      t.messagesCallback &&
                        (t.eMIs.add(e.id), t.messagesCallback(e.data));
                    }),
                    Promise.resolve()
                  );
                })
              : Promise.resolve();
        }
        const v = {
          create: function (t, e) {
            return (
              (e = d(e)),
              (function (t) {
                var e = "pubkey.broadcast-channel-0-" + t,
                  r = y().open(e, 1);
                return (
                  (r.onupgradeneeded = function (t) {
                    t.target.result.createObjectStore(p, {
                      keyPath: "id",
                      autoIncrement: !0,
                    });
                  }),
                  new Promise(function (t, e) {
                    (r.onerror = function (t) {
                      return e(t);
                    }),
                      (r.onsuccess = function () {
                        t(r.result);
                      });
                  })
                );
              })(t).then(function (r) {
                var n = {
                  closed: !1,
                  lastCursorId: 0,
                  channelName: t,
                  options: e,
                  uuid: o(),
                  eMIs: new h(2 * e.idb.ttl),
                  writeBlockPromise: Promise.resolve(),
                  messagesCallback: null,
                  readQueuePromises: [],
                  db: r,
                };
                return (
                  (r.onclose = function () {
                    (n.closed = !0), e.idb.onclose && e.idb.onclose();
                  }),
                  b(n),
                  n
                );
              })
            );
          },
          close: function (t) {
            (t.closed = !0), t.db.close();
          },
          onMessage: function (t, e, r) {
            (t.messagesCallbackTime = r), (t.messagesCallback = e), w(t);
          },
          postMessage: function (t, e) {
            return (
              (t.writeBlockPromise = t.writeBlockPromise
                .then(function () {
                  return (function (t, e, r) {
                    var n = { uuid: e, time: new Date().getTime(), data: r },
                      i = t.transaction([p], "readwrite");
                    return new Promise(function (t, e) {
                      (i.oncomplete = function () {
                        return t();
                      }),
                        (i.onerror = function (t) {
                          return e(t);
                        }),
                        i.objectStore(p).add(n);
                    });
                  })(t.db, t.uuid, e);
                })
                .then(function () {
                  var e, r;
                  0 ===
                    ((e = 0),
                    (r = 10),
                    Math.floor(Math.random() * (r - e + 1) + e)) &&
                    m(t.db, t.options.idb.ttl);
                })),
              t.writeBlockPromise
            );
          },
          canBeUsed: function () {
            return !c && !!y();
          },
          type: "idb",
          averageResponseTime: function (t) {
            return 2 * t.idb.fallbackInterval;
          },
          microSeconds: u,
        };
        function _() {
          var t;
          if ("undefined" == typeof window) return null;
          try {
            (t = window.localStorage),
              (t = window["ie8-eventlistener/storage"] || window.localStorage);
          } catch (t) {}
          return t;
        }
        function E(t) {
          return "pubkey.broadcastChannel-" + t;
        }
        function S() {
          if (c) return !1;
          var t = _();
          if (!t) return !1;
          try {
            var e = "__broadcastchannel_check";
            t.setItem(e, "works"), t.removeItem(e);
          } catch (t) {
            return !1;
          }
          return !0;
        }
        const I = {
          create: function (t, e) {
            if (((e = d(e)), !S()))
              throw new Error("BroadcastChannel: localstorage cannot be used");
            var r = o(),
              n = new h(e.localstorage.removeTimeout),
              i = { channelName: t, uuid: r, eMIs: n };
            return (
              (i.listener = (function (t, e) {
                var r = E(t),
                  n = function (t) {
                    t.key === r && e(JSON.parse(t.newValue));
                  };
                return window.addEventListener("storage", n), n;
              })(t, function (t) {
                i.messagesCallback &&
                  t.uuid !== r &&
                  t.token &&
                  !n.has(t.token) &&
                  ((t.data.time && t.data.time < i.messagesCallbackTime) ||
                    (n.add(t.token), i.messagesCallback(t.data)));
              })),
              i
            );
          },
          close: function (t) {
            var e;
            (e = t.listener), window.removeEventListener("storage", e);
          },
          onMessage: function (t, e, r) {
            (t.messagesCallbackTime = r), (t.messagesCallback = e);
          },
          postMessage: function (t, e) {
            return new Promise(function (r) {
              i().then(function () {
                var n = E(t.channelName),
                  i = {
                    token: o(),
                    time: new Date().getTime(),
                    data: e,
                    uuid: t.uuid,
                  },
                  s = JSON.stringify(i);
                _().setItem(n, s);
                var a = document.createEvent("Event");
                a.initEvent("storage", !0, !0),
                  (a.key = n),
                  (a.newValue = s),
                  window.dispatchEvent(a),
                  r();
              });
            });
          },
          canBeUsed: S,
          type: "localstorage",
          averageResponseTime: function () {
            var t = navigator.userAgent.toLowerCase();
            return t.includes("safari") && !t.includes("chrome") ? 240 : 120;
          },
          microSeconds: u,
        };
        var M = u,
          A = new Set();
        const T = {
          create: function (t) {
            var e = { name: t, messagesCallback: null };
            return A.add(e), e;
          },
          close: function (t) {
            A.delete(t);
          },
          onMessage: function (t, e) {
            t.messagesCallback = e;
          },
          postMessage: function (t, e) {
            return new Promise(function (r) {
              return setTimeout(function () {
                Array.from(A)
                  .filter(function (e) {
                    return e.name === t.name;
                  })
                  .filter(function (e) {
                    return e !== t;
                  })
                  .filter(function (t) {
                    return !!t.messagesCallback;
                  })
                  .forEach(function (t) {
                    return t.messagesCallback(e);
                  }),
                  r();
              }, 5);
            });
          },
          canBeUsed: function () {
            return !0;
          },
          type: "simulate",
          averageResponseTime: function () {
            return 5;
          },
          microSeconds: M,
        };
        var k = [f, v, I];
        if (c) {
          var O = r(68289);
          "function" == typeof O.canBeUsed && k.push(O);
        }
        function x(t) {
          var e = [].concat(t.methods, k).filter(Boolean);
          if (t.type) {
            if ("simulate" === t.type) return T;
            var r = e.find(function (e) {
              return e.type === t.type;
            });
            if (r) return r;
            throw new Error("method-type " + t.type + " not found");
          }
          t.webWorkerSupport ||
            c ||
            (e = e.filter(function (t) {
              return "idb" !== t.type;
            }));
          var n = e.find(function (t) {
            return t.canBeUsed();
          });
          if (n) return n;
          throw new Error(
            "No useable methode found:" +
              JSON.stringify(
                k.map(function (t) {
                  return t.type;
                }),
              ),
          );
        }
        var P,
          B = function (t, e) {
            var r, n, i;
            (this.name = t),
              P && (e = P),
              (this.options = d(e)),
              (this.method = x(this.options)),
              (this._iL = !1),
              (this._onML = null),
              (this._addEL = { message: [], internal: [] }),
              (this._uMP = new Set()),
              (this._befC = []),
              (this._prepP = null),
              (n = (r = this).method.create(r.name, r.options)),
              (i = n) && "function" == typeof i.then
                ? ((r._prepP = n),
                  n.then(function (t) {
                    r._state = t;
                  }))
                : (r._state = n);
          };
        function C(t) {
          var e = x((t = d(t)));
          return "node" === e.type
            ? e.clearNodeFolder().then(function () {
                return !0;
              })
            : Promise.resolve(!1);
        }
        function R(t) {
          P = t;
        }
        function N(t, e, r) {
          var n = { time: t.method.microSeconds(), type: e, data: r };
          return (t._prepP ? t._prepP : Promise.resolve()).then(function () {
            var e = t.method.postMessage(t._state, n);
            return (
              t._uMP.add(e),
              e.catch().then(function () {
                return t._uMP.delete(e);
              }),
              e
            );
          });
        }
        function U(t) {
          return t._addEL.message.length > 0 || t._addEL.internal.length > 0;
        }
        function D(t, e, r) {
          t._addEL[e].push(r),
            (function (t) {
              if (!t._iL && U(t)) {
                var e = function (e) {
                    t._addEL[e.type].forEach(function (t) {
                      e.time >= t.time && t.fn(e.data);
                    });
                  },
                  r = t.method.microSeconds();
                t._prepP
                  ? t._prepP.then(function () {
                      (t._iL = !0), t.method.onMessage(t._state, e, r);
                    })
                  : ((t._iL = !0), t.method.onMessage(t._state, e, r));
              }
            })(t);
        }
        function L(t, e, r) {
          (t._addEL[e] = t._addEL[e].filter(function (t) {
            return t !== r;
          })),
            (function (t) {
              if (t._iL && !U(t)) {
                t._iL = !1;
                var e = t.method.microSeconds();
                t.method.onMessage(t._state, null, e);
              }
            })(t);
        }
        (B._pubkey = !0),
          (B.prototype = {
            postMessage: function (t) {
              if (this.closed)
                throw new Error(
                  "BroadcastChannel.postMessage(): Cannot post message after channel has closed",
                );
              return N(this, "message", t);
            },
            postInternal: function (t) {
              return N(this, "internal", t);
            },
            set onmessage(t) {
              var e = { time: this.method.microSeconds(), fn: t };
              L(this, "message", this._onML),
                t && "function" == typeof t
                  ? ((this._onML = e), D(this, "message", e))
                  : (this._onML = null);
            },
            addEventListener: function (t, e) {
              D(this, t, { time: this.method.microSeconds(), fn: e });
            },
            removeEventListener: function (t, e) {
              L(
                this,
                t,
                this._addEL[t].find(function (t) {
                  return t.fn === e;
                }),
              );
            },
            close: function () {
              var t = this;
              if (!this.closed) {
                this.closed = !0;
                var e = this._prepP ? this._prepP : Promise.resolve();
                return (
                  (this._onML = null),
                  (this._addEL.message = []),
                  e
                    .then(function () {
                      return Promise.all(Array.from(t._uMP));
                    })
                    .then(function () {
                      return Promise.all(
                        t._befC.map(function (t) {
                          return t();
                        }),
                      );
                    })
                    .then(function () {
                      return t.method.close(t._state);
                    })
                );
              }
            },
            get type() {
              return this.method.type;
            },
            get isClosed() {
              return this.closed;
            },
          });
        var j = r(74021),
          F = r.n(j);
        const H = {
          add: function (t) {
            if (
              "function" == typeof WorkerGlobalScope &&
              self instanceof WorkerGlobalScope
            );
            else {
              if ("function" != typeof window.addEventListener) return;
              window.addEventListener(
                "beforeunload",
                function () {
                  t();
                },
                !0,
              ),
                window.addEventListener(
                  "unload",
                  function () {
                    t();
                  },
                  !0,
                );
            }
          },
        };
        var K = r(25870),
          V = r.n(K),
          q = F() ? V() : H,
          z = new Set(),
          $ = !1;
        function G() {
          var t = [];
          return (
            z.forEach(function (e) {
              t.push(e()), z.delete(e);
            }),
            Promise.all(t)
          );
        }
        const W = {
          add: function (t) {
            if (($ || (($ = !0), q.add(G)), "function" != typeof t))
              throw new Error("Listener is no function");
            return (
              z.add(t),
              {
                remove: function () {
                  return z.delete(t);
                },
                run: function () {
                  return z.delete(t), t();
                },
              }
            );
          },
          runAll: G,
          removeAll: function () {
            z.clear();
          },
          getSize: function () {
            return z.size;
          },
        };
        var Y = function (t, e) {
          (this._channel = t),
            (this._options = e),
            (this.isLeader = !1),
            (this.isDead = !1),
            (this.token = o()),
            (this._isApl = !1),
            (this._reApply = !1),
            (this._unl = []),
            (this._lstns = []),
            (this._invs = []),
            (this._dpL = function () {}),
            (this._dpLC = !1);
        };
        function X(t, e) {
          var r = { context: "leader", action: e, token: t.token };
          return t._channel.postInternal(r);
        }
        function Z(t) {
          t.isLeader = !0;
          var e = W.add(function () {
            return t.die();
          });
          t._unl.push(e);
          var r = function (e) {
            "leader" === e.context && "apply" === e.action && X(t, "tell"),
              "leader" !== e.context ||
                "tell" !== e.action ||
                t._dpLC ||
                ((t._dpLC = !0), t._dpL(), X(t, "tell"));
          };
          return (
            t._channel.addEventListener("internal", r),
            t._lstns.push(r),
            X(t, "tell")
          );
        }
        function J(t, e) {
          if (t._leaderElector)
            throw new Error("BroadcastChannel already has a leader-elector");
          e = (function (t, e) {
            return (
              t || (t = {}),
              (t = JSON.parse(JSON.stringify(t))).fallbackInterval ||
                (t.fallbackInterval = 3e3),
              t.responseTime ||
                (t.responseTime = e.method.averageResponseTime(e.options)),
              t
            );
          })(e, t);
          var r = new Y(t, e);
          return (
            t._befC.push(function () {
              return r.die();
            }),
            (t._leaderElector = r),
            r
          );
        }
        Y.prototype = {
          applyOnce: function () {
            var t = this;
            if (this.isLeader) return Promise.resolve(!1);
            if (this.isDead) return Promise.resolve(!1);
            if (this._isApl) return (this._reApply = !0), Promise.resolve(!1);
            this._isApl = !0;
            var e = !1,
              r = [],
              n = function (n) {
                "leader" === n.context &&
                  n.token != t.token &&
                  (r.push(n),
                  "apply" === n.action && n.token > t.token && (e = !0),
                  "tell" === n.action && (e = !0));
              };
            return (
              this._channel.addEventListener("internal", n),
              X(this, "apply")
                .then(function () {
                  return i(t._options.responseTime);
                })
                .then(function () {
                  return e ? Promise.reject(new Error()) : X(t, "apply");
                })
                .then(function () {
                  return i(t._options.responseTime);
                })
                .then(function () {
                  return e ? Promise.reject(new Error()) : X(t);
                })
                .then(function () {
                  return Z(t);
                })
                .then(function () {
                  return !0;
                })
                .catch(function () {
                  return !1;
                })
                .then(function (e) {
                  return (
                    t._channel.removeEventListener("internal", n),
                    (t._isApl = !1),
                    !e && t._reApply ? ((t._reApply = !1), t.applyOnce()) : e
                  );
                })
            );
          },
          awaitLeadership: function () {
            var t;
            return (
              this._aLP ||
                (this._aLP = (t = this).isLeader
                  ? Promise.resolve()
                  : new Promise(function (e) {
                      var r = !1;
                      function n() {
                        r ||
                          ((r = !0),
                          clearInterval(i),
                          t._channel.removeEventListener("internal", o),
                          e(!0));
                      }
                      t.applyOnce().then(function () {
                        t.isLeader && n();
                      });
                      var i = setInterval(function () {
                        t.applyOnce().then(function () {
                          t.isLeader && n();
                        });
                      }, t._options.fallbackInterval);
                      t._invs.push(i);
                      var o = function (e) {
                        "leader" === e.context &&
                          "death" === e.action &&
                          t.applyOnce().then(function () {
                            t.isLeader && n();
                          });
                      };
                      t._channel.addEventListener("internal", o),
                        t._lstns.push(o);
                    })),
              this._aLP
            );
          },
          set onduplicate(t) {
            this._dpL = t;
          },
          die: function () {
            var t = this;
            if (!this.isDead)
              return (
                (this.isDead = !0),
                this._lstns.forEach(function (e) {
                  return t._channel.removeEventListener("internal", e);
                }),
                this._invs.forEach(function (t) {
                  return clearInterval(t);
                }),
                this._unl.forEach(function (t) {
                  t.remove();
                }),
                X(this, "death")
              );
          },
        };
      },
      66011: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer,
          i = r(56698),
          o = r(4729),
          s = new Array(16),
          a = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1,
            10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1,
            2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15,
            14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
          ],
          u = [
            5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7,
            0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9,
            11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13,
            9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
          ],
          c = [
            11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13,
            11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
            15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14,
            5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8,
            5, 6,
          ],
          f = [
            8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15,
            7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
            14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9,
            12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
            11, 11,
          ],
          h = [0, 1518500249, 1859775393, 2400959708, 2840853838],
          l = [1352829926, 1548603684, 1836072691, 2053994217, 0];
        function d() {
          o.call(this, 64),
            (this._a = 1732584193),
            (this._b = 4023233417),
            (this._c = 2562383102),
            (this._d = 271733878),
            (this._e = 3285377520);
        }
        function p(t, e) {
          return (t << e) | (t >>> (32 - e));
        }
        function y(t, e, r, n, i, o, s, a) {
          return (p((t + (e ^ r ^ n) + o + s) | 0, a) + i) | 0;
        }
        function g(t, e, r, n, i, o, s, a) {
          return (p((t + ((e & r) | (~e & n)) + o + s) | 0, a) + i) | 0;
        }
        function m(t, e, r, n, i, o, s, a) {
          return (p((t + ((e | ~r) ^ n) + o + s) | 0, a) + i) | 0;
        }
        function b(t, e, r, n, i, o, s, a) {
          return (p((t + ((e & n) | (r & ~n)) + o + s) | 0, a) + i) | 0;
        }
        function w(t, e, r, n, i, o, s, a) {
          return (p((t + (e ^ (r | ~n)) + o + s) | 0, a) + i) | 0;
        }
        i(d, o),
          (d.prototype._update = function () {
            for (var t = s, e = 0; e < 16; ++e)
              t[e] = this._block.readInt32LE(4 * e);
            for (
              var r = 0 | this._a,
                n = 0 | this._b,
                i = 0 | this._c,
                o = 0 | this._d,
                d = 0 | this._e,
                v = 0 | this._a,
                _ = 0 | this._b,
                E = 0 | this._c,
                S = 0 | this._d,
                I = 0 | this._e,
                M = 0;
              M < 80;
              M += 1
            ) {
              var A, T;
              M < 16
                ? ((A = y(r, n, i, o, d, t[a[M]], h[0], c[M])),
                  (T = w(v, _, E, S, I, t[u[M]], l[0], f[M])))
                : M < 32
                  ? ((A = g(r, n, i, o, d, t[a[M]], h[1], c[M])),
                    (T = b(v, _, E, S, I, t[u[M]], l[1], f[M])))
                  : M < 48
                    ? ((A = m(r, n, i, o, d, t[a[M]], h[2], c[M])),
                      (T = m(v, _, E, S, I, t[u[M]], l[2], f[M])))
                    : M < 64
                      ? ((A = b(r, n, i, o, d, t[a[M]], h[3], c[M])),
                        (T = g(v, _, E, S, I, t[u[M]], l[3], f[M])))
                      : ((A = w(r, n, i, o, d, t[a[M]], h[4], c[M])),
                        (T = y(v, _, E, S, I, t[u[M]], l[4], f[M]))),
                (r = d),
                (d = o),
                (o = p(i, 10)),
                (i = n),
                (n = A),
                (v = I),
                (I = S),
                (S = p(E, 10)),
                (E = _),
                (_ = T);
            }
            var k = (this._b + i + S) | 0;
            (this._b = (this._c + o + I) | 0),
              (this._c = (this._d + d + v) | 0),
              (this._d = (this._e + r + _) | 0),
              (this._e = (this._a + n + E) | 0),
              (this._a = k);
          }),
          (d.prototype._digest = function () {
            (this._block[this._blockOffset++] = 128),
              this._blockOffset > 56 &&
                (this._block.fill(0, this._blockOffset, 64),
                this._update(),
                (this._blockOffset = 0)),
              this._block.fill(0, this._blockOffset, 56),
              this._block.writeUInt32LE(this._length[0], 56),
              this._block.writeUInt32LE(this._length[1], 60),
              this._update();
            var t = n.alloc ? n.alloc(20) : new n(20);
            return (
              t.writeInt32LE(this._a, 0),
              t.writeInt32LE(this._b, 4),
              t.writeInt32LE(this._c, 8),
              t.writeInt32LE(this._d, 12),
              t.writeInt32LE(this._e, 16),
              t
            );
          }),
          (t.exports = d);
      },
      92861: (t, e, r) => {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        var n = r(48287),
          i = n.Buffer;
        function o(t, e) {
          for (var r in t) e[r] = t[r];
        }
        function s(t, e, r) {
          return i(t, e, r);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow
          ? (t.exports = n)
          : (o(n, e), (e.Buffer = s)),
          (s.prototype = Object.create(i.prototype)),
          o(i, s),
          (s.from = function (t, e, r) {
            if ("number" == typeof t)
              throw new TypeError("Argument must not be a number");
            return i(t, e, r);
          }),
          (s.alloc = function (t, e, r) {
            if ("number" != typeof t)
              throw new TypeError("Argument must be a number");
            var n = i(t);
            return (
              void 0 !== e
                ? "string" == typeof r
                  ? n.fill(e, r)
                  : n.fill(e)
                : n.fill(0),
              n
            );
          }),
          (s.allocUnsafe = function (t) {
            if ("number" != typeof t)
              throw new TypeError("Argument must be a number");
            return i(t);
          }),
          (s.allocUnsafeSlow = function (t) {
            if ("number" != typeof t)
              throw new TypeError("Argument must be a number");
            return n.SlowBuffer(t);
          });
      },
      99721: (t, e, r) => {
        "use strict";
        var n = r(36556),
          i = r(14035),
          o = n("RegExp.prototype.exec"),
          s = r(69675);
        t.exports = function (t) {
          if (!i(t)) throw new s("`regex` must be a RegExp");
          return function (e) {
            return null !== o(t, e);
          };
        };
      },
      54774: (t, e, r) => {
        "use strict";
        var n,
          i = r(65606),
          o = r(48287),
          s = o.Buffer,
          a = {};
        for (n in o)
          o.hasOwnProperty(n) &&
            "SlowBuffer" !== n &&
            "Buffer" !== n &&
            (a[n] = o[n]);
        var u = (a.Buffer = {});
        for (n in s)
          s.hasOwnProperty(n) &&
            "allocUnsafe" !== n &&
            "allocUnsafeSlow" !== n &&
            (u[n] = s[n]);
        if (
          ((a.Buffer.prototype = s.prototype),
          (u.from && u.from !== Uint8Array.from) ||
            (u.from = function (t, e, r) {
              if ("number" == typeof t)
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type ' +
                    typeof t,
                );
              if (t && void 0 === t.length)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof t,
                );
              return s(t, e, r);
            }),
          u.alloc ||
            (u.alloc = function (t, e, r) {
              if ("number" != typeof t)
                throw new TypeError(
                  'The "size" argument must be of type number. Received type ' +
                    typeof t,
                );
              if (t < 0 || t >= 2 * (1 << 30))
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"',
                );
              var n = s(t);
              return (
                e && 0 !== e.length
                  ? "string" == typeof r
                    ? n.fill(e, r)
                    : n.fill(e)
                  : n.fill(0),
                n
              );
            }),
          !a.kStringMaxLength)
        )
          try {
            a.kStringMaxLength = i.binding("buffer").kStringMaxLength;
          } catch (t) {}
        a.constants ||
          ((a.constants = { MAX_LENGTH: a.kMaxLength }),
          a.kStringMaxLength &&
            (a.constants.MAX_STRING_LENGTH = a.kStringMaxLength)),
          (t.exports = a);
      },
      37141: (t, e, r) => {
        "use strict";
        t.exports = r(95483)(r(558));
      },
      95469: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer,
          i = Object.prototype.toString;
        (e.isArray = function (t, e) {
          if (!Array.isArray(t)) throw TypeError(e);
        }),
          (e.isBoolean = function (t, e) {
            if ("[object Boolean]" !== i.call(t)) throw TypeError(e);
          }),
          (e.isBuffer = function (t, e) {
            if (!n.isBuffer(t)) throw TypeError(e);
          }),
          (e.isFunction = function (t, e) {
            if ("[object Function]" !== i.call(t)) throw TypeError(e);
          }),
          (e.isNumber = function (t, e) {
            if ("[object Number]" !== i.call(t)) throw TypeError(e);
          }),
          (e.isObject = function (t, e) {
            if ("[object Object]" !== i.call(t)) throw TypeError(e);
          }),
          (e.isBufferLength = function (t, e, r) {
            if (t.length !== e) throw RangeError(r);
          }),
          (e.isBufferLength2 = function (t, e, r, n) {
            if (t.length !== e && t.length !== r) throw RangeError(n);
          }),
          (e.isLengthGTZero = function (t, e) {
            if (0 === t.length) throw RangeError(e);
          }),
          (e.isNumberInInterval = function (t, e, r, n) {
            if (t <= e || t >= r) throw RangeError(n);
          });
      },
      95712: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(92368),
          o = n.from([
            48, 129, 211, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 129,
            133, 48, 129, 130, 2, 1, 1, 48, 44, 6, 7, 42, 134, 72, 206, 61, 1,
            1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 254, 255, 255, 252, 47, 48, 6, 4, 1, 0, 4, 1, 7, 4,
            33, 2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149,
            206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129,
            91, 22, 248, 23, 152, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230,
            175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65, 2, 1, 1, 161,
            36, 3, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          ]),
          s = n.from([
            48, 130, 1, 19, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160,
            129, 165, 48, 129, 162, 2, 1, 1, 48, 44, 6, 7, 42, 134, 72, 206, 61,
            1, 1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 254, 255, 255, 252, 47, 48, 6, 4, 1, 0, 4, 1, 7,
            4, 65, 4, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149,
            206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129,
            91, 22, 248, 23, 152, 72, 58, 218, 119, 38, 163, 196, 101, 93, 164,
            251, 252, 14, 17, 8, 168, 253, 23, 180, 72, 166, 133, 84, 25, 156,
            71, 208, 143, 251, 16, 212, 184, 2, 33, 0, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174,
            220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65, 2,
            1, 1, 161, 68, 3, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
          ]);
        (e.privateKeyExport = function (t, e, r) {
          var i = n.from(r ? o : s);
          return t.copy(i, r ? 8 : 9), e.copy(i, r ? 181 : 214), i;
        }),
          (e.privateKeyImport = function (t) {
            var e = t.length,
              r = 0;
            if (
              !(e < r + 1 || 48 !== t[r]) &&
              !(e < (r += 1) + 1) &&
              128 & t[r]
            ) {
              var n = 127 & t[r];
              if (((r += 1), !(n < 1 || n > 2 || e < r + n))) {
                var i = t[r + n - 1] | (n > 1 ? t[r + n - 2] << 8 : 0);
                if (
                  !(
                    e < (r += n) + i ||
                    e < r + 3 ||
                    2 !== t[r] ||
                    1 !== t[r + 1] ||
                    1 !== t[r + 2] ||
                    e < (r += 3) + 2 ||
                    4 !== t[r] ||
                    t[r + 1] > 32 ||
                    e < r + 2 + t[r + 1]
                  )
                )
                  return t.slice(r + 2, r + 2 + t[r + 1]);
              }
            }
          }),
          (e.signatureExport = function (t) {
            for (
              var e = n.concat([n.from([0]), t.r]), r = 33, o = 0;
              r > 1 && 0 === e[o] && !(128 & e[o + 1]);
              --r, ++o
            );
            for (
              var s = n.concat([n.from([0]), t.s]), a = 33, u = 0;
              a > 1 && 0 === s[u] && !(128 & s[u + 1]);
              --a, ++u
            );
            return i.encode(e.slice(o), s.slice(u));
          }),
          (e.signatureImport = function (t) {
            var e = n.alloc(32, 0),
              r = n.alloc(32, 0);
            try {
              var o = i.decode(t);
              if (
                (33 === o.r.length && 0 === o.r[0] && (o.r = o.r.slice(1)),
                o.r.length > 32)
              )
                throw new Error("R length is too long");
              if (
                (33 === o.s.length && 0 === o.s[0] && (o.s = o.s.slice(1)),
                o.s.length > 32)
              )
                throw new Error("S length is too long");
            } catch (t) {
              return;
            }
            return (
              o.r.copy(e, 32 - o.r.length),
              o.s.copy(r, 32 - o.s.length),
              { r: e, s: r }
            );
          }),
          (e.signatureImportLax = function (t) {
            var e = n.alloc(32, 0),
              r = n.alloc(32, 0),
              i = t.length,
              o = 0;
            if (48 === t[o++]) {
              var s = t[o++];
              if (!(128 & s && (o += s - 128) > i) && 2 === t[o++]) {
                var a = t[o++];
                if (128 & a) {
                  if (o + (s = a - 128) > i) return;
                  for (; s > 0 && 0 === t[o]; o += 1, s -= 1);
                  for (a = 0; s > 0; o += 1, s -= 1) a = (a << 8) + t[o];
                }
                if (!(a > i - o)) {
                  var u = o;
                  if (((o += a), 2 === t[o++])) {
                    var c = t[o++];
                    if (128 & c) {
                      if (o + (s = c - 128) > i) return;
                      for (; s > 0 && 0 === t[o]; o += 1, s -= 1);
                      for (c = 0; s > 0; o += 1, s -= 1) c = (c << 8) + t[o];
                    }
                    if (!(c > i - o)) {
                      var f = o;
                      for (o += c; a > 0 && 0 === t[u]; a -= 1, u += 1);
                      if (!(a > 32)) {
                        var h = t.slice(u, u + a);
                        for (
                          h.copy(e, 32 - h.length);
                          c > 0 && 0 === t[f];
                          c -= 1, f += 1
                        );
                        if (!(c > 32)) {
                          var l = t.slice(f, f + c);
                          return l.copy(r, 32 - l.length), { r: e, s: r };
                        }
                      }
                    }
                  }
                }
              }
            }
          });
      },
      558: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = r(47108),
          o = r(5262),
          s = r(86729).ec,
          a = r(53892),
          u = new s("secp256k1"),
          c = u.curve;
        function f(t) {
          var e = t[0];
          switch (e) {
            case 2:
            case 3:
              return 33 !== t.length
                ? null
                : (function (t, e) {
                    var r = new o(e);
                    if (r.cmp(c.p) >= 0) return null;
                    var n = (r = r.toRed(c.red))
                      .redSqr()
                      .redIMul(r)
                      .redIAdd(c.b)
                      .redSqrt();
                    (3 === t) !== n.isOdd() && (n = n.redNeg());
                    const i = r.redSqr().redIMul(r);
                    return n.redSqr().redISub(i.redIAdd(c.b)).isZero()
                      ? u.keyPair({ pub: { x: r, y: n } })
                      : null;
                  })(e, t.slice(1, 33));
            case 4:
            case 6:
            case 7:
              return 65 !== t.length
                ? null
                : (function (t, e, r) {
                    var n = new o(e),
                      i = new o(r);
                    if (n.cmp(c.p) >= 0 || i.cmp(c.p) >= 0) return null;
                    if (
                      ((n = n.toRed(c.red)),
                      (i = i.toRed(c.red)),
                      (6 === t || 7 === t) && i.isOdd() !== (7 === t))
                    )
                      return null;
                    var s = n.redSqr().redIMul(n);
                    return i.redSqr().redISub(s.redIAdd(c.b)).isZero()
                      ? u.keyPair({ pub: { x: n, y: i } })
                      : null;
                  })(e, t.slice(1, 33), t.slice(33, 65));
            default:
              return null;
          }
        }
        (e.privateKeyVerify = function (t) {
          var e = new o(t);
          return e.cmp(c.n) < 0 && !e.isZero();
        }),
          (e.privateKeyExport = function (t, e) {
            var r = new o(t);
            if (r.cmp(c.n) >= 0 || r.isZero())
              throw new Error(a.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
            return n.from(u.keyFromPrivate(t).getPublic(e, !0));
          }),
          (e.privateKeyNegate = function (t) {
            var e = new o(t);
            return e.isZero()
              ? n.alloc(32)
              : c.n.sub(e).umod(c.n).toArrayLike(n, "be", 32);
          }),
          (e.privateKeyModInverse = function (t) {
            var e = new o(t);
            if (e.cmp(c.n) >= 0 || e.isZero())
              throw new Error(a.EC_PRIVATE_KEY_RANGE_INVALID);
            return e.invm(c.n).toArrayLike(n, "be", 32);
          }),
          (e.privateKeyTweakAdd = function (t, e) {
            var r = new o(e);
            if (r.cmp(c.n) >= 0)
              throw new Error(a.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
            if ((r.iadd(new o(t)), r.cmp(c.n) >= 0 && r.isub(c.n), r.isZero()))
              throw new Error(a.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
            return r.toArrayLike(n, "be", 32);
          }),
          (e.privateKeyTweakMul = function (t, e) {
            var r = new o(e);
            if (r.cmp(c.n) >= 0 || r.isZero())
              throw new Error(a.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
            return (
              r.imul(new o(t)),
              r.cmp(c.n) && (r = r.umod(c.n)),
              r.toArrayLike(n, "be", 32)
            );
          }),
          (e.publicKeyCreate = function (t, e) {
            var r = new o(t);
            if (r.cmp(c.n) >= 0 || r.isZero())
              throw new Error(a.EC_PUBLIC_KEY_CREATE_FAIL);
            return n.from(u.keyFromPrivate(t).getPublic(e, !0));
          }),
          (e.publicKeyConvert = function (t, e) {
            var r = f(t);
            if (null === r) throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            return n.from(r.getPublic(e, !0));
          }),
          (e.publicKeyVerify = function (t) {
            return null !== f(t);
          }),
          (e.publicKeyTweakAdd = function (t, e, r) {
            var i = f(t);
            if (null === i) throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            if ((e = new o(e)).cmp(c.n) >= 0)
              throw new Error(a.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
            var s = c.g.mul(e).add(i.pub);
            if (s.isInfinity()) throw new Error(a.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
            return n.from(s.encode(!0, r));
          }),
          (e.publicKeyTweakMul = function (t, e, r) {
            var i = f(t);
            if (null === i) throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            if ((e = new o(e)).cmp(c.n) >= 0 || e.isZero())
              throw new Error(a.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
            return n.from(i.pub.mul(e).encode(!0, r));
          }),
          (e.publicKeyCombine = function (t, e) {
            for (var r = new Array(t.length), i = 0; i < t.length; ++i)
              if (((r[i] = f(t[i])), null === r[i]))
                throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            for (var o = r[0].pub, s = 1; s < r.length; ++s)
              o = o.add(r[s].pub);
            if (o.isInfinity()) throw new Error(a.EC_PUBLIC_KEY_COMBINE_FAIL);
            return n.from(o.encode(!0, e));
          }),
          (e.signatureNormalize = function (t) {
            var e = new o(t.slice(0, 32)),
              r = new o(t.slice(32, 64));
            if (e.cmp(c.n) >= 0 || r.cmp(c.n) >= 0)
              throw new Error(a.ECDSA_SIGNATURE_PARSE_FAIL);
            var i = n.from(t);
            return (
              1 === r.cmp(u.nh) &&
                c.n.sub(r).toArrayLike(n, "be", 32).copy(i, 32),
              i
            );
          }),
          (e.signatureExport = function (t) {
            var e = t.slice(0, 32),
              r = t.slice(32, 64);
            if (new o(e).cmp(c.n) >= 0 || new o(r).cmp(c.n) >= 0)
              throw new Error(a.ECDSA_SIGNATURE_PARSE_FAIL);
            return { r: e, s: r };
          }),
          (e.signatureImport = function (t) {
            var e = new o(t.r);
            e.cmp(c.n) >= 0 && (e = new o(0));
            var r = new o(t.s);
            return (
              r.cmp(c.n) >= 0 && (r = new o(0)),
              n.concat([e.toArrayLike(n, "be", 32), r.toArrayLike(n, "be", 32)])
            );
          }),
          (e.sign = function (t, e, r, i) {
            if ("function" == typeof r) {
              var s = r;
              r = function (r) {
                var u = s(t, e, null, i, r);
                if (!n.isBuffer(u) || 32 !== u.length)
                  throw new Error(a.ECDSA_SIGN_FAIL);
                return new o(u);
              };
            }
            var f = new o(e);
            if (f.cmp(c.n) >= 0 || f.isZero())
              throw new Error(a.ECDSA_SIGN_FAIL);
            var h = u.sign(t, e, { canonical: !0, k: r, pers: i });
            return {
              signature: n.concat([
                h.r.toArrayLike(n, "be", 32),
                h.s.toArrayLike(n, "be", 32),
              ]),
              recovery: h.recoveryParam,
            };
          }),
          (e.verify = function (t, e, r) {
            var n = { r: e.slice(0, 32), s: e.slice(32, 64) },
              i = new o(n.r),
              s = new o(n.s);
            if (i.cmp(c.n) >= 0 || s.cmp(c.n) >= 0)
              throw new Error(a.ECDSA_SIGNATURE_PARSE_FAIL);
            if (1 === s.cmp(u.nh) || i.isZero() || s.isZero()) return !1;
            var h = f(r);
            if (null === h) throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            return u.verify(t, n, { x: h.pub.x, y: h.pub.y });
          }),
          (e.recover = function (t, e, r, i) {
            var s = { r: e.slice(0, 32), s: e.slice(32, 64) },
              f = new o(s.r),
              h = new o(s.s);
            if (f.cmp(c.n) >= 0 || h.cmp(c.n) >= 0)
              throw new Error(a.ECDSA_SIGNATURE_PARSE_FAIL);
            try {
              if (f.isZero() || h.isZero()) throw new Error();
              var l = u.recoverPubKey(t, s, r);
              return n.from(l.encode(!0, i));
            } catch (t) {
              throw new Error(a.ECDSA_RECOVER_FAIL);
            }
          }),
          (e.ecdh = function (t, r) {
            var n = e.ecdhUnsafe(t, r, !0);
            return i("sha256").update(n).digest();
          }),
          (e.ecdhUnsafe = function (t, e, r) {
            var i = f(t);
            if (null === i) throw new Error(a.EC_PUBLIC_KEY_PARSE_FAIL);
            var s = new o(e);
            if (s.cmp(c.n) >= 0 || s.isZero()) throw new Error(a.ECDH_FAIL);
            return n.from(i.pub.mul(s).encode(!0, r));
          });
      },
      95483: (t, e, r) => {
        "use strict";
        var n = r(95469),
          i = r(95712),
          o = r(53892);
        function s(t, e) {
          return void 0 === t
            ? e
            : (n.isBoolean(t, o.COMPRESSED_TYPE_INVALID), t);
        }
        t.exports = function (t) {
          return {
            privateKeyVerify: function (e) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                32 === e.length && t.privateKeyVerify(e)
              );
            },
            privateKeyExport: function (e, r) {
              n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                (r = s(r, !0));
              var a = t.privateKeyExport(e, r);
              return i.privateKeyExport(e, a, r);
            },
            privateKeyImport: function (e) {
              if (
                (n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                (e = i.privateKeyImport(e)) &&
                  32 === e.length &&
                  t.privateKeyVerify(e))
              )
                return e;
              throw new Error(o.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
            },
            privateKeyNegate: function (e) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                t.privateKeyNegate(e)
              );
            },
            privateKeyModInverse: function (e) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                t.privateKeyModInverse(e)
              );
            },
            privateKeyTweakAdd: function (e, r) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.TWEAK_TYPE_INVALID),
                n.isBufferLength(r, 32, o.TWEAK_LENGTH_INVALID),
                t.privateKeyTweakAdd(e, r)
              );
            },
            privateKeyTweakMul: function (e, r) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.TWEAK_TYPE_INVALID),
                n.isBufferLength(r, 32, o.TWEAK_LENGTH_INVALID),
                t.privateKeyTweakMul(e, r)
              );
            },
            publicKeyCreate: function (e, r) {
              return (
                n.isBuffer(e, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(e, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                (r = s(r, !0)),
                t.publicKeyCreate(e, r)
              );
            },
            publicKeyConvert: function (e, r) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(e, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                (r = s(r, !0)),
                t.publicKeyConvert(e, r)
              );
            },
            publicKeyVerify: function (e) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                t.publicKeyVerify(e)
              );
            },
            publicKeyTweakAdd: function (e, r, i) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(e, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.TWEAK_TYPE_INVALID),
                n.isBufferLength(r, 32, o.TWEAK_LENGTH_INVALID),
                (i = s(i, !0)),
                t.publicKeyTweakAdd(e, r, i)
              );
            },
            publicKeyTweakMul: function (e, r, i) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(e, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.TWEAK_TYPE_INVALID),
                n.isBufferLength(r, 32, o.TWEAK_LENGTH_INVALID),
                (i = s(i, !0)),
                t.publicKeyTweakMul(e, r, i)
              );
            },
            publicKeyCombine: function (e, r) {
              n.isArray(e, o.EC_PUBLIC_KEYS_TYPE_INVALID),
                n.isLengthGTZero(e, o.EC_PUBLIC_KEYS_LENGTH_INVALID);
              for (var i = 0; i < e.length; ++i)
                n.isBuffer(e[i], o.EC_PUBLIC_KEY_TYPE_INVALID),
                  n.isBufferLength2(
                    e[i],
                    33,
                    65,
                    o.EC_PUBLIC_KEY_LENGTH_INVALID,
                  );
              return (r = s(r, !0)), t.publicKeyCombine(e, r);
            },
            signatureNormalize: function (e) {
              return (
                n.isBuffer(e, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isBufferLength(e, 64, o.ECDSA_SIGNATURE_LENGTH_INVALID),
                t.signatureNormalize(e)
              );
            },
            signatureExport: function (e) {
              n.isBuffer(e, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isBufferLength(e, 64, o.ECDSA_SIGNATURE_LENGTH_INVALID);
              var r = t.signatureExport(e);
              return i.signatureExport(r);
            },
            signatureImport: function (e) {
              n.isBuffer(e, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isLengthGTZero(e, o.ECDSA_SIGNATURE_LENGTH_INVALID);
              var r = i.signatureImport(e);
              if (r) return t.signatureImport(r);
              throw new Error(o.ECDSA_SIGNATURE_PARSE_DER_FAIL);
            },
            signatureImportLax: function (e) {
              n.isBuffer(e, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isLengthGTZero(e, o.ECDSA_SIGNATURE_LENGTH_INVALID);
              var r = i.signatureImportLax(e);
              if (r) return t.signatureImport(r);
              throw new Error(o.ECDSA_SIGNATURE_PARSE_DER_FAIL);
            },
            sign: function (e, r, i) {
              n.isBuffer(e, o.MSG32_TYPE_INVALID),
                n.isBufferLength(e, 32, o.MSG32_LENGTH_INVALID),
                n.isBuffer(r, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(r, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID);
              var s = null,
                a = null;
              return (
                void 0 !== i &&
                  (n.isObject(i, o.OPTIONS_TYPE_INVALID),
                  void 0 !== i.data &&
                    (n.isBuffer(i.data, o.OPTIONS_DATA_TYPE_INVALID),
                    n.isBufferLength(i.data, 32, o.OPTIONS_DATA_LENGTH_INVALID),
                    (s = i.data)),
                  void 0 !== i.noncefn &&
                    (n.isFunction(i.noncefn, o.OPTIONS_NONCEFN_TYPE_INVALID),
                    (a = i.noncefn))),
                t.sign(e, r, a, s)
              );
            },
            verify: function (e, r, i) {
              return (
                n.isBuffer(e, o.MSG32_TYPE_INVALID),
                n.isBufferLength(e, 32, o.MSG32_LENGTH_INVALID),
                n.isBuffer(r, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isBufferLength(r, 64, o.ECDSA_SIGNATURE_LENGTH_INVALID),
                n.isBuffer(i, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(i, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                t.verify(e, r, i)
              );
            },
            recover: function (e, r, i, a) {
              return (
                n.isBuffer(e, o.MSG32_TYPE_INVALID),
                n.isBufferLength(e, 32, o.MSG32_LENGTH_INVALID),
                n.isBuffer(r, o.ECDSA_SIGNATURE_TYPE_INVALID),
                n.isBufferLength(r, 64, o.ECDSA_SIGNATURE_LENGTH_INVALID),
                n.isNumber(i, o.RECOVERY_ID_TYPE_INVALID),
                n.isNumberInInterval(i, -1, 4, o.RECOVERY_ID_VALUE_INVALID),
                (a = s(a, !0)),
                t.recover(e, r, i, a)
              );
            },
            ecdh: function (e, r) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(e, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(r, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                t.ecdh(e, r)
              );
            },
            ecdhUnsafe: function (e, r, i) {
              return (
                n.isBuffer(e, o.EC_PUBLIC_KEY_TYPE_INVALID),
                n.isBufferLength2(e, 33, 65, o.EC_PUBLIC_KEY_LENGTH_INVALID),
                n.isBuffer(r, o.EC_PRIVATE_KEY_TYPE_INVALID),
                n.isBufferLength(r, 32, o.EC_PRIVATE_KEY_LENGTH_INVALID),
                (i = s(i, !0)),
                t.ecdhUnsafe(e, r, i)
              );
            },
          };
        };
      },
      5262: function (t, e, r) {
        !(function (t, e) {
          "use strict";
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function i(t, e) {
            t.super_ = e;
            var r = function () {};
            (r.prototype = e.prototype),
              (t.prototype = new r()),
              (t.prototype.constructor = t);
          }
          function o(t, e, r) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((r = e), (e = 10)),
                this._init(t || 0, e || 10, r || "be"));
          }
          var s;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            s =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(87648).Buffer;
          } catch (t) {}
          function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
                ? r - 87
                : (r - 48) & 15;
          }
          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n;
          }
          function c(t, e, r, n) {
            for (var i = 0, o = Math.min(t.length, r), s = e; s < o; s++) {
              var a = t.charCodeAt(s) - 48;
              (i *= n),
                (i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a);
            }
            return i;
          }
          (o.isBN = function (t) {
            return (
              t instanceof o ||
              (null !== t &&
                "object" == typeof t &&
                t.constructor.wordSize === o.wordSize &&
                Array.isArray(t.words))
            );
          }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < t.length &&
                  (16 === e
                    ? this._parseHex(t, i, r)
                    : (this._parseBase(t, e, i),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                    ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                      (this.length = 2))
                    : (n(t < 9007199254740992),
                      (this.words = [
                        67108863 & t,
                        (t / 67108864) & 67108863,
                        1,
                      ]),
                      (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o,
                s,
                a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3)
                  (s = t[i] | (t[i - 1] << 8) | (t[i - 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3)
                  (s = t[i] | (t[i + 1] << 8) | (t[i + 2] << 16)),
                    (this.words[o] |= (s << a) & 67108863),
                    (this.words[o + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), o++);
              return this.strip();
            }),
            (o.prototype._parseHex = function (t, e, r) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2)
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              else
                for (
                  n = (t.length - e) % 2 == 0 ? e + 1 : e;
                  n < t.length;
                  n += 2
                )
                  (i = u(t, e, n) << o),
                    (this.words[s] |= 67108863 & i),
                    o >= 18
                      ? ((o -= 18), (s += 1), (this.words[s] |= i >>> 26))
                      : (o += 8);
              this.strip();
            }),
            (o.prototype._parseBase = function (t, e, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
              n--, (i = (i / e) | 0);
              for (
                var o = t.length - r,
                  s = o % n,
                  a = Math.min(o, o - s) + r,
                  u = 0,
                  f = r;
                f < a;
                f += n
              )
                (u = c(t, f, f + n, e)),
                  this.imuln(i),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, f, t.length, e), f = 0; f < s; f++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this.strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype.strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            (o.prototype.inspect = function () {
              return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            });
          var f = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            h = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            l = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function d(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = (t.length + e.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            r.words[0] = a;
            for (var c = 1; c < n; c++) {
              for (
                var f = u >>> 26,
                  h = 67108863 & u,
                  l = Math.min(c, e.length - 1),
                  d = Math.max(0, c - t.length + 1);
                d <= l;
                d++
              ) {
                var p = (c - d) | 0;
                (f +=
                  ((s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (r.words[c] = 0 | h), (u = 0 | f);
            }
            return 0 !== u ? (r.words[c] = 0 | u) : r.length--, r.strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << i) | o)).toString(16);
                (o = (a >>> (24 - i)) & 16777215),
                  (i += 2) >= 26 && ((i -= 26), s--),
                  (r =
                    0 !== o || s !== this.length - 1
                      ? f[6 - u.length] + u + r
                      : u + r);
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = h[t],
                d = l[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var y = p.modn(d).toString(t);
                r = (p = p.idivn(d)).isZero() ? y + r : f[c - y.length] + y + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                    ? (t += 4503599627370496 + 67108864 * this.words[1])
                    : this.length > 2 &&
                      n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16);
            }),
            (o.prototype.toBuffer = function (t, e) {
              return n(void 0 !== s), this.toArrayLike(s, t, e);
            }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              var i = this.byteLength(),
                o = r || Math.max(1, i);
              n(i <= o, "byte array longer than desired length"),
                n(o > 0, "Requested array length <= 0"),
                this.strip();
              var s,
                a,
                u = "le" === e,
                c = new t(o),
                f = this.clone();
              if (u) {
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[a] = s);
                for (; a < o; a++) c[a] = 0;
              } else {
                for (a = 0; a < o - i; a++) c[a] = 0;
                for (a = 0; !f.isZero(); a++)
                  (s = f.andln(255)), f.iushrn(8), (c[o - a - 1] = s);
              }
              return c;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    r = 0;
                  return (
                    e >= 4096 && ((r += 13), (e >>>= 13)),
                    e >= 64 && ((r += 7), (e >>>= 7)),
                    e >= 8 && ((r += 4), (e >>>= 4)),
                    e >= 2 && ((r += 2), (e >>>= 2)),
                    r + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                r = 0;
              return (
                8191 & e || ((r += 13), (e >>>= 13)),
                127 & e || ((r += 7), (e >>>= 7)),
                15 & e || ((r += 4), (e >>>= 4)),
                3 & e || ((r += 2), (e >>>= 2)),
                1 & e || r++,
                r
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var r = this._zeroBits(this.words[e]);
                if (((t += r), 26 !== r)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this.strip();
            }),
            (o.prototype.ior = function (t) {
              return n(!(this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var r = 0; r < e.length; r++)
                this.words[r] = this.words[r] & t.words[r];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.iand = function (t) {
              return n(!(this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, r;
              this.length > t.length
                ? ((e = this), (r = t))
                : ((e = t), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = e.words[n] ^ r.words[n];
              if (this !== e)
                for (; n < e.length; n++) this.words[n] = e.words[n];
              return (this.length = e.length), this.strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(!(this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this.strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                i = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this.strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, r, n;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((r = this), (n = t))
                : ((r = t), (n = this));
              for (var i = 0, o = 0; o < n.length; o++)
                (e = (0 | r.words[o]) + (0 | n.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              for (; 0 !== i && o < r.length; o++)
                (e = (0 | r.words[o]) + i),
                  (this.words[o] = 67108863 & e),
                  (i = e >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                  ? ((this.negative = 0),
                    (e = t.sub(this)),
                    (this.negative = 1),
                    e)
                  : this.length > t.length
                    ? this.clone().iadd(t)
                    : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(t);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = t)) : ((r = t), (n = this));
              for (var o = 0, s = 0; s < n.length; s++)
                (o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== o && s < r.length; s++)
                (o = (e = (0 | r.words[s]) + o) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === o && s < r.length && r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                r !== this && (this.negative = 1),
                this.strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var p = function (t, e, r) {
            var n,
              i,
              o,
              s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              h = 8191 & f,
              l = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              y = d >>> 13,
              g = 0 | s[2],
              m = 8191 & g,
              b = g >>> 13,
              w = 0 | s[3],
              v = 8191 & w,
              _ = w >>> 13,
              E = 0 | s[4],
              S = 8191 & E,
              I = E >>> 13,
              M = 0 | s[5],
              A = 8191 & M,
              T = M >>> 13,
              k = 0 | s[6],
              O = 8191 & k,
              x = k >>> 13,
              P = 0 | s[7],
              B = 8191 & P,
              C = P >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              U = R >>> 13,
              D = 0 | s[9],
              L = 8191 & D,
              j = D >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              K = F >>> 13,
              V = 0 | a[1],
              q = 8191 & V,
              z = V >>> 13,
              $ = 0 | a[2],
              G = 8191 & $,
              W = $ >>> 13,
              Y = 0 | a[3],
              X = 8191 & Y,
              Z = Y >>> 13,
              J = 0 | a[4],
              Q = 8191 & J,
              tt = J >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              ht = 8191 & ft,
              lt = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              yt = dt >>> 13;
            (r.negative = t.negative ^ e.negative), (r.length = 19);
            var gt =
              (((c + (n = Math.imul(h, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(h, K)) + Math.imul(l, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = Math.imul(l, K)) + (i >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, K)) + Math.imul(y, H)) | 0),
              (o = Math.imul(y, K));
            var mt =
              (((c + (n = (n + Math.imul(h, q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, z)) | 0) + Math.imul(l, q)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, z)) | 0) + (i >>> 13)) | 0) +
                (mt >>> 26)) |
              0),
              (mt &= 67108863),
              (n = Math.imul(m, H)),
              (i = ((i = Math.imul(m, K)) + Math.imul(b, H)) | 0),
              (o = Math.imul(b, K)),
              (n = (n + Math.imul(p, q)) | 0),
              (i = ((i = (i + Math.imul(p, z)) | 0) + Math.imul(y, q)) | 0),
              (o = (o + Math.imul(y, z)) | 0);
            var bt =
              (((c + (n = (n + Math.imul(h, G)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, W)) | 0) + Math.imul(l, G)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, W)) | 0) + (i >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (n = Math.imul(v, H)),
              (i = ((i = Math.imul(v, K)) + Math.imul(_, H)) | 0),
              (o = Math.imul(_, K)),
              (n = (n + Math.imul(m, q)) | 0),
              (i = ((i = (i + Math.imul(m, z)) | 0) + Math.imul(b, q)) | 0),
              (o = (o + Math.imul(b, z)) | 0),
              (n = (n + Math.imul(p, G)) | 0),
              (i = ((i = (i + Math.imul(p, W)) | 0) + Math.imul(y, G)) | 0),
              (o = (o + Math.imul(y, W)) | 0);
            var wt =
              (((c + (n = (n + Math.imul(h, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, Z)) | 0) + Math.imul(l, X)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, Z)) | 0) + (i >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (n = Math.imul(S, H)),
              (i = ((i = Math.imul(S, K)) + Math.imul(I, H)) | 0),
              (o = Math.imul(I, K)),
              (n = (n + Math.imul(v, q)) | 0),
              (i = ((i = (i + Math.imul(v, z)) | 0) + Math.imul(_, q)) | 0),
              (o = (o + Math.imul(_, z)) | 0),
              (n = (n + Math.imul(m, G)) | 0),
              (i = ((i = (i + Math.imul(m, W)) | 0) + Math.imul(b, G)) | 0),
              (o = (o + Math.imul(b, W)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Z)) | 0) + Math.imul(y, X)) | 0),
              (o = (o + Math.imul(y, Z)) | 0);
            var vt =
              (((c + (n = (n + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, tt)) | 0) + Math.imul(l, Q)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, tt)) | 0) + (i >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (n = Math.imul(A, H)),
              (i = ((i = Math.imul(A, K)) + Math.imul(T, H)) | 0),
              (o = Math.imul(T, K)),
              (n = (n + Math.imul(S, q)) | 0),
              (i = ((i = (i + Math.imul(S, z)) | 0) + Math.imul(I, q)) | 0),
              (o = (o + Math.imul(I, z)) | 0),
              (n = (n + Math.imul(v, G)) | 0),
              (i = ((i = (i + Math.imul(v, W)) | 0) + Math.imul(_, G)) | 0),
              (o = (o + Math.imul(_, W)) | 0),
              (n = (n + Math.imul(m, X)) | 0),
              (i = ((i = (i + Math.imul(m, Z)) | 0) + Math.imul(b, X)) | 0),
              (o = (o + Math.imul(b, Z)) | 0),
              (n = (n + Math.imul(p, Q)) | 0),
              (i = ((i = (i + Math.imul(p, tt)) | 0) + Math.imul(y, Q)) | 0),
              (o = (o + Math.imul(y, tt)) | 0);
            var _t =
              (((c + (n = (n + Math.imul(h, rt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, nt)) | 0) + Math.imul(l, rt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, nt)) | 0) + (i >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (n = Math.imul(O, H)),
              (i = ((i = Math.imul(O, K)) + Math.imul(x, H)) | 0),
              (o = Math.imul(x, K)),
              (n = (n + Math.imul(A, q)) | 0),
              (i = ((i = (i + Math.imul(A, z)) | 0) + Math.imul(T, q)) | 0),
              (o = (o + Math.imul(T, z)) | 0),
              (n = (n + Math.imul(S, G)) | 0),
              (i = ((i = (i + Math.imul(S, W)) | 0) + Math.imul(I, G)) | 0),
              (o = (o + Math.imul(I, W)) | 0),
              (n = (n + Math.imul(v, X)) | 0),
              (i = ((i = (i + Math.imul(v, Z)) | 0) + Math.imul(_, X)) | 0),
              (o = (o + Math.imul(_, Z)) | 0),
              (n = (n + Math.imul(m, Q)) | 0),
              (i = ((i = (i + Math.imul(m, tt)) | 0) + Math.imul(b, Q)) | 0),
              (o = (o + Math.imul(b, tt)) | 0),
              (n = (n + Math.imul(p, rt)) | 0),
              (i = ((i = (i + Math.imul(p, nt)) | 0) + Math.imul(y, rt)) | 0),
              (o = (o + Math.imul(y, nt)) | 0);
            var Et =
              (((c + (n = (n + Math.imul(h, ot)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, st)) | 0) + Math.imul(l, ot)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, st)) | 0) + (i >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, K)) + Math.imul(C, H)) | 0),
              (o = Math.imul(C, K)),
              (n = (n + Math.imul(O, q)) | 0),
              (i = ((i = (i + Math.imul(O, z)) | 0) + Math.imul(x, q)) | 0),
              (o = (o + Math.imul(x, z)) | 0),
              (n = (n + Math.imul(A, G)) | 0),
              (i = ((i = (i + Math.imul(A, W)) | 0) + Math.imul(T, G)) | 0),
              (o = (o + Math.imul(T, W)) | 0),
              (n = (n + Math.imul(S, X)) | 0),
              (i = ((i = (i + Math.imul(S, Z)) | 0) + Math.imul(I, X)) | 0),
              (o = (o + Math.imul(I, Z)) | 0),
              (n = (n + Math.imul(v, Q)) | 0),
              (i = ((i = (i + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (o = (o + Math.imul(_, tt)) | 0),
              (n = (n + Math.imul(m, rt)) | 0),
              (i = ((i = (i + Math.imul(m, nt)) | 0) + Math.imul(b, rt)) | 0),
              (o = (o + Math.imul(b, nt)) | 0),
              (n = (n + Math.imul(p, ot)) | 0),
              (i = ((i = (i + Math.imul(p, st)) | 0) + Math.imul(y, ot)) | 0),
              (o = (o + Math.imul(y, st)) | 0);
            var St =
              (((c + (n = (n + Math.imul(h, ut)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, ct)) | 0) + Math.imul(l, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, ct)) | 0) + (i >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (n = Math.imul(N, H)),
              (i = ((i = Math.imul(N, K)) + Math.imul(U, H)) | 0),
              (o = Math.imul(U, K)),
              (n = (n + Math.imul(B, q)) | 0),
              (i = ((i = (i + Math.imul(B, z)) | 0) + Math.imul(C, q)) | 0),
              (o = (o + Math.imul(C, z)) | 0),
              (n = (n + Math.imul(O, G)) | 0),
              (i = ((i = (i + Math.imul(O, W)) | 0) + Math.imul(x, G)) | 0),
              (o = (o + Math.imul(x, W)) | 0),
              (n = (n + Math.imul(A, X)) | 0),
              (i = ((i = (i + Math.imul(A, Z)) | 0) + Math.imul(T, X)) | 0),
              (o = (o + Math.imul(T, Z)) | 0),
              (n = (n + Math.imul(S, Q)) | 0),
              (i = ((i = (i + Math.imul(S, tt)) | 0) + Math.imul(I, Q)) | 0),
              (o = (o + Math.imul(I, tt)) | 0),
              (n = (n + Math.imul(v, rt)) | 0),
              (i = ((i = (i + Math.imul(v, nt)) | 0) + Math.imul(_, rt)) | 0),
              (o = (o + Math.imul(_, nt)) | 0),
              (n = (n + Math.imul(m, ot)) | 0),
              (i = ((i = (i + Math.imul(m, st)) | 0) + Math.imul(b, ot)) | 0),
              (o = (o + Math.imul(b, st)) | 0),
              (n = (n + Math.imul(p, ut)) | 0),
              (i = ((i = (i + Math.imul(p, ct)) | 0) + Math.imul(y, ut)) | 0),
              (o = (o + Math.imul(y, ct)) | 0);
            var It =
              (((c + (n = (n + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, lt)) | 0) + Math.imul(l, ht)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, lt)) | 0) + (i >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, K)) + Math.imul(j, H)) | 0),
              (o = Math.imul(j, K)),
              (n = (n + Math.imul(N, q)) | 0),
              (i = ((i = (i + Math.imul(N, z)) | 0) + Math.imul(U, q)) | 0),
              (o = (o + Math.imul(U, z)) | 0),
              (n = (n + Math.imul(B, G)) | 0),
              (i = ((i = (i + Math.imul(B, W)) | 0) + Math.imul(C, G)) | 0),
              (o = (o + Math.imul(C, W)) | 0),
              (n = (n + Math.imul(O, X)) | 0),
              (i = ((i = (i + Math.imul(O, Z)) | 0) + Math.imul(x, X)) | 0),
              (o = (o + Math.imul(x, Z)) | 0),
              (n = (n + Math.imul(A, Q)) | 0),
              (i = ((i = (i + Math.imul(A, tt)) | 0) + Math.imul(T, Q)) | 0),
              (o = (o + Math.imul(T, tt)) | 0),
              (n = (n + Math.imul(S, rt)) | 0),
              (i = ((i = (i + Math.imul(S, nt)) | 0) + Math.imul(I, rt)) | 0),
              (o = (o + Math.imul(I, nt)) | 0),
              (n = (n + Math.imul(v, ot)) | 0),
              (i = ((i = (i + Math.imul(v, st)) | 0) + Math.imul(_, ot)) | 0),
              (o = (o + Math.imul(_, st)) | 0),
              (n = (n + Math.imul(m, ut)) | 0),
              (i = ((i = (i + Math.imul(m, ct)) | 0) + Math.imul(b, ut)) | 0),
              (o = (o + Math.imul(b, ct)) | 0),
              (n = (n + Math.imul(p, ht)) | 0),
              (i = ((i = (i + Math.imul(p, lt)) | 0) + Math.imul(y, ht)) | 0),
              (o = (o + Math.imul(y, lt)) | 0);
            var Mt =
              (((c + (n = (n + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(h, yt)) | 0) + Math.imul(l, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(l, yt)) | 0) + (i >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863),
              (n = Math.imul(L, q)),
              (i = ((i = Math.imul(L, z)) + Math.imul(j, q)) | 0),
              (o = Math.imul(j, z)),
              (n = (n + Math.imul(N, G)) | 0),
              (i = ((i = (i + Math.imul(N, W)) | 0) + Math.imul(U, G)) | 0),
              (o = (o + Math.imul(U, W)) | 0),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Z)) | 0) + Math.imul(C, X)) | 0),
              (o = (o + Math.imul(C, Z)) | 0),
              (n = (n + Math.imul(O, Q)) | 0),
              (i = ((i = (i + Math.imul(O, tt)) | 0) + Math.imul(x, Q)) | 0),
              (o = (o + Math.imul(x, tt)) | 0),
              (n = (n + Math.imul(A, rt)) | 0),
              (i = ((i = (i + Math.imul(A, nt)) | 0) + Math.imul(T, rt)) | 0),
              (o = (o + Math.imul(T, nt)) | 0),
              (n = (n + Math.imul(S, ot)) | 0),
              (i = ((i = (i + Math.imul(S, st)) | 0) + Math.imul(I, ot)) | 0),
              (o = (o + Math.imul(I, st)) | 0),
              (n = (n + Math.imul(v, ut)) | 0),
              (i = ((i = (i + Math.imul(v, ct)) | 0) + Math.imul(_, ut)) | 0),
              (o = (o + Math.imul(_, ct)) | 0),
              (n = (n + Math.imul(m, ht)) | 0),
              (i = ((i = (i + Math.imul(m, lt)) | 0) + Math.imul(b, ht)) | 0),
              (o = (o + Math.imul(b, lt)) | 0);
            var At =
              (((c + (n = (n + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, yt)) | 0) + Math.imul(y, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(y, yt)) | 0) + (i >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (n = Math.imul(L, G)),
              (i = ((i = Math.imul(L, W)) + Math.imul(j, G)) | 0),
              (o = Math.imul(j, W)),
              (n = (n + Math.imul(N, X)) | 0),
              (i = ((i = (i + Math.imul(N, Z)) | 0) + Math.imul(U, X)) | 0),
              (o = (o + Math.imul(U, Z)) | 0),
              (n = (n + Math.imul(B, Q)) | 0),
              (i = ((i = (i + Math.imul(B, tt)) | 0) + Math.imul(C, Q)) | 0),
              (o = (o + Math.imul(C, tt)) | 0),
              (n = (n + Math.imul(O, rt)) | 0),
              (i = ((i = (i + Math.imul(O, nt)) | 0) + Math.imul(x, rt)) | 0),
              (o = (o + Math.imul(x, nt)) | 0),
              (n = (n + Math.imul(A, ot)) | 0),
              (i = ((i = (i + Math.imul(A, st)) | 0) + Math.imul(T, ot)) | 0),
              (o = (o + Math.imul(T, st)) | 0),
              (n = (n + Math.imul(S, ut)) | 0),
              (i = ((i = (i + Math.imul(S, ct)) | 0) + Math.imul(I, ut)) | 0),
              (o = (o + Math.imul(I, ct)) | 0),
              (n = (n + Math.imul(v, ht)) | 0),
              (i = ((i = (i + Math.imul(v, lt)) | 0) + Math.imul(_, ht)) | 0),
              (o = (o + Math.imul(_, lt)) | 0);
            var Tt =
              (((c + (n = (n + Math.imul(m, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(m, yt)) | 0) + Math.imul(b, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(b, yt)) | 0) + (i >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Z)) + Math.imul(j, X)) | 0),
              (o = Math.imul(j, Z)),
              (n = (n + Math.imul(N, Q)) | 0),
              (i = ((i = (i + Math.imul(N, tt)) | 0) + Math.imul(U, Q)) | 0),
              (o = (o + Math.imul(U, tt)) | 0),
              (n = (n + Math.imul(B, rt)) | 0),
              (i = ((i = (i + Math.imul(B, nt)) | 0) + Math.imul(C, rt)) | 0),
              (o = (o + Math.imul(C, nt)) | 0),
              (n = (n + Math.imul(O, ot)) | 0),
              (i = ((i = (i + Math.imul(O, st)) | 0) + Math.imul(x, ot)) | 0),
              (o = (o + Math.imul(x, st)) | 0),
              (n = (n + Math.imul(A, ut)) | 0),
              (i = ((i = (i + Math.imul(A, ct)) | 0) + Math.imul(T, ut)) | 0),
              (o = (o + Math.imul(T, ct)) | 0),
              (n = (n + Math.imul(S, ht)) | 0),
              (i = ((i = (i + Math.imul(S, lt)) | 0) + Math.imul(I, ht)) | 0),
              (o = (o + Math.imul(I, lt)) | 0);
            var kt =
              (((c + (n = (n + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(v, yt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(_, yt)) | 0) + (i >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (n = Math.imul(L, Q)),
              (i = ((i = Math.imul(L, tt)) + Math.imul(j, Q)) | 0),
              (o = Math.imul(j, tt)),
              (n = (n + Math.imul(N, rt)) | 0),
              (i = ((i = (i + Math.imul(N, nt)) | 0) + Math.imul(U, rt)) | 0),
              (o = (o + Math.imul(U, nt)) | 0),
              (n = (n + Math.imul(B, ot)) | 0),
              (i = ((i = (i + Math.imul(B, st)) | 0) + Math.imul(C, ot)) | 0),
              (o = (o + Math.imul(C, st)) | 0),
              (n = (n + Math.imul(O, ut)) | 0),
              (i = ((i = (i + Math.imul(O, ct)) | 0) + Math.imul(x, ut)) | 0),
              (o = (o + Math.imul(x, ct)) | 0),
              (n = (n + Math.imul(A, ht)) | 0),
              (i = ((i = (i + Math.imul(A, lt)) | 0) + Math.imul(T, ht)) | 0),
              (o = (o + Math.imul(T, lt)) | 0);
            var Ot =
              (((c + (n = (n + Math.imul(S, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(S, yt)) | 0) + Math.imul(I, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(I, yt)) | 0) + (i >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (n = Math.imul(L, rt)),
              (i = ((i = Math.imul(L, nt)) + Math.imul(j, rt)) | 0),
              (o = Math.imul(j, nt)),
              (n = (n + Math.imul(N, ot)) | 0),
              (i = ((i = (i + Math.imul(N, st)) | 0) + Math.imul(U, ot)) | 0),
              (o = (o + Math.imul(U, st)) | 0),
              (n = (n + Math.imul(B, ut)) | 0),
              (i = ((i = (i + Math.imul(B, ct)) | 0) + Math.imul(C, ut)) | 0),
              (o = (o + Math.imul(C, ct)) | 0),
              (n = (n + Math.imul(O, ht)) | 0),
              (i = ((i = (i + Math.imul(O, lt)) | 0) + Math.imul(x, ht)) | 0),
              (o = (o + Math.imul(x, lt)) | 0);
            var xt =
              (((c + (n = (n + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(A, yt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(T, yt)) | 0) + (i >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (n = Math.imul(L, ot)),
              (i = ((i = Math.imul(L, st)) + Math.imul(j, ot)) | 0),
              (o = Math.imul(j, st)),
              (n = (n + Math.imul(N, ut)) | 0),
              (i = ((i = (i + Math.imul(N, ct)) | 0) + Math.imul(U, ut)) | 0),
              (o = (o + Math.imul(U, ct)) | 0),
              (n = (n + Math.imul(B, ht)) | 0),
              (i = ((i = (i + Math.imul(B, lt)) | 0) + Math.imul(C, ht)) | 0),
              (o = (o + Math.imul(C, lt)) | 0);
            var Pt =
              (((c + (n = (n + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(O, yt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(x, yt)) | 0) + (i >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (n = Math.imul(L, ut)),
              (i = ((i = Math.imul(L, ct)) + Math.imul(j, ut)) | 0),
              (o = Math.imul(j, ct)),
              (n = (n + Math.imul(N, ht)) | 0),
              (i = ((i = (i + Math.imul(N, lt)) | 0) + Math.imul(U, ht)) | 0),
              (o = (o + Math.imul(U, lt)) | 0);
            var Bt =
              (((c + (n = (n + Math.imul(B, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, yt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(C, yt)) | 0) + (i >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (n = Math.imul(L, ht)),
              (i = ((i = Math.imul(L, lt)) + Math.imul(j, ht)) | 0),
              (o = Math.imul(j, lt));
            var Ct =
              (((c + (n = (n + Math.imul(N, pt)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(N, yt)) | 0) + Math.imul(U, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((o = (o + Math.imul(U, yt)) | 0) + (i >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863);
            var Rt =
              (((c + (n = Math.imul(L, pt))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, yt)) + Math.imul(j, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((o = Math.imul(j, yt)) + (i >>> 13)) | 0) + (Rt >>> 26)) |
                0),
              (Rt &= 67108863),
              (u[0] = gt),
              (u[1] = mt),
              (u[2] = bt),
              (u[3] = wt),
              (u[4] = vt),
              (u[5] = _t),
              (u[6] = Et),
              (u[7] = St),
              (u[8] = It),
              (u[9] = Mt),
              (u[10] = At),
              (u[11] = Tt),
              (u[12] = kt),
              (u[13] = Ot),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Bt),
              (u[17] = Ct),
              (u[18] = Rt),
              0 !== c && ((u[19] = c), r.length++),
              r
            );
          };
          function y(t, e, r) {
            return new g().mulp(t, e, r);
          }
          function g(t, e) {
            (this.x = t), (this.y = e);
          }
          Math.imul || (p = d),
            (o.prototype.mulTo = function (t, e) {
              var r,
                n = this.length + t.length;
              return (
                (r =
                  10 === this.length && 10 === t.length
                    ? p(this, t, e)
                    : n < 63
                      ? d(this, t, e)
                      : n < 1024
                        ? (function (t, e, r) {
                            (r.negative = e.negative ^ t.negative),
                              (r.length = t.length + e.length);
                            for (
                              var n = 0, i = 0, o = 0;
                              o < r.length - 1;
                              o++
                            ) {
                              var s = i;
                              i = 0;
                              for (
                                var a = 67108863 & n,
                                  u = Math.min(o, e.length - 1),
                                  c = Math.max(0, o - t.length + 1);
                                c <= u;
                                c++
                              ) {
                                var f = o - c,
                                  h = (0 | t.words[f]) * (0 | e.words[c]),
                                  l = 67108863 & h;
                                (a = 67108863 & (l = (l + a) | 0)),
                                  (i +=
                                    (s =
                                      ((s = (s + ((h / 67108864) | 0)) | 0) +
                                        (l >>> 26)) |
                                      0) >>> 26),
                                  (s &= 67108863);
                              }
                              (r.words[o] = a), (n = s), (s = i);
                            }
                            return (
                              0 !== n ? (r.words[o] = n) : r.length--, r.strip()
                            );
                          })(this, t, e)
                        : y(this, t, e)),
                r
              );
            }),
            (g.prototype.makeRBT = function (t) {
              for (
                var e = new Array(t), r = o.prototype._countBits(t) - 1, n = 0;
                n < t;
                n++
              )
                e[n] = this.revBin(n, r, t);
              return e;
            }),
            (g.prototype.revBin = function (t, e, r) {
              if (0 === t || t === r - 1) return t;
              for (var n = 0, i = 0; i < e; i++)
                (n |= (1 & t) << (e - i - 1)), (t >>= 1);
              return n;
            }),
            (g.prototype.permute = function (t, e, r, n, i, o) {
              for (var s = 0; s < o; s++) (n[s] = e[t[s]]), (i[s] = r[t[s]]);
            }),
            (g.prototype.transform = function (t, e, r, n, i, o) {
              this.permute(o, t, e, r, n, i);
              for (var s = 1; s < i; s <<= 1)
                for (
                  var a = s << 1,
                    u = Math.cos((2 * Math.PI) / a),
                    c = Math.sin((2 * Math.PI) / a),
                    f = 0;
                  f < i;
                  f += a
                )
                  for (var h = u, l = c, d = 0; d < s; d++) {
                    var p = r[f + d],
                      y = n[f + d],
                      g = r[f + d + s],
                      m = n[f + d + s],
                      b = h * g - l * m;
                    (m = h * m + l * g),
                      (g = b),
                      (r[f + d] = p + g),
                      (n[f + d] = y + m),
                      (r[f + d + s] = p - g),
                      (n[f + d + s] = y - m),
                      d !== a &&
                        ((b = u * h - c * l), (l = u * l + c * h), (h = b));
                  }
            }),
            (g.prototype.guessLen13b = function (t, e) {
              var r = 1 | Math.max(e, t),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (g.prototype.conjugate = function (t, e, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = t[n];
                  (t[n] = t[r - n - 1]),
                    (t[r - n - 1] = i),
                    (i = e[n]),
                    (e[n] = -e[r - n - 1]),
                    (e[r - n - 1] = -i);
                }
            }),
            (g.prototype.normalize13b = function (t, e) {
              for (var r = 0, n = 0; n < e / 2; n++) {
                var i =
                  8192 * Math.round(t[2 * n + 1] / e) +
                  Math.round(t[2 * n] / e) +
                  r;
                (t[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return t;
            }),
            (g.prototype.convert13b = function (t, e, r, i) {
              for (var o = 0, s = 0; s < e; s++)
                (o += 0 | t[s]),
                  (r[2 * s] = 8191 & o),
                  (o >>>= 13),
                  (r[2 * s + 1] = 8191 & o),
                  (o >>>= 13);
              for (s = 2 * e; s < i; ++s) r[s] = 0;
              n(0 === o), n(!(-8192 & o));
            }),
            (g.prototype.stub = function (t) {
              for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
              return e;
            }),
            (g.prototype.mulp = function (t, e, r) {
              var n = 2 * this.guessLen13b(t.length, e.length),
                i = this.makeRBT(n),
                o = this.stub(n),
                s = new Array(n),
                a = new Array(n),
                u = new Array(n),
                c = new Array(n),
                f = new Array(n),
                h = new Array(n),
                l = r.words;
              (l.length = n),
                this.convert13b(t.words, t.length, s, n),
                this.convert13b(e.words, e.length, c, n),
                this.transform(s, o, a, u, n, i),
                this.transform(c, o, f, h, n, i);
              for (var d = 0; d < n; d++) {
                var p = a[d] * f[d] - u[d] * h[d];
                (u[d] = a[d] * h[d] + u[d] * f[d]), (a[d] = p);
              }
              return (
                this.conjugate(a, u, n),
                this.transform(a, u, l, o, n, i),
                this.conjugate(l, o, n),
                this.normalize13b(l, n),
                (r.negative = t.negative ^ e.negative),
                (r.length = t.length + e.length),
                r.strip()
              );
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              n("number" == typeof t), n(t < 67108864);
              for (var e = 0, r = 0; r < this.length; r++) {
                var i = (0 | this.words[r]) * t,
                  o = (67108863 & i) + (67108863 & e);
                (e >>= 26),
                  (e += (i / 67108864) | 0),
                  (e += o >>> 26),
                  (this.words[r] = 67108863 & o);
              }
              return 0 !== e && ((this.words[r] = e), this.length++), this;
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), r = 0;
                  r < e.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  e[r] = (t.words[n] & (1 << i)) >>> i;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var r = this, n = 0;
                n < e.length && 0 === e[n];
                n++, r = r.sqr()
              );
              if (++n < e.length)
                for (var i = r.sqr(); n < e.length; n++, i = i.sqr())
                  0 !== e[n] && (r = r.mul(i));
              return r;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                i = (t - r) / 26,
                o = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & o,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++) this.words[e] = 0;
                this.length += i;
              }
              return this.strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var i;
              n("number" == typeof t && t >= 0),
                (i = e ? (e - (e % 26)) / 26 : 0);
              var o = t % 26,
                s = Math.min((t - o) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> o) << o),
                u = r;
              if (((i -= s), (i = Math.max(0, i)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var f = 0;
              for (c = this.length - 1; c >= 0 && (0 !== f || c >= i); c--) {
                var h = 0 | this.words[c];
                (this.words[c] = (f << (26 - o)) | (h >>> o)), (f = h & a);
              }
              return (
                u && 0 !== f && (u.words[u.length++] = f),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              return !(this.length <= r) && !!(this.words[r] & i);
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var i = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= i;
              }
              return this.strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                    ? 1 === this.length && (0 | this.words[0]) < t
                      ? ((this.words[0] = t - (0 | this.words[0])),
                        (this.negative = 0),
                        this)
                      : ((this.negative = 0),
                        this.isubn(t),
                        (this.negative = 1),
                        this)
                    : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this.strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var i,
                o,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (i = 0; i < t.length; i++) {
                o = (0 | this.words[i + r]) + a;
                var u = (0 | t.words[i]) * e;
                (a = ((o -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & o);
              }
              for (; i < this.length - r; i++)
                (a = (o = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & o);
              if (0 === a) return this.strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (o = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & o);
              return (this.negative = 1), this.strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var r = (this.length, t.length),
                n = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 !== (r = 26 - this._countBits(s)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = n.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var f = n.clone()._ishlnsubmul(i, 1, u);
              0 === f.negative && ((n = f), a && (a.words[u] = 1));
              for (var h = u - 1; h >= 0; h--) {
                var l =
                  67108864 * (0 | n.words[i.length + h]) +
                  (0 | n.words[i.length + h - 1]);
                for (
                  l = Math.min((l / s) | 0, 67108863), n._ishlnsubmul(i, l, h);
                  0 !== n.negative;

                )
                  l--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, h),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[h] = l);
              }
              return (
                a && a.strip(),
                n.strip(),
                "div" !== e && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                    ? ((a = this.neg().divmod(t, e)),
                      "mod" !== e && (i = a.div.neg()),
                      "div" !== e &&
                        ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                      { div: i, mod: s })
                    : 0 === this.negative && 0 !== t.negative
                      ? ((a = this.divmod(t.neg(), e)),
                        "mod" !== e && (i = a.div.neg()),
                        { div: i, mod: a.mod })
                      : this.negative & t.negative
                        ? ((a = this.neg().divmod(t.neg(), e)),
                          "div" !== e &&
                            ((s = a.mod.neg()),
                            r && 0 !== s.negative && s.isub(t)),
                          { div: a.div, mod: s })
                        : t.length > this.length || this.cmp(t) < 0
                          ? { div: new o(0), mod: this }
                          : 1 === t.length
                            ? "div" === e
                              ? { div: this.divn(t.words[0]), mod: null }
                              : "mod" === e
                                ? {
                                    div: null,
                                    mod: new o(this.modn(t.words[0])),
                                  }
                                : {
                                    div: this.divn(t.words[0]),
                                    mod: new o(this.modn(t.words[0])),
                                  }
                            : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                n = t.ushrn(1),
                i = t.andln(1),
                o = r.cmp(n);
              return o < 0 || (1 === i && 0 === o)
                ? e.div
                : 0 !== e.div.negative
                  ? e.div.isubn(1)
                  : e.div.iaddn(1);
            }),
            (o.prototype.modn = function (t) {
              n(t <= 67108863);
              for (
                var e = (1 << 26) % t, r = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                r = (e * r + (0 | this.words[i])) % t;
              return r;
            }),
            (o.prototype.idivn = function (t) {
              n(t <= 67108863);
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var i = (0 | this.words[r]) + 67108864 * e;
                (this.words[r] = (i / t) | 0), (e = i % t);
              }
              return this.strip();
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var f = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var l = 0, d = 1;
                  !(e.words[0] & d) && l < 26;
                  ++l, d <<= 1
                );
                if (l > 0)
                  for (e.iushrn(l); l-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, y = 1;
                  !(r.words[0] & y) && p < 26;
                  ++p, y <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(h)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, f = 1;
                  !(e.words[0] & f) && c < 26;
                  ++c, f <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var h = 0, l = 1;
                  !(r.words[0] & l) && h < 26;
                  ++h, l <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                r = t.clone();
              (e.negative = 0), (r.negative = 0);
              for (var n = 0; e.isEven() && r.isEven(); n++)
                e.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = e.cmp(r);
                if (i < 0) {
                  var o = e;
                  (e = r), (r = o);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                e.isub(r);
              }
              return r.iushln(n);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                i = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var o = i, s = r; 0 !== o && s < this.length; s++) {
                var a = 0 | this.words[s];
                (o = (a += o) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== o && ((this.words[s] = o), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this.strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | t.words[r];
                if (n !== i) {
                  n < i ? (e = -1) : n > i && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var m = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function w() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function v() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function _() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function E() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                r = t;
              do {
                this.split(r, this.tmp),
                  (e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var n = e < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                    ? r.isub(this.p)
                    : void 0 !== r.strip
                      ? r.strip()
                      : r._strip(),
                r
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            i(w, b),
            (w.prototype.split = function (t, e) {
              for (
                var r = 4194303, n = Math.min(t.length, 9), i = 0;
                i < n;
                i++
              )
                e.words[i] = t.words[i];
              if (((e.length = n), t.length <= 9))
                return (t.words[0] = 0), void (t.length = 1);
              var o = t.words[9];
              for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
                var s = 0 | t.words[i];
                (t.words[i - 10] = ((s & r) << 4) | (o >>> 22)), (o = s);
              }
              (o >>>= 22),
                (t.words[i - 10] = o),
                0 === o && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (w.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 0 | t.words[r];
                (e += 977 * n),
                  (t.words[r] = 67108863 & e),
                  (e = 64 * n + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            i(v, b),
            i(_, b),
            i(E, b),
            (E.prototype.imulK = function (t) {
              for (var e = 0, r = 0; r < t.length; r++) {
                var n = 19 * (0 | t.words[r]) + e,
                  i = 67108863 & n;
                (n >>>= 26), (t.words[r] = i), (e = n);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (m[t]) return m[t];
              var e;
              if ("k256" === t) e = new w();
              else if ("p224" === t) e = new v();
              else if ("p192" === t) e = new _();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new E();
              }
              return (m[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(!(t.negative | e.negative), "red works only with positives"),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : t.umod(this.m)._forceRed(this);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var r = t.add(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var r = t.iadd(e);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var r = t.sub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var r = t.isub(e);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                f = this.m.bitLength();
              for (
                f = new o(2 * f * f).toRed(this);
                0 !== this.pow(f, c).cmp(u);

              )
                f.redIAdd(u);
              for (
                var h = this.pow(f, i),
                  l = this.pow(t, i.addn(1).iushrn(1)),
                  d = this.pow(t, i),
                  p = s;
                0 !== d.cmp(a);

              ) {
                for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                n(g < p);
                var m = this.pow(h, new o(1).iushln(p - g - 1));
                (l = l.redMul(m)), (h = m.redSqr()), (d = d.redMul(h)), (p = g);
              }
              return l;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var r = new Array(16);
              (r[0] = new o(1).toRed(this)), (r[1] = t);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
              var i = r[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
                for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                  var h = (c >> f) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === n && 0 === f)) &&
                          ((i = this.mul(i, r[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            i(I, S),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var r = t.imul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var r = t.mul(e),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((t = r.nmd(t)), this);
      },
      96897: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(30041),
          o = r(30592)(),
          s = r(75795),
          a = r(69675),
          u = n("%Math.floor%");
        t.exports = function (t, e) {
          if ("function" != typeof t) throw new a("`fn` is not a function");
          if ("number" != typeof e || e < 0 || e > 4294967295 || u(e) !== e)
            throw new a("`length` must be a positive 32-bit integer");
          var r = arguments.length > 2 && !!arguments[2],
            n = !0,
            c = !0;
          if ("length" in t && s) {
            var f = s(t, "length");
            f && !f.configurable && (n = !1), f && !f.writable && (c = !1);
          }
          return (
            (n || c || !r) &&
              (o ? i(t, "length", e, !0, !0) : i(t, "length", e)),
            t
          );
        };
      },
      90392: (t, e, r) => {
        var n = r(92861).Buffer;
        function i(t, e) {
          (this._block = n.alloc(t)),
            (this._finalSize = e),
            (this._blockSize = t),
            (this._len = 0);
        }
        (i.prototype.update = function (t, e) {
          "string" == typeof t && ((e = e || "utf8"), (t = n.from(t, e)));
          for (
            var r = this._block,
              i = this._blockSize,
              o = t.length,
              s = this._len,
              a = 0;
            a < o;

          ) {
            for (var u = s % i, c = Math.min(o - a, i - u), f = 0; f < c; f++)
              r[u + f] = t[a + f];
            (a += c), (s += c) % i == 0 && this._update(r);
          }
          return (this._len += o), this;
        }),
          (i.prototype.digest = function (t) {
            var e = this._len % this._blockSize;
            (this._block[e] = 128),
              this._block.fill(0, e + 1),
              e >= this._finalSize &&
                (this._update(this._block), this._block.fill(0));
            var r = 8 * this._len;
            if (r <= 4294967295)
              this._block.writeUInt32BE(r, this._blockSize - 4);
            else {
              var n = (4294967295 & r) >>> 0,
                i = (r - n) / 4294967296;
              this._block.writeUInt32BE(i, this._blockSize - 8),
                this._block.writeUInt32BE(n, this._blockSize - 4);
            }
            this._update(this._block);
            var o = this._hash();
            return t ? o.toString(t) : o;
          }),
          (i.prototype._update = function () {
            throw new Error("_update must be implemented by subclass");
          }),
          (t.exports = i);
      },
      62802: (t, e, r) => {
        var n = (t.exports = function (t) {
          t = t.toLowerCase();
          var e = n[t];
          if (!e)
            throw new Error(t + " is not supported (we accept pull requests)");
          return new e();
        });
        (n.sha = r(27816)),
          (n.sha1 = r(63737)),
          (n.sha224 = r(26710)),
          (n.sha256 = r(24107)),
          (n.sha384 = r(32827)),
          (n.sha512 = r(82890));
      },
      27816: (t, e, r) => {
        var n = r(56698),
          i = r(90392),
          o = r(92861).Buffer,
          s = [1518500249, 1859775393, -1894007588, -899497514],
          a = new Array(80);
        function u() {
          this.init(), (this._w = a), i.call(this, 64, 56);
        }
        function c(t) {
          return (t << 30) | (t >>> 2);
        }
        function f(t, e, r, n) {
          return 0 === t
            ? (e & r) | (~e & n)
            : 2 === t
              ? (e & r) | (e & n) | (r & n)
              : e ^ r ^ n;
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._a = 1732584193),
              (this._b = 4023233417),
              (this._c = 2562383102),
              (this._d = 271733878),
              (this._e = 3285377520),
              this
            );
          }),
          (u.prototype._update = function (t) {
            for (
              var e,
                r = this._w,
                n = 0 | this._a,
                i = 0 | this._b,
                o = 0 | this._c,
                a = 0 | this._d,
                u = 0 | this._e,
                h = 0;
              h < 16;
              ++h
            )
              r[h] = t.readInt32BE(4 * h);
            for (; h < 80; ++h)
              r[h] = r[h - 3] ^ r[h - 8] ^ r[h - 14] ^ r[h - 16];
            for (var l = 0; l < 80; ++l) {
              var d = ~~(l / 20),
                p =
                  0 |
                  ((((e = n) << 5) | (e >>> 27)) +
                    f(d, i, o, a) +
                    u +
                    r[l] +
                    s[d]);
              (u = a), (a = o), (o = c(i)), (i = n), (n = p);
            }
            (this._a = (n + this._a) | 0),
              (this._b = (i + this._b) | 0),
              (this._c = (o + this._c) | 0),
              (this._d = (a + this._d) | 0),
              (this._e = (u + this._e) | 0);
          }),
          (u.prototype._hash = function () {
            var t = o.allocUnsafe(20);
            return (
              t.writeInt32BE(0 | this._a, 0),
              t.writeInt32BE(0 | this._b, 4),
              t.writeInt32BE(0 | this._c, 8),
              t.writeInt32BE(0 | this._d, 12),
              t.writeInt32BE(0 | this._e, 16),
              t
            );
          }),
          (t.exports = u);
      },
      63737: (t, e, r) => {
        var n = r(56698),
          i = r(90392),
          o = r(92861).Buffer,
          s = [1518500249, 1859775393, -1894007588, -899497514],
          a = new Array(80);
        function u() {
          this.init(), (this._w = a), i.call(this, 64, 56);
        }
        function c(t) {
          return (t << 5) | (t >>> 27);
        }
        function f(t) {
          return (t << 30) | (t >>> 2);
        }
        function h(t, e, r, n) {
          return 0 === t
            ? (e & r) | (~e & n)
            : 2 === t
              ? (e & r) | (e & n) | (r & n)
              : e ^ r ^ n;
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._a = 1732584193),
              (this._b = 4023233417),
              (this._c = 2562383102),
              (this._d = 271733878),
              (this._e = 3285377520),
              this
            );
          }),
          (u.prototype._update = function (t) {
            for (
              var e,
                r = this._w,
                n = 0 | this._a,
                i = 0 | this._b,
                o = 0 | this._c,
                a = 0 | this._d,
                u = 0 | this._e,
                l = 0;
              l < 16;
              ++l
            )
              r[l] = t.readInt32BE(4 * l);
            for (; l < 80; ++l)
              r[l] =
                ((e = r[l - 3] ^ r[l - 8] ^ r[l - 14] ^ r[l - 16]) << 1) |
                (e >>> 31);
            for (var d = 0; d < 80; ++d) {
              var p = ~~(d / 20),
                y = (c(n) + h(p, i, o, a) + u + r[d] + s[p]) | 0;
              (u = a), (a = o), (o = f(i)), (i = n), (n = y);
            }
            (this._a = (n + this._a) | 0),
              (this._b = (i + this._b) | 0),
              (this._c = (o + this._c) | 0),
              (this._d = (a + this._d) | 0),
              (this._e = (u + this._e) | 0);
          }),
          (u.prototype._hash = function () {
            var t = o.allocUnsafe(20);
            return (
              t.writeInt32BE(0 | this._a, 0),
              t.writeInt32BE(0 | this._b, 4),
              t.writeInt32BE(0 | this._c, 8),
              t.writeInt32BE(0 | this._d, 12),
              t.writeInt32BE(0 | this._e, 16),
              t
            );
          }),
          (t.exports = u);
      },
      26710: (t, e, r) => {
        var n = r(56698),
          i = r(24107),
          o = r(90392),
          s = r(92861).Buffer,
          a = new Array(64);
        function u() {
          this.init(), (this._w = a), o.call(this, 64, 56);
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._a = 3238371032),
              (this._b = 914150663),
              (this._c = 812702999),
              (this._d = 4144912697),
              (this._e = 4290775857),
              (this._f = 1750603025),
              (this._g = 1694076839),
              (this._h = 3204075428),
              this
            );
          }),
          (u.prototype._hash = function () {
            var t = s.allocUnsafe(28);
            return (
              t.writeInt32BE(this._a, 0),
              t.writeInt32BE(this._b, 4),
              t.writeInt32BE(this._c, 8),
              t.writeInt32BE(this._d, 12),
              t.writeInt32BE(this._e, 16),
              t.writeInt32BE(this._f, 20),
              t.writeInt32BE(this._g, 24),
              t
            );
          }),
          (t.exports = u);
      },
      24107: (t, e, r) => {
        var n = r(56698),
          i = r(90392),
          o = r(92861).Buffer,
          s = [
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ],
          a = new Array(64);
        function u() {
          this.init(), (this._w = a), i.call(this, 64, 56);
        }
        function c(t, e, r) {
          return r ^ (t & (e ^ r));
        }
        function f(t, e, r) {
          return (t & e) | (r & (t | e));
        }
        function h(t) {
          return (
            ((t >>> 2) | (t << 30)) ^
            ((t >>> 13) | (t << 19)) ^
            ((t >>> 22) | (t << 10))
          );
        }
        function l(t) {
          return (
            ((t >>> 6) | (t << 26)) ^
            ((t >>> 11) | (t << 21)) ^
            ((t >>> 25) | (t << 7))
          );
        }
        function d(t) {
          return ((t >>> 7) | (t << 25)) ^ ((t >>> 18) | (t << 14)) ^ (t >>> 3);
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._a = 1779033703),
              (this._b = 3144134277),
              (this._c = 1013904242),
              (this._d = 2773480762),
              (this._e = 1359893119),
              (this._f = 2600822924),
              (this._g = 528734635),
              (this._h = 1541459225),
              this
            );
          }),
          (u.prototype._update = function (t) {
            for (
              var e,
                r = this._w,
                n = 0 | this._a,
                i = 0 | this._b,
                o = 0 | this._c,
                a = 0 | this._d,
                u = 0 | this._e,
                p = 0 | this._f,
                y = 0 | this._g,
                g = 0 | this._h,
                m = 0;
              m < 16;
              ++m
            )
              r[m] = t.readInt32BE(4 * m);
            for (; m < 64; ++m)
              r[m] =
                0 |
                (((((e = r[m - 2]) >>> 17) | (e << 15)) ^
                  ((e >>> 19) | (e << 13)) ^
                  (e >>> 10)) +
                  r[m - 7] +
                  d(r[m - 15]) +
                  r[m - 16]);
            for (var b = 0; b < 64; ++b) {
              var w = (g + l(u) + c(u, p, y) + s[b] + r[b]) | 0,
                v = (h(n) + f(n, i, o)) | 0;
              (g = y),
                (y = p),
                (p = u),
                (u = (a + w) | 0),
                (a = o),
                (o = i),
                (i = n),
                (n = (w + v) | 0);
            }
            (this._a = (n + this._a) | 0),
              (this._b = (i + this._b) | 0),
              (this._c = (o + this._c) | 0),
              (this._d = (a + this._d) | 0),
              (this._e = (u + this._e) | 0),
              (this._f = (p + this._f) | 0),
              (this._g = (y + this._g) | 0),
              (this._h = (g + this._h) | 0);
          }),
          (u.prototype._hash = function () {
            var t = o.allocUnsafe(32);
            return (
              t.writeInt32BE(this._a, 0),
              t.writeInt32BE(this._b, 4),
              t.writeInt32BE(this._c, 8),
              t.writeInt32BE(this._d, 12),
              t.writeInt32BE(this._e, 16),
              t.writeInt32BE(this._f, 20),
              t.writeInt32BE(this._g, 24),
              t.writeInt32BE(this._h, 28),
              t
            );
          }),
          (t.exports = u);
      },
      32827: (t, e, r) => {
        var n = r(56698),
          i = r(82890),
          o = r(90392),
          s = r(92861).Buffer,
          a = new Array(160);
        function u() {
          this.init(), (this._w = a), o.call(this, 128, 112);
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._ah = 3418070365),
              (this._bh = 1654270250),
              (this._ch = 2438529370),
              (this._dh = 355462360),
              (this._eh = 1731405415),
              (this._fh = 2394180231),
              (this._gh = 3675008525),
              (this._hh = 1203062813),
              (this._al = 3238371032),
              (this._bl = 914150663),
              (this._cl = 812702999),
              (this._dl = 4144912697),
              (this._el = 4290775857),
              (this._fl = 1750603025),
              (this._gl = 1694076839),
              (this._hl = 3204075428),
              this
            );
          }),
          (u.prototype._hash = function () {
            var t = s.allocUnsafe(48);
            function e(e, r, n) {
              t.writeInt32BE(e, n), t.writeInt32BE(r, n + 4);
            }
            return (
              e(this._ah, this._al, 0),
              e(this._bh, this._bl, 8),
              e(this._ch, this._cl, 16),
              e(this._dh, this._dl, 24),
              e(this._eh, this._el, 32),
              e(this._fh, this._fl, 40),
              t
            );
          }),
          (t.exports = u);
      },
      82890: (t, e, r) => {
        var n = r(56698),
          i = r(90392),
          o = r(92861).Buffer,
          s = [
            1116352408, 3609767458, 1899447441, 602891725, 3049323471,
            3964484399, 3921009573, 2173295548, 961987163, 4081628472,
            1508970993, 3053834265, 2453635748, 2937671579, 2870763221,
            3664609560, 3624381080, 2734883394, 310598401, 1164996542,
            607225278, 1323610764, 1426881987, 3590304994, 1925078388,
            4068182383, 2162078206, 991336113, 2614888103, 633803317,
            3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
            944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983,
            1495990901, 1249150122, 1856431235, 1555081692, 3175218132,
            1996064986, 2198950837, 2554220882, 3999719339, 2821834349,
            766784016, 2952996808, 2566594879, 3210313671, 3203337956,
            3336571891, 1034457026, 3584528711, 2466948901, 113926993,
            3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912,
            1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
            1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
            1206759142, 2456956037, 344077627, 2730485921, 1290863460,
            2820302411, 3158454273, 3259730800, 3505952657, 3345764771,
            106217008, 3516065817, 3606008344, 3600352804, 1432725776,
            4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752,
            506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
            958139571, 3318307427, 1322822218, 3812723403, 1537002063,
            2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
            2024104815, 1125592928, 2227730452, 2716904306, 2361852424,
            442776044, 2428436474, 593698344, 2756734187, 3733110249,
            3204031479, 2999351573, 3329325298, 3815920427, 3391569614,
            3928383900, 3515267271, 566280711, 3940187606, 3454069534,
            4118630271, 4000239992, 116418474, 1914138554, 174292421,
            2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733,
            587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580,
            2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
            1607167915, 987167468, 1816402316, 1246189591,
          ],
          a = new Array(160);
        function u() {
          this.init(), (this._w = a), i.call(this, 128, 112);
        }
        function c(t, e, r) {
          return r ^ (t & (e ^ r));
        }
        function f(t, e, r) {
          return (t & e) | (r & (t | e));
        }
        function h(t, e) {
          return (
            ((t >>> 28) | (e << 4)) ^
            ((e >>> 2) | (t << 30)) ^
            ((e >>> 7) | (t << 25))
          );
        }
        function l(t, e) {
          return (
            ((t >>> 14) | (e << 18)) ^
            ((t >>> 18) | (e << 14)) ^
            ((e >>> 9) | (t << 23))
          );
        }
        function d(t, e) {
          return ((t >>> 1) | (e << 31)) ^ ((t >>> 8) | (e << 24)) ^ (t >>> 7);
        }
        function p(t, e) {
          return (
            ((t >>> 1) | (e << 31)) ^
            ((t >>> 8) | (e << 24)) ^
            ((t >>> 7) | (e << 25))
          );
        }
        function y(t, e) {
          return ((t >>> 19) | (e << 13)) ^ ((e >>> 29) | (t << 3)) ^ (t >>> 6);
        }
        function g(t, e) {
          return (
            ((t >>> 19) | (e << 13)) ^
            ((e >>> 29) | (t << 3)) ^
            ((t >>> 6) | (e << 26))
          );
        }
        function m(t, e) {
          return t >>> 0 < e >>> 0 ? 1 : 0;
        }
        n(u, i),
          (u.prototype.init = function () {
            return (
              (this._ah = 1779033703),
              (this._bh = 3144134277),
              (this._ch = 1013904242),
              (this._dh = 2773480762),
              (this._eh = 1359893119),
              (this._fh = 2600822924),
              (this._gh = 528734635),
              (this._hh = 1541459225),
              (this._al = 4089235720),
              (this._bl = 2227873595),
              (this._cl = 4271175723),
              (this._dl = 1595750129),
              (this._el = 2917565137),
              (this._fl = 725511199),
              (this._gl = 4215389547),
              (this._hl = 327033209),
              this
            );
          }),
          (u.prototype._update = function (t) {
            for (
              var e = this._w,
                r = 0 | this._ah,
                n = 0 | this._bh,
                i = 0 | this._ch,
                o = 0 | this._dh,
                a = 0 | this._eh,
                u = 0 | this._fh,
                b = 0 | this._gh,
                w = 0 | this._hh,
                v = 0 | this._al,
                _ = 0 | this._bl,
                E = 0 | this._cl,
                S = 0 | this._dl,
                I = 0 | this._el,
                M = 0 | this._fl,
                A = 0 | this._gl,
                T = 0 | this._hl,
                k = 0;
              k < 32;
              k += 2
            )
              (e[k] = t.readInt32BE(4 * k)),
                (e[k + 1] = t.readInt32BE(4 * k + 4));
            for (; k < 160; k += 2) {
              var O = e[k - 30],
                x = e[k - 30 + 1],
                P = d(O, x),
                B = p(x, O),
                C = y((O = e[k - 4]), (x = e[k - 4 + 1])),
                R = g(x, O),
                N = e[k - 14],
                U = e[k - 14 + 1],
                D = e[k - 32],
                L = e[k - 32 + 1],
                j = (B + U) | 0,
                F = (P + N + m(j, B)) | 0;
              (F =
                ((F = (F + C + m((j = (j + R) | 0), R)) | 0) +
                  D +
                  m((j = (j + L) | 0), L)) |
                0),
                (e[k] = F),
                (e[k + 1] = j);
            }
            for (var H = 0; H < 160; H += 2) {
              (F = e[H]), (j = e[H + 1]);
              var K = f(r, n, i),
                V = f(v, _, E),
                q = h(r, v),
                z = h(v, r),
                $ = l(a, I),
                G = l(I, a),
                W = s[H],
                Y = s[H + 1],
                X = c(a, u, b),
                Z = c(I, M, A),
                J = (T + G) | 0,
                Q = (w + $ + m(J, T)) | 0;
              Q =
                ((Q =
                  ((Q = (Q + X + m((J = (J + Z) | 0), Z)) | 0) +
                    W +
                    m((J = (J + Y) | 0), Y)) |
                  0) +
                  F +
                  m((J = (J + j) | 0), j)) |
                0;
              var tt = (z + V) | 0,
                et = (q + K + m(tt, z)) | 0;
              (w = b),
                (T = A),
                (b = u),
                (A = M),
                (u = a),
                (M = I),
                (a = (o + Q + m((I = (S + J) | 0), S)) | 0),
                (o = i),
                (S = E),
                (i = n),
                (E = _),
                (n = r),
                (_ = v),
                (r = (Q + et + m((v = (J + tt) | 0), J)) | 0);
            }
            (this._al = (this._al + v) | 0),
              (this._bl = (this._bl + _) | 0),
              (this._cl = (this._cl + E) | 0),
              (this._dl = (this._dl + S) | 0),
              (this._el = (this._el + I) | 0),
              (this._fl = (this._fl + M) | 0),
              (this._gl = (this._gl + A) | 0),
              (this._hl = (this._hl + T) | 0),
              (this._ah = (this._ah + r + m(this._al, v)) | 0),
              (this._bh = (this._bh + n + m(this._bl, _)) | 0),
              (this._ch = (this._ch + i + m(this._cl, E)) | 0),
              (this._dh = (this._dh + o + m(this._dl, S)) | 0),
              (this._eh = (this._eh + a + m(this._el, I)) | 0),
              (this._fh = (this._fh + u + m(this._fl, M)) | 0),
              (this._gh = (this._gh + b + m(this._gl, A)) | 0),
              (this._hh = (this._hh + w + m(this._hl, T)) | 0);
          }),
          (u.prototype._hash = function () {
            var t = o.allocUnsafe(64);
            function e(e, r, n) {
              t.writeInt32BE(e, n), t.writeInt32BE(r, n + 4);
            }
            return (
              e(this._ah, this._al, 0),
              e(this._bh, this._bl, 8),
              e(this._ch, this._cl, 16),
              e(this._dh, this._dl, 24),
              e(this._eh, this._el, 32),
              e(this._fh, this._fl, 40),
              e(this._gh, this._gl, 48),
              e(this._hh, this._hl, 56),
              t
            );
          }),
          (t.exports = u);
      },
      88310: (t, e, r) => {
        t.exports = i;
        var n = r(37007).EventEmitter;
        function i() {
          n.call(this);
        }
        r(56698)(i, n),
          (i.Readable = r(45412)),
          (i.Writable = r(16708)),
          (i.Duplex = r(25382)),
          (i.Transform = r(74610)),
          (i.PassThrough = r(63600)),
          (i.finished = r(86238)),
          (i.pipeline = r(57758)),
          (i.Stream = i),
          (i.prototype.pipe = function (t, e) {
            var r = this;
            function i(e) {
              t.writable && !1 === t.write(e) && r.pause && r.pause();
            }
            function o() {
              r.readable && r.resume && r.resume();
            }
            r.on("data", i),
              t.on("drain", o),
              t._isStdio ||
                (e && !1 === e.end) ||
                (r.on("end", a), r.on("close", u));
            var s = !1;
            function a() {
              s || ((s = !0), t.end());
            }
            function u() {
              s || ((s = !0), "function" == typeof t.destroy && t.destroy());
            }
            function c(t) {
              if ((f(), 0 === n.listenerCount(this, "error"))) throw t;
            }
            function f() {
              r.removeListener("data", i),
                t.removeListener("drain", o),
                r.removeListener("end", a),
                r.removeListener("close", u),
                r.removeListener("error", c),
                t.removeListener("error", c),
                r.removeListener("end", f),
                r.removeListener("close", f),
                t.removeListener("close", f);
            }
            return (
              r.on("error", c),
              t.on("error", c),
              r.on("end", f),
              r.on("close", f),
              t.on("close", f),
              t.emit("pipe", r),
              t
            );
          });
      },
      83141: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i =
            n.isEncoding ||
            function (t) {
              switch ((t = "" + t) && t.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                  return !0;
                default:
                  return !1;
              }
            };
        function o(t) {
          var e;
          switch (
            ((this.encoding = (function (t) {
              var e = (function (t) {
                if (!t) return "utf8";
                for (var e; ; )
                  switch (t) {
                    case "utf8":
                    case "utf-8":
                      return "utf8";
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return "utf16le";
                    case "latin1":
                    case "binary":
                      return "latin1";
                    case "base64":
                    case "ascii":
                    case "hex":
                      return t;
                    default:
                      if (e) return;
                      (t = ("" + t).toLowerCase()), (e = !0);
                  }
              })(t);
              if ("string" != typeof e && (n.isEncoding === i || !i(t)))
                throw new Error("Unknown encoding: " + t);
              return e || t;
            })(t)),
            this.encoding)
          ) {
            case "utf16le":
              (this.text = u), (this.end = c), (e = 4);
              break;
            case "utf8":
              (this.fillLast = a), (e = 4);
              break;
            case "base64":
              (this.text = f), (this.end = h), (e = 3);
              break;
            default:
              return (this.write = l), void (this.end = d);
          }
          (this.lastNeed = 0),
            (this.lastTotal = 0),
            (this.lastChar = n.allocUnsafe(e));
        }
        function s(t) {
          return t <= 127
            ? 0
            : t >> 5 == 6
              ? 2
              : t >> 4 == 14
                ? 3
                : t >> 3 == 30
                  ? 4
                  : t >> 6 == 2
                    ? -1
                    : -2;
        }
        function a(t) {
          var e = this.lastTotal - this.lastNeed,
            r = (function (t, e) {
              if (128 != (192 & e[0])) return (t.lastNeed = 0), "�";
              if (t.lastNeed > 1 && e.length > 1) {
                if (128 != (192 & e[1])) return (t.lastNeed = 1), "�";
                if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2]))
                  return (t.lastNeed = 2), "�";
              }
            })(this, t);
          return void 0 !== r
            ? r
            : this.lastNeed <= t.length
              ? (t.copy(this.lastChar, e, 0, this.lastNeed),
                this.lastChar.toString(this.encoding, 0, this.lastTotal))
              : (t.copy(this.lastChar, e, 0, t.length),
                void (this.lastNeed -= t.length));
        }
        function u(t, e) {
          if ((t.length - e) % 2 == 0) {
            var r = t.toString("utf16le", e);
            if (r) {
              var n = r.charCodeAt(r.length - 1);
              if (n >= 55296 && n <= 56319)
                return (
                  (this.lastNeed = 2),
                  (this.lastTotal = 4),
                  (this.lastChar[0] = t[t.length - 2]),
                  (this.lastChar[1] = t[t.length - 1]),
                  r.slice(0, -1)
                );
            }
            return r;
          }
          return (
            (this.lastNeed = 1),
            (this.lastTotal = 2),
            (this.lastChar[0] = t[t.length - 1]),
            t.toString("utf16le", e, t.length - 1)
          );
        }
        function c(t) {
          var e = t && t.length ? this.write(t) : "";
          if (this.lastNeed) {
            var r = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, r);
          }
          return e;
        }
        function f(t, e) {
          var r = (t.length - e) % 3;
          return 0 === r
            ? t.toString("base64", e)
            : ((this.lastNeed = 3 - r),
              (this.lastTotal = 3),
              1 === r
                ? (this.lastChar[0] = t[t.length - 1])
                : ((this.lastChar[0] = t[t.length - 2]),
                  (this.lastChar[1] = t[t.length - 1])),
              t.toString("base64", e, t.length - r));
        }
        function h(t) {
          var e = t && t.length ? this.write(t) : "";
          return this.lastNeed
            ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
            : e;
        }
        function l(t) {
          return t.toString(this.encoding);
        }
        function d(t) {
          return t && t.length ? this.write(t) : "";
        }
        (e.I = o),
          (o.prototype.write = function (t) {
            if (0 === t.length) return "";
            var e, r;
            if (this.lastNeed) {
              if (void 0 === (e = this.fillLast(t))) return "";
              (r = this.lastNeed), (this.lastNeed = 0);
            } else r = 0;
            return r < t.length
              ? e
                ? e + this.text(t, r)
                : this.text(t, r)
              : e || "";
          }),
          (o.prototype.end = function (t) {
            var e = t && t.length ? this.write(t) : "";
            return this.lastNeed ? e + "�" : e;
          }),
          (o.prototype.text = function (t, e) {
            var r = (function (t, e, r) {
              var n = e.length - 1;
              if (n < r) return 0;
              var i = s(e[n]);
              if (i >= 0) return i > 0 && (t.lastNeed = i - 1), i;
              if (--n < r || -2 === i) return 0;
              if (((i = s(e[n])), i >= 0))
                return i > 0 && (t.lastNeed = i - 2), i;
              if (--n < r || -2 === i) return 0;
              if (((i = s(e[n])), i >= 0))
                return i > 0 && (2 === i ? (i = 0) : (t.lastNeed = i - 3)), i;
              return 0;
            })(this, t, e);
            if (!this.lastNeed) return t.toString("utf8", e);
            this.lastTotal = r;
            var n = t.length - (r - this.lastNeed);
            return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n);
          }),
          (o.prototype.fillLast = function (t) {
            if (this.lastNeed <= t.length)
              return (
                t.copy(
                  this.lastChar,
                  this.lastTotal - this.lastNeed,
                  0,
                  this.lastNeed,
                ),
                this.lastChar.toString(this.encoding, 0, this.lastTotal)
              );
            t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length),
              (this.lastNeed -= t.length);
          });
      },
      1061: (t, e, r) => {
        var n = r(12113);
        function i(t) {
          return t.name || t.toString().match(/function (.*?)\s*\(/)[1];
        }
        function o(t) {
          return n.Nil(t) ? "" : i(t.constructor);
        }
        function s(t, e) {
          Error.captureStackTrace && Error.captureStackTrace(t, e);
        }
        function a(t) {
          return n.Function(t)
            ? t.toJSON
              ? t.toJSON()
              : i(t)
            : n.Array(t)
              ? "Array"
              : t && n.Object(t)
                ? "Object"
                : void 0 !== t
                  ? t
                  : "";
        }
        function u(t, e, r) {
          var i = (function (t) {
            return n.Function(t)
              ? ""
              : n.String(t)
                ? JSON.stringify(t)
                : t && n.Object(t)
                  ? ""
                  : t;
          })(e);
          return (
            "Expected " +
            a(t) +
            ", got" +
            ("" !== r ? " " + r : "") +
            ("" !== i ? " " + i : "")
          );
        }
        function c(t, e, r) {
          (r = r || o(e)),
            (this.message = u(t, e, r)),
            s(this, c),
            (this.__type = t),
            (this.__value = e),
            (this.__valueTypeName = r);
        }
        function f(t, e, r, n, i) {
          t
            ? ((i = i || o(n)),
              (this.message = (function (t, e, r, n, i) {
                var o = '" of type ';
                return (
                  "key" === e && (o = '" with key type '),
                  u('property "' + a(r) + o + a(t), n, i)
                );
              })(t, r, e, n, i)))
            : (this.message = 'Unexpected property "' + e + '"'),
            s(this, c),
            (this.__label = r),
            (this.__property = e),
            (this.__type = t),
            (this.__value = n),
            (this.__valueTypeName = i);
        }
        (c.prototype = Object.create(Error.prototype)),
          (c.prototype.constructor = c),
          (f.prototype = Object.create(Error.prototype)),
          (f.prototype.constructor = c),
          (t.exports = {
            TfTypeError: c,
            TfPropertyTypeError: f,
            tfCustomError: function (t, e) {
              return new c(t, {}, e);
            },
            tfSubError: function (t, e, r) {
              return (
                t instanceof f
                  ? ((e = e + "." + t.__property),
                    (t = new f(
                      t.__type,
                      e,
                      t.__label,
                      t.__value,
                      t.__valueTypeName,
                    )))
                  : t instanceof c &&
                    (t = new f(t.__type, e, r, t.__value, t.__valueTypeName)),
                s(t),
                t
              );
            },
            tfJSON: a,
            getValueTypeName: o,
          });
      },
      69542: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(12113),
          o = r(1061);
        function s(t) {
          return n.isBuffer(t);
        }
        function a(t) {
          return "string" == typeof t && /^([0-9a-f]{2})+$/i.test(t);
        }
        function u(t, e) {
          var r = t.toJSON();
          function n(n) {
            if (!t(n)) return !1;
            if (n.length === e) return !0;
            throw o.tfCustomError(
              r + "(Length: " + e + ")",
              r + "(Length: " + n.length + ")",
            );
          }
          return (
            (n.toJSON = function () {
              return r;
            }),
            n
          );
        }
        var c = u.bind(null, i.Array),
          f = u.bind(null, s),
          h = u.bind(null, a),
          l = u.bind(null, i.String);
        var d = Math.pow(2, 53) - 1;
        var p = {
          ArrayN: c,
          Buffer: s,
          BufferN: f,
          Finite: function (t) {
            return "number" == typeof t && isFinite(t);
          },
          Hex: a,
          HexN: h,
          Int8: function (t) {
            return (t << 24) >> 24 === t;
          },
          Int16: function (t) {
            return (t << 16) >> 16 === t;
          },
          Int32: function (t) {
            return (0 | t) === t;
          },
          Int53: function (t) {
            return (
              "number" == typeof t && t >= -d && t <= d && Math.floor(t) === t
            );
          },
          Range: function (t, e, r) {
            function n(n, i) {
              return r(n, i) && n > t && n < e;
            }
            return (
              (r = r || i.Number),
              (n.toJSON = function () {
                return `${r.toJSON()} between [${t}, ${e}]`;
              }),
              n
            );
          },
          StringN: l,
          UInt8: function (t) {
            return (255 & t) === t;
          },
          UInt16: function (t) {
            return (65535 & t) === t;
          },
          UInt32: function (t) {
            return t >>> 0 === t;
          },
          UInt53: function (t) {
            return (
              "number" == typeof t && t >= 0 && t <= d && Math.floor(t) === t
            );
          },
        };
        for (var y in p)
          p[y].toJSON = function (t) {
            return t;
          }.bind(null, y);
        t.exports = p;
      },
      8676: (t, e, r) => {
        var n = r(1061),
          i = r(12113),
          o = n.tfJSON,
          s = n.TfTypeError,
          a = n.TfPropertyTypeError,
          u = n.tfSubError,
          c = n.getValueTypeName,
          f = {
            arrayOf: function (t, e) {
              function r(r, n) {
                return (
                  !!i.Array(r) &&
                  !i.Nil(r) &&
                  !(void 0 !== e.minLength && r.length < e.minLength) &&
                  !(void 0 !== e.maxLength && r.length > e.maxLength) &&
                  (void 0 === e.length || r.length === e.length) &&
                  r.every(function (e, r) {
                    try {
                      return l(t, e, n);
                    } catch (t) {
                      throw u(t, r);
                    }
                  })
                );
              }
              return (
                (t = h(t)),
                (e = e || {}),
                (r.toJSON = function () {
                  var r = "[" + o(t) + "]";
                  return (
                    void 0 !== e.length
                      ? (r += "{" + e.length + "}")
                      : (void 0 === e.minLength && void 0 === e.maxLength) ||
                        (r +=
                          "{" +
                          (void 0 === e.minLength ? 0 : e.minLength) +
                          "," +
                          (void 0 === e.maxLength ? 1 / 0 : e.maxLength) +
                          "}"),
                    r
                  );
                }),
                r
              );
            },
            maybe: function t(e) {
              function r(r, n) {
                return i.Nil(r) || e(r, n, t);
              }
              return (
                (e = h(e)),
                (r.toJSON = function () {
                  return "?" + o(e);
                }),
                r
              );
            },
            map: function (t, e) {
              function r(r, n) {
                if (!i.Object(r)) return !1;
                if (i.Nil(r)) return !1;
                for (var o in r) {
                  try {
                    e && l(e, o, n);
                  } catch (t) {
                    throw u(t, o, "key");
                  }
                  try {
                    var s = r[o];
                    l(t, s, n);
                  } catch (t) {
                    throw u(t, o);
                  }
                }
                return !0;
              }
              return (
                (t = h(t)),
                e && (e = h(e)),
                (r.toJSON = e
                  ? function () {
                      return "{" + o(e) + ": " + o(t) + "}";
                    }
                  : function () {
                      return "{" + o(t) + "}";
                    }),
                r
              );
            },
            object: function (t) {
              var e = {};
              for (var r in t) e[r] = h(t[r]);
              function n(t, r) {
                if (!i.Object(t)) return !1;
                if (i.Nil(t)) return !1;
                var n;
                try {
                  for (n in e) {
                    l(e[n], t[n], r);
                  }
                } catch (t) {
                  throw u(t, n);
                }
                if (r) for (n in t) if (!e[n]) throw new a(void 0, n);
                return !0;
              }
              return (
                (n.toJSON = function () {
                  return o(e);
                }),
                n
              );
            },
            anyOf: function () {
              var t = [].slice.call(arguments).map(h);
              function e(e, r) {
                return t.some(function (t) {
                  try {
                    return l(t, e, r);
                  } catch (t) {
                    return !1;
                  }
                });
              }
              return (
                (e.toJSON = function () {
                  return t.map(o).join("|");
                }),
                e
              );
            },
            allOf: function () {
              var t = [].slice.call(arguments).map(h);
              function e(e, r) {
                return t.every(function (t) {
                  try {
                    return l(t, e, r);
                  } catch (t) {
                    return !1;
                  }
                });
              }
              return (
                (e.toJSON = function () {
                  return t.map(o).join(" & ");
                }),
                e
              );
            },
            quacksLike: function (t) {
              function e(e) {
                return t === c(e);
              }
              return (
                (e.toJSON = function () {
                  return t;
                }),
                e
              );
            },
            tuple: function () {
              var t = [].slice.call(arguments).map(h);
              function e(e, r) {
                return (
                  !i.Nil(e) &&
                  !i.Nil(e.length) &&
                  (!r || e.length === t.length) &&
                  t.every(function (t, n) {
                    try {
                      return l(t, e[n], r);
                    } catch (t) {
                      throw u(t, n);
                    }
                  })
                );
              }
              return (
                (e.toJSON = function () {
                  return "(" + t.map(o).join(", ") + ")";
                }),
                e
              );
            },
            value: function (t) {
              function e(e) {
                return e === t;
              }
              return (
                (e.toJSON = function () {
                  return t;
                }),
                e
              );
            },
          };
        function h(t) {
          if (i.String(t))
            return "?" === t[0] ? f.maybe(t.slice(1)) : i[t] || f.quacksLike(t);
          if (t && i.Object(t)) {
            if (i.Array(t)) {
              if (1 !== t.length)
                throw new TypeError(
                  "Expected compile() parameter of type Array of length 1",
                );
              return f.arrayOf(t[0]);
            }
            return f.object(t);
          }
          return i.Function(t) ? t : f.value(t);
        }
        function l(t, e, r, n) {
          if (i.Function(t)) {
            if (t(e, r)) return !0;
            throw new s(n || t, e);
          }
          return l(h(t), e, r);
        }
        for (var d in ((f.oneOf = f.anyOf), i)) l[d] = i[d];
        for (d in f) l[d] = f[d];
        var p = r(69542);
        for (d in p) l[d] = p[d];
        (l.compile = h),
          (l.TfTypeError = s),
          (l.TfPropertyTypeError = a),
          (t.exports = l);
      },
      12113: (t) => {
        var e = {
          Array: function (t) {
            return null != t && t.constructor === Array;
          },
          Boolean: function (t) {
            return "boolean" == typeof t;
          },
          Function: function (t) {
            return "function" == typeof t;
          },
          Nil: function (t) {
            return null == t;
          },
          Number: function (t) {
            return "number" == typeof t;
          },
          Object: function (t) {
            return "object" == typeof t;
          },
          String: function (t) {
            return "string" == typeof t;
          },
          "": function () {
            return !0;
          },
        };
        for (var r in ((e.Null = e.Nil), e))
          e[r].toJSON = function (t) {
            return t;
          }.bind(null, r);
        t.exports = e;
      },
      94643: (t, e, r) => {
        function n(t) {
          try {
            if (!r.g.localStorage) return !1;
          } catch (t) {
            return !1;
          }
          var e = r.g.localStorage[t];
          return null != e && "true" === String(e).toLowerCase();
        }
        t.exports = function (t, e) {
          if (n("noDeprecation")) return t;
          var r = !1;
          return function () {
            if (!r) {
              if (n("throwDeprecation")) throw new Error(e);
              n("traceDeprecation") ? console.trace(e) : console.warn(e),
                (r = !0);
            }
            return t.apply(this, arguments);
          };
        };
      },
      81135: (t) => {
        t.exports = function (t) {
          return (
            t &&
            "object" == typeof t &&
            "function" == typeof t.copy &&
            "function" == typeof t.fill &&
            "function" == typeof t.readUInt8
          );
        };
      },
      49032: (t, e, r) => {
        "use strict";
        var n = r(47244),
          i = r(48184),
          o = r(25767),
          s = r(35680);
        function a(t) {
          return t.call.bind(t);
        }
        var u = "undefined" != typeof BigInt,
          c = "undefined" != typeof Symbol,
          f = a(Object.prototype.toString),
          h = a(Number.prototype.valueOf),
          l = a(String.prototype.valueOf),
          d = a(Boolean.prototype.valueOf);
        if (u) var p = a(BigInt.prototype.valueOf);
        if (c) var y = a(Symbol.prototype.valueOf);
        function g(t, e) {
          if ("object" != typeof t) return !1;
          try {
            return e(t), !0;
          } catch (t) {
            return !1;
          }
        }
        function m(t) {
          return "[object Map]" === f(t);
        }
        function b(t) {
          return "[object Set]" === f(t);
        }
        function w(t) {
          return "[object WeakMap]" === f(t);
        }
        function v(t) {
          return "[object WeakSet]" === f(t);
        }
        function _(t) {
          return "[object ArrayBuffer]" === f(t);
        }
        function E(t) {
          return (
            "undefined" != typeof ArrayBuffer &&
            (_.working ? _(t) : t instanceof ArrayBuffer)
          );
        }
        function S(t) {
          return "[object DataView]" === f(t);
        }
        function I(t) {
          return (
            "undefined" != typeof DataView &&
            (S.working ? S(t) : t instanceof DataView)
          );
        }
        (e.isArgumentsObject = n),
          (e.isGeneratorFunction = i),
          (e.isTypedArray = s),
          (e.isPromise = function (t) {
            return (
              ("undefined" != typeof Promise && t instanceof Promise) ||
              (null !== t &&
                "object" == typeof t &&
                "function" == typeof t.then &&
                "function" == typeof t.catch)
            );
          }),
          (e.isArrayBufferView = function (t) {
            return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
              ? ArrayBuffer.isView(t)
              : s(t) || I(t);
          }),
          (e.isUint8Array = function (t) {
            return "Uint8Array" === o(t);
          }),
          (e.isUint8ClampedArray = function (t) {
            return "Uint8ClampedArray" === o(t);
          }),
          (e.isUint16Array = function (t) {
            return "Uint16Array" === o(t);
          }),
          (e.isUint32Array = function (t) {
            return "Uint32Array" === o(t);
          }),
          (e.isInt8Array = function (t) {
            return "Int8Array" === o(t);
          }),
          (e.isInt16Array = function (t) {
            return "Int16Array" === o(t);
          }),
          (e.isInt32Array = function (t) {
            return "Int32Array" === o(t);
          }),
          (e.isFloat32Array = function (t) {
            return "Float32Array" === o(t);
          }),
          (e.isFloat64Array = function (t) {
            return "Float64Array" === o(t);
          }),
          (e.isBigInt64Array = function (t) {
            return "BigInt64Array" === o(t);
          }),
          (e.isBigUint64Array = function (t) {
            return "BigUint64Array" === o(t);
          }),
          (m.working = "undefined" != typeof Map && m(new Map())),
          (e.isMap = function (t) {
            return (
              "undefined" != typeof Map && (m.working ? m(t) : t instanceof Map)
            );
          }),
          (b.working = "undefined" != typeof Set && b(new Set())),
          (e.isSet = function (t) {
            return (
              "undefined" != typeof Set && (b.working ? b(t) : t instanceof Set)
            );
          }),
          (w.working = "undefined" != typeof WeakMap && w(new WeakMap())),
          (e.isWeakMap = function (t) {
            return (
              "undefined" != typeof WeakMap &&
              (w.working ? w(t) : t instanceof WeakMap)
            );
          }),
          (v.working = "undefined" != typeof WeakSet && v(new WeakSet())),
          (e.isWeakSet = function (t) {
            return v(t);
          }),
          (_.working =
            "undefined" != typeof ArrayBuffer && _(new ArrayBuffer())),
          (e.isArrayBuffer = E),
          (S.working =
            "undefined" != typeof ArrayBuffer &&
            "undefined" != typeof DataView &&
            S(new DataView(new ArrayBuffer(1), 0, 1))),
          (e.isDataView = I);
        var M =
          "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
        function A(t) {
          return "[object SharedArrayBuffer]" === f(t);
        }
        function T(t) {
          return (
            void 0 !== M &&
            (void 0 === A.working && (A.working = A(new M())),
            A.working ? A(t) : t instanceof M)
          );
        }
        function k(t) {
          return g(t, h);
        }
        function O(t) {
          return g(t, l);
        }
        function x(t) {
          return g(t, d);
        }
        function P(t) {
          return u && g(t, p);
        }
        function B(t) {
          return c && g(t, y);
        }
        (e.isSharedArrayBuffer = T),
          (e.isAsyncFunction = function (t) {
            return "[object AsyncFunction]" === f(t);
          }),
          (e.isMapIterator = function (t) {
            return "[object Map Iterator]" === f(t);
          }),
          (e.isSetIterator = function (t) {
            return "[object Set Iterator]" === f(t);
          }),
          (e.isGeneratorObject = function (t) {
            return "[object Generator]" === f(t);
          }),
          (e.isWebAssemblyCompiledModule = function (t) {
            return "[object WebAssembly.Module]" === f(t);
          }),
          (e.isNumberObject = k),
          (e.isStringObject = O),
          (e.isBooleanObject = x),
          (e.isBigIntObject = P),
          (e.isSymbolObject = B),
          (e.isBoxedPrimitive = function (t) {
            return k(t) || O(t) || x(t) || P(t) || B(t);
          }),
          (e.isAnyArrayBuffer = function (t) {
            return "undefined" != typeof Uint8Array && (E(t) || T(t));
          }),
          ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(
            function (t) {
              Object.defineProperty(e, t, {
                enumerable: !1,
                value: function () {
                  throw new Error(t + " is not supported in userland");
                },
              });
            },
          );
      },
      40537: (t, e, r) => {
        var n = r(65606),
          i =
            Object.getOwnPropertyDescriptors ||
            function (t) {
              for (var e = Object.keys(t), r = {}, n = 0; n < e.length; n++)
                r[e[n]] = Object.getOwnPropertyDescriptor(t, e[n]);
              return r;
            },
          o = /%[sdj%]/g;
        (e.format = function (t) {
          if (!w(t)) {
            for (var e = [], r = 0; r < arguments.length; r++)
              e.push(c(arguments[r]));
            return e.join(" ");
          }
          r = 1;
          for (
            var n = arguments,
              i = n.length,
              s = String(t).replace(o, function (t) {
                if ("%%" === t) return "%";
                if (r >= i) return t;
                switch (t) {
                  case "%s":
                    return String(n[r++]);
                  case "%d":
                    return Number(n[r++]);
                  case "%j":
                    try {
                      return JSON.stringify(n[r++]);
                    } catch (t) {
                      return "[Circular]";
                    }
                  default:
                    return t;
                }
              }),
              a = n[r];
            r < i;
            a = n[++r]
          )
            m(a) || !E(a) ? (s += " " + a) : (s += " " + c(a));
          return s;
        }),
          (e.deprecate = function (t, r) {
            if (void 0 !== n && !0 === n.noDeprecation) return t;
            if (void 0 === n)
              return function () {
                return e.deprecate(t, r).apply(this, arguments);
              };
            var i = !1;
            return function () {
              if (!i) {
                if (n.throwDeprecation) throw new Error(r);
                n.traceDeprecation ? console.trace(r) : console.error(r),
                  (i = !0);
              }
              return t.apply(this, arguments);
            };
          });
        var s = {},
          a = /^$/;
        if ("MISSING_ENV_VAR".NODE_DEBUG) {
          var u = "MISSING_ENV_VAR".NODE_DEBUG;
          (u = u
            .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
            .replace(/\*/g, ".*")
            .replace(/,/g, "$|^")
            .toUpperCase()),
            (a = new RegExp("^" + u + "$", "i"));
        }
        function c(t, r) {
          var n = { seen: [], stylize: h };
          return (
            arguments.length >= 3 && (n.depth = arguments[2]),
            arguments.length >= 4 && (n.colors = arguments[3]),
            g(r) ? (n.showHidden = r) : r && e._extend(n, r),
            v(n.showHidden) && (n.showHidden = !1),
            v(n.depth) && (n.depth = 2),
            v(n.colors) && (n.colors = !1),
            v(n.customInspect) && (n.customInspect = !0),
            n.colors && (n.stylize = f),
            l(n, t, n.depth)
          );
        }
        function f(t, e) {
          var r = c.styles[e];
          return r
            ? "[" + c.colors[r][0] + "m" + t + "[" + c.colors[r][1] + "m"
            : t;
        }
        function h(t, e) {
          return t;
        }
        function l(t, r, n) {
          if (
            t.customInspect &&
            r &&
            M(r.inspect) &&
            r.inspect !== e.inspect &&
            (!r.constructor || r.constructor.prototype !== r)
          ) {
            var i = r.inspect(n, t);
            return w(i) || (i = l(t, i, n)), i;
          }
          var o = (function (t, e) {
            if (v(e)) return t.stylize("undefined", "undefined");
            if (w(e)) {
              var r =
                "'" +
                JSON.stringify(e)
                  .replace(/^"|"$/g, "")
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"') +
                "'";
              return t.stylize(r, "string");
            }
            if (b(e)) return t.stylize("" + e, "number");
            if (g(e)) return t.stylize("" + e, "boolean");
            if (m(e)) return t.stylize("null", "null");
          })(t, r);
          if (o) return o;
          var s = Object.keys(r),
            a = (function (t) {
              var e = {};
              return (
                t.forEach(function (t, r) {
                  e[t] = !0;
                }),
                e
              );
            })(s);
          if (
            (t.showHidden && (s = Object.getOwnPropertyNames(r)),
            I(r) &&
              (s.indexOf("message") >= 0 || s.indexOf("description") >= 0))
          )
            return d(r);
          if (0 === s.length) {
            if (M(r)) {
              var u = r.name ? ": " + r.name : "";
              return t.stylize("[Function" + u + "]", "special");
            }
            if (_(r))
              return t.stylize(RegExp.prototype.toString.call(r), "regexp");
            if (S(r)) return t.stylize(Date.prototype.toString.call(r), "date");
            if (I(r)) return d(r);
          }
          var c,
            f = "",
            h = !1,
            E = ["{", "}"];
          (y(r) && ((h = !0), (E = ["[", "]"])), M(r)) &&
            (f = " [Function" + (r.name ? ": " + r.name : "") + "]");
          return (
            _(r) && (f = " " + RegExp.prototype.toString.call(r)),
            S(r) && (f = " " + Date.prototype.toUTCString.call(r)),
            I(r) && (f = " " + d(r)),
            0 !== s.length || (h && 0 != r.length)
              ? n < 0
                ? _(r)
                  ? t.stylize(RegExp.prototype.toString.call(r), "regexp")
                  : t.stylize("[Object]", "special")
                : (t.seen.push(r),
                  (c = h
                    ? (function (t, e, r, n, i) {
                        for (var o = [], s = 0, a = e.length; s < a; ++s)
                          O(e, String(s))
                            ? o.push(p(t, e, r, n, String(s), !0))
                            : o.push("");
                        return (
                          i.forEach(function (i) {
                            i.match(/^\d+$/) || o.push(p(t, e, r, n, i, !0));
                          }),
                          o
                        );
                      })(t, r, n, a, s)
                    : s.map(function (e) {
                        return p(t, r, n, a, e, h);
                      })),
                  t.seen.pop(),
                  (function (t, e, r) {
                    var n = t.reduce(function (t, e) {
                      return (
                        e.indexOf("\n") >= 0 && 0,
                        t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
                      );
                    }, 0);
                    if (n > 60)
                      return (
                        r[0] +
                        ("" === e ? "" : e + "\n ") +
                        " " +
                        t.join(",\n  ") +
                        " " +
                        r[1]
                      );
                    return r[0] + e + " " + t.join(", ") + " " + r[1];
                  })(c, f, E))
              : E[0] + f + E[1]
          );
        }
        function d(t) {
          return "[" + Error.prototype.toString.call(t) + "]";
        }
        function p(t, e, r, n, i, o) {
          var s, a, u;
          if (
            ((u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }).get
              ? (a = u.set
                  ? t.stylize("[Getter/Setter]", "special")
                  : t.stylize("[Getter]", "special"))
              : u.set && (a = t.stylize("[Setter]", "special")),
            O(n, i) || (s = "[" + i + "]"),
            a ||
              (t.seen.indexOf(u.value) < 0
                ? (a = m(r)
                    ? l(t, u.value, null)
                    : l(t, u.value, r - 1)).indexOf("\n") > -1 &&
                  (a = o
                    ? a
                        .split("\n")
                        .map(function (t) {
                          return "  " + t;
                        })
                        .join("\n")
                        .slice(2)
                    : "\n" +
                      a
                        .split("\n")
                        .map(function (t) {
                          return "   " + t;
                        })
                        .join("\n"))
                : (a = t.stylize("[Circular]", "special"))),
            v(s))
          ) {
            if (o && i.match(/^\d+$/)) return a;
            (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
              ? ((s = s.slice(1, -1)), (s = t.stylize(s, "name")))
              : ((s = s
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"')
                  .replace(/(^"|"$)/g, "'")),
                (s = t.stylize(s, "string")));
          }
          return s + ": " + a;
        }
        function y(t) {
          return Array.isArray(t);
        }
        function g(t) {
          return "boolean" == typeof t;
        }
        function m(t) {
          return null === t;
        }
        function b(t) {
          return "number" == typeof t;
        }
        function w(t) {
          return "string" == typeof t;
        }
        function v(t) {
          return void 0 === t;
        }
        function _(t) {
          return E(t) && "[object RegExp]" === A(t);
        }
        function E(t) {
          return "object" == typeof t && null !== t;
        }
        function S(t) {
          return E(t) && "[object Date]" === A(t);
        }
        function I(t) {
          return E(t) && ("[object Error]" === A(t) || t instanceof Error);
        }
        function M(t) {
          return "function" == typeof t;
        }
        function A(t) {
          return Object.prototype.toString.call(t);
        }
        function T(t) {
          return t < 10 ? "0" + t.toString(10) : t.toString(10);
        }
        (e.debuglog = function (t) {
          if (((t = t.toUpperCase()), !s[t]))
            if (a.test(t)) {
              var r = n.pid;
              s[t] = function () {
                var n = e.format.apply(e, arguments);
                console.error("%s %d: %s", t, r, n);
              };
            } else s[t] = function () {};
          return s[t];
        }),
          (e.inspect = c),
          (c.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39],
          }),
          (c.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red",
          }),
          (e.types = r(49032)),
          (e.isArray = y),
          (e.isBoolean = g),
          (e.isNull = m),
          (e.isNullOrUndefined = function (t) {
            return null == t;
          }),
          (e.isNumber = b),
          (e.isString = w),
          (e.isSymbol = function (t) {
            return "symbol" == typeof t;
          }),
          (e.isUndefined = v),
          (e.isRegExp = _),
          (e.types.isRegExp = _),
          (e.isObject = E),
          (e.isDate = S),
          (e.types.isDate = S),
          (e.isError = I),
          (e.types.isNativeError = I),
          (e.isFunction = M),
          (e.isPrimitive = function (t) {
            return (
              null === t ||
              "boolean" == typeof t ||
              "number" == typeof t ||
              "string" == typeof t ||
              "symbol" == typeof t ||
              void 0 === t
            );
          }),
          (e.isBuffer = r(81135));
        var k = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ];
        function O(t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }
        (e.log = function () {
          var t, r;
          console.log(
            "%s - %s",
            ((t = new Date()),
            (r = [T(t.getHours()), T(t.getMinutes()), T(t.getSeconds())].join(
              ":",
            )),
            [t.getDate(), k[t.getMonth()], r].join(" ")),
            e.format.apply(e, arguments),
          );
        }),
          (e.inherits = r(56698)),
          (e._extend = function (t, e) {
            if (!e || !E(e)) return t;
            for (var r = Object.keys(e), n = r.length; n--; ) t[r[n]] = e[r[n]];
            return t;
          });
        var x =
          "undefined" != typeof Symbol
            ? Symbol("util.promisify.custom")
            : void 0;
        function P(t, e) {
          if (!t) {
            var r = new Error("Promise was rejected with a falsy value");
            (r.reason = t), (t = r);
          }
          return e(t);
        }
        (e.promisify = function (t) {
          if ("function" != typeof t)
            throw new TypeError(
              'The "original" argument must be of type Function',
            );
          if (x && t[x]) {
            var e;
            if ("function" != typeof (e = t[x]))
              throw new TypeError(
                'The "util.promisify.custom" argument must be of type Function',
              );
            return (
              Object.defineProperty(e, x, {
                value: e,
                enumerable: !1,
                writable: !1,
                configurable: !0,
              }),
              e
            );
          }
          function e() {
            for (
              var e,
                r,
                n = new Promise(function (t, n) {
                  (e = t), (r = n);
                }),
                i = [],
                o = 0;
              o < arguments.length;
              o++
            )
              i.push(arguments[o]);
            i.push(function (t, n) {
              t ? r(t) : e(n);
            });
            try {
              t.apply(this, i);
            } catch (t) {
              r(t);
            }
            return n;
          }
          return (
            Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
            x &&
              Object.defineProperty(e, x, {
                value: e,
                enumerable: !1,
                writable: !1,
                configurable: !0,
              }),
            Object.defineProperties(e, i(t))
          );
        }),
          (e.promisify.custom = x),
          (e.callbackify = function (t) {
            if ("function" != typeof t)
              throw new TypeError(
                'The "original" argument must be of type Function',
              );
            function e() {
              for (var e = [], r = 0; r < arguments.length; r++)
                e.push(arguments[r]);
              var i = e.pop();
              if ("function" != typeof i)
                throw new TypeError(
                  "The last argument must be of type Function",
                );
              var o = this,
                s = function () {
                  return i.apply(o, arguments);
                };
              t.apply(this, e).then(
                function (t) {
                  n.nextTick(s.bind(null, null, t));
                },
                function (t) {
                  n.nextTick(P.bind(null, t, s));
                },
              );
            }
            return (
              Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
              Object.defineProperties(e, i(t)),
              e
            );
          });
      },
      10611: (t, e, r) => {
        "use strict";
        var n;
        r.r(e),
          r.d(e, {
            NIL: () => B,
            parse: () => g,
            stringify: () => f,
            v1: () => y,
            v3: () => A,
            v4: () => T,
            v5: () => P,
            validate: () => a,
            version: () => C,
          });
        var i = new Uint8Array(16);
        function o() {
          if (
            !n &&
            !(n =
              ("undefined" != typeof crypto &&
                crypto.getRandomValues &&
                crypto.getRandomValues.bind(crypto)) ||
              ("undefined" != typeof msCrypto &&
                "function" == typeof msCrypto.getRandomValues &&
                msCrypto.getRandomValues.bind(msCrypto)))
          )
            throw new Error(
              "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
            );
          return n(i);
        }
        const s =
          /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        const a = function (t) {
          return "string" == typeof t && s.test(t);
        };
        for (var u = [], c = 0; c < 256; ++c)
          u.push((c + 256).toString(16).substr(1));
        const f = function (t) {
          var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
            r = (
              u[t[e + 0]] +
              u[t[e + 1]] +
              u[t[e + 2]] +
              u[t[e + 3]] +
              "-" +
              u[t[e + 4]] +
              u[t[e + 5]] +
              "-" +
              u[t[e + 6]] +
              u[t[e + 7]] +
              "-" +
              u[t[e + 8]] +
              u[t[e + 9]] +
              "-" +
              u[t[e + 10]] +
              u[t[e + 11]] +
              u[t[e + 12]] +
              u[t[e + 13]] +
              u[t[e + 14]] +
              u[t[e + 15]]
            ).toLowerCase();
          if (!a(r)) throw TypeError("Stringified UUID is invalid");
          return r;
        };
        var h,
          l,
          d = 0,
          p = 0;
        const y = function (t, e, r) {
          var n = (e && r) || 0,
            i = e || new Array(16),
            s = (t = t || {}).node || h,
            a = void 0 !== t.clockseq ? t.clockseq : l;
          if (null == s || null == a) {
            var u = t.random || (t.rng || o)();
            null == s && (s = h = [1 | u[0], u[1], u[2], u[3], u[4], u[5]]),
              null == a && (a = l = 16383 & ((u[6] << 8) | u[7]));
          }
          var c = void 0 !== t.msecs ? t.msecs : Date.now(),
            y = void 0 !== t.nsecs ? t.nsecs : p + 1,
            g = c - d + (y - p) / 1e4;
          if (
            (g < 0 && void 0 === t.clockseq && (a = (a + 1) & 16383),
            (g < 0 || c > d) && void 0 === t.nsecs && (y = 0),
            y >= 1e4)
          )
            throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
          (d = c), (p = y), (l = a);
          var m = (1e4 * (268435455 & (c += 122192928e5)) + y) % 4294967296;
          (i[n++] = (m >>> 24) & 255),
            (i[n++] = (m >>> 16) & 255),
            (i[n++] = (m >>> 8) & 255),
            (i[n++] = 255 & m);
          var b = ((c / 4294967296) * 1e4) & 268435455;
          (i[n++] = (b >>> 8) & 255),
            (i[n++] = 255 & b),
            (i[n++] = ((b >>> 24) & 15) | 16),
            (i[n++] = (b >>> 16) & 255),
            (i[n++] = (a >>> 8) | 128),
            (i[n++] = 255 & a);
          for (var w = 0; w < 6; ++w) i[n + w] = s[w];
          return e || f(i);
        };
        const g = function (t) {
          if (!a(t)) throw TypeError("Invalid UUID");
          var e,
            r = new Uint8Array(16);
          return (
            (r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24),
            (r[1] = (e >>> 16) & 255),
            (r[2] = (e >>> 8) & 255),
            (r[3] = 255 & e),
            (r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8),
            (r[5] = 255 & e),
            (r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8),
            (r[7] = 255 & e),
            (r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8),
            (r[9] = 255 & e),
            (r[10] =
              ((e = parseInt(t.slice(24, 36), 16)) / 1099511627776) & 255),
            (r[11] = (e / 4294967296) & 255),
            (r[12] = (e >>> 24) & 255),
            (r[13] = (e >>> 16) & 255),
            (r[14] = (e >>> 8) & 255),
            (r[15] = 255 & e),
            r
          );
        };
        function m(t, e, r) {
          function n(t, n, i, o) {
            if (
              ("string" == typeof t &&
                (t = (function (t) {
                  t = unescape(encodeURIComponent(t));
                  for (var e = [], r = 0; r < t.length; ++r)
                    e.push(t.charCodeAt(r));
                  return e;
                })(t)),
              "string" == typeof n && (n = g(n)),
              16 !== n.length)
            )
              throw TypeError(
                "Namespace must be array-like (16 iterable integer values, 0-255)",
              );
            var s = new Uint8Array(16 + t.length);
            if (
              (s.set(n),
              s.set(t, n.length),
              ((s = r(s))[6] = (15 & s[6]) | e),
              (s[8] = (63 & s[8]) | 128),
              i)
            ) {
              o = o || 0;
              for (var a = 0; a < 16; ++a) i[o + a] = s[a];
              return i;
            }
            return f(s);
          }
          try {
            n.name = t;
          } catch (t) {}
          return (
            (n.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
            (n.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"),
            n
          );
        }
        function b(t) {
          return 14 + (((t + 64) >>> 9) << 4) + 1;
        }
        function w(t, e) {
          var r = (65535 & t) + (65535 & e);
          return (((t >> 16) + (e >> 16) + (r >> 16)) << 16) | (65535 & r);
        }
        function v(t, e, r, n, i, o) {
          return w(
            ((s = w(w(e, t), w(n, o))) << (a = i)) | (s >>> (32 - a)),
            r,
          );
          var s, a;
        }
        function _(t, e, r, n, i, o, s) {
          return v((e & r) | (~e & n), t, e, i, o, s);
        }
        function E(t, e, r, n, i, o, s) {
          return v((e & n) | (r & ~n), t, e, i, o, s);
        }
        function S(t, e, r, n, i, o, s) {
          return v(e ^ r ^ n, t, e, i, o, s);
        }
        function I(t, e, r, n, i, o, s) {
          return v(r ^ (e | ~n), t, e, i, o, s);
        }
        const M = function (t) {
          if ("string" == typeof t) {
            var e = unescape(encodeURIComponent(t));
            t = new Uint8Array(e.length);
            for (var r = 0; r < e.length; ++r) t[r] = e.charCodeAt(r);
          }
          return (function (t) {
            for (
              var e = [], r = 32 * t.length, n = "0123456789abcdef", i = 0;
              i < r;
              i += 8
            ) {
              var o = (t[i >> 5] >>> i % 32) & 255,
                s = parseInt(n.charAt((o >>> 4) & 15) + n.charAt(15 & o), 16);
              e.push(s);
            }
            return e;
          })(
            (function (t, e) {
              (t[e >> 5] |= 128 << e % 32), (t[b(e) - 1] = e);
              for (
                var r = 1732584193,
                  n = -271733879,
                  i = -1732584194,
                  o = 271733878,
                  s = 0;
                s < t.length;
                s += 16
              ) {
                var a = r,
                  u = n,
                  c = i,
                  f = o;
                (r = _(r, n, i, o, t[s], 7, -680876936)),
                  (o = _(o, r, n, i, t[s + 1], 12, -389564586)),
                  (i = _(i, o, r, n, t[s + 2], 17, 606105819)),
                  (n = _(n, i, o, r, t[s + 3], 22, -1044525330)),
                  (r = _(r, n, i, o, t[s + 4], 7, -176418897)),
                  (o = _(o, r, n, i, t[s + 5], 12, 1200080426)),
                  (i = _(i, o, r, n, t[s + 6], 17, -1473231341)),
                  (n = _(n, i, o, r, t[s + 7], 22, -45705983)),
                  (r = _(r, n, i, o, t[s + 8], 7, 1770035416)),
                  (o = _(o, r, n, i, t[s + 9], 12, -1958414417)),
                  (i = _(i, o, r, n, t[s + 10], 17, -42063)),
                  (n = _(n, i, o, r, t[s + 11], 22, -1990404162)),
                  (r = _(r, n, i, o, t[s + 12], 7, 1804603682)),
                  (o = _(o, r, n, i, t[s + 13], 12, -40341101)),
                  (i = _(i, o, r, n, t[s + 14], 17, -1502002290)),
                  (r = E(
                    r,
                    (n = _(n, i, o, r, t[s + 15], 22, 1236535329)),
                    i,
                    o,
                    t[s + 1],
                    5,
                    -165796510,
                  )),
                  (o = E(o, r, n, i, t[s + 6], 9, -1069501632)),
                  (i = E(i, o, r, n, t[s + 11], 14, 643717713)),
                  (n = E(n, i, o, r, t[s], 20, -373897302)),
                  (r = E(r, n, i, o, t[s + 5], 5, -701558691)),
                  (o = E(o, r, n, i, t[s + 10], 9, 38016083)),
                  (i = E(i, o, r, n, t[s + 15], 14, -660478335)),
                  (n = E(n, i, o, r, t[s + 4], 20, -405537848)),
                  (r = E(r, n, i, o, t[s + 9], 5, 568446438)),
                  (o = E(o, r, n, i, t[s + 14], 9, -1019803690)),
                  (i = E(i, o, r, n, t[s + 3], 14, -187363961)),
                  (n = E(n, i, o, r, t[s + 8], 20, 1163531501)),
                  (r = E(r, n, i, o, t[s + 13], 5, -1444681467)),
                  (o = E(o, r, n, i, t[s + 2], 9, -51403784)),
                  (i = E(i, o, r, n, t[s + 7], 14, 1735328473)),
                  (r = S(
                    r,
                    (n = E(n, i, o, r, t[s + 12], 20, -1926607734)),
                    i,
                    o,
                    t[s + 5],
                    4,
                    -378558,
                  )),
                  (o = S(o, r, n, i, t[s + 8], 11, -2022574463)),
                  (i = S(i, o, r, n, t[s + 11], 16, 1839030562)),
                  (n = S(n, i, o, r, t[s + 14], 23, -35309556)),
                  (r = S(r, n, i, o, t[s + 1], 4, -1530992060)),
                  (o = S(o, r, n, i, t[s + 4], 11, 1272893353)),
                  (i = S(i, o, r, n, t[s + 7], 16, -155497632)),
                  (n = S(n, i, o, r, t[s + 10], 23, -1094730640)),
                  (r = S(r, n, i, o, t[s + 13], 4, 681279174)),
                  (o = S(o, r, n, i, t[s], 11, -358537222)),
                  (i = S(i, o, r, n, t[s + 3], 16, -722521979)),
                  (n = S(n, i, o, r, t[s + 6], 23, 76029189)),
                  (r = S(r, n, i, o, t[s + 9], 4, -640364487)),
                  (o = S(o, r, n, i, t[s + 12], 11, -421815835)),
                  (i = S(i, o, r, n, t[s + 15], 16, 530742520)),
                  (r = I(
                    r,
                    (n = S(n, i, o, r, t[s + 2], 23, -995338651)),
                    i,
                    o,
                    t[s],
                    6,
                    -198630844,
                  )),
                  (o = I(o, r, n, i, t[s + 7], 10, 1126891415)),
                  (i = I(i, o, r, n, t[s + 14], 15, -1416354905)),
                  (n = I(n, i, o, r, t[s + 5], 21, -57434055)),
                  (r = I(r, n, i, o, t[s + 12], 6, 1700485571)),
                  (o = I(o, r, n, i, t[s + 3], 10, -1894986606)),
                  (i = I(i, o, r, n, t[s + 10], 15, -1051523)),
                  (n = I(n, i, o, r, t[s + 1], 21, -2054922799)),
                  (r = I(r, n, i, o, t[s + 8], 6, 1873313359)),
                  (o = I(o, r, n, i, t[s + 15], 10, -30611744)),
                  (i = I(i, o, r, n, t[s + 6], 15, -1560198380)),
                  (n = I(n, i, o, r, t[s + 13], 21, 1309151649)),
                  (r = I(r, n, i, o, t[s + 4], 6, -145523070)),
                  (o = I(o, r, n, i, t[s + 11], 10, -1120210379)),
                  (i = I(i, o, r, n, t[s + 2], 15, 718787259)),
                  (n = I(n, i, o, r, t[s + 9], 21, -343485551)),
                  (r = w(r, a)),
                  (n = w(n, u)),
                  (i = w(i, c)),
                  (o = w(o, f));
              }
              return [r, n, i, o];
            })(
              (function (t) {
                if (0 === t.length) return [];
                for (
                  var e = 8 * t.length, r = new Uint32Array(b(e)), n = 0;
                  n < e;
                  n += 8
                )
                  r[n >> 5] |= (255 & t[n / 8]) << n % 32;
                return r;
              })(t),
              8 * t.length,
            ),
          );
        };
        const A = m("v3", 48, M);
        const T = function (t, e, r) {
          var n = (t = t || {}).random || (t.rng || o)();
          if (((n[6] = (15 & n[6]) | 64), (n[8] = (63 & n[8]) | 128), e)) {
            r = r || 0;
            for (var i = 0; i < 16; ++i) e[r + i] = n[i];
            return e;
          }
          return f(n);
        };
        function k(t, e, r, n) {
          switch (t) {
            case 0:
              return (e & r) ^ (~e & n);
            case 1:
            case 3:
              return e ^ r ^ n;
            case 2:
              return (e & r) ^ (e & n) ^ (r & n);
          }
        }
        function O(t, e) {
          return (t << e) | (t >>> (32 - e));
        }
        const x = function (t) {
          var e = [1518500249, 1859775393, 2400959708, 3395469782],
            r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
          if ("string" == typeof t) {
            var n = unescape(encodeURIComponent(t));
            t = [];
            for (var i = 0; i < n.length; ++i) t.push(n.charCodeAt(i));
          } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
          t.push(128);
          for (
            var o = t.length / 4 + 2,
              s = Math.ceil(o / 16),
              a = new Array(s),
              u = 0;
            u < s;
            ++u
          ) {
            for (var c = new Uint32Array(16), f = 0; f < 16; ++f)
              c[f] =
                (t[64 * u + 4 * f] << 24) |
                (t[64 * u + 4 * f + 1] << 16) |
                (t[64 * u + 4 * f + 2] << 8) |
                t[64 * u + 4 * f + 3];
            a[u] = c;
          }
          (a[s - 1][14] = (8 * (t.length - 1)) / Math.pow(2, 32)),
            (a[s - 1][14] = Math.floor(a[s - 1][14])),
            (a[s - 1][15] = (8 * (t.length - 1)) & 4294967295);
          for (var h = 0; h < s; ++h) {
            for (var l = new Uint32Array(80), d = 0; d < 16; ++d)
              l[d] = a[h][d];
            for (var p = 16; p < 80; ++p)
              l[p] = O(l[p - 3] ^ l[p - 8] ^ l[p - 14] ^ l[p - 16], 1);
            for (
              var y = r[0], g = r[1], m = r[2], b = r[3], w = r[4], v = 0;
              v < 80;
              ++v
            ) {
              var _ = Math.floor(v / 20),
                E = (O(y, 5) + k(_, g, m, b) + w + e[_] + l[v]) >>> 0;
              (w = b), (b = m), (m = O(g, 30) >>> 0), (g = y), (y = E);
            }
            (r[0] = (r[0] + y) >>> 0),
              (r[1] = (r[1] + g) >>> 0),
              (r[2] = (r[2] + m) >>> 0),
              (r[3] = (r[3] + b) >>> 0),
              (r[4] = (r[4] + w) >>> 0);
          }
          return [
            (r[0] >> 24) & 255,
            (r[0] >> 16) & 255,
            (r[0] >> 8) & 255,
            255 & r[0],
            (r[1] >> 24) & 255,
            (r[1] >> 16) & 255,
            (r[1] >> 8) & 255,
            255 & r[1],
            (r[2] >> 24) & 255,
            (r[2] >> 16) & 255,
            (r[2] >> 8) & 255,
            255 & r[2],
            (r[3] >> 24) & 255,
            (r[3] >> 16) & 255,
            (r[3] >> 8) & 255,
            255 & r[3],
            (r[4] >> 24) & 255,
            (r[4] >> 16) & 255,
            (r[4] >> 8) & 255,
            255 & r[4],
          ];
        };
        const P = m("v5", 80, x),
          B = "00000000-0000-0000-0000-000000000000";
        const C = function (t) {
          if (!a(t)) throw TypeError("Invalid UUID");
          return parseInt(t.substr(14, 1), 16);
        };
      },
      68469: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer;
        function i(t) {
          if (t < 0 || t > 9007199254740991 || t % 1 != 0)
            throw new RangeError("value out of range");
        }
        function o(t) {
          return i(t), t < 253 ? 1 : t <= 65535 ? 3 : t <= 4294967295 ? 5 : 9;
        }
        t.exports = {
          encode: function t(e, r, s) {
            if ((i(e), r || (r = n.allocUnsafe(o(e))), !n.isBuffer(r)))
              throw new TypeError("buffer must be a Buffer instance");
            return (
              s || (s = 0),
              e < 253
                ? (r.writeUInt8(e, s), (t.bytes = 1))
                : e <= 65535
                  ? (r.writeUInt8(253, s),
                    r.writeUInt16LE(e, s + 1),
                    (t.bytes = 3))
                  : e <= 4294967295
                    ? (r.writeUInt8(254, s),
                      r.writeUInt32LE(e, s + 1),
                      (t.bytes = 5))
                    : (r.writeUInt8(255, s),
                      r.writeUInt32LE(e >>> 0, s + 1),
                      r.writeUInt32LE((e / 4294967296) | 0, s + 5),
                      (t.bytes = 9)),
              r
            );
          },
          decode: function t(e, r) {
            if (!n.isBuffer(e))
              throw new TypeError("buffer must be a Buffer instance");
            r || (r = 0);
            var o = e.readUInt8(r);
            if (o < 253) return (t.bytes = 1), o;
            if (253 === o) return (t.bytes = 3), e.readUInt16LE(r + 1);
            if (254 === o) return (t.bytes = 5), e.readUInt32LE(r + 1);
            t.bytes = 9;
            var s = e.readUInt32LE(r + 1),
              a = 4294967296 * e.readUInt32LE(r + 5) + s;
            return i(a), a;
          },
          encodingLength: o,
        };
      },
      25767: (t, e, r) => {
        "use strict";
        var n = r(82682),
          i = r(39209),
          o = r(10487),
          s = r(38075),
          a = r(75795),
          u = s("Object.prototype.toString"),
          c = r(49092)(),
          f = "undefined" == typeof globalThis ? r.g : globalThis,
          h = i(),
          l = s("String.prototype.slice"),
          d = Object.getPrototypeOf,
          p =
            s("Array.prototype.indexOf", !0) ||
            function (t, e) {
              for (var r = 0; r < t.length; r += 1) if (t[r] === e) return r;
              return -1;
            },
          y = { __proto__: null };
        n(
          h,
          c && a && d
            ? function (t) {
                var e = new f[t]();
                if (Symbol.toStringTag in e) {
                  var r = d(e),
                    n = a(r, Symbol.toStringTag);
                  if (!n) {
                    var i = d(r);
                    n = a(i, Symbol.toStringTag);
                  }
                  y["$" + t] = o(n.get);
                }
              }
            : function (t) {
                var e = new f[t]();
                y["$" + t] = o(e.slice);
              },
        );
        t.exports = function (t) {
          if (!t || "object" != typeof t) return !1;
          if (!c) {
            var e = l(u(t), 8, -1);
            return p(h, e) > -1
              ? e
              : "Object" === e &&
                  (function (t) {
                    var e = !1;
                    return (
                      n(y, function (r, n) {
                        if (!e)
                          try {
                            r(t), (e = l(n, 1));
                          } catch (t) {}
                      }),
                      e
                    );
                  })(t);
          }
          return a
            ? (function (t) {
                var e = !1;
                return (
                  n(y, function (r, n) {
                    if (!e)
                      try {
                        "$" + r(t) === n && (e = l(n, 1));
                      } catch (t) {}
                  }),
                  e
                );
              })(t)
            : null;
        };
      },
      57513: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(91889);
        function o(t, e) {
          if (void 0 !== e && t[0] !== e)
            throw new Error("Invalid network version");
          if (33 === t.length)
            return {
              version: t[0],
              privateKey: t.slice(1, 33),
              compressed: !1,
            };
          if (34 !== t.length) throw new Error("Invalid WIF length");
          if (1 !== t[33]) throw new Error("Invalid compression flag");
          return { version: t[0], privateKey: t.slice(1, 33), compressed: !0 };
        }
        function s(t, e, r) {
          var i = new n(r ? 34 : 33);
          return i.writeUInt8(t, 0), e.copy(i, 1), r && (i[33] = 1), i;
        }
        t.exports = {
          decode: function (t, e) {
            return o(i.decode(t), e);
          },
          decodeRaw: o,
          encode: function (t, e, r) {
            return "number" == typeof t
              ? i.encode(s(t, e, r))
              : i.encode(s(t.version, t.privateKey, t.compressed));
          },
          encodeRaw: s,
        };
      },
      70495: () => {},
      14923: () => {},
      78982: () => {},
      47790: () => {},
      73776: () => {},
      77965: () => {},
      66089: () => {},
      79368: () => {},
      32632: () => {},
      64688: () => {},
      51069: () => {},
      15340: () => {},
      79838: () => {},
      68289: () => {},
      87648: () => {},
      25870: () => {},
      96395: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.default = function (t) {
            if (t.length >= 255) throw new TypeError("Alphabet too long");
            const e = new Uint8Array(256);
            for (let t = 0; t < e.length; t++) e[t] = 255;
            for (let r = 0; r < t.length; r++) {
              const n = t.charAt(r),
                i = n.charCodeAt(0);
              if (255 !== e[i]) throw new TypeError(n + " is ambiguous");
              e[i] = r;
            }
            const r = t.length,
              n = t.charAt(0),
              i = Math.log(r) / Math.log(256),
              o = Math.log(256) / Math.log(r);
            function s(t) {
              if ("string" != typeof t) throw new TypeError("Expected String");
              if (0 === t.length) return new Uint8Array();
              let o = 0,
                s = 0,
                a = 0;
              for (; t[o] === n; ) s++, o++;
              const u = ((t.length - o) * i + 1) >>> 0,
                c = new Uint8Array(u);
              for (; t[o]; ) {
                let n = e[t.charCodeAt(o)];
                if (255 === n) return;
                let i = 0;
                for (let t = u - 1; (0 !== n || i < a) && -1 !== t; t--, i++)
                  (n += (r * c[t]) >>> 0),
                    (c[t] = n % 256 >>> 0),
                    (n = (n / 256) >>> 0);
                if (0 !== n) throw new Error("Non-zero carry");
                (a = i), o++;
              }
              let f = u - a;
              for (; f !== u && 0 === c[f]; ) f++;
              const h = new Uint8Array(s + (u - f));
              let l = s;
              for (; f !== u; ) h[l++] = c[f++];
              return h;
            }
            return {
              encode: function (e) {
                if (
                  (e instanceof Uint8Array ||
                    (ArrayBuffer.isView(e)
                      ? (e = new Uint8Array(
                          e.buffer,
                          e.byteOffset,
                          e.byteLength,
                        ))
                      : Array.isArray(e) && (e = Uint8Array.from(e))),
                  !(e instanceof Uint8Array))
                )
                  throw new TypeError("Expected Uint8Array");
                if (0 === e.length) return "";
                let i = 0,
                  s = 0,
                  a = 0;
                const u = e.length;
                for (; a !== u && 0 === e[a]; ) a++, i++;
                const c = ((u - a) * o + 1) >>> 0,
                  f = new Uint8Array(c);
                for (; a !== u; ) {
                  let t = e[a],
                    n = 0;
                  for (let e = c - 1; (0 !== t || n < s) && -1 !== e; e--, n++)
                    (t += (256 * f[e]) >>> 0),
                      (f[e] = t % r >>> 0),
                      (t = (t / r) >>> 0);
                  if (0 !== t) throw new Error("Non-zero carry");
                  (s = n), a++;
                }
                let h = c - s;
                for (; h !== c && 0 === f[h]; ) h++;
                let l = n.repeat(i);
                for (; h < c; ++h) l += t.charAt(f[h]);
                return l;
              },
              decodeUnsafe: s,
              decode: function (t) {
                const e = s(t);
                if (e) return e;
                throw new Error("Non-base" + r + " character");
              },
            };
          });
      },
      36746: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(19092),
          o = n(r(22333));
        function s(t, e, r) {
          return (n) => {
            if (t.has(n)) return;
            const i = r.filter((t) => o.toHex(t.key) === n)[0];
            e.push(i), t.add(n);
          };
        }
        function a(t) {
          return t.globalMap.unsignedTx;
        }
        function u(t) {
          const e = new Set();
          return (
            t.forEach((t) => {
              const r = o.toHex(t.key);
              if (e.has(r))
                throw new Error("Combine: KeyValue Map keys should be unique");
              e.add(r);
            }),
            e
          );
        }
        e.combine = function (t) {
          const e = t[0],
            r = i.psbtToKeyVals(e),
            n = t.slice(1);
          if (0 === n.length) throw new Error("Combine: Nothing to combine");
          const c = a(e);
          if (void 0 === c)
            throw new Error("Combine: Self missing transaction");
          const f = u(r.globalKeyVals),
            h = r.inputKeyVals.map(u),
            l = r.outputKeyVals.map(u);
          for (const t of n) {
            const e = a(t);
            if (void 0 === e || 0 !== o.compare(e.toBuffer(), c.toBuffer()))
              throw new Error(
                "Combine: One of the Psbts does not have the same transaction.",
              );
            const n = i.psbtToKeyVals(t);
            u(n.globalKeyVals).forEach(s(f, r.globalKeyVals, n.globalKeyVals));
            n.inputKeyVals
              .map(u)
              .forEach((t, e) =>
                t.forEach(s(h[e], r.inputKeyVals[e], n.inputKeyVals[e])),
              );
            n.outputKeyVals
              .map(u)
              .forEach((t, e) =>
                t.forEach(s(l[e], r.outputKeyVals[e], n.outputKeyVals[e])),
              );
          }
          return i.psbtFromKeyVals(c, {
            globalMapKeyVals: r.globalKeyVals,
            inputKeyVals: r.inputKeyVals,
            outputKeyVals: r.outputKeyVals,
          });
        };
      },
      74673: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.GlobalTypes.GLOBAL_XPUB)
            throw new Error(
              "Decode Error: could not decode globalXpub with key 0x" +
                o.toHex(t.key),
            );
          if (79 !== t.key.length || ![2, 3].includes(t.key[46]))
            throw new Error(
              "Decode Error: globalXpub has invalid extended pubkey in key 0x" +
                o.toHex(t.key),
            );
          if ((t.value.length / 4) % 1 != 0)
            throw new Error(
              "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4",
            );
          const e = t.key.slice(1),
            r = {
              masterFingerprint: t.value.slice(0, 4),
              extendedPubkey: e,
              path: "m",
            };
          for (const e of ((n = t.value.length / 4 - 1),
          [...Array(n).keys()])) {
            const n = o.readUInt32(t.value, 4 * e + 4, "LE"),
              i = !!(2147483648 & n),
              s = 2147483647 & n;
            r.path += "/" + s.toString(10) + (i ? "'" : "");
          }
          var n;
          return r;
        }),
          (e.encode = function (t) {
            const e = new Uint8Array([i.GlobalTypes.GLOBAL_XPUB]),
              r = o.concat([e, t.extendedPubkey]),
              n = t.path.split("/"),
              s = new Uint8Array(4 * n.length);
            s.set(t.masterFingerprint, 0);
            let a = 4;
            return (
              n.slice(1).forEach((t) => {
                const e = "'" === t.slice(-1);
                let r = 2147483647 & parseInt(e ? t.slice(0, -1) : t, 10);
                e && (r += 2147483648), o.writeUInt32(s, a, r, "LE"), (a += 4);
              }),
              { key: r, value: s }
            );
          }),
          (e.expected =
            "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }"),
          (e.check = function (t) {
            const e = t.extendedPubkey,
              r = t.masterFingerprint,
              n = t.path;
            return (
              e instanceof Uint8Array &&
              78 === e.length &&
              [2, 3].indexOf(e[45]) > -1 &&
              r instanceof Uint8Array &&
              4 === r.length &&
              "string" == typeof n &&
              !!n.match(/^m(\/\d+'?)*$/)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = o.toHex(e.extendedPubkey);
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter((t) => o.compare(t.extendedPubkey, e.extendedPubkey))
                  .length)
            );
          });
      },
      94564: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const n = r(48143);
        e.encode = function (t) {
          return {
            key: new Uint8Array([n.GlobalTypes.UNSIGNED_TX]),
            value: t.toBuffer(),
          };
        };
      },
      79821: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(74673)),
          s = n(r(94564)),
          a = n(r(41396)),
          u = n(r(91042)),
          c = n(r(53882)),
          f = n(r(40314)),
          h = n(r(11680)),
          l = n(r(72219)),
          d = n(r(84131)),
          p = n(r(96590)),
          y = n(r(37873)),
          g = n(r(60369)),
          m = n(r(49513)),
          b = n(r(81578)),
          w = n(r(40396)),
          v = n(r(51279)),
          _ = n(r(39678)),
          E = n(r(74571)),
          S = n(r(61274)),
          I = n(r(8117)),
          M = { unsignedTx: s, globalXpub: o, checkPubkey: v.makeChecker([]) };
        e.globals = M;
        const A = {
          nonWitnessUtxo: c,
          partialSig: f,
          sighashType: l,
          finalScriptSig: a,
          finalScriptWitness: u,
          porCommitment: h,
          witnessUtxo: m,
          bip32Derivation: w.makeConverter(i.InputTypes.BIP32_DERIVATION),
          redeemScript: _.makeConverter(i.InputTypes.REDEEM_SCRIPT),
          witnessScript: I.makeConverter(i.InputTypes.WITNESS_SCRIPT),
          checkPubkey: v.makeChecker([
            i.InputTypes.PARTIAL_SIG,
            i.InputTypes.BIP32_DERIVATION,
          ]),
          tapKeySig: d,
          tapScriptSig: g,
          tapLeafScript: p,
          tapBip32Derivation: E.makeConverter(
            i.InputTypes.TAP_BIP32_DERIVATION,
          ),
          tapInternalKey: S.makeConverter(i.InputTypes.TAP_INTERNAL_KEY),
          tapMerkleRoot: y,
        };
        e.inputs = A;
        const T = {
          bip32Derivation: w.makeConverter(i.OutputTypes.BIP32_DERIVATION),
          redeemScript: _.makeConverter(i.OutputTypes.REDEEM_SCRIPT),
          witnessScript: I.makeConverter(i.OutputTypes.WITNESS_SCRIPT),
          checkPubkey: v.makeChecker([i.OutputTypes.BIP32_DERIVATION]),
          tapBip32Derivation: E.makeConverter(
            i.OutputTypes.TAP_BIP32_DERIVATION,
          ),
          tapTree: b,
          tapInternalKey: S.makeConverter(i.OutputTypes.TAP_INTERNAL_KEY),
        };
        e.outputs = T;
      },
      41396: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.FINAL_SCRIPTSIG)
            throw new Error(
              "Decode Error: could not decode finalScriptSig with key 0x" +
                o.toHex(t.key),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: new Uint8Array([i.InputTypes.FINAL_SCRIPTSIG]),
              value: t,
            };
          }),
          (e.expected = "Uint8Array"),
          (e.check = function (t) {
            return t instanceof Uint8Array;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.finalScriptSig;
          });
      },
      91042: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.FINAL_SCRIPTWITNESS)
            throw new Error(
              "Decode Error: could not decode finalScriptWitness with key 0x" +
                o.toHex(t.key),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: new Uint8Array([i.InputTypes.FINAL_SCRIPTWITNESS]),
              value: t,
            };
          }),
          (e.expected = "Uint8Array"),
          (e.check = function (t) {
            return t instanceof Uint8Array;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.finalScriptWitness;
          });
      },
      53882: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.NON_WITNESS_UTXO)
            throw new Error(
              "Decode Error: could not decode nonWitnessUtxo with key 0x" +
                o.toHex(t.key),
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: new Uint8Array([i.InputTypes.NON_WITNESS_UTXO]),
              value: t,
            };
          }),
          (e.expected = "Uint8Array"),
          (e.check = function (t) {
            return t instanceof Uint8Array;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.nonWitnessUtxo;
          });
      },
      40314: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.PARTIAL_SIG)
            throw new Error(
              "Decode Error: could not decode partialSig with key 0x" +
                o.toHex(t.key),
            );
          if (
            (34 !== t.key.length && 66 !== t.key.length) ||
            ![2, 3, 4].includes(t.key[1])
          )
            throw new Error(
              "Decode Error: partialSig has invalid pubkey in key 0x" +
                o.toHex(t.key),
            );
          return { pubkey: t.key.slice(1), signature: t.value };
        }),
          (e.encode = function (t) {
            const e = new Uint8Array([i.InputTypes.PARTIAL_SIG]);
            return { key: o.concat([e, t.pubkey]), value: t.signature };
          }),
          (e.expected = "{ pubkey: Uint8Array; signature: Uint8Array; }"),
          (e.check = function (t) {
            return (
              t.pubkey instanceof Uint8Array &&
              t.signature instanceof Uint8Array &&
              [33, 65].includes(t.pubkey.length) &&
              [2, 3, 4].includes(t.pubkey[0]) &&
              (function (t) {
                if (!(t instanceof Uint8Array) || t.length < 9) return !1;
                if (48 !== t[0]) return !1;
                if (t.length !== t[1] + 3) return !1;
                if (2 !== t[2]) return !1;
                const e = t[3];
                if (e > 33 || e < 1) return !1;
                if (2 !== t[3 + e + 1]) return !1;
                const r = t[3 + e + 2];
                return !(r > 33 || r < 1) && t.length === 3 + e + 2 + r + 2;
              })(t.signature)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = o.toHex(e.pubkey);
            return (
              !r.has(n) &&
              (r.add(n),
              0 === t.filter((t) => 0 === o.compare(t.pubkey, e.pubkey)).length)
            );
          });
      },
      11680: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.POR_COMMITMENT)
            throw new Error(
              "Decode Error: could not decode porCommitment with key 0x" +
                o.toHex(t.key),
            );
          return o.toUtf8(t.value);
        }),
          (e.encode = function (t) {
            return {
              key: new Uint8Array([i.InputTypes.POR_COMMITMENT]),
              value: o.fromUtf8(t),
            };
          }),
          (e.expected = "string"),
          (e.check = function (t) {
            return "string" == typeof t;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.porCommitment;
          });
      },
      72219: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.SIGHASH_TYPE)
            throw new Error(
              "Decode Error: could not decode sighashType with key 0x" +
                o.toHex(t.key),
            );
          return Number(o.readUInt32(t.value, 0, "LE"));
        }),
          (e.encode = function (t) {
            const e = Uint8Array.from([i.InputTypes.SIGHASH_TYPE]),
              r = new Uint8Array(4);
            return o.writeUInt32(r, 0, t, "LE"), { key: e, value: r };
          }),
          (e.expected = "number"),
          (e.check = function (t) {
            return "number" == typeof t;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.sighashType;
          });
      },
      84131: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        function s(t) {
          return (
            t instanceof Uint8Array && (64 === t.length || 65 === t.length)
          );
        }
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_KEY_SIG || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapKeySig with key 0x" +
                o.toHex(t.key),
            );
          if (!s(t.value))
            throw new Error(
              "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature",
            );
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: Uint8Array.from([i.InputTypes.TAP_KEY_SIG]),
              value: t,
            };
          }),
          (e.expected = "Uint8Array"),
          (e.check = s),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapKeySig;
          });
      },
      96590: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_LEAF_SCRIPT)
            throw new Error(
              "Decode Error: could not decode tapLeafScript with key 0x" +
                o.toHex(t.key),
            );
          if ((t.key.length - 2) % 32 != 0)
            throw new Error(
              "Decode Error: tapLeafScript has invalid control block in key 0x" +
                o.toHex(t.key),
            );
          const e = t.value[t.value.length - 1];
          if ((254 & t.key[1]) !== e)
            throw new Error(
              "Decode Error: tapLeafScript bad leaf version in key 0x" +
                o.toHex(t.key),
            );
          const r = t.value.slice(0, -1);
          return { controlBlock: t.key.slice(1), script: r, leafVersion: e };
        }),
          (e.encode = function (t) {
            const e = Uint8Array.from([i.InputTypes.TAP_LEAF_SCRIPT]),
              r = Uint8Array.from([t.leafVersion]);
            return {
              key: o.concat([e, t.controlBlock]),
              value: o.concat([t.script, r]),
            };
          }),
          (e.expected =
            "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }"),
          (e.check = function (t) {
            return (
              t.controlBlock instanceof Uint8Array &&
              (t.controlBlock.length - 1) % 32 == 0 &&
              (254 & t.controlBlock[0]) === t.leafVersion &&
              t.script instanceof Uint8Array
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = o.toHex(e.controlBlock);
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter((t) => 0 === o.compare(t.controlBlock, e.controlBlock))
                  .length)
            );
          });
      },
      37873: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        function s(t) {
          return t instanceof Uint8Array && 32 === t.length;
        }
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_MERKLE_ROOT || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapMerkleRoot with key 0x" +
                o.toHex(t.key),
            );
          if (!s(t.value))
            throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
          return t.value;
        }),
          (e.encode = function (t) {
            return {
              key: Uint8Array.from([i.InputTypes.TAP_MERKLE_ROOT]),
              value: t,
            };
          }),
          (e.expected = "Uint8Array"),
          (e.check = s),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapMerkleRoot;
          });
      },
      60369: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.TAP_SCRIPT_SIG)
            throw new Error(
              "Decode Error: could not decode tapScriptSig with key 0x" +
                o.toHex(t.key),
            );
          if (65 !== t.key.length)
            throw new Error(
              "Decode Error: tapScriptSig has invalid key 0x" + o.toHex(t.key),
            );
          if (64 !== t.value.length && 65 !== t.value.length)
            throw new Error(
              "Decode Error: tapScriptSig has invalid signature in key 0x" +
                o.toHex(t.key),
            );
          return {
            pubkey: t.key.slice(1, 33),
            leafHash: t.key.slice(33),
            signature: t.value,
          };
        }),
          (e.encode = function (t) {
            const e = Uint8Array.from([i.InputTypes.TAP_SCRIPT_SIG]);
            return {
              key: o.concat([e, t.pubkey, t.leafHash]),
              value: t.signature,
            };
          }),
          (e.expected =
            "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }"),
          (e.check = function (t) {
            return (
              t.pubkey instanceof Uint8Array &&
              t.leafHash instanceof Uint8Array &&
              t.signature instanceof Uint8Array &&
              32 === t.pubkey.length &&
              32 === t.leafHash.length &&
              (64 === t.signature.length || 65 === t.signature.length)
            );
          }),
          (e.canAddToArray = function (t, e, r) {
            const n = o.toHex(e.pubkey) + o.toHex(e.leafHash);
            return (
              !r.has(n) &&
              (r.add(n),
              0 ===
                t.filter(
                  (t) =>
                    0 === o.compare(t.pubkey, e.pubkey) &&
                    0 === o.compare(t.leafHash, e.leafHash),
                ).length)
            );
          });
      },
      49513: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(22333)),
          s = n(r(60882));
        (e.decode = function (t) {
          if (t.key[0] !== i.InputTypes.WITNESS_UTXO)
            throw new Error(
              "Decode Error: could not decode witnessUtxo with key 0x" +
                o.toHex(t.key),
            );
          const e = o.readInt64(t.value, 0, "LE");
          let r = 8;
          const { numberValue: n, bytes: a } = s.decode(t.value, r);
          r += a;
          const u = t.value.slice(r);
          if (u.length !== n)
            throw new Error(
              "Decode Error: WITNESS_UTXO script is not proper length",
            );
          return { script: u, value: e };
        }),
          (e.encode = function (t) {
            const { script: e, value: r } = t,
              n = s.encodingLength(e.length),
              a = new Uint8Array(8 + n + e.length);
            return (
              o.writeInt64(a, 0, BigInt(r), "LE"),
              s.encode(e.length, a, 8),
              a.set(e, 8 + n),
              { key: Uint8Array.from([i.InputTypes.WITNESS_UTXO]), value: a }
            );
          }),
          (e.expected = "{ script: Uint8Array; value: bigint; }"),
          (e.check = function (t) {
            return t.script instanceof Uint8Array && "bigint" == typeof t.value;
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.witnessUtxo;
          });
      },
      81578: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(48143),
          o = n(r(60882)),
          s = n(r(22333));
        (e.decode = function (t) {
          if (t.key[0] !== i.OutputTypes.TAP_TREE || 1 !== t.key.length)
            throw new Error(
              "Decode Error: could not decode tapTree with key 0x" +
                s.toHex(t.key),
            );
          let e = 0;
          const r = [];
          for (; e < t.value.length; ) {
            const n = t.value[e++],
              i = t.value[e++],
              { numberValue: s, bytes: a } = o.decode(t.value, e);
            (e += a),
              r.push({
                depth: n,
                leafVersion: i,
                script: t.value.slice(e, e + s),
              }),
              (e += s);
          }
          return { leaves: r };
        }),
          (e.encode = function (t) {
            const e = Uint8Array.from([i.OutputTypes.TAP_TREE]),
              r = [].concat(
                ...t.leaves.map((t) => [
                  Uint8Array.of(t.depth, t.leafVersion),
                  o.encode(BigInt(t.script.length)).buffer,
                  t.script,
                ]),
              );
            return { key: e, value: s.concat(r) };
          }),
          (e.expected =
            "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }"),
          (e.check = function (t) {
            return (
              Array.isArray(t.leaves) &&
              t.leaves.every(
                (t) =>
                  t.depth >= 0 &&
                  t.depth <= 128 &&
                  (254 & t.leafVersion) === t.leafVersion &&
                  t.script instanceof Uint8Array,
              )
            );
          }),
          (e.canAdd = function (t, e) {
            return !!t && !!e && void 0 === t.tapTree;
          });
      },
      40396: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(22333)),
          o = (t) =>
            (33 === t.length && [2, 3].includes(t[0])) ||
            (65 === t.length && 4 === t[0]);
        e.makeConverter = function (t, e = o) {
          return {
            decode: function (r) {
              if (r.key[0] !== t)
                throw new Error(
                  "Decode Error: could not decode bip32Derivation with key 0x" +
                    i.toHex(r.key),
                );
              const n = r.key.slice(1);
              if (!e(n))
                throw new Error(
                  "Decode Error: bip32Derivation has invalid pubkey in key 0x" +
                    i.toHex(r.key),
                );
              if ((r.value.length / 4) % 1 != 0)
                throw new Error(
                  "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4",
                );
              const o = {
                masterFingerprint: r.value.slice(0, 4),
                pubkey: n,
                path: "m",
              };
              for (const t of ((s = r.value.length / 4 - 1),
              [...Array(s).keys()])) {
                const e = i.readUInt32(r.value, 4 * t + 4, "LE"),
                  n = !!(2147483648 & e),
                  s = 2147483647 & e;
                o.path += "/" + s.toString(10) + (n ? "'" : "");
              }
              var s;
              return o;
            },
            encode: function (e) {
              const r = Uint8Array.from([t]),
                n = i.concat([r, e.pubkey]),
                o = e.path.split("/"),
                s = new Uint8Array(4 * o.length);
              s.set(e.masterFingerprint, 0);
              let a = 4;
              return (
                o.slice(1).forEach((t) => {
                  const e = "'" === t.slice(-1);
                  let r = 2147483647 & parseInt(e ? t.slice(0, -1) : t, 10);
                  e && (r += 2147483648),
                    i.writeUInt32(s, a, r, "LE"),
                    (a += 4);
                }),
                { key: n, value: s }
              );
            },
            check: function (t) {
              return (
                t.pubkey instanceof Uint8Array &&
                t.masterFingerprint instanceof Uint8Array &&
                "string" == typeof t.path &&
                e(t.pubkey) &&
                4 === t.masterFingerprint.length
              );
            },
            expected:
              "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }",
            canAddToArray: function (t, e, r) {
              const n = i.toHex(e.pubkey);
              return (
                !r.has(n) &&
                (r.add(n),
                0 ===
                  t.filter((t) => 0 === i.compare(t.pubkey, e.pubkey)).length)
              );
            },
          };
        };
      },
      51279: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(22333));
        e.makeChecker = function (t) {
          return function (e) {
            let r;
            if (
              t.includes(e.key[0]) &&
              ((r = e.key.slice(1)),
              (33 !== r.length && 65 !== r.length) || ![2, 3, 4].includes(r[0]))
            )
              throw new Error(
                "Format Error: invalid pubkey in key 0x" + i.toHex(e.key),
              );
            return r;
          };
        };
      },
      39678: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(22333));
        e.makeConverter = function (t) {
          return {
            decode: function (e) {
              if (e.key[0] !== t)
                throw new Error(
                  "Decode Error: could not decode redeemScript with key 0x" +
                    i.toHex(e.key),
                );
              return e.value;
            },
            encode: function (e) {
              return { key: Uint8Array.from([t]), value: e };
            },
            check: function (t) {
              return t instanceof Uint8Array;
            },
            expected: "Uint8Array",
            canAdd: function (t, e) {
              return !!t && !!e && void 0 === t.redeemScript;
            },
          };
        };
      },
      74571: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(60882)),
          o = n(r(22333)),
          s = n(r(40396)),
          a = (t) => 32 === t.length;
        e.makeConverter = function (t) {
          const e = s.makeConverter(t, a);
          return {
            decode: function (t) {
              const { numberValue: r, bytes: n } = i.decode(t.value),
                o = e.decode({
                  key: t.key,
                  value: t.value.slice(n + 32 * Number(r)),
                }),
                s = new Array(Number(r));
              for (let e = 0, i = n; e < r; e++, i += 32)
                s[e] = t.value.slice(i, i + 32);
              return { ...o, leafHashes: s };
            },
            encode: function (t) {
              const r = e.encode(t),
                n = i.encodingLength(t.leafHashes.length),
                s = new Uint8Array(n);
              i.encode(t.leafHashes.length, s);
              const a = o.concat([s, ...t.leafHashes, r.value]);
              return { ...r, value: a };
            },
            check: function (t) {
              return (
                Array.isArray(t.leafHashes) &&
                t.leafHashes.every(
                  (t) => t instanceof Uint8Array && 32 === t.length,
                ) &&
                e.check(t)
              );
            },
            expected:
              "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }",
            canAddToArray: e.canAddToArray,
          };
        };
      },
      61274: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(22333));
        e.makeConverter = function (t) {
          return {
            decode: function (e) {
              if (e.key[0] !== t || 1 !== e.key.length)
                throw new Error(
                  "Decode Error: could not decode tapInternalKey with key 0x" +
                    i.toHex(e.key),
                );
              if (32 !== e.value.length)
                throw new Error(
                  "Decode Error: tapInternalKey not a 32-byte x-only pubkey",
                );
              return e.value;
            },
            encode: function (e) {
              return { key: Uint8Array.from([t]), value: e };
            },
            check: function (t) {
              return t instanceof Uint8Array && 32 === t.length;
            },
            expected: "Uint8Array",
            canAdd: function (t, e) {
              return !!t && !!e && void 0 === t.tapInternalKey;
            },
          };
        };
      },
      8117: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(22333));
        e.makeConverter = function (t) {
          return {
            decode: function (e) {
              if (e.key[0] !== t)
                throw new Error(
                  "Decode Error: could not decode witnessScript with key 0x" +
                    i.toHex(e.key),
                );
              return e.value;
            },
            encode: function (e) {
              return { key: Uint8Array.from([t]), value: e };
            },
            check: function (t) {
              return t instanceof Uint8Array;
            },
            expected: "Uint8Array",
            canAdd: function (t, e) {
              return !!t && !!e && void 0 === t.witnessScript;
            },
          };
        };
      },
      28672: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(60882)),
          o = n(r(22333));
        function s(t) {
          const e = t.key.length,
            r = t.value.length,
            n = i.encodingLength(e),
            o = i.encodingLength(r),
            s = new Uint8Array(n + e + o + r);
          return (
            i.encode(e, s, 0),
            s.set(t.key, n),
            i.encode(r, s, n + e),
            s.set(t.value, n + e + o),
            s
          );
        }
        (e.range = (t) => [...Array(t).keys()]),
          (e.reverseBuffer = function (t) {
            if (t.length < 1) return t;
            let e = t.length - 1,
              r = 0;
            for (let n = 0; n < t.length / 2; n++)
              (r = t[n]), (t[n] = t[e]), (t[e] = r), e--;
            return t;
          }),
          (e.keyValsToBuffer = function (t) {
            const e = t.map(s);
            return e.push(Uint8Array.from([0])), o.concat(e);
          }),
          (e.keyValToBuffer = s);
      },
      38526: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(79821)),
          o = r(28672),
          s = n(r(60882)),
          a = n(r(22333)),
          u = r(48143);
        function c(t, e, r) {
          if (a.compare(e, Uint8Array.from([r])))
            throw new Error(`Format Error: Invalid ${t} key: ${a.toHex(e)}`);
        }
        function f(
          t,
          { globalMapKeyVals: e, inputKeyVals: r, outputKeyVals: n },
        ) {
          const s = { unsignedTx: t };
          let a = 0;
          for (const t of e)
            switch (t.key[0]) {
              case u.GlobalTypes.UNSIGNED_TX:
                if ((c("global", t.key, u.GlobalTypes.UNSIGNED_TX), a > 0))
                  throw new Error(
                    "Format Error: GlobalMap has multiple UNSIGNED_TX",
                  );
                a++;
                break;
              case u.GlobalTypes.GLOBAL_XPUB:
                void 0 === s.globalXpub && (s.globalXpub = []),
                  s.globalXpub.push(i.globals.globalXpub.decode(t));
                break;
              default:
                s.unknownKeyVals || (s.unknownKeyVals = []),
                  s.unknownKeyVals.push(t);
            }
          const f = r.length,
            h = n.length,
            l = [],
            d = [];
          for (const t of o.range(f)) {
            const e = {};
            for (const n of r[t])
              switch ((i.inputs.checkPubkey(n), n.key[0])) {
                case u.InputTypes.NON_WITNESS_UTXO:
                  if (
                    (c("input", n.key, u.InputTypes.NON_WITNESS_UTXO),
                    void 0 !== e.nonWitnessUtxo)
                  )
                    throw new Error(
                      "Format Error: Input has multiple NON_WITNESS_UTXO",
                    );
                  e.nonWitnessUtxo = i.inputs.nonWitnessUtxo.decode(n);
                  break;
                case u.InputTypes.WITNESS_UTXO:
                  if (
                    (c("input", n.key, u.InputTypes.WITNESS_UTXO),
                    void 0 !== e.witnessUtxo)
                  )
                    throw new Error(
                      "Format Error: Input has multiple WITNESS_UTXO",
                    );
                  e.witnessUtxo = i.inputs.witnessUtxo.decode(n);
                  break;
                case u.InputTypes.PARTIAL_SIG:
                  void 0 === e.partialSig && (e.partialSig = []),
                    e.partialSig.push(i.inputs.partialSig.decode(n));
                  break;
                case u.InputTypes.SIGHASH_TYPE:
                  if (
                    (c("input", n.key, u.InputTypes.SIGHASH_TYPE),
                    void 0 !== e.sighashType)
                  )
                    throw new Error(
                      "Format Error: Input has multiple SIGHASH_TYPE",
                    );
                  e.sighashType = i.inputs.sighashType.decode(n);
                  break;
                case u.InputTypes.REDEEM_SCRIPT:
                  if (
                    (c("input", n.key, u.InputTypes.REDEEM_SCRIPT),
                    void 0 !== e.redeemScript)
                  )
                    throw new Error(
                      "Format Error: Input has multiple REDEEM_SCRIPT",
                    );
                  e.redeemScript = i.inputs.redeemScript.decode(n);
                  break;
                case u.InputTypes.WITNESS_SCRIPT:
                  if (
                    (c("input", n.key, u.InputTypes.WITNESS_SCRIPT),
                    void 0 !== e.witnessScript)
                  )
                    throw new Error(
                      "Format Error: Input has multiple WITNESS_SCRIPT",
                    );
                  e.witnessScript = i.inputs.witnessScript.decode(n);
                  break;
                case u.InputTypes.BIP32_DERIVATION:
                  void 0 === e.bip32Derivation && (e.bip32Derivation = []),
                    e.bip32Derivation.push(i.inputs.bip32Derivation.decode(n));
                  break;
                case u.InputTypes.FINAL_SCRIPTSIG:
                  c("input", n.key, u.InputTypes.FINAL_SCRIPTSIG),
                    (e.finalScriptSig = i.inputs.finalScriptSig.decode(n));
                  break;
                case u.InputTypes.FINAL_SCRIPTWITNESS:
                  c("input", n.key, u.InputTypes.FINAL_SCRIPTWITNESS),
                    (e.finalScriptWitness =
                      i.inputs.finalScriptWitness.decode(n));
                  break;
                case u.InputTypes.POR_COMMITMENT:
                  c("input", n.key, u.InputTypes.POR_COMMITMENT),
                    (e.porCommitment = i.inputs.porCommitment.decode(n));
                  break;
                case u.InputTypes.TAP_KEY_SIG:
                  c("input", n.key, u.InputTypes.TAP_KEY_SIG),
                    (e.tapKeySig = i.inputs.tapKeySig.decode(n));
                  break;
                case u.InputTypes.TAP_SCRIPT_SIG:
                  void 0 === e.tapScriptSig && (e.tapScriptSig = []),
                    e.tapScriptSig.push(i.inputs.tapScriptSig.decode(n));
                  break;
                case u.InputTypes.TAP_LEAF_SCRIPT:
                  void 0 === e.tapLeafScript && (e.tapLeafScript = []),
                    e.tapLeafScript.push(i.inputs.tapLeafScript.decode(n));
                  break;
                case u.InputTypes.TAP_BIP32_DERIVATION:
                  void 0 === e.tapBip32Derivation &&
                    (e.tapBip32Derivation = []),
                    e.tapBip32Derivation.push(
                      i.inputs.tapBip32Derivation.decode(n),
                    );
                  break;
                case u.InputTypes.TAP_INTERNAL_KEY:
                  c("input", n.key, u.InputTypes.TAP_INTERNAL_KEY),
                    (e.tapInternalKey = i.inputs.tapInternalKey.decode(n));
                  break;
                case u.InputTypes.TAP_MERKLE_ROOT:
                  c("input", n.key, u.InputTypes.TAP_MERKLE_ROOT),
                    (e.tapMerkleRoot = i.inputs.tapMerkleRoot.decode(n));
                  break;
                default:
                  e.unknownKeyVals || (e.unknownKeyVals = []),
                    e.unknownKeyVals.push(n);
              }
            l.push(e);
          }
          for (const t of o.range(h)) {
            const e = {};
            for (const r of n[t])
              switch ((i.outputs.checkPubkey(r), r.key[0])) {
                case u.OutputTypes.REDEEM_SCRIPT:
                  if (
                    (c("output", r.key, u.OutputTypes.REDEEM_SCRIPT),
                    void 0 !== e.redeemScript)
                  )
                    throw new Error(
                      "Format Error: Output has multiple REDEEM_SCRIPT",
                    );
                  e.redeemScript = i.outputs.redeemScript.decode(r);
                  break;
                case u.OutputTypes.WITNESS_SCRIPT:
                  if (
                    (c("output", r.key, u.OutputTypes.WITNESS_SCRIPT),
                    void 0 !== e.witnessScript)
                  )
                    throw new Error(
                      "Format Error: Output has multiple WITNESS_SCRIPT",
                    );
                  e.witnessScript = i.outputs.witnessScript.decode(r);
                  break;
                case u.OutputTypes.BIP32_DERIVATION:
                  void 0 === e.bip32Derivation && (e.bip32Derivation = []),
                    e.bip32Derivation.push(i.outputs.bip32Derivation.decode(r));
                  break;
                case u.OutputTypes.TAP_INTERNAL_KEY:
                  c("output", r.key, u.OutputTypes.TAP_INTERNAL_KEY),
                    (e.tapInternalKey = i.outputs.tapInternalKey.decode(r));
                  break;
                case u.OutputTypes.TAP_TREE:
                  c("output", r.key, u.OutputTypes.TAP_TREE),
                    (e.tapTree = i.outputs.tapTree.decode(r));
                  break;
                case u.OutputTypes.TAP_BIP32_DERIVATION:
                  void 0 === e.tapBip32Derivation &&
                    (e.tapBip32Derivation = []),
                    e.tapBip32Derivation.push(
                      i.outputs.tapBip32Derivation.decode(r),
                    );
                  break;
                default:
                  e.unknownKeyVals || (e.unknownKeyVals = []),
                    e.unknownKeyVals.push(r);
              }
            d.push(e);
          }
          return { globalMap: s, inputs: l, outputs: d };
        }
        (e.psbtFromBuffer = function (t, e) {
          let r = 0;
          function n() {
            const { numberValue: e, bytes: n } = s.decode(t, r);
            r += n;
            const i = t.slice(r, r + Number(e));
            return (r += Number(e)), i;
          }
          function i() {
            return { key: n(), value: n() };
          }
          function c() {
            if (r >= t.length)
              throw new Error("Format Error: Unexpected End of PSBT");
            const e = 0 === a.readUInt8(t, r);
            return e && r++, e;
          }
          if (
            1886610036 !==
            (function () {
              const e = a.readUInt32(t, r, "BE");
              return (r += 4), e;
            })()
          )
            throw new Error("Format Error: Invalid Magic Number");
          if (
            255 !==
            (function () {
              const e = a.readUInt8(t, r);
              return (r += 1), e;
            })()
          )
            throw new Error(
              "Format Error: Magic Number must be followed by 0xff separator",
            );
          const h = [],
            l = {};
          for (; !c(); ) {
            const t = i(),
              e = a.toHex(t.key);
            if (l[e])
              throw new Error(
                "Format Error: Keys must be unique for global keymap: key " + e,
              );
            (l[e] = 1), h.push(t);
          }
          const d = h.filter((t) => t.key[0] === u.GlobalTypes.UNSIGNED_TX);
          if (1 !== d.length)
            throw new Error("Format Error: Only one UNSIGNED_TX allowed");
          const p = e(d[0].value),
            { inputCount: y, outputCount: g } = p.getInputOutputCounts(),
            m = [],
            b = [];
          for (const t of o.range(y)) {
            const e = {},
              r = [];
            for (; !c(); ) {
              const n = i(),
                o = a.toHex(n.key);
              if (e[o])
                throw new Error(
                  "Format Error: Keys must be unique for each input: input index " +
                    t +
                    " key " +
                    o,
                );
              (e[o] = 1), r.push(n);
            }
            m.push(r);
          }
          for (const t of o.range(g)) {
            const e = {},
              r = [];
            for (; !c(); ) {
              const n = i(),
                o = a.toHex(n.key);
              if (e[o])
                throw new Error(
                  "Format Error: Keys must be unique for each output: output index " +
                    t +
                    " key " +
                    o,
                );
              (e[o] = 1), r.push(n);
            }
            b.push(r);
          }
          return f(p, {
            globalMapKeyVals: h,
            inputKeyVals: m,
            outputKeyVals: b,
          });
        }),
          (e.checkKeyBuffer = c),
          (e.psbtFromKeyVals = f);
      },
      19092: (t, e, r) => {
        "use strict";
        function n(t) {
          for (var r in t) e.hasOwnProperty(r) || (e[r] = t[r]);
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          n(r(38526)),
          n(r(44813));
      },
      44813: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(79821)),
          o = r(28672),
          s = n(r(22333));
        e.psbtToBuffer = function ({ globalMap: t, inputs: e, outputs: r }) {
          const {
              globalKeyVals: n,
              inputKeyVals: i,
              outputKeyVals: a,
            } = c({ globalMap: t, inputs: e, outputs: r }),
            u = o.keyValsToBuffer(n),
            f = (t) =>
              0 === t.length
                ? [Uint8Array.from([0])]
                : t.map(o.keyValsToBuffer),
            h = f(i),
            l = f(a),
            d = new Uint8Array(5);
          return (
            d.set([112, 115, 98, 116, 255], 0), s.concat([d, u].concat(h, l))
          );
        };
        const a = (t, e) => s.compare(t.key, e.key);
        function u(t, e) {
          const r = new Set(),
            n = Object.entries(t).reduce((t, [n, i]) => {
              if ("unknownKeyVals" === n) return t;
              const o = e[n];
              if (void 0 === o) return t;
              const a = (Array.isArray(i) ? i : [i]).map(o.encode);
              return (
                a
                  .map((t) => s.toHex(t.key))
                  .forEach((t) => {
                    if (r.has(t))
                      throw new Error("Serialize Error: Duplicate key: " + t);
                    r.add(t);
                  }),
                t.concat(a)
              );
            }, []),
            i = t.unknownKeyVals
              ? t.unknownKeyVals.filter((t) => !r.has(s.toHex(t.key)))
              : [];
          return n.concat(i).sort(a);
        }
        function c({ globalMap: t, inputs: e, outputs: r }) {
          return {
            globalKeyVals: u(t, i.globals),
            inputKeyVals: e.map((t) => u(t, i.inputs)),
            outputKeyVals: r.map((t) => u(t, i.outputs)),
          };
        }
        e.psbtToKeyVals = c;
      },
      92933: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = r(36746),
          o = r(19092),
          s = r(48143),
          a = r(38247),
          u = n(r(22333));
        e.Psbt = class {
          constructor(t) {
            (this.inputs = []),
              (this.outputs = []),
              (this.globalMap = { unsignedTx: t });
          }
          static fromBase64(t, e) {
            const r = u.fromBase64(t);
            return this.fromBuffer(r, e);
          }
          static fromHex(t, e) {
            const r = u.fromHex(t);
            return this.fromBuffer(r, e);
          }
          static fromBuffer(t, e) {
            const r = o.psbtFromBuffer(t, e),
              n = new this(r.globalMap.unsignedTx);
            return Object.assign(n, r), n;
          }
          toBase64() {
            const t = this.toBuffer();
            return u.toBase64(t);
          }
          toHex() {
            const t = this.toBuffer();
            return u.toHex(t);
          }
          toBuffer() {
            return o.psbtToBuffer(this);
          }
          updateGlobal(t) {
            return a.updateGlobal(t, this.globalMap), this;
          }
          updateInput(t, e) {
            const r = a.checkForInput(this.inputs, t);
            return a.updateInput(e, r), this;
          }
          updateOutput(t, e) {
            const r = a.checkForOutput(this.outputs, t);
            return a.updateOutput(e, r), this;
          }
          addUnknownKeyValToGlobal(t) {
            return (
              a.checkHasKey(
                t,
                this.globalMap.unknownKeyVals,
                a.getEnumLength(s.GlobalTypes),
              ),
              this.globalMap.unknownKeyVals ||
                (this.globalMap.unknownKeyVals = []),
              this.globalMap.unknownKeyVals.push(t),
              this
            );
          }
          addUnknownKeyValToInput(t, e) {
            const r = a.checkForInput(this.inputs, t);
            return (
              a.checkHasKey(e, r.unknownKeyVals, a.getEnumLength(s.InputTypes)),
              r.unknownKeyVals || (r.unknownKeyVals = []),
              r.unknownKeyVals.push(e),
              this
            );
          }
          addUnknownKeyValToOutput(t, e) {
            const r = a.checkForOutput(this.outputs, t);
            return (
              a.checkHasKey(
                e,
                r.unknownKeyVals,
                a.getEnumLength(s.OutputTypes),
              ),
              r.unknownKeyVals || (r.unknownKeyVals = []),
              r.unknownKeyVals.push(e),
              this
            );
          }
          addInput(t) {
            this.globalMap.unsignedTx.addInput(t),
              this.inputs.push({ unknownKeyVals: [] });
            const e = t.unknownKeyVals || [],
              r = this.inputs.length - 1;
            if (!Array.isArray(e))
              throw new Error("unknownKeyVals must be an Array");
            return (
              e.forEach((t) => this.addUnknownKeyValToInput(r, t)),
              a.addInputAttributes(this.inputs, t),
              this
            );
          }
          addOutput(t) {
            this.globalMap.unsignedTx.addOutput(t),
              this.outputs.push({ unknownKeyVals: [] });
            const e = t.unknownKeyVals || [],
              r = this.outputs.length - 1;
            if (!Array.isArray(e))
              throw new Error("unknownKeyVals must be an Array");
            return (
              e.forEach((t) => this.addUnknownKeyValToOutput(r, t)),
              a.addOutputAttributes(this.outputs, t),
              this
            );
          }
          clearFinalizedInput(t) {
            const e = a.checkForInput(this.inputs, t);
            a.inputCheckUncleanFinalized(t, e);
            for (const t of Object.keys(e))
              [
                "witnessUtxo",
                "nonWitnessUtxo",
                "finalScriptSig",
                "finalScriptWitness",
                "unknownKeyVals",
              ].includes(t) || delete e[t];
            return this;
          }
          combine(...t) {
            const e = i.combine([this].concat(t));
            return Object.assign(this, e), this;
          }
          getTransaction() {
            return this.globalMap.unsignedTx.toBuffer();
          }
        };
        var c = r(38247);
        (e.checkForInput = c.checkForInput),
          (e.checkForOutput = c.checkForOutput);
      },
      48143: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (function (t) {
            (t[(t.UNSIGNED_TX = 0)] = "UNSIGNED_TX"),
              (t[(t.GLOBAL_XPUB = 1)] = "GLOBAL_XPUB");
          })(e.GlobalTypes || (e.GlobalTypes = {})),
          (e.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"]),
          (function (t) {
            (t[(t.NON_WITNESS_UTXO = 0)] = "NON_WITNESS_UTXO"),
              (t[(t.WITNESS_UTXO = 1)] = "WITNESS_UTXO"),
              (t[(t.PARTIAL_SIG = 2)] = "PARTIAL_SIG"),
              (t[(t.SIGHASH_TYPE = 3)] = "SIGHASH_TYPE"),
              (t[(t.REDEEM_SCRIPT = 4)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 5)] = "WITNESS_SCRIPT"),
              (t[(t.BIP32_DERIVATION = 6)] = "BIP32_DERIVATION"),
              (t[(t.FINAL_SCRIPTSIG = 7)] = "FINAL_SCRIPTSIG"),
              (t[(t.FINAL_SCRIPTWITNESS = 8)] = "FINAL_SCRIPTWITNESS"),
              (t[(t.POR_COMMITMENT = 9)] = "POR_COMMITMENT"),
              (t[(t.TAP_KEY_SIG = 19)] = "TAP_KEY_SIG"),
              (t[(t.TAP_SCRIPT_SIG = 20)] = "TAP_SCRIPT_SIG"),
              (t[(t.TAP_LEAF_SCRIPT = 21)] = "TAP_LEAF_SCRIPT"),
              (t[(t.TAP_BIP32_DERIVATION = 22)] = "TAP_BIP32_DERIVATION"),
              (t[(t.TAP_INTERNAL_KEY = 23)] = "TAP_INTERNAL_KEY"),
              (t[(t.TAP_MERKLE_ROOT = 24)] = "TAP_MERKLE_ROOT");
          })(e.InputTypes || (e.InputTypes = {})),
          (e.INPUT_TYPE_NAMES = [
            "nonWitnessUtxo",
            "witnessUtxo",
            "partialSig",
            "sighashType",
            "redeemScript",
            "witnessScript",
            "bip32Derivation",
            "finalScriptSig",
            "finalScriptWitness",
            "porCommitment",
            "tapKeySig",
            "tapScriptSig",
            "tapLeafScript",
            "tapBip32Derivation",
            "tapInternalKey",
            "tapMerkleRoot",
          ]),
          (function (t) {
            (t[(t.REDEEM_SCRIPT = 0)] = "REDEEM_SCRIPT"),
              (t[(t.WITNESS_SCRIPT = 1)] = "WITNESS_SCRIPT"),
              (t[(t.BIP32_DERIVATION = 2)] = "BIP32_DERIVATION"),
              (t[(t.TAP_INTERNAL_KEY = 5)] = "TAP_INTERNAL_KEY"),
              (t[(t.TAP_TREE = 6)] = "TAP_TREE"),
              (t[(t.TAP_BIP32_DERIVATION = 7)] = "TAP_BIP32_DERIVATION");
          })(e.OutputTypes || (e.OutputTypes = {})),
          (e.OUTPUT_TYPE_NAMES = [
            "redeemScript",
            "witnessScript",
            "bip32Derivation",
            "tapInternalKey",
            "tapTree",
            "tapBip32Derivation",
          ]);
      },
      38247: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importStar) ||
          function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
              for (var r in t)
                Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return (e.default = t), e;
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        const i = n(r(79821)),
          o = n(r(22333));
        function s(t, e) {
          const r = t[e];
          if (void 0 === r) throw new Error(`No input #${e}`);
          return r;
        }
        function a(t, e) {
          const r = t[e];
          if (void 0 === r) throw new Error(`No output #${e}`);
          return r;
        }
        function u(t, e, r, n) {
          throw new Error(
            `Data for ${t} key ${e} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`,
          );
        }
        function c(t) {
          return (e, r) => {
            for (const n of Object.keys(e)) {
              const o = e[n],
                {
                  canAdd: s,
                  canAddToArray: a,
                  check: c,
                  expected: f,
                } = i[t + "s"][n] || {};
              if (c)
                if (!!a) {
                  if (!Array.isArray(o) || (r[n] && !Array.isArray(r[n])))
                    throw new Error(`Key type ${n} must be an array`);
                  o.every(c) || u(t, n, f, o);
                  const e = r[n] || [],
                    i = new Set();
                  if (!o.every((t) => a(e, t, i)))
                    throw new Error("Can not add duplicate data to array");
                  r[n] = e.concat(o);
                } else {
                  if ((c(o) || u(t, n, f, o), !s(r, o)))
                    throw new Error(`Can not add duplicate data to ${t}`);
                  r[n] = o;
                }
            }
          };
        }
        (e.checkForInput = s),
          (e.checkForOutput = a),
          (e.checkHasKey = function (t, e, r) {
            if (t.key[0] < r)
              throw new Error(
                "Use the method for your specific key instead of addUnknownKeyVal*",
              );
            if (
              e &&
              0 !== e.filter((e) => 0 === o.compare(e.key, t.key)).length
            )
              throw new Error(`Duplicate Key: ${o.toHex(t.key)}`);
          }),
          (e.getEnumLength = function (t) {
            let e = 0;
            return (
              Object.keys(t).forEach((t) => {
                Number(isNaN(Number(t))) && e++;
              }),
              e
            );
          }),
          (e.inputCheckUncleanFinalized = function (t, e) {
            let r = !1;
            if (e.nonWitnessUtxo || e.witnessUtxo) {
              const t = !!e.redeemScript,
                n = !!e.witnessScript,
                i = !t || !!e.finalScriptSig,
                o = !n || !!e.finalScriptWitness,
                s = !!e.finalScriptSig || !!e.finalScriptWitness;
              r = i && o && s;
            }
            if (!1 === r)
              throw new Error(
                `Input #${t} has too much or too little data to clean`,
              );
          }),
          (e.updateGlobal = c("global")),
          (e.updateInput = c("input")),
          (e.updateOutput = c("output")),
          (e.addInputAttributes = function (t, r) {
            const n = s(t, t.length - 1);
            e.updateInput(r, n);
          }),
          (e.addOutputAttributes = function (t, r) {
            const n = a(t, t.length - 1);
            e.updateOutput(r, n);
          }),
          (e.defaultVersionSetter = function (t, e) {
            if (!(e instanceof Uint8Array) || e.length < 4)
              throw new Error("Set Version: Invalid Transaction");
            return o.writeUInt32(e, 0, t, "LE"), e;
          }),
          (e.defaultLocktimeSetter = function (t, e) {
            if (!(e instanceof Uint8Array) || e.length < 4)
              throw new Error("Set Locktime: Invalid Transaction");
            return o.writeUInt32(e, e.length - 4, t, "LE"), e;
          });
      },
      22058: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            },
          s =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.fromBase58Check = _),
          (e.fromBech32 = E),
          (e.toBase58Check = function (t, e) {
            p.parse(p.tuple([f.Hash160bitSchema, f.UInt8Schema]), [t, e]);
            const r = new Uint8Array(21);
            return d.writeUInt8(r, 0, e), r.set(t, 1), l.default.encode(r);
          }),
          (e.toBech32 = S),
          (e.fromOutputScript = function (t, e) {
            e = e || a.bitcoin;
            try {
              return u.p2pkh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return u.p2sh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return u.p2wpkh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return u.p2wsh({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return u.p2tr({ output: t, network: e }).address;
            } catch (t) {}
            try {
              return (function (t, e) {
                const r = t.slice(2);
                if (r.length < g || r.length > y)
                  throw new TypeError(
                    "Invalid program length for segwit address",
                  );
                const n = t[0] - w;
                if (n < b || n > m)
                  throw new TypeError("Invalid version for segwit address");
                if (t[1] !== r.length)
                  throw new TypeError("Invalid script for segwit address");
                return console.warn(v), S(r, n, e.bech32);
              })(t, e);
            } catch (t) {}
            throw new Error(c.toASM(t) + " has no matching Address");
          }),
          (e.toOutputScript = function (t, e) {
            let r, n;
            e = e || a.bitcoin;
            try {
              r = _(t);
            } catch (t) {}
            if (r) {
              if (r.version === e.pubKeyHash)
                return u.p2pkh({ hash: r.hash }).output;
              if (r.version === e.scriptHash)
                return u.p2sh({ hash: r.hash }).output;
            } else {
              try {
                n = E(t);
              } catch (t) {}
              if (n) {
                if (n.prefix !== e.bech32)
                  throw new Error(t + " has an invalid prefix");
                if (0 === n.version) {
                  if (20 === n.data.length)
                    return u.p2wpkh({ hash: n.data }).output;
                  if (32 === n.data.length)
                    return u.p2wsh({ hash: n.data }).output;
                } else if (1 === n.version) {
                  if (32 === n.data.length)
                    return u.p2tr({ pubkey: n.data }).output;
                } else if (
                  n.version >= b &&
                  n.version <= m &&
                  n.data.length >= g &&
                  n.data.length <= y
                )
                  return console.warn(v), c.compile([n.version + w, n.data]);
              }
            }
            throw new Error(t + " has no matching Script");
          });
        const a = o(r(29007)),
          u = o(r(96286)),
          c = o(r(19711)),
          f = r(90485),
          h = r(22343),
          l = s(r(30681)),
          d = o(r(22333)),
          p = o(r(51947)),
          y = 40,
          g = 2,
          m = 16,
          b = 2,
          w = 80,
          v =
            "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
        function _(t) {
          const e = l.default.decode(t);
          if (e.length < 21) throw new TypeError(t + " is too short");
          if (e.length > 21) throw new TypeError(t + " is too long");
          return { version: d.readUInt8(e, 0), hash: e.slice(1) };
        }
        function E(t) {
          let e, r;
          try {
            e = h.bech32.decode(t);
          } catch (t) {}
          if (e) {
            if (((r = e.words[0]), 0 !== r))
              throw new TypeError(t + " uses wrong encoding");
          } else if (((e = h.bech32m.decode(t)), (r = e.words[0]), 0 === r))
            throw new TypeError(t + " uses wrong encoding");
          const n = h.bech32.fromWords(e.words.slice(1));
          return { version: r, prefix: e.prefix, data: Uint8Array.from(n) };
        }
        function S(t, e, r) {
          const n = h.bech32.toWords(t);
          return (
            n.unshift(e),
            0 === e ? h.bech32.encode(r, n) : h.bech32m.encode(r, n)
          );
        }
      },
      56607: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.check = function (t) {
            if (t.length < 8) return !1;
            if (t.length > 72) return !1;
            if (48 !== t[0]) return !1;
            if (t[1] !== t.length - 2) return !1;
            if (2 !== t[2]) return !1;
            const e = t[3];
            if (0 === e) return !1;
            if (5 + e >= t.length) return !1;
            if (2 !== t[4 + e]) return !1;
            const r = t[5 + e];
            return (
              0 !== r &&
              6 + e + r === t.length &&
              !(128 & t[4]) &&
              !(e > 1 && 0 === t[4] && !(128 & t[5])) &&
              !(128 & t[e + 6]) &&
              !(r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
            );
          }),
          (e.decode = function (t) {
            if (t.length < 8)
              throw new Error("DER sequence length is too short");
            if (t.length > 72)
              throw new Error("DER sequence length is too long");
            if (48 !== t[0]) throw new Error("Expected DER sequence");
            if (t[1] !== t.length - 2)
              throw new Error("DER sequence length is invalid");
            if (2 !== t[2]) throw new Error("Expected DER integer");
            const e = t[3];
            if (0 === e) throw new Error("R length is zero");
            if (5 + e >= t.length) throw new Error("R length is too long");
            if (2 !== t[4 + e]) throw new Error("Expected DER integer (2)");
            const r = t[5 + e];
            if (0 === r) throw new Error("S length is zero");
            if (6 + e + r !== t.length) throw new Error("S length is invalid");
            if (128 & t[4]) throw new Error("R value is negative");
            if (e > 1 && 0 === t[4] && !(128 & t[5]))
              throw new Error("R value excessively padded");
            if (128 & t[e + 6]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[e + 6] && !(128 & t[e + 7]))
              throw new Error("S value excessively padded");
            return { r: t.slice(4, 4 + e), s: t.slice(6 + e) };
          }),
          (e.encode = function (t, e) {
            const r = t.length,
              n = e.length;
            if (0 === r) throw new Error("R length is zero");
            if (0 === n) throw new Error("S length is zero");
            if (r > 33) throw new Error("R length is too long");
            if (n > 33) throw new Error("S length is too long");
            if (128 & t[0]) throw new Error("R value is negative");
            if (128 & e[0]) throw new Error("S value is negative");
            if (r > 1 && 0 === t[0] && !(128 & t[1]))
              throw new Error("R value excessively padded");
            if (n > 1 && 0 === e[0] && !(128 & e[1]))
              throw new Error("S value excessively padded");
            const i = new Uint8Array(6 + r + n);
            return (
              (i[0] = 48),
              (i[1] = i.length - 2),
              (i[2] = 2),
              (i[3] = t.length),
              i.set(t, 4),
              (i[4 + r] = 2),
              (i[5 + r] = e.length),
              i.set(e, 6 + r),
              i
            );
          });
      },
      87385: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Block = void 0);
        const s = r(44311),
          a = o(r(5449)),
          u = r(71016),
          c = r(54110),
          f = o(r(51947)),
          h = o(r(22333)),
          l = new TypeError("Cannot compute merkle root for zero transactions"),
          d = new TypeError(
            "Cannot compute witness commit for non-segwit block",
          );
        class p {
          static fromBuffer(t) {
            if (t.length < 80) throw new Error("Buffer too small (< 80 bytes)");
            const e = new s.BufferReader(t),
              r = new p();
            if (
              ((r.version = e.readInt32()),
              (r.prevHash = e.readSlice(32)),
              (r.merkleRoot = e.readSlice(32)),
              (r.timestamp = e.readUInt32()),
              (r.bits = e.readUInt32()),
              (r.nonce = e.readUInt32()),
              80 === t.length)
            )
              return r;
            const n = () => {
                const t = c.Transaction.fromBuffer(
                  e.buffer.slice(e.offset),
                  !0,
                );
                return (e.offset += t.byteLength()), t;
              },
              i = e.readVarInt();
            r.transactions = [];
            for (let t = 0; t < i; ++t) {
              const t = n();
              r.transactions.push(t);
            }
            const o = r.getWitnessCommit();
            return o && (r.witnessCommit = o), r;
          }
          static fromHex(t) {
            return p.fromBuffer(h.fromHex(t));
          }
          static calculateTarget(t) {
            const e = ((4278190080 & t) >> 24) - 3,
              r = 8388607 & t,
              n = new Uint8Array(32);
            return (
              (n[29 - e] = (r >> 16) & 255),
              (n[30 - e] = (r >> 8) & 255),
              (n[31 - e] = 255 & r),
              n
            );
          }
          static calculateMerkleRoot(t, e) {
            if (
              (f.parse(f.array(f.object({ getHash: f.function() })), t),
              0 === t.length)
            )
              throw l;
            if (e && !y(t)) throw d;
            const r = t.map((t) => t.getHash(e)),
              n = (0, u.fastMerkleRoot)(r, a.hash256);
            return e ? a.hash256(h.concat([n, t[0].ins[0].witness[0]])) : n;
          }
          version = 1;
          prevHash = void 0;
          merkleRoot = void 0;
          timestamp = 0;
          witnessCommit = void 0;
          bits = 0;
          nonce = 0;
          transactions = void 0;
          getWitnessCommit() {
            if (!y(this.transactions)) return null;
            const t = this.transactions[0].outs
              .filter(
                (t) =>
                  0 ===
                  h.compare(
                    t.script.slice(0, 6),
                    Uint8Array.from([106, 36, 170, 33, 169, 237]),
                  ),
              )
              .map((t) => t.script.slice(6, 38));
            if (0 === t.length) return null;
            const e = t[t.length - 1];
            return e instanceof Uint8Array && 32 === e.length ? e : null;
          }
          hasWitnessCommit() {
            return (
              (this.witnessCommit instanceof Uint8Array &&
                32 === this.witnessCommit.length) ||
              null !== this.getWitnessCommit()
            );
          }
          hasWitness() {
            return (
              (t = this.transactions) instanceof Array &&
              t.some(
                (t) =>
                  "object" == typeof t &&
                  t.ins instanceof Array &&
                  t.ins.some(
                    (t) =>
                      "object" == typeof t &&
                      t.witness instanceof Array &&
                      t.witness.length > 0,
                  ),
              )
            );
            var t;
          }
          weight() {
            return 3 * this.byteLength(!1, !1) + this.byteLength(!1, !0);
          }
          byteLength(t, e = !0) {
            return t || !this.transactions
              ? 80
              : 80 +
                  s.varuint.encodingLength(this.transactions.length) +
                  this.transactions.reduce((t, r) => t + r.byteLength(e), 0);
          }
          getHash() {
            return a.hash256(this.toBuffer(!0));
          }
          getId() {
            return h.toHex((0, s.reverseBuffer)(this.getHash()));
          }
          getUTCDate() {
            const t = new Date(0);
            return t.setUTCSeconds(this.timestamp), t;
          }
          toBuffer(t) {
            const e = new Uint8Array(this.byteLength(t)),
              r = new s.BufferWriter(e);
            if (
              (r.writeInt32(this.version),
              r.writeSlice(this.prevHash),
              r.writeSlice(this.merkleRoot),
              r.writeUInt32(this.timestamp),
              r.writeUInt32(this.bits),
              r.writeUInt32(this.nonce),
              t || !this.transactions)
            )
              return e;
            const { bytes: n } = s.varuint.encode(
              this.transactions.length,
              e,
              r.offset,
            );
            return (
              (r.offset += n),
              this.transactions.forEach((t) => {
                const n = t.byteLength();
                t.toBuffer(e, r.offset), (r.offset += n);
              }),
              e
            );
          }
          toHex(t) {
            return h.toHex(this.toBuffer(t));
          }
          checkTxRoots() {
            const t = this.hasWitnessCommit();
            return (
              !(!t && this.hasWitness()) &&
              this.__checkMerkleRoot() &&
              (!t || this.__checkWitnessCommit())
            );
          }
          checkProofOfWork() {
            const t = (0, s.reverseBuffer)(this.getHash()),
              e = p.calculateTarget(this.bits);
            return h.compare(t, e) <= 0;
          }
          __checkMerkleRoot() {
            if (!this.transactions) throw l;
            const t = p.calculateMerkleRoot(this.transactions);
            return 0 === h.compare(this.merkleRoot, t);
          }
          __checkWitnessCommit() {
            if (!this.transactions) throw l;
            if (!this.hasWitnessCommit()) throw d;
            const t = p.calculateMerkleRoot(this.transactions, !0);
            return 0 === h.compare(this.witnessCommit, t);
          }
        }
        function y(t) {
          return (
            t instanceof Array &&
            t[0] &&
            t[0].ins &&
            t[0].ins instanceof Array &&
            t[0].ins[0] &&
            t[0].ins[0].witness &&
            t[0].ins[0].witness instanceof Array &&
            t[0].ins[0].witness.length > 0
          );
        }
        e.Block = p;
      },
      44311: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.BufferReader = e.BufferWriter = e.varuint = void 0),
          (e.reverseBuffer = function (t) {
            if (t.length < 1) return t;
            let e = t.length - 1,
              r = 0;
            for (let n = 0; n < t.length / 2; n++)
              (r = t[n]), (t[n] = t[e]), (t[e] = r), e--;
            return t;
          }),
          (e.cloneBuffer = function (t) {
            const e = new Uint8Array(t.length);
            return e.set(t), e;
          });
        const s = o(r(90485)),
          a = o(r(60882));
        e.varuint = a;
        const u = o(r(51947)),
          c = o(r(22333));
        class f {
          buffer;
          offset;
          static withCapacity(t) {
            return new f(new Uint8Array(t));
          }
          constructor(t, e = 0) {
            (this.buffer = t),
              (this.offset = e),
              u.parse(u.tuple([s.BufferSchema, s.UInt32Schema]), [t, e]);
          }
          writeUInt8(t) {
            this.offset = c.writeUInt8(this.buffer, this.offset, t);
          }
          writeInt32(t) {
            this.offset = c.writeInt32(this.buffer, this.offset, t, "LE");
          }
          writeInt64(t) {
            this.offset = c.writeInt64(
              this.buffer,
              this.offset,
              BigInt(t),
              "LE",
            );
          }
          writeUInt32(t) {
            this.offset = c.writeUInt32(this.buffer, this.offset, t, "LE");
          }
          writeUInt64(t) {
            this.offset = c.writeUInt64(
              this.buffer,
              this.offset,
              BigInt(t),
              "LE",
            );
          }
          writeVarInt(t) {
            const { bytes: e } = a.encode(t, this.buffer, this.offset);
            this.offset += e;
          }
          writeSlice(t) {
            if (this.buffer.length < this.offset + t.length)
              throw new Error("Cannot write slice out of bounds");
            this.buffer.set(t, this.offset), (this.offset += t.length);
          }
          writeVarSlice(t) {
            this.writeVarInt(t.length), this.writeSlice(t);
          }
          writeVector(t) {
            this.writeVarInt(t.length), t.forEach((t) => this.writeVarSlice(t));
          }
          end() {
            if (this.buffer.length === this.offset) return this.buffer;
            throw new Error(
              `buffer size ${this.buffer.length}, offset ${this.offset}`,
            );
          }
        }
        e.BufferWriter = f;
        e.BufferReader = class {
          buffer;
          offset;
          constructor(t, e = 0) {
            (this.buffer = t),
              (this.offset = e),
              u.parse(u.tuple([s.BufferSchema, s.UInt32Schema]), [t, e]);
          }
          readUInt8() {
            const t = c.readUInt8(this.buffer, this.offset);
            return this.offset++, t;
          }
          readInt32() {
            const t = c.readInt32(this.buffer, this.offset, "LE");
            return (this.offset += 4), t;
          }
          readUInt32() {
            const t = c.readUInt32(this.buffer, this.offset, "LE");
            return (this.offset += 4), t;
          }
          readInt64() {
            const t = c.readInt64(this.buffer, this.offset, "LE");
            return (this.offset += 8), t;
          }
          readVarInt() {
            const { bigintValue: t, bytes: e } = a.decode(
              this.buffer,
              this.offset,
            );
            return (this.offset += e), t;
          }
          readSlice(t) {
            !(function (t, e) {
              if ("number" != typeof t && "bigint" != typeof t)
                throw new Error("cannot write a non-number as a number");
              if (t < 0 && t < BigInt(0))
                throw new Error(
                  "specified a negative value for writing an unsigned value",
                );
              if (t > e && t > BigInt(e))
                throw new Error("RangeError: value out of range");
              if (Math.floor(Number(t)) !== Number(t))
                throw new Error("value has a fractional component");
            })(t, 9007199254740991);
            const e = Number(t);
            if (this.buffer.length < this.offset + e)
              throw new Error("Cannot read slice out of bounds");
            const r = this.buffer.slice(this.offset, this.offset + e);
            return (this.offset += e), r;
          }
          readVarSlice() {
            return this.readSlice(this.readVarInt());
          }
          readVector() {
            const t = this.readVarInt(),
              e = [];
            for (let r = 0; r < t; r++) e.push(this.readVarSlice());
            return e;
          }
        };
      },
      5449: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.TAGGED_HASH_PREFIXES = e.TAGS = void 0),
          (e.hash160 = function (t) {
            return (0, s.ripemd160)((0, a.sha256)(t));
          }),
          (e.hash256 = function (t) {
            return (0, a.sha256)((0, a.sha256)(t));
          }),
          (e.taggedHash = function (t, r) {
            return (0, a.sha256)(u.concat([e.TAGGED_HASH_PREFIXES[t], r]));
          });
        const s = r(93238),
          a = r(22623),
          u = o(r(22333));
        (e.TAGS = [
          "BIP0340/challenge",
          "BIP0340/aux",
          "BIP0340/nonce",
          "TapLeaf",
          "TapBranch",
          "TapSighash",
          "TapTweak",
          "KeyAgg list",
          "KeyAgg coefficient",
        ]),
          (e.TAGGED_HASH_PREFIXES = {
            "BIP0340/challenge": Uint8Array.from([
              123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125,
              179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143,
              109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88, 50, 62, 177,
              191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79,
              73, 254, 81, 143, 109, 72, 211, 124,
            ]),
            "BIP0340/aux": Uint8Array.from([
              241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152,
              126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46,
              216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202, 218, 109, 148,
              202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151,
              45, 119, 165, 46, 216, 193, 204, 144,
            ]),
            "BIP0340/nonce": Uint8Array.from([
              7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18,
              28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191,
              235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3,
              79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251,
              82, 191, 235, 47,
            ]),
            TapLeaf: Uint8Array.from([
              174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38,
              56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233,
              238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29,
              30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190,
              120, 233, 238,
            ]),
            TapBranch: Uint8Array.from([
              25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92,
              1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91,
              245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95, 162, 169,
              241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70,
              52, 144, 208, 91, 245, 22, 160, 21,
            ]),
            TapSighash: Uint8Array.from([
              244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70,
              97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198,
              40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200, 180, 146,
              75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135,
              35, 117, 151, 198, 40, 228, 160, 49,
            ]),
            TapTweak: Uint8Array.from([
              232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67,
              198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244,
              175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160, 80, 227, 175,
              27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251,
              181, 197, 161, 244, 175, 87, 197, 233,
            ]),
            "KeyAgg list": Uint8Array.from([
              72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78,
              44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153,
              2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174,
              89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158,
              160, 212, 153, 2, 148, 240,
            ]),
            "KeyAgg coefficient": Uint8Array.from([
              191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86,
              109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205,
              82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229,
              61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0,
              249, 77, 205, 82, 201, 129,
            ]),
          });
      },
      87965: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.initEccLib = function (t) {
            t
              ? t !== a.eccLib &&
                (!(function (t) {
                  c("function" == typeof t.isXOnlyPoint),
                    c(
                      t.isXOnlyPoint(
                        u(
                          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                        ),
                      ),
                    ),
                    c(
                      t.isXOnlyPoint(
                        u(
                          "fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e",
                        ),
                      ),
                    ),
                    c(
                      t.isXOnlyPoint(
                        u(
                          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                        ),
                      ),
                    ),
                    c(
                      t.isXOnlyPoint(
                        u(
                          "0000000000000000000000000000000000000000000000000000000000000001",
                        ),
                      ),
                    ),
                    c(
                      !t.isXOnlyPoint(
                        u(
                          "0000000000000000000000000000000000000000000000000000000000000000",
                        ),
                      ),
                    ),
                    c(
                      !t.isXOnlyPoint(
                        u(
                          "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
                        ),
                      ),
                    ),
                    c("function" == typeof t.xOnlyPointAddTweak),
                    f.forEach((e) => {
                      const r = t.xOnlyPointAddTweak(u(e.pubkey), u(e.tweak));
                      null === e.result
                        ? c(null === r)
                        : (c(null !== r),
                          c(r.parity === e.parity),
                          c(0 === s.compare(r.xOnlyPubkey, u(e.result))));
                    });
                })(t),
                (a.eccLib = t))
              : (a.eccLib = t);
          }),
          (e.getEccLib = function () {
            if (!a.eccLib)
              throw new Error(
                "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance",
              );
            return a.eccLib;
          });
        const s = o(r(22333)),
          a = {};
        const u = (t) => s.fromHex(t);
        function c(t) {
          if (!t) throw new Error("ecc library invalid");
        }
        const f = [
          {
            pubkey:
              "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            tweak:
              "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
            parity: -1,
            result: null,
          },
          {
            pubkey:
              "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
            tweak:
              "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
            parity: 1,
            result:
              "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf",
          },
          {
            pubkey:
              "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
            tweak:
              "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
            parity: 0,
            result:
              "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c",
          },
        ];
      },
      40630: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.initEccLib =
            e.Transaction =
            e.opcodes =
            e.Psbt =
            e.Block =
            e.script =
            e.payments =
            e.networks =
            e.crypto =
            e.address =
              void 0);
        const s = o(r(22058));
        e.address = s;
        const a = o(r(5449));
        e.crypto = a;
        const u = o(r(29007));
        e.networks = u;
        const c = o(r(96286));
        e.payments = c;
        const f = o(r(19711));
        e.script = f;
        var h = r(87385);
        Object.defineProperty(e, "Block", {
          enumerable: !0,
          get: function () {
            return h.Block;
          },
        });
        var l = r(5055);
        Object.defineProperty(e, "Psbt", {
          enumerable: !0,
          get: function () {
            return l.Psbt;
          },
        });
        var d = r(31234);
        Object.defineProperty(e, "opcodes", {
          enumerable: !0,
          get: function () {
            return d.OPS;
          },
        });
        var p = r(54110);
        Object.defineProperty(e, "Transaction", {
          enumerable: !0,
          get: function () {
            return p.Transaction;
          },
        });
        var y = r(87965);
        Object.defineProperty(e, "initEccLib", {
          enumerable: !0,
          get: function () {
            return y.initEccLib;
          },
        });
      },
      71016: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.fastMerkleRoot = function (t, e) {
            if (!Array.isArray(t)) throw TypeError("Expected values Array");
            if ("function" != typeof e)
              throw TypeError("Expected digest Function");
            let r = t.length;
            const n = t.concat();
            for (; r > 1; ) {
              let t = 0;
              for (let i = 0; i < r; i += 2, ++t) {
                const o = n[i],
                  a = i + 1 === r ? o : n[i + 1],
                  u = s.concat([o, a]);
                n[t] = e(u);
              }
              r = t;
            }
            return n[0];
          });
        const s = o(r(22333));
      },
      29007: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.testnet = e.regtest = e.bitcoin = void 0),
          (e.bitcoin = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "bc",
            bip32: { public: 76067358, private: 76066276 },
            pubKeyHash: 0,
            scriptHash: 5,
            wif: 128,
          }),
          (e.regtest = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "bcrt",
            bip32: { public: 70617039, private: 70615956 },
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239,
          }),
          (e.testnet = {
            messagePrefix: "Bitcoin Signed Message:\n",
            bech32: "tb",
            bip32: { public: 70617039, private: 70615956 },
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239,
          });
      },
      31234: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.REVERSE_OPS = e.OPS = void 0);
        const r = {
          OP_FALSE: 0,
          OP_0: 0,
          OP_PUSHDATA1: 76,
          OP_PUSHDATA2: 77,
          OP_PUSHDATA4: 78,
          OP_1NEGATE: 79,
          OP_RESERVED: 80,
          OP_TRUE: 81,
          OP_1: 81,
          OP_2: 82,
          OP_3: 83,
          OP_4: 84,
          OP_5: 85,
          OP_6: 86,
          OP_7: 87,
          OP_8: 88,
          OP_9: 89,
          OP_10: 90,
          OP_11: 91,
          OP_12: 92,
          OP_13: 93,
          OP_14: 94,
          OP_15: 95,
          OP_16: 96,
          OP_NOP: 97,
          OP_VER: 98,
          OP_IF: 99,
          OP_NOTIF: 100,
          OP_VERIF: 101,
          OP_VERNOTIF: 102,
          OP_ELSE: 103,
          OP_ENDIF: 104,
          OP_VERIFY: 105,
          OP_RETURN: 106,
          OP_TOALTSTACK: 107,
          OP_FROMALTSTACK: 108,
          OP_2DROP: 109,
          OP_2DUP: 110,
          OP_3DUP: 111,
          OP_2OVER: 112,
          OP_2ROT: 113,
          OP_2SWAP: 114,
          OP_IFDUP: 115,
          OP_DEPTH: 116,
          OP_DROP: 117,
          OP_DUP: 118,
          OP_NIP: 119,
          OP_OVER: 120,
          OP_PICK: 121,
          OP_ROLL: 122,
          OP_ROT: 123,
          OP_SWAP: 124,
          OP_TUCK: 125,
          OP_CAT: 126,
          OP_SUBSTR: 127,
          OP_LEFT: 128,
          OP_RIGHT: 129,
          OP_SIZE: 130,
          OP_INVERT: 131,
          OP_AND: 132,
          OP_OR: 133,
          OP_XOR: 134,
          OP_EQUAL: 135,
          OP_EQUALVERIFY: 136,
          OP_RESERVED1: 137,
          OP_RESERVED2: 138,
          OP_1ADD: 139,
          OP_1SUB: 140,
          OP_2MUL: 141,
          OP_2DIV: 142,
          OP_NEGATE: 143,
          OP_ABS: 144,
          OP_NOT: 145,
          OP_0NOTEQUAL: 146,
          OP_ADD: 147,
          OP_SUB: 148,
          OP_MUL: 149,
          OP_DIV: 150,
          OP_MOD: 151,
          OP_LSHIFT: 152,
          OP_RSHIFT: 153,
          OP_BOOLAND: 154,
          OP_BOOLOR: 155,
          OP_NUMEQUAL: 156,
          OP_NUMEQUALVERIFY: 157,
          OP_NUMNOTEQUAL: 158,
          OP_LESSTHAN: 159,
          OP_GREATERTHAN: 160,
          OP_LESSTHANOREQUAL: 161,
          OP_GREATERTHANOREQUAL: 162,
          OP_MIN: 163,
          OP_MAX: 164,
          OP_WITHIN: 165,
          OP_RIPEMD160: 166,
          OP_SHA1: 167,
          OP_SHA256: 168,
          OP_HASH160: 169,
          OP_HASH256: 170,
          OP_CODESEPARATOR: 171,
          OP_CHECKSIG: 172,
          OP_CHECKSIGVERIFY: 173,
          OP_CHECKMULTISIG: 174,
          OP_CHECKMULTISIGVERIFY: 175,
          OP_NOP1: 176,
          OP_NOP2: 177,
          OP_CHECKLOCKTIMEVERIFY: 177,
          OP_NOP3: 178,
          OP_CHECKSEQUENCEVERIFY: 178,
          OP_NOP4: 179,
          OP_NOP5: 180,
          OP_NOP6: 181,
          OP_NOP7: 182,
          OP_NOP8: 183,
          OP_NOP9: 184,
          OP_NOP10: 185,
          OP_CHECKSIGADD: 186,
          OP_PUBKEYHASH: 253,
          OP_PUBKEY: 254,
          OP_INVALIDOPCODE: 255,
        };
        e.OPS = r;
        const n = {};
        e.REVERSE_OPS = n;
        for (const t of Object.keys(r)) {
          n[r[t]] = t;
        }
      },
      43011: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.MAX_TAPTREE_DEPTH = e.LEAF_VERSION_TAPSCRIPT = void 0),
          (e.rootHashFromPath = function (t, e) {
            if (t.length < 33)
              throw new TypeError(
                `The control-block length is too small. Got ${t.length}, expected min 33.`,
              );
            const r = (t.length - 33) / 32;
            let n = e;
            for (let e = 0; e < r; e++) {
              const r = t.slice(33 + 32 * e, 65 + 32 * e);
              n = f.compare(n, r) < 0 ? p(n, r) : p(r, n);
            }
            return n;
          }),
          (e.toHashTree = function t(e) {
            if ((0, c.isTapleaf)(e)) return { hash: l(e) };
            const r = [t(e[0]), t(e[1])];
            r.sort((t, e) => f.compare(t.hash, e.hash));
            const [n, i] = r;
            return { hash: p(n.hash, i.hash), left: n, right: i };
          }),
          (e.findScriptPath = function t(e, r) {
            if (h(e)) {
              const n = t(e.left, r);
              if (void 0 !== n) return [...n, e.right.hash];
              const i = t(e.right, r);
              if (void 0 !== i) return [...i, e.left.hash];
            } else if (0 === f.compare(e.hash, r)) return [];
            return;
          }),
          (e.tapleafHash = l),
          (e.tapTweakHash = d),
          (e.tweakKey = function (t, e) {
            if (!(t instanceof Uint8Array)) return null;
            if (32 !== t.length) return null;
            if (e && 32 !== e.length) return null;
            const r = d(t, e),
              n = (0, s.getEccLib)().xOnlyPointAddTweak(t, r);
            return n && null !== n.xOnlyPubkey
              ? { parity: n.parity, x: Uint8Array.from(n.xOnlyPubkey) }
              : null;
          });
        const s = r(87965),
          a = o(r(5449)),
          u = r(44311),
          c = r(90485),
          f = o(r(22333));
        (e.LEAF_VERSION_TAPSCRIPT = 192), (e.MAX_TAPTREE_DEPTH = 128);
        const h = (t) => "left" in t && "right" in t;
        function l(t) {
          const r = t.version || e.LEAF_VERSION_TAPSCRIPT;
          return a.taggedHash(
            "TapLeaf",
            f.concat([Uint8Array.from([r]), y(t.output)]),
          );
        }
        function d(t, e) {
          return a.taggedHash("TapTweak", f.concat(e ? [t, e] : [t]));
        }
        function p(t, e) {
          return a.taggedHash("TapBranch", f.concat([t, e]));
        }
        function y(t) {
          const e = u.varuint.encodingLength(t.length),
            r = new Uint8Array(e);
          return u.varuint.encode(t.length, r), f.concat([r, t]);
        }
      },
      82361: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2data = function (t, e) {
            if (!t.data && !t.output) throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              f.parse(
                f.partial(
                  f.object({
                    network: f.object({}),
                    output: u.BufferSchema,
                    data: f.array(u.BufferSchema),
                  }),
                ),
                t,
              );
            const r = { name: "embed", network: t.network || s.bitcoin };
            if (
              (c.prop(r, "output", () => {
                if (t.data) return a.compile([h.OP_RETURN].concat(t.data));
              }),
              c.prop(r, "data", () => {
                if (t.output) return a.decompile(t.output).slice(1);
              }),
              e.validate && t.output)
            ) {
              const e = a.decompile(t.output);
              if (e[0] !== h.OP_RETURN)
                throw new TypeError("Output is invalid");
              if (!e.slice(1).every((t) => f.is(u.BufferSchema, t)))
                throw new TypeError("Output is invalid");
              if (t.data && !(0, u.stacksEqual)(t.data, r.data))
                throw new TypeError("Data mismatch");
            }
            return Object.assign(r, t);
          });
        const s = r(29007),
          a = o(r(19711)),
          u = r(90485),
          c = o(r(62364)),
          f = o(r(51947)),
          h = a.OPS;
      },
      96286: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2tr =
            e.p2wsh =
            e.p2wpkh =
            e.p2sh =
            e.p2pkh =
            e.p2pk =
            e.p2ms =
            e.embed =
              void 0);
        const n = r(82361);
        Object.defineProperty(e, "embed", {
          enumerable: !0,
          get: function () {
            return n.p2data;
          },
        });
        const i = r(33284);
        Object.defineProperty(e, "p2ms", {
          enumerable: !0,
          get: function () {
            return i.p2ms;
          },
        });
        const o = r(95715);
        Object.defineProperty(e, "p2pk", {
          enumerable: !0,
          get: function () {
            return o.p2pk;
          },
        });
        const s = r(21177);
        Object.defineProperty(e, "p2pkh", {
          enumerable: !0,
          get: function () {
            return s.p2pkh;
          },
        });
        const a = r(76913);
        Object.defineProperty(e, "p2sh", {
          enumerable: !0,
          get: function () {
            return a.p2sh;
          },
        });
        const u = r(63108);
        Object.defineProperty(e, "p2wpkh", {
          enumerable: !0,
          get: function () {
            return u.p2wpkh;
          },
        });
        const c = r(27394);
        Object.defineProperty(e, "p2wsh", {
          enumerable: !0,
          get: function () {
            return c.p2wsh;
          },
        });
        const f = r(43118);
        Object.defineProperty(e, "p2tr", {
          enumerable: !0,
          get: function () {
            return f.p2tr;
          },
        });
      },
      62364: (t, e) => {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.prop = function (t, e, r) {
            Object.defineProperty(t, e, {
              configurable: !0,
              enumerable: !0,
              get() {
                const t = r.call(this);
                return (this[e] = t), t;
              },
              set(t) {
                Object.defineProperty(this, e, {
                  configurable: !0,
                  enumerable: !0,
                  value: t,
                  writable: !0,
                });
              },
            });
          }),
          (e.value = function (t) {
            let e;
            return () => (void 0 !== e || (e = t()), e);
          });
      },
      33284: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2ms = function (t, e) {
            if (
              !(
                t.input ||
                t.output ||
                (t.pubkeys && void 0 !== t.m) ||
                t.signatures
              )
            )
              throw new TypeError("Not enough data");
            function r(t) {
              return (
                a.isCanonicalScriptSignature(t) ||
                void 0 !== (e.allowIncomplete && t === h.OP_0)
              );
            }
            (e = Object.assign({ validate: !0 }, e || {})),
              f.parse(
                f.partial(
                  f.object({
                    network: f.object({}),
                    m: f.number(),
                    n: f.number(),
                    output: u.BufferSchema,
                    pubkeys: f.array(
                      f.custom(u.isPoint),
                      "Received invalid pubkey",
                    ),
                    signatures: f.array(
                      f.custom(r),
                      "Expected signature to be of type isAcceptableSignature",
                    ),
                    input: u.BufferSchema,
                  }),
                ),
                t,
              );
            const n = { network: t.network || s.bitcoin };
            let i = [],
              o = !1;
            function d(t) {
              o ||
                ((o = !0),
                (i = a.decompile(t)),
                (n.m = i[0] - l),
                (n.n = i[i.length - 2] - l),
                (n.pubkeys = i.slice(1, -2)));
            }
            if (
              (c.prop(n, "output", () => {
                if (t.m && n.n && t.pubkeys)
                  return a.compile(
                    [].concat(l + t.m, t.pubkeys, l + n.n, h.OP_CHECKMULTISIG),
                  );
              }),
              c.prop(n, "m", () => {
                if (n.output) return d(n.output), n.m;
              }),
              c.prop(n, "n", () => {
                if (n.pubkeys) return n.pubkeys.length;
              }),
              c.prop(n, "pubkeys", () => {
                if (t.output) return d(t.output), n.pubkeys;
              }),
              c.prop(n, "signatures", () => {
                if (t.input) return a.decompile(t.input).slice(1);
              }),
              c.prop(n, "input", () => {
                if (t.signatures)
                  return a.compile([h.OP_0].concat(t.signatures));
              }),
              c.prop(n, "witness", () => {
                if (n.input) return [];
              }),
              c.prop(n, "name", () => {
                if (n.m && n.n) return `p2ms(${n.m} of ${n.n})`;
              }),
              e.validate)
            ) {
              if (t.output) {
                if (
                  (d(t.output),
                  f.parse(f.number(), i[0], { message: "Output is invalid" }),
                  f.parse(f.number(), i[i.length - 2], {
                    message: "Output is invalid",
                  }),
                  i[i.length - 1] !== h.OP_CHECKMULTISIG)
                )
                  throw new TypeError("Output is invalid");
                if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== i.length - 3)
                  throw new TypeError("Output is invalid");
                if (!n.pubkeys.every((t) => (0, u.isPoint)(t)))
                  throw new TypeError("Output is invalid");
                if (void 0 !== t.m && t.m !== n.m)
                  throw new TypeError("m mismatch");
                if (void 0 !== t.n && t.n !== n.n)
                  throw new TypeError("n mismatch");
                if (t.pubkeys && !(0, u.stacksEqual)(t.pubkeys, n.pubkeys))
                  throw new TypeError("Pubkeys mismatch");
              }
              if (t.pubkeys) {
                if (void 0 !== t.n && t.n !== t.pubkeys.length)
                  throw new TypeError("Pubkey count mismatch");
                if (((n.n = t.pubkeys.length), n.n < n.m))
                  throw new TypeError("Pubkey count cannot be less than m");
              }
              if (t.signatures) {
                if (t.signatures.length < n.m)
                  throw new TypeError("Not enough signatures provided");
                if (t.signatures.length > n.m)
                  throw new TypeError("Too many signatures provided");
              }
              if (t.input) {
                if (t.input[0] !== h.OP_0)
                  throw new TypeError("Input is invalid");
                if (0 === n.signatures.length || !n.signatures.every(r))
                  throw new TypeError("Input has invalid signature(s)");
                if (
                  t.signatures &&
                  !(0, u.stacksEqual)(t.signatures, n.signatures)
                )
                  throw new TypeError("Signature mismatch");
                if (void 0 !== t.m && t.m !== t.signatures.length)
                  throw new TypeError("Signature count mismatch");
              }
            }
            return Object.assign(n, t);
          });
        const s = r(29007),
          a = o(r(19711)),
          u = r(90485),
          c = o(r(62364)),
          f = o(r(51947)),
          h = a.OPS,
          l = h.OP_RESERVED;
      },
      95715: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2pk = function (t, e) {
            if (!(t.input || t.output || t.pubkey || t.input || t.signature))
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              h.parse(
                h.partial(
                  h.object({
                    network: h.object({}),
                    output: u.BufferSchema,
                    pubkey: h.custom(u.isPoint, "invalid pubkey"),
                    signature: h.custom(
                      a.isCanonicalScriptSignature,
                      "Expected signature to be of type isCanonicalScriptSignature",
                    ),
                    input: u.BufferSchema,
                  }),
                ),
                t,
              );
            const r = c.value(() => a.decompile(t.input)),
              n = { name: "p2pk", network: t.network || s.bitcoin };
            if (
              (c.prop(n, "output", () => {
                if (t.pubkey) return a.compile([t.pubkey, l.OP_CHECKSIG]);
              }),
              c.prop(n, "pubkey", () => {
                if (t.output) return t.output.slice(1, -1);
              }),
              c.prop(n, "signature", () => {
                if (t.input) return r()[0];
              }),
              c.prop(n, "input", () => {
                if (t.signature) return a.compile([t.signature]);
              }),
              c.prop(n, "witness", () => {
                if (n.input) return [];
              }),
              e.validate)
            ) {
              if (t.output) {
                if (t.output[t.output.length - 1] !== l.OP_CHECKSIG)
                  throw new TypeError("Output is invalid");
                if (!(0, u.isPoint)(n.pubkey))
                  throw new TypeError("Output pubkey is invalid");
                if (t.pubkey && 0 !== f.compare(t.pubkey, n.pubkey))
                  throw new TypeError("Pubkey mismatch");
              }
              if (t.signature && t.input && 0 !== f.compare(t.input, n.input))
                throw new TypeError("Signature mismatch");
              if (t.input) {
                if (1 !== r().length) throw new TypeError("Input is invalid");
                if (!a.isCanonicalScriptSignature(n.signature))
                  throw new TypeError("Input has invalid signature");
              }
            }
            return Object.assign(n, t);
          });
        const s = r(29007),
          a = o(r(19711)),
          u = r(90485),
          c = o(r(62364)),
          f = o(r(22333)),
          h = o(r(51947)),
          l = a.OPS;
      },
      21177: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            },
          s =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2pkh = function (t, e) {
            if (!(t.address || t.hash || t.output || t.pubkey || t.input))
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              p.parse(
                p.partial(
                  p.object({
                    network: p.object({}),
                    address: p.string(),
                    hash: f.Hash160bitSchema,
                    output: (0, f.NBufferSchemaFactory)(25),
                    pubkey: p.custom(f.isPoint),
                    signature: p.custom(c.isCanonicalScriptSignature),
                    input: f.BufferSchema,
                  }),
                ),
                t,
              );
            const r = h.value(() => {
                const e = l.default.decode(t.address);
                return { version: d.readUInt8(e, 0), hash: e.slice(1) };
              }),
              n = h.value(() => c.decompile(t.input)),
              i = t.network || u.bitcoin,
              o = { name: "p2pkh", network: i };
            if (
              (h.prop(o, "address", () => {
                if (!o.hash) return;
                const t = new Uint8Array(21);
                return (
                  d.writeUInt8(t, 0, i.pubKeyHash),
                  t.set(o.hash, 1),
                  l.default.encode(t)
                );
              }),
              h.prop(o, "hash", () =>
                t.output
                  ? t.output.slice(3, 23)
                  : t.address
                    ? r().hash
                    : t.pubkey || o.pubkey
                      ? a.hash160(t.pubkey || o.pubkey)
                      : void 0,
              ),
              h.prop(o, "output", () => {
                if (o.hash)
                  return c.compile([
                    y.OP_DUP,
                    y.OP_HASH160,
                    o.hash,
                    y.OP_EQUALVERIFY,
                    y.OP_CHECKSIG,
                  ]);
              }),
              h.prop(o, "pubkey", () => {
                if (t.input) return n()[1];
              }),
              h.prop(o, "signature", () => {
                if (t.input) return n()[0];
              }),
              h.prop(o, "input", () => {
                if (t.pubkey && t.signature)
                  return c.compile([t.signature, t.pubkey]);
              }),
              h.prop(o, "witness", () => {
                if (o.input) return [];
              }),
              e.validate)
            ) {
              let e = Uint8Array.from([]);
              if (t.address) {
                if (r().version !== i.pubKeyHash)
                  throw new TypeError("Invalid version or Network mismatch");
                if (20 !== r().hash.length)
                  throw new TypeError("Invalid address");
                e = r().hash;
              }
              if (t.hash) {
                if (e.length > 0 && 0 !== d.compare(e, t.hash))
                  throw new TypeError("Hash mismatch");
                e = t.hash;
              }
              if (t.output) {
                if (
                  25 !== t.output.length ||
                  t.output[0] !== y.OP_DUP ||
                  t.output[1] !== y.OP_HASH160 ||
                  20 !== t.output[2] ||
                  t.output[23] !== y.OP_EQUALVERIFY ||
                  t.output[24] !== y.OP_CHECKSIG
                )
                  throw new TypeError("Output is invalid");
                const r = t.output.slice(3, 23);
                if (e.length > 0 && 0 !== d.compare(e, r))
                  throw new TypeError("Hash mismatch");
                e = r;
              }
              if (t.pubkey) {
                const r = a.hash160(t.pubkey);
                if (e.length > 0 && 0 !== d.compare(e, r))
                  throw new TypeError("Hash mismatch");
                e = r;
              }
              if (t.input) {
                const r = n();
                if (2 !== r.length) throw new TypeError("Input is invalid");
                if (!c.isCanonicalScriptSignature(r[0]))
                  throw new TypeError("Input has invalid signature");
                if (!(0, f.isPoint)(r[1]))
                  throw new TypeError("Input has invalid pubkey");
                if (t.signature && 0 !== d.compare(t.signature, r[0]))
                  throw new TypeError("Signature mismatch");
                if (t.pubkey && 0 !== d.compare(t.pubkey, r[1]))
                  throw new TypeError("Pubkey mismatch");
                const i = a.hash160(r[1]);
                if (e.length > 0 && 0 !== d.compare(e, i))
                  throw new TypeError("Hash mismatch");
              }
            }
            return Object.assign(o, t);
          });
        const a = o(r(5449)),
          u = r(29007),
          c = o(r(19711)),
          f = r(90485),
          h = o(r(62364)),
          l = s(r(30681)),
          d = o(r(22333)),
          p = o(r(51947)),
          y = c.OPS;
      },
      76913: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            },
          s =
            (this && this.__importDefault) ||
            function (t) {
              return t && t.__esModule ? t : { default: t };
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2sh = function (t, e) {
            if (!(t.address || t.hash || t.output || t.redeem || t.input))
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              p.parse(
                p.partial(
                  p.object({
                    network: p.object({}),
                    address: p.string(),
                    hash: (0, f.NBufferSchemaFactory)(20),
                    output: (0, f.NBufferSchemaFactory)(23),
                    redeem: p.partial(
                      p.object({
                        network: p.object({}),
                        output: f.BufferSchema,
                        input: f.BufferSchema,
                        witness: p.array(f.BufferSchema),
                      }),
                    ),
                    input: f.BufferSchema,
                    witness: p.array(f.BufferSchema),
                  }),
                ),
                t,
              );
            let r = t.network;
            r || (r = (t.redeem && t.redeem.network) || u.bitcoin);
            const n = { network: r },
              i = h.value(() => {
                const e = l.default.decode(t.address);
                return { version: d.readUInt8(e, 0), hash: e.slice(1) };
              }),
              o = h.value(() => c.decompile(t.input)),
              s = h.value(() => {
                const e = o(),
                  n = e[e.length - 1];
                return {
                  network: r,
                  output: n === y.OP_FALSE ? Uint8Array.from([]) : n,
                  input: c.compile(e.slice(0, -1)),
                  witness: t.witness || [],
                };
              });
            if (
              (h.prop(n, "address", () => {
                if (!n.hash) return;
                const t = new Uint8Array(21);
                return (
                  d.writeUInt8(t, 0, n.network.scriptHash),
                  t.set(n.hash, 1),
                  l.default.encode(t)
                );
              }),
              h.prop(n, "hash", () =>
                t.output
                  ? t.output.slice(2, 22)
                  : t.address
                    ? i().hash
                    : n.redeem && n.redeem.output
                      ? a.hash160(n.redeem.output)
                      : void 0,
              ),
              h.prop(n, "output", () => {
                if (n.hash)
                  return c.compile([y.OP_HASH160, n.hash, y.OP_EQUAL]);
              }),
              h.prop(n, "redeem", () => {
                if (t.input) return s();
              }),
              h.prop(n, "input", () => {
                if (t.redeem && t.redeem.input && t.redeem.output)
                  return c.compile(
                    [].concat(c.decompile(t.redeem.input), t.redeem.output),
                  );
              }),
              h.prop(n, "witness", () =>
                n.redeem && n.redeem.witness
                  ? n.redeem.witness
                  : n.input
                    ? []
                    : void 0,
              ),
              h.prop(n, "name", () => {
                const t = ["p2sh"];
                return (
                  void 0 !== n.redeem &&
                    void 0 !== n.redeem.name &&
                    t.push(n.redeem.name),
                  t.join("-")
                );
              }),
              e.validate)
            ) {
              let e = Uint8Array.from([]);
              if (t.address) {
                if (i().version !== r.scriptHash)
                  throw new TypeError("Invalid version or Network mismatch");
                if (20 !== i().hash.length)
                  throw new TypeError("Invalid address");
                e = i().hash;
              }
              if (t.hash) {
                if (e.length > 0 && 0 !== d.compare(e, t.hash))
                  throw new TypeError("Hash mismatch");
                e = t.hash;
              }
              if (t.output) {
                if (
                  23 !== t.output.length ||
                  t.output[0] !== y.OP_HASH160 ||
                  20 !== t.output[1] ||
                  t.output[22] !== y.OP_EQUAL
                )
                  throw new TypeError("Output is invalid");
                const r = t.output.slice(2, 22);
                if (e.length > 0 && 0 !== d.compare(e, r))
                  throw new TypeError("Hash mismatch");
                e = r;
              }
              const n = (t) => {
                if (t.output) {
                  const r = c.decompile(t.output);
                  if (!r || r.length < 1)
                    throw new TypeError("Redeem.output too short");
                  if (t.output.byteLength > 520)
                    throw new TypeError(
                      "Redeem.output unspendable if larger than 520 bytes",
                    );
                  if (c.countNonPushOnlyOPs(r) > 201)
                    throw new TypeError(
                      "Redeem.output unspendable with more than 201 non-push ops",
                    );
                  const n = a.hash160(t.output);
                  if (e.length > 0 && 0 !== d.compare(e, n))
                    throw new TypeError("Hash mismatch");
                  e = n;
                }
                if (t.input) {
                  const e = t.input.length > 0,
                    r = t.witness && t.witness.length > 0;
                  if (!e && !r) throw new TypeError("Empty input");
                  if (e && r) throw new TypeError("Input and witness provided");
                  if (e) {
                    const e = c.decompile(t.input);
                    if (!c.isPushOnly(e))
                      throw new TypeError("Non push-only scriptSig");
                  }
                }
              };
              if (t.input) {
                const t = o();
                if (!t || t.length < 1) throw new TypeError("Input too short");
                if (!(s().output instanceof Uint8Array))
                  throw new TypeError("Input is invalid");
                n(s());
              }
              if (t.redeem) {
                if (t.redeem.network && t.redeem.network !== r)
                  throw new TypeError("Network mismatch");
                if (t.input) {
                  const e = s();
                  if (
                    t.redeem.output &&
                    0 !== d.compare(t.redeem.output, e.output)
                  )
                    throw new TypeError("Redeem.output mismatch");
                  if (
                    t.redeem.input &&
                    0 !== d.compare(t.redeem.input, e.input)
                  )
                    throw new TypeError("Redeem.input mismatch");
                }
                n(t.redeem);
              }
              if (
                t.witness &&
                t.redeem &&
                t.redeem.witness &&
                !(0, f.stacksEqual)(t.redeem.witness, t.witness)
              )
                throw new TypeError("Witness and redeem.witness mismatch");
            }
            return Object.assign(n, t);
          });
        const a = o(r(5449)),
          u = r(29007),
          c = o(r(19711)),
          f = r(90485),
          h = o(r(62364)),
          l = s(r(30681)),
          d = o(r(22333)),
          p = o(r(51947)),
          y = c.OPS;
      },
      43118: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2tr = function (t, e) {
            if (
              !(
                t.address ||
                t.output ||
                t.pubkey ||
                t.internalPubkey ||
                (t.witness && t.witness.length > 1)
              )
            )
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              y.parse(
                y.partial(
                  y.object({
                    address: y.string(),
                    input: (0, u.NBufferSchemaFactory)(0),
                    network: y.object({}),
                    output: (0, u.NBufferSchemaFactory)(34),
                    internalPubkey: (0, u.NBufferSchemaFactory)(32),
                    hash: (0, u.NBufferSchemaFactory)(32),
                    pubkey: (0, u.NBufferSchemaFactory)(32),
                    signature: y.union([
                      (0, u.NBufferSchemaFactory)(64),
                      (0, u.NBufferSchemaFactory)(65),
                    ]),
                    witness: y.array(u.BufferSchema),
                    scriptTree: y.custom(
                      u.isTaptree,
                      "Taptree is not of type isTaptree",
                    ),
                    redeem: y.partial(
                      y.object({
                        output: u.BufferSchema,
                        redeemVersion: y.number(),
                        witness: y.array(u.BufferSchema),
                      }),
                    ),
                    redeemVersion: y.number(),
                  }),
                ),
                t,
              );
            const r = h.value(() => (0, d.fromBech32)(t.address)),
              n = h.value(() => {
                if (t.witness && t.witness.length)
                  return t.witness.length >= 2 &&
                    t.witness[t.witness.length - 1][0] === b
                    ? t.witness.slice(0, -1)
                    : t.witness.slice();
              }),
              i = h.value(() =>
                t.scriptTree
                  ? (0, f.toHashTree)(t.scriptTree)
                  : t.hash
                    ? { hash: t.hash }
                    : void 0,
              ),
              o = t.network || s.bitcoin,
              w = { name: "p2tr", network: o };
            if (
              (h.prop(w, "address", () => {
                if (!w.pubkey) return;
                const t = l.bech32m.toWords(w.pubkey);
                return t.unshift(m), l.bech32m.encode(o.bech32, t);
              }),
              h.prop(w, "hash", () => {
                const t = i();
                if (t) return t.hash;
                const e = n();
                if (e && e.length > 1) {
                  const t = e[e.length - 1],
                    r = t[0] & u.TAPLEAF_VERSION_MASK,
                    n = e[e.length - 2],
                    i = (0, f.tapleafHash)({ output: n, version: r });
                  return (0, f.rootHashFromPath)(t, i);
                }
                return null;
              }),
              h.prop(w, "output", () => {
                if (w.pubkey) return a.compile([g.OP_1, w.pubkey]);
              }),
              h.prop(w, "redeemVersion", () =>
                t.redeemVersion
                  ? t.redeemVersion
                  : t.redeem &&
                      void 0 !== t.redeem.redeemVersion &&
                      null !== t.redeem.redeemVersion
                    ? t.redeem.redeemVersion
                    : f.LEAF_VERSION_TAPSCRIPT,
              ),
              h.prop(w, "redeem", () => {
                const t = n();
                if (t && !(t.length < 2))
                  return {
                    output: t[t.length - 2],
                    witness: t.slice(0, -2),
                    redeemVersion: t[t.length - 1][0] & u.TAPLEAF_VERSION_MASK,
                  };
              }),
              h.prop(w, "pubkey", () => {
                if (t.pubkey) return t.pubkey;
                if (t.output) return t.output.slice(2);
                if (t.address) return r().data;
                if (w.internalPubkey) {
                  const t = (0, f.tweakKey)(w.internalPubkey, w.hash);
                  if (t) return t.x;
                }
              }),
              h.prop(w, "internalPubkey", () => {
                if (t.internalPubkey) return t.internalPubkey;
                const e = n();
                return e && e.length > 1
                  ? e[e.length - 1].slice(1, 33)
                  : void 0;
              }),
              h.prop(w, "signature", () => {
                if (t.signature) return t.signature;
                const e = n();
                return e && 1 === e.length ? e[0] : void 0;
              }),
              h.prop(w, "witness", () => {
                if (t.witness) return t.witness;
                const e = i();
                if (e && t.redeem && t.redeem.output && t.internalPubkey) {
                  const r = (0, f.tapleafHash)({
                      output: t.redeem.output,
                      version: w.redeemVersion,
                    }),
                    n = (0, f.findScriptPath)(e, r);
                  if (!n) return;
                  const i = (0, f.tweakKey)(t.internalPubkey, e.hash);
                  if (!i) return;
                  const o = p.concat(
                    [
                      Uint8Array.from([w.redeemVersion | i.parity]),
                      t.internalPubkey,
                    ].concat(n),
                  );
                  return [t.redeem.output, o];
                }
                return t.signature ? [t.signature] : void 0;
              }),
              e.validate)
            ) {
              let e = Uint8Array.from([]);
              if (t.address) {
                if (o && o.bech32 !== r().prefix)
                  throw new TypeError("Invalid prefix or Network mismatch");
                if (r().version !== m)
                  throw new TypeError("Invalid address version");
                if (32 !== r().data.length)
                  throw new TypeError("Invalid address data");
                e = r().data;
              }
              if (t.pubkey) {
                if (e.length > 0 && 0 !== p.compare(e, t.pubkey))
                  throw new TypeError("Pubkey mismatch");
                e = t.pubkey;
              }
              if (t.output) {
                if (
                  34 !== t.output.length ||
                  t.output[0] !== g.OP_1 ||
                  32 !== t.output[1]
                )
                  throw new TypeError("Output is invalid");
                if (e.length > 0 && 0 !== p.compare(e, t.output.slice(2)))
                  throw new TypeError("Pubkey mismatch");
                e = t.output.slice(2);
              }
              if (t.internalPubkey) {
                const r = (0, f.tweakKey)(t.internalPubkey, w.hash);
                if (e.length > 0 && 0 !== p.compare(e, r.x))
                  throw new TypeError("Pubkey mismatch");
                e = r.x;
              }
              if (e && e.length && !(0, c.getEccLib)().isXOnlyPoint(e))
                throw new TypeError("Invalid pubkey for p2tr");
              const s = i();
              if (t.hash && s && 0 !== p.compare(t.hash, s.hash))
                throw new TypeError("Hash mismatch");
              if (t.redeem && t.redeem.output && s) {
                const e = (0, f.tapleafHash)({
                  output: t.redeem.output,
                  version: w.redeemVersion,
                });
                if (!(0, f.findScriptPath)(s, e))
                  throw new TypeError("Redeem script not in tree");
              }
              const h = n();
              if (t.redeem && w.redeem) {
                if (
                  t.redeem.redeemVersion &&
                  t.redeem.redeemVersion !== w.redeem.redeemVersion
                )
                  throw new TypeError(
                    "Redeem.redeemVersion and witness mismatch",
                  );
                if (t.redeem.output) {
                  if (0 === a.decompile(t.redeem.output).length)
                    throw new TypeError("Redeem.output is invalid");
                  if (
                    w.redeem.output &&
                    0 !== p.compare(t.redeem.output, w.redeem.output)
                  )
                    throw new TypeError("Redeem.output and witness mismatch");
                }
                if (
                  t.redeem.witness &&
                  w.redeem.witness &&
                  !(0, u.stacksEqual)(t.redeem.witness, w.redeem.witness)
                )
                  throw new TypeError("Redeem.witness and witness mismatch");
              }
              if (h && h.length)
                if (1 === h.length) {
                  if (t.signature && 0 !== p.compare(t.signature, h[0]))
                    throw new TypeError("Signature mismatch");
                } else {
                  const r = h[h.length - 1];
                  if (r.length < 33)
                    throw new TypeError(
                      `The control-block length is too small. Got ${r.length}, expected min 33.`,
                    );
                  if ((r.length - 33) % 32 != 0)
                    throw new TypeError(
                      `The control-block length of ${r.length} is incorrect!`,
                    );
                  const n = (r.length - 33) / 32;
                  if (n > 128)
                    throw new TypeError(
                      `The script path is too long. Got ${n}, expected max 128.`,
                    );
                  const i = r.slice(1, 33);
                  if (t.internalPubkey && 0 !== p.compare(t.internalPubkey, i))
                    throw new TypeError("Internal pubkey mismatch");
                  if (!(0, c.getEccLib)().isXOnlyPoint(i))
                    throw new TypeError(
                      "Invalid internalPubkey for p2tr witness",
                    );
                  const o = r[0] & u.TAPLEAF_VERSION_MASK,
                    s = h[h.length - 2],
                    a = (0, f.tapleafHash)({ output: s, version: o }),
                    l = (0, f.rootHashFromPath)(r, a),
                    d = (0, f.tweakKey)(i, l);
                  if (!d)
                    throw new TypeError("Invalid outputKey for p2tr witness");
                  if (e.length && 0 !== p.compare(e, d.x))
                    throw new TypeError("Pubkey mismatch for p2tr witness");
                  if (d.parity !== (1 & r[0]))
                    throw new Error("Incorrect parity");
                }
            }
            return Object.assign(w, t);
          });
        const s = r(29007),
          a = o(r(19711)),
          u = r(90485),
          c = r(87965),
          f = r(43011),
          h = o(r(62364)),
          l = r(22343),
          d = r(22058),
          p = o(r(22333)),
          y = o(r(51947)),
          g = a.OPS,
          m = 1,
          b = 80;
      },
      63108: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2wpkh = function (t, e) {
            if (!(t.address || t.hash || t.output || t.pubkey || t.witness))
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              d.parse(
                d.partial(
                  d.object({
                    address: d.string(),
                    hash: (0, c.NBufferSchemaFactory)(20),
                    input: (0, c.NBufferSchemaFactory)(0),
                    network: d.object({}),
                    output: (0, c.NBufferSchemaFactory)(22),
                    pubkey: d.custom(c.isPoint, "Not a valid pubkey"),
                    signature: d.custom(u.isCanonicalScriptSignature),
                    witness: d.array(c.BufferSchema),
                  }),
                ),
                t,
              );
            const r = f.value(() => {
                const e = h.bech32.decode(t.address),
                  r = e.words.shift(),
                  n = h.bech32.fromWords(e.words);
                return {
                  version: r,
                  prefix: e.prefix,
                  data: Uint8Array.from(n),
                };
              }),
              n = t.network || a.bitcoin,
              i = { name: "p2wpkh", network: n };
            if (
              (f.prop(i, "address", () => {
                if (!i.hash) return;
                const t = h.bech32.toWords(i.hash);
                return t.unshift(0), h.bech32.encode(n.bech32, t);
              }),
              f.prop(i, "hash", () =>
                t.output
                  ? t.output.slice(2, 22)
                  : t.address
                    ? r().data
                    : t.pubkey || i.pubkey
                      ? s.hash160(t.pubkey || i.pubkey)
                      : void 0,
              ),
              f.prop(i, "output", () => {
                if (i.hash) return u.compile([p.OP_0, i.hash]);
              }),
              f.prop(i, "pubkey", () =>
                t.pubkey ? t.pubkey : t.witness ? t.witness[1] : void 0,
              ),
              f.prop(i, "signature", () => {
                if (t.witness) return t.witness[0];
              }),
              f.prop(i, "input", () => {
                if (i.witness) return y;
              }),
              f.prop(i, "witness", () => {
                if (t.pubkey && t.signature) return [t.signature, t.pubkey];
              }),
              e.validate)
            ) {
              let e = Uint8Array.from([]);
              if (t.address) {
                if (n && n.bech32 !== r().prefix)
                  throw new TypeError("Invalid prefix or Network mismatch");
                if (0 !== r().version)
                  throw new TypeError("Invalid address version");
                if (20 !== r().data.length)
                  throw new TypeError("Invalid address data");
                e = r().data;
              }
              if (t.hash) {
                if (e.length > 0 && 0 !== l.compare(e, t.hash))
                  throw new TypeError("Hash mismatch");
                e = t.hash;
              }
              if (t.output) {
                if (
                  22 !== t.output.length ||
                  t.output[0] !== p.OP_0 ||
                  20 !== t.output[1]
                )
                  throw new TypeError("Output is invalid");
                if (e.length > 0 && 0 !== l.compare(e, t.output.slice(2)))
                  throw new TypeError("Hash mismatch");
                e = t.output.slice(2);
              }
              if (t.pubkey) {
                const r = s.hash160(t.pubkey);
                if (e.length > 0 && 0 !== l.compare(e, r))
                  throw new TypeError("Hash mismatch");
                if (
                  ((e = r), !(0, c.isPoint)(t.pubkey) || 33 !== t.pubkey.length)
                )
                  throw new TypeError("Invalid pubkey for p2wpkh");
              }
              if (t.witness) {
                if (2 !== t.witness.length)
                  throw new TypeError("Witness is invalid");
                if (!u.isCanonicalScriptSignature(t.witness[0]))
                  throw new TypeError("Witness has invalid signature");
                if (!(0, c.isPoint)(t.witness[1]) || 33 !== t.witness[1].length)
                  throw new TypeError("Witness has invalid pubkey");
                if (t.signature && 0 !== l.compare(t.signature, t.witness[0]))
                  throw new TypeError("Signature mismatch");
                if (t.pubkey && 0 !== l.compare(t.pubkey, t.witness[1]))
                  throw new TypeError("Pubkey mismatch");
                const r = s.hash160(t.witness[1]);
                if (e.length > 0 && 0 !== l.compare(e, r))
                  throw new TypeError("Hash mismatch");
              }
            }
            return Object.assign(i, t);
          });
        const s = o(r(5449)),
          a = r(29007),
          u = o(r(19711)),
          c = r(90485),
          f = o(r(62364)),
          h = r(22343),
          l = o(r(22333)),
          d = o(r(51947)),
          p = u.OPS,
          y = new Uint8Array(0);
      },
      27394: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.p2wsh = function (t, e) {
            if (!(t.address || t.hash || t.output || t.redeem || t.witness))
              throw new TypeError("Not enough data");
            (e = Object.assign({ validate: !0 }, e || {})),
              d.parse(
                (0, c.NullablePartial)({
                  network: d.object({}),
                  address: d.string(),
                  hash: c.Buffer256bitSchema,
                  output: (0, c.NBufferSchemaFactory)(34),
                  redeem: (0, c.NullablePartial)({
                    input: c.BufferSchema,
                    network: d.object({}),
                    output: c.BufferSchema,
                    witness: d.array(c.BufferSchema),
                  }),
                  input: (0, c.NBufferSchemaFactory)(0),
                  witness: d.array(c.BufferSchema),
                }),
                t,
              );
            const r = f.value(() => {
                const e = h.bech32.decode(t.address),
                  r = e.words.shift(),
                  n = h.bech32.fromWords(e.words);
                return {
                  version: r,
                  prefix: e.prefix,
                  data: Uint8Array.from(n),
                };
              }),
              n = f.value(() => u.decompile(t.redeem.input));
            let i = t.network;
            i || (i = (t.redeem && t.redeem.network) || a.bitcoin);
            const o = { network: i };
            if (
              (f.prop(o, "address", () => {
                if (!o.hash) return;
                const t = h.bech32.toWords(o.hash);
                return t.unshift(0), h.bech32.encode(i.bech32, t);
              }),
              f.prop(o, "hash", () =>
                t.output
                  ? t.output.slice(2)
                  : t.address
                    ? r().data
                    : o.redeem && o.redeem.output
                      ? (0, s.sha256)(o.redeem.output)
                      : void 0,
              ),
              f.prop(o, "output", () => {
                if (o.hash) return u.compile([p.OP_0, o.hash]);
              }),
              f.prop(o, "redeem", () => {
                if (t.witness)
                  return {
                    output: t.witness[t.witness.length - 1],
                    input: y,
                    witness: t.witness.slice(0, -1),
                  };
              }),
              f.prop(o, "input", () => {
                if (o.witness) return y;
              }),
              f.prop(o, "witness", () => {
                if (
                  t.redeem &&
                  t.redeem.input &&
                  t.redeem.input.length > 0 &&
                  t.redeem.output &&
                  t.redeem.output.length > 0
                ) {
                  const e = u.toStack(n());
                  return (
                    (o.redeem = Object.assign({ witness: e }, t.redeem)),
                    (o.redeem.input = y),
                    [].concat(e, t.redeem.output)
                  );
                }
                if (t.redeem && t.redeem.output && t.redeem.witness)
                  return [].concat(t.redeem.witness, t.redeem.output);
              }),
              f.prop(o, "name", () => {
                const t = ["p2wsh"];
                return (
                  void 0 !== o.redeem &&
                    void 0 !== o.redeem.name &&
                    t.push(o.redeem.name),
                  t.join("-")
                );
              }),
              e.validate)
            ) {
              let e = Uint8Array.from([]);
              if (t.address) {
                if (r().prefix !== i.bech32)
                  throw new TypeError("Invalid prefix or Network mismatch");
                if (0 !== r().version)
                  throw new TypeError("Invalid address version");
                if (32 !== r().data.length)
                  throw new TypeError("Invalid address data");
                e = r().data;
              }
              if (t.hash) {
                if (e.length > 0 && 0 !== l.compare(e, t.hash))
                  throw new TypeError("Hash mismatch");
                e = t.hash;
              }
              if (t.output) {
                if (
                  34 !== t.output.length ||
                  t.output[0] !== p.OP_0 ||
                  32 !== t.output[1]
                )
                  throw new TypeError("Output is invalid");
                const r = t.output.slice(2);
                if (e.length > 0 && 0 !== l.compare(e, r))
                  throw new TypeError("Hash mismatch");
                e = r;
              }
              if (t.redeem) {
                if (t.redeem.network && t.redeem.network !== i)
                  throw new TypeError("Network mismatch");
                if (
                  t.redeem.input &&
                  t.redeem.input.length > 0 &&
                  t.redeem.witness &&
                  t.redeem.witness.length > 0
                )
                  throw new TypeError("Ambiguous witness source");
                if (t.redeem.output) {
                  const r = u.decompile(t.redeem.output);
                  if (!r || r.length < 1)
                    throw new TypeError("Redeem.output is invalid");
                  if (t.redeem.output.byteLength > 3600)
                    throw new TypeError(
                      "Redeem.output unspendable if larger than 3600 bytes",
                    );
                  if (u.countNonPushOnlyOPs(r) > 201)
                    throw new TypeError(
                      "Redeem.output unspendable with more than 201 non-push ops",
                    );
                  const n = (0, s.sha256)(t.redeem.output);
                  if (e.length > 0 && 0 !== l.compare(e, n))
                    throw new TypeError("Hash mismatch");
                  e = n;
                }
                if (t.redeem.input && !u.isPushOnly(n()))
                  throw new TypeError("Non push-only scriptSig");
                if (
                  t.witness &&
                  t.redeem.witness &&
                  !(0, c.stacksEqual)(t.witness, t.redeem.witness)
                )
                  throw new TypeError("Witness and redeem.witness mismatch");
                if (
                  (t.redeem.input && n().some(g)) ||
                  (t.redeem.output &&
                    (u.decompile(t.redeem.output) || []).some(g))
                )
                  throw new TypeError(
                    "redeem.input or redeem.output contains uncompressed pubkey",
                  );
              }
              if (t.witness && t.witness.length > 0) {
                const e = t.witness[t.witness.length - 1];
                if (
                  t.redeem &&
                  t.redeem.output &&
                  0 !== l.compare(t.redeem.output, e)
                )
                  throw new TypeError("Witness and redeem.output mismatch");
                if (t.witness.some(g) || (u.decompile(e) || []).some(g))
                  throw new TypeError("Witness contains uncompressed pubkey");
              }
            }
            return Object.assign(o, t);
          });
        const s = r(22623),
          a = r(29007),
          u = o(r(19711)),
          c = r(90485),
          f = o(r(62364)),
          h = r(22343),
          l = o(r(22333)),
          d = o(r(51947)),
          p = u.OPS,
          y = new Uint8Array(0);
        function g(t) {
          return !!(
            t instanceof Uint8Array &&
            65 === t.length &&
            4 === t[0] &&
            (0, c.isPoint)(t)
          );
        }
      },
      5055: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Psbt = void 0);
        const s = r(92933),
          a = o(r(60882)),
          u = r(92933),
          c = r(22058),
          f = r(44311),
          h = r(29007),
          l = o(r(96286)),
          d = r(43011),
          p = o(r(19711)),
          y = r(54110),
          g = r(1878),
          m = r(13730),
          b = o(r(22333)),
          w = { network: h.bitcoin, maximumFeeRate: 5e3 };
        class v {
          data;
          static fromBase64(t, e = {}) {
            const r = b.fromBase64(t);
            return this.fromBuffer(r, e);
          }
          static fromHex(t, e = {}) {
            const r = b.fromHex(t);
            return this.fromBuffer(r, e);
          }
          static fromBuffer(t, e = {}) {
            const r = s.Psbt.fromBuffer(t, _),
              n = new v(e, r);
            var i, o;
            return (
              (i = n.__CACHE.__TX),
              (o = n.__CACHE),
              i.ins.forEach((t) => {
                x(o, t);
              }),
              n
            );
          }
          __CACHE;
          opts;
          constructor(t = {}, e = new s.Psbt(new E())) {
            (this.data = e),
              (this.opts = Object.assign({}, w, t)),
              (this.__CACHE = {
                __NON_WITNESS_UTXO_TX_CACHE: [],
                __NON_WITNESS_UTXO_BUF_CACHE: [],
                __TX_IN_CACHE: {},
                __TX: this.data.globalMap.unsignedTx.tx,
                __UNSAFE_SIGN_NONSEGWIT: !1,
              }),
              0 === this.data.inputs.length && this.setVersion(2);
            const r = (t, e, r, n) =>
              Object.defineProperty(t, e, { enumerable: r, writable: n });
            r(this, "__CACHE", !1, !0), r(this, "opts", !1, !0);
          }
          get inputCount() {
            return this.data.inputs.length;
          }
          get version() {
            return this.__CACHE.__TX.version;
          }
          set version(t) {
            this.setVersion(t);
          }
          get locktime() {
            return this.__CACHE.__TX.locktime;
          }
          set locktime(t) {
            this.setLocktime(t);
          }
          get txInputs() {
            return this.__CACHE.__TX.ins.map((t) => ({
              hash: (0, f.cloneBuffer)(t.hash),
              index: t.index,
              sequence: t.sequence,
            }));
          }
          get txOutputs() {
            return this.__CACHE.__TX.outs.map((t) => {
              let e;
              try {
                e = (0, c.fromOutputScript)(t.script, this.opts.network);
              } catch (t) {}
              return {
                script: (0, f.cloneBuffer)(t.script),
                value: t.value,
                address: e,
              };
            });
          }
          combine(...t) {
            return this.data.combine(...t.map((t) => t.data)), this;
          }
          clone() {
            const t = v.fromBuffer(this.data.toBuffer());
            return (t.opts = JSON.parse(JSON.stringify(this.opts))), t;
          }
          setMaximumFeeRate(t) {
            T(t), (this.opts.maximumFeeRate = t);
          }
          setVersion(t) {
            T(t), k(this.data.inputs, "setVersion");
            const e = this.__CACHE;
            return (e.__TX.version = t), (e.__EXTRACTED_TX = void 0), this;
          }
          setLocktime(t) {
            T(t), k(this.data.inputs, "setLocktime");
            const e = this.__CACHE;
            return (e.__TX.locktime = t), (e.__EXTRACTED_TX = void 0), this;
          }
          setInputSequence(t, e) {
            T(e), k(this.data.inputs, "setInputSequence");
            const r = this.__CACHE;
            if (r.__TX.ins.length <= t) throw new Error("Input index too high");
            return (
              (r.__TX.ins[t].sequence = e), (r.__EXTRACTED_TX = void 0), this
            );
          }
          addInputs(t) {
            return t.forEach((t) => this.addInput(t)), this;
          }
          addInput(t) {
            if (
              arguments.length > 1 ||
              !t ||
              void 0 === t.hash ||
              void 0 === t.index
            )
              throw new Error(
                "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]",
              );
            (0, g.checkTaprootInputFields)(t, t, "addInput"),
              k(this.data.inputs, "addInput"),
              t.witnessScript && Z(t.witnessScript);
            const e = this.__CACHE;
            this.data.addInput(t);
            x(e, e.__TX.ins[e.__TX.ins.length - 1]);
            const r = this.data.inputs.length - 1,
              n = this.data.inputs[r];
            return (
              n.nonWitnessUtxo && q(this.__CACHE, n, r),
              (e.__FEE = void 0),
              (e.__FEE_RATE = void 0),
              (e.__EXTRACTED_TX = void 0),
              this
            );
          }
          addOutputs(t) {
            return t.forEach((t) => this.addOutput(t)), this;
          }
          addOutput(t) {
            if (
              arguments.length > 1 ||
              !t ||
              void 0 === t.value ||
              (void 0 === t.address && void 0 === t.script)
            )
              throw new Error(
                "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]",
              );
            k(this.data.inputs, "addOutput");
            const { address: e } = t;
            if ("string" == typeof e) {
              const { network: r } = this.opts,
                n = (0, c.toOutputScript)(e, r);
              t = Object.assign({}, t, { script: n });
            }
            (0, g.checkTaprootOutputFields)(t, t, "addOutput");
            const r = this.__CACHE;
            return (
              this.data.addOutput(t),
              (r.__FEE = void 0),
              (r.__FEE_RATE = void 0),
              (r.__EXTRACTED_TX = void 0),
              this
            );
          }
          extractTransaction(t) {
            if (!this.data.inputs.every(M)) throw new Error("Not finalized");
            const e = this.__CACHE;
            if (
              (t ||
                (function (t, e, r) {
                  const n = e.__FEE_RATE || t.getFeeRate(),
                    i = e.__EXTRACTED_TX.virtualSize(),
                    o = n * i;
                  if (n >= r.maximumFeeRate)
                    throw new Error(
                      `Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`,
                    );
                })(this, e, this.opts),
              e.__EXTRACTED_TX)
            )
              return e.__EXTRACTED_TX;
            const r = e.__TX.clone();
            return z(this.data.inputs, r, e, !0), r;
          }
          getFeeRate() {
            return R("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
          }
          getFee() {
            return R("__FEE", "fee", this.data.inputs, this.__CACHE);
          }
          finalizeAllInputs() {
            return (
              (0, u.checkForInput)(this.data.inputs, 0),
              Q(this.data.inputs.length).forEach((t) => this.finalizeInput(t)),
              this
            );
          }
          finalizeInput(t, e) {
            const r = (0, u.checkForInput)(this.data.inputs, t);
            return (0, g.isTaprootInput)(r)
              ? this._finalizeTaprootInput(t, r, void 0, e)
              : this._finalizeInput(t, r, e);
          }
          finalizeTaprootInput(t, e, r = g.tapScriptFinalizer) {
            const n = (0, u.checkForInput)(this.data.inputs, t);
            if ((0, g.isTaprootInput)(n))
              return this._finalizeTaprootInput(t, n, e, r);
            throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
          }
          _finalizeInput(t, e, r = N) {
            const {
              script: n,
              isP2SH: i,
              isP2WSH: o,
              isSegwit: s,
            } = (function (t, e, r) {
              const n = r.__TX,
                i = { script: null, isSegwit: !1, isP2SH: !1, isP2WSH: !1 };
              if (
                ((i.isP2SH = !!e.redeemScript),
                (i.isP2WSH = !!e.witnessScript),
                e.witnessScript)
              )
                i.script = e.witnessScript;
              else if (e.redeemScript) i.script = e.redeemScript;
              else if (e.nonWitnessUtxo) {
                const o = $(r, e, t),
                  s = n.ins[t].index;
                i.script = o.outs[s].script;
              } else e.witnessUtxo && (i.script = e.witnessUtxo.script);
              (e.witnessScript || (0, m.isP2WPKH)(i.script)) &&
                (i.isSegwit = !0);
              return i;
            })(t, e, this.__CACHE);
            if (!n) throw new Error(`No script found for input #${t}`);
            !(function (t) {
              if (!t.sighashType || !t.partialSig) return;
              const { partialSig: e, sighashType: r } = t;
              e.forEach((t) => {
                const { hashType: e } = p.signature.decode(t.signature);
                if (r !== e)
                  throw new Error(
                    "Signature sighash does not match input sighash type",
                  );
              });
            })(e);
            const { finalScriptSig: a, finalScriptWitness: u } = r(
              t,
              e,
              n,
              s,
              i,
              o,
            );
            if (
              (a && this.data.updateInput(t, { finalScriptSig: a }),
              u && this.data.updateInput(t, { finalScriptWitness: u }),
              !a && !u)
            )
              throw new Error(`Unknown error finalizing input #${t}`);
            return this.data.clearFinalizedInput(t), this;
          }
          _finalizeTaprootInput(t, e, r, n = g.tapScriptFinalizer) {
            if (!e.witnessUtxo)
              throw new Error(
                `Cannot finalize input #${t}. Missing withness utxo.`,
              );
            if (e.tapKeySig) {
              const r = l.p2tr({
                  output: e.witnessUtxo.script,
                  signature: e.tapKeySig,
                }),
                n = (0, m.witnessStackToScriptWitness)(r.witness);
              this.data.updateInput(t, { finalScriptWitness: n });
            } else {
              const { finalScriptWitness: i } = n(t, e, r);
              this.data.updateInput(t, { finalScriptWitness: i });
            }
            return this.data.clearFinalizedInput(t), this;
          }
          getInputType(t) {
            const e = (0, u.checkForInput)(this.data.inputs, t),
              r = X(
                G(t, e, this.__CACHE),
                t,
                "input",
                e.redeemScript ||
                  (function (t) {
                    if (!t) return;
                    const e = p.decompile(t);
                    if (!e) return;
                    const r = e[e.length - 1];
                    if (
                      !(r instanceof Uint8Array) ||
                      Y(r) ||
                      ((n = r), p.isCanonicalScriptSignature(n))
                    )
                      return;
                    var n;
                    if (!p.decompile(r)) return;
                    return r;
                  })(e.finalScriptSig),
                e.witnessScript ||
                  (function (t) {
                    if (!t) return;
                    const e = V(t),
                      r = e[e.length - 1];
                    if (Y(r)) return;
                    if (!p.decompile(r)) return;
                    return r;
                  })(e.finalScriptWitness),
              );
            return (
              ("raw" === r.type ? "" : r.type + "-") + J(r.meaningfulScript)
            );
          }
          inputHasPubkey(t, e) {
            return (function (t, e, r, n) {
              const i = G(r, e, n),
                { meaningfulScript: o } = X(
                  i,
                  r,
                  "input",
                  e.redeemScript,
                  e.witnessScript,
                );
              return (0, m.pubkeyInScript)(t, o);
            })(e, (0, u.checkForInput)(this.data.inputs, t), t, this.__CACHE);
          }
          inputHasHDKey(t, e) {
            const r = (0, u.checkForInput)(this.data.inputs, t),
              n = A(e);
            return !!r.bip32Derivation && r.bip32Derivation.some(n);
          }
          outputHasPubkey(t, e) {
            return (function (t, e, r, n) {
              const i = n.__TX.outs[r].script,
                { meaningfulScript: o } = X(
                  i,
                  r,
                  "output",
                  e.redeemScript,
                  e.witnessScript,
                );
              return (0, m.pubkeyInScript)(t, o);
            })(e, (0, u.checkForOutput)(this.data.outputs, t), t, this.__CACHE);
          }
          outputHasHDKey(t, e) {
            const r = (0, u.checkForOutput)(this.data.outputs, t),
              n = A(e);
            return !!r.bip32Derivation && r.bip32Derivation.some(n);
          }
          validateSignaturesOfAllInputs(t) {
            (0, u.checkForInput)(this.data.inputs, 0);
            return Q(this.data.inputs.length)
              .map((e) => this.validateSignaturesOfInput(e, t))
              .reduce((t, e) => !0 === e && t, !0);
          }
          validateSignaturesOfInput(t, e, r) {
            const n = this.data.inputs[t];
            return (0, g.isTaprootInput)(n)
              ? this.validateSignaturesOfTaprootInput(t, e, r)
              : this._validateSignaturesOfInput(t, e, r);
          }
          _validateSignaturesOfInput(t, e, r) {
            const n = this.data.inputs[t],
              i = (n || {}).partialSig;
            if (!n || !i || i.length < 1)
              throw new Error("No signatures to validate");
            if ("function" != typeof e)
              throw new Error("Need validator function to validate signatures");
            const o = r ? i.filter((t) => 0 === b.compare(t.pubkey, r)) : i;
            if (o.length < 1) throw new Error("No signatures for this pubkey");
            const s = [];
            let a, u, c;
            for (const r of o) {
              const i = p.signature.decode(r.signature),
                { hash: o, script: f } =
                  c !== i.hashType
                    ? D(
                        t,
                        Object.assign({}, n, { sighashType: i.hashType }),
                        this.__CACHE,
                        !0,
                      )
                    : { hash: a, script: u };
              (c = i.hashType),
                (a = o),
                (u = f),
                O(r.pubkey, f, "verify"),
                s.push(e(r.pubkey, o, i.signature));
            }
            return s.every((t) => !0 === t);
          }
          validateSignaturesOfTaprootInput(t, e, r) {
            const n = this.data.inputs[t],
              i = (n || {}).tapKeySig,
              o = (n || {}).tapScriptSig;
            if (!n && !i && (!o || o.length))
              throw new Error("No signatures to validate");
            if ("function" != typeof e)
              throw new Error("Need validator function to validate signatures");
            const s = (r = r && (0, g.toXOnly)(r))
              ? F(t, n, this.data.inputs, r, this.__CACHE)
              : (function (t, e, r, n) {
                  const i = [];
                  if (e.tapInternalKey) {
                    const r = L(t, e, n);
                    r && i.push(r);
                  }
                  if (e.tapScriptSig) {
                    const t = e.tapScriptSig.map((t) => t.pubkey);
                    i.push(...t);
                  }
                  const o = i.map((i) => F(t, e, r, i, n));
                  return o.flat();
                })(t, n, this.data.inputs, this.__CACHE);
            if (!s.length) throw new Error("No signatures for this pubkey");
            const a = s.find((t) => !t.leafHash);
            let u = 0;
            if (i && a) {
              if (!e(a.pubkey, a.hash, j(i))) return !1;
              u++;
            }
            if (o)
              for (const t of o) {
                const r = s.find((e) => 0 === b.compare(e.pubkey, t.pubkey));
                if (r) {
                  if (!e(t.pubkey, r.hash, j(t.signature))) return !1;
                  u++;
                }
              }
            return u > 0;
          }
          signAllInputsHD(t, e = [y.Transaction.SIGHASH_ALL]) {
            if (!t || !t.publicKey || !t.fingerprint)
              throw new Error("Need HDSigner to sign input");
            const r = [];
            for (const n of Q(this.data.inputs.length))
              try {
                this.signInputHD(n, t, e), r.push(!0);
              } catch (t) {
                r.push(!1);
              }
            if (r.every((t) => !1 === t))
              throw new Error("No inputs were signed");
            return this;
          }
          signAllInputsHDAsync(t, e = [y.Transaction.SIGHASH_ALL]) {
            return new Promise((r, n) => {
              if (!t || !t.publicKey || !t.fingerprint)
                return n(new Error("Need HDSigner to sign input"));
              const i = [],
                o = [];
              for (const r of Q(this.data.inputs.length))
                o.push(
                  this.signInputHDAsync(r, t, e).then(
                    () => {
                      i.push(!0);
                    },
                    () => {
                      i.push(!1);
                    },
                  ),
                );
              return Promise.all(o).then(() => {
                if (i.every((t) => !1 === t))
                  return n(new Error("No inputs were signed"));
                r();
              });
            });
          }
          signInputHD(t, e, r = [y.Transaction.SIGHASH_ALL]) {
            if (!e || !e.publicKey || !e.fingerprint)
              throw new Error("Need HDSigner to sign input");
            return (
              K(t, this.data.inputs, e).forEach((e) => this.signInput(t, e, r)),
              this
            );
          }
          signInputHDAsync(t, e, r = [y.Transaction.SIGHASH_ALL]) {
            return new Promise((n, i) => {
              if (!e || !e.publicKey || !e.fingerprint)
                return i(new Error("Need HDSigner to sign input"));
              const o = K(t, this.data.inputs, e).map((e) =>
                this.signInputAsync(t, e, r),
              );
              return Promise.all(o)
                .then(() => {
                  n();
                })
                .catch(i);
            });
          }
          signAllInputs(t, e) {
            if (!t || !t.publicKey)
              throw new Error("Need Signer to sign input");
            const r = [];
            for (const n of Q(this.data.inputs.length))
              try {
                this.signInput(n, t, e), r.push(!0);
              } catch (t) {
                r.push(!1);
              }
            if (r.every((t) => !1 === t))
              throw new Error("No inputs were signed");
            return this;
          }
          signAllInputsAsync(t, e) {
            return new Promise((r, n) => {
              if (!t || !t.publicKey)
                return n(new Error("Need Signer to sign input"));
              const i = [],
                o = [];
              for (const [r] of this.data.inputs.entries())
                o.push(
                  this.signInputAsync(r, t, e).then(
                    () => {
                      i.push(!0);
                    },
                    () => {
                      i.push(!1);
                    },
                  ),
                );
              return Promise.all(o).then(() => {
                if (i.every((t) => !1 === t))
                  return n(new Error("No inputs were signed"));
                r();
              });
            });
          }
          signInput(t, e, r) {
            if (!e || !e.publicKey)
              throw new Error("Need Signer to sign input");
            const n = (0, u.checkForInput)(this.data.inputs, t);
            return (0, g.isTaprootInput)(n)
              ? this._signTaprootInput(t, n, e, void 0, r)
              : this._signInput(t, e, r);
          }
          signTaprootInput(t, e, r, n) {
            if (!e || !e.publicKey)
              throw new Error("Need Signer to sign input");
            const i = (0, u.checkForInput)(this.data.inputs, t);
            if ((0, g.isTaprootInput)(i))
              return this._signTaprootInput(t, i, e, r, n);
            throw new Error(`Input #${t} is not of type Taproot.`);
          }
          _signInput(t, e, r = [y.Transaction.SIGHASH_ALL]) {
            const { hash: n, sighashType: i } = U(
                this.data.inputs,
                t,
                e.publicKey,
                this.__CACHE,
                r,
              ),
              o = [
                {
                  pubkey: e.publicKey,
                  signature: p.signature.encode(e.sign(n), i),
                },
              ];
            return this.data.updateInput(t, { partialSig: o }), this;
          }
          _signTaprootInput(t, e, r, n, i = [y.Transaction.SIGHASH_DEFAULT]) {
            const o = this.checkTaprootHashesForSig(t, e, r, n, i),
              s = o
                .filter((t) => !t.leafHash)
                .map((t) =>
                  (0, g.serializeTaprootSignature)(
                    r.signSchnorr(t.hash),
                    e.sighashType,
                  ),
                )[0],
              a = o
                .filter((t) => !!t.leafHash)
                .map((t) => ({
                  pubkey: (0, g.toXOnly)(r.publicKey),
                  signature: (0, g.serializeTaprootSignature)(
                    r.signSchnorr(t.hash),
                    e.sighashType,
                  ),
                  leafHash: t.leafHash,
                }));
            return (
              s && this.data.updateInput(t, { tapKeySig: s }),
              a.length && this.data.updateInput(t, { tapScriptSig: a }),
              this
            );
          }
          signInputAsync(t, e, r) {
            return Promise.resolve().then(() => {
              if (!e || !e.publicKey)
                throw new Error("Need Signer to sign input");
              const n = (0, u.checkForInput)(this.data.inputs, t);
              return (0, g.isTaprootInput)(n)
                ? this._signTaprootInputAsync(t, n, e, void 0, r)
                : this._signInputAsync(t, e, r);
            });
          }
          signTaprootInputAsync(t, e, r, n) {
            return Promise.resolve().then(() => {
              if (!e || !e.publicKey)
                throw new Error("Need Signer to sign input");
              const i = (0, u.checkForInput)(this.data.inputs, t);
              if ((0, g.isTaprootInput)(i))
                return this._signTaprootInputAsync(t, i, e, r, n);
              throw new Error(`Input #${t} is not of type Taproot.`);
            });
          }
          _signInputAsync(t, e, r = [y.Transaction.SIGHASH_ALL]) {
            const { hash: n, sighashType: i } = U(
              this.data.inputs,
              t,
              e.publicKey,
              this.__CACHE,
              r,
            );
            return Promise.resolve(e.sign(n)).then((r) => {
              const n = [
                { pubkey: e.publicKey, signature: p.signature.encode(r, i) },
              ];
              this.data.updateInput(t, { partialSig: n });
            });
          }
          async _signTaprootInputAsync(
            t,
            e,
            r,
            n,
            i = [y.Transaction.SIGHASH_DEFAULT],
          ) {
            const o = this.checkTaprootHashesForSig(t, e, r, n, i),
              s = [],
              a = o.filter((t) => !t.leafHash)[0];
            if (a) {
              const t = Promise.resolve(r.signSchnorr(a.hash)).then((t) => ({
                tapKeySig: (0, g.serializeTaprootSignature)(t, e.sighashType),
              }));
              s.push(t);
            }
            const u = o.filter((t) => !!t.leafHash);
            if (u.length) {
              const t = u.map((t) =>
                Promise.resolve(r.signSchnorr(t.hash)).then((n) => ({
                  tapScriptSig: [
                    {
                      pubkey: (0, g.toXOnly)(r.publicKey),
                      signature: (0, g.serializeTaprootSignature)(
                        n,
                        e.sighashType,
                      ),
                      leafHash: t.leafHash,
                    },
                  ],
                })),
              );
              s.push(...t);
            }
            return Promise.all(s).then((e) => {
              e.forEach((e) => this.data.updateInput(t, e));
            });
          }
          checkTaprootHashesForSig(t, e, r, n, i) {
            if ("function" != typeof r.signSchnorr)
              throw new Error(
                `Need Schnorr Signer to sign taproot input #${t}.`,
              );
            const o = F(
              t,
              e,
              this.data.inputs,
              r.publicKey,
              this.__CACHE,
              n,
              i,
            );
            if (!o || !o.length)
              throw new Error(
                `Can not sign for input #${t} with the key ${b.toHex(r.publicKey)}`,
              );
            return o;
          }
          toBuffer() {
            return S(this.__CACHE), this.data.toBuffer();
          }
          toHex() {
            return S(this.__CACHE), this.data.toHex();
          }
          toBase64() {
            return S(this.__CACHE), this.data.toBase64();
          }
          updateGlobal(t) {
            return this.data.updateGlobal(t), this;
          }
          updateInput(t, e) {
            return (
              e.witnessScript && Z(e.witnessScript),
              (0, g.checkTaprootInputFields)(
                this.data.inputs[t],
                e,
                "updateInput",
              ),
              this.data.updateInput(t, e),
              e.nonWitnessUtxo && q(this.__CACHE, this.data.inputs[t], t),
              this
            );
          }
          updateOutput(t, e) {
            const r = this.data.outputs[t];
            return (
              (0, g.checkTaprootOutputFields)(r, e, "updateOutput"),
              this.data.updateOutput(t, e),
              this
            );
          }
          addUnknownKeyValToGlobal(t) {
            return this.data.addUnknownKeyValToGlobal(t), this;
          }
          addUnknownKeyValToInput(t, e) {
            return this.data.addUnknownKeyValToInput(t, e), this;
          }
          addUnknownKeyValToOutput(t, e) {
            return this.data.addUnknownKeyValToOutput(t, e), this;
          }
          clearFinalizedInput(t) {
            return this.data.clearFinalizedInput(t), this;
          }
        }
        e.Psbt = v;
        const _ = (t) => new E(t);
        class E {
          tx;
          constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
            (this.tx = y.Transaction.fromBuffer(t)),
              (function (t) {
                if (
                  !t.ins.every(
                    (t) =>
                      t.script &&
                      0 === t.script.length &&
                      t.witness &&
                      0 === t.witness.length,
                  )
                )
                  throw new Error(
                    "Format Error: Transaction ScriptSigs are not empty",
                  );
              })(this.tx),
              Object.defineProperty(this, "tx", {
                enumerable: !1,
                writable: !0,
              });
          }
          getInputOutputCounts() {
            return {
              inputCount: this.tx.ins.length,
              outputCount: this.tx.outs.length,
            };
          }
          addInput(t) {
            if (
              void 0 === t.hash ||
              void 0 === t.index ||
              (!(t.hash instanceof Uint8Array) && "string" != typeof t.hash) ||
              "number" != typeof t.index
            )
              throw new Error("Error adding input.");
            const e =
              "string" == typeof t.hash
                ? (0, f.reverseBuffer)(b.fromHex(t.hash))
                : t.hash;
            this.tx.addInput(e, t.index, t.sequence);
          }
          addOutput(t) {
            if (
              void 0 === t.script ||
              void 0 === t.value ||
              !(t.script instanceof Uint8Array) ||
              "bigint" != typeof t.value
            )
              throw new Error("Error adding output.");
            this.tx.addOutput(t.script, t.value);
          }
          toBuffer() {
            return this.tx.toBuffer();
          }
        }
        function S(t) {
          if (!1 !== t.__UNSAFE_SIGN_NONSEGWIT)
            throw new Error("Not BIP174 compliant, can not export");
        }
        function I(t, e, r) {
          if (!e) return !1;
          let n;
          if (
            ((n = r
              ? r
                  .map((t) => {
                    const r = (function (t) {
                      if (65 === t.length) {
                        const e = 1 & t[64],
                          r = t.slice(0, 33);
                        return (r[0] = 2 | e), r;
                      }
                      return t.slice();
                    })(t);
                    return e.find((t) => 0 === b.compare(t.pubkey, r));
                  })
                  .filter((t) => !!t)
              : e),
            n.length > t)
          )
            throw new Error("Too many signatures");
          return n.length === t;
        }
        function M(t) {
          return !!t.finalScriptSig || !!t.finalScriptWitness;
        }
        function A(t) {
          return (e) =>
            !b.compare(t.fingerprint, e.masterFingerprint) &&
            !b.compare(t.derivePath(e.path).publicKey, e.pubkey);
        }
        function T(t) {
          if (
            "number" != typeof t ||
            t !== Math.floor(t) ||
            t > 4294967295 ||
            t < 0
          )
            throw new Error("Invalid 32 bit integer");
        }
        function k(t, e) {
          t.forEach((t) => {
            if (
              (0, g.isTaprootInput)(t)
                ? (0, g.checkTaprootInputForSigs)(t, e)
                : (0, m.checkInputForSig)(t, e)
            )
              throw new Error("Can not modify transaction, signatures exist.");
          });
        }
        function O(t, e, r) {
          if (!(0, m.pubkeyInScript)(t, e))
            throw new Error(
              `Can not ${r} for this input with the key ${b.toHex(t)}`,
            );
        }
        function x(t, e) {
          const r =
            b.toHex((0, f.reverseBuffer)(Uint8Array.from(e.hash))) +
            ":" +
            e.index;
          if (t.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
          t.__TX_IN_CACHE[r] = 1;
        }
        function P(t, e) {
          return (r, n, i, o) => {
            const s = t({ redeem: { output: i } }).output;
            if (b.compare(n, s))
              throw new Error(
                `${e} for ${o} #${r} doesn't match the scriptPubKey in the prevout`,
              );
          };
        }
        const B = P(l.p2sh, "Redeem script"),
          C = P(l.p2wsh, "Witness script");
        function R(t, e, r, n) {
          if (!r.every(M))
            throw new Error(`PSBT must be finalized to calculate ${e}`);
          if ("__FEE_RATE" === t && n.__FEE_RATE) return n.__FEE_RATE;
          if ("__FEE" === t && n.__FEE) return n.__FEE;
          let i,
            o = !0;
          return (
            n.__EXTRACTED_TX
              ? ((i = n.__EXTRACTED_TX), (o = !1))
              : (i = n.__TX.clone()),
            z(r, i, n, o),
            "__FEE_RATE" === t ? n.__FEE_RATE : "__FEE" === t ? n.__FEE : void 0
          );
        }
        function N(t, e, r, n, i, o) {
          const s = J(r);
          if (
            !(function (t, e, r) {
              switch (r) {
                case "pubkey":
                case "pubkeyhash":
                case "witnesspubkeyhash":
                  return I(1, t.partialSig);
                case "multisig":
                  const r = l.p2ms({ output: e });
                  return I(r.m, t.partialSig, r.pubkeys);
                default:
                  return !1;
              }
            })(e, r, s)
          )
            throw new Error(`Can not finalize input #${t}`);
          return (function (t, e, r, n, i, o) {
            let s, a;
            const u = (function (t, e, r) {
                let n;
                switch (e) {
                  case "multisig":
                    const e = (function (t, e) {
                      const r = l.p2ms({ output: t });
                      return r.pubkeys
                        .map(
                          (t) =>
                            (
                              e.filter(
                                (e) => 0 === b.compare(e.pubkey, t),
                              )[0] || {}
                            ).signature,
                        )
                        .filter((t) => !!t);
                    })(t, r);
                    n = l.p2ms({ output: t, signatures: e });
                    break;
                  case "pubkey":
                    n = l.p2pk({ output: t, signature: r[0].signature });
                    break;
                  case "pubkeyhash":
                    n = l.p2pkh({
                      output: t,
                      pubkey: r[0].pubkey,
                      signature: r[0].signature,
                    });
                    break;
                  case "witnesspubkeyhash":
                    n = l.p2wpkh({
                      output: t,
                      pubkey: r[0].pubkey,
                      signature: r[0].signature,
                    });
                }
                return n;
              })(t, e, r),
              c = o ? l.p2wsh({ redeem: u }) : null,
              f = i ? l.p2sh({ redeem: c || u }) : null;
            n
              ? ((a = c
                  ? (0, m.witnessStackToScriptWitness)(c.witness)
                  : (0, m.witnessStackToScriptWitness)(u.witness)),
                f && (s = f.input))
              : (s = f ? f.input : u.input);
            return { finalScriptSig: s, finalScriptWitness: a };
          })(r, s, e.partialSig, n, i, o);
        }
        function U(t, e, r, n, i) {
          const o = (0, u.checkForInput)(t, e),
            { hash: s, sighashType: a, script: c } = D(e, o, n, !1, i);
          return O(r, c, "sign"), { hash: s, sighashType: a };
        }
        function D(t, e, r, n, i) {
          const o = r.__TX,
            s = e.sighashType || y.Transaction.SIGHASH_ALL;
          let a, u;
          if ((H(s, i), e.nonWitnessUtxo)) {
            const n = $(r, e, t),
              i = o.ins[t].hash,
              s = n.getHash();
            if (0 !== b.compare(i, s))
              throw new Error(
                `Non-witness UTXO hash for input #${t} doesn't match the hash specified in the prevout`,
              );
            const a = o.ins[t].index;
            u = n.outs[a];
          } else {
            if (!e.witnessUtxo)
              throw new Error("Need a Utxo input item for signing");
            u = e.witnessUtxo;
          }
          const { meaningfulScript: c, type: f } = X(
            u.script,
            t,
            "input",
            e.redeemScript,
            e.witnessScript,
          );
          if (["p2sh-p2wsh", "p2wsh"].indexOf(f) >= 0)
            a = o.hashForWitnessV0(t, c, u.value, s);
          else if ((0, m.isP2WPKH)(c)) {
            const e = l.p2pkh({ hash: c.slice(2) }).output;
            a = o.hashForWitnessV0(t, e, u.value, s);
          } else {
            if (void 0 === e.nonWitnessUtxo && !1 === r.__UNSAFE_SIGN_NONSEGWIT)
              throw new Error(
                `Input #${t} has witnessUtxo but non-segwit script: ${b.toHex(c)}`,
              );
            n ||
              !1 === r.__UNSAFE_SIGN_NONSEGWIT ||
              console.warn(
                "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************",
              ),
              (a = o.hashForSignature(t, c, s));
          }
          return { script: c, sighashType: s, hash: a };
        }
        function L(t, e, r) {
          const { script: n } = W(t, e, r);
          return (0, m.isP2TR)(n) ? n.subarray(2, 34) : null;
        }
        function j(t) {
          return 64 === t.length ? t : t.subarray(0, 64);
        }
        function F(t, e, r, n, i, o, s) {
          const a = i.__TX,
            u = e.sighashType || y.Transaction.SIGHASH_DEFAULT;
          H(u, s);
          const c = r.map((t, e) => W(e, t, i)),
            f = c.map((t) => t.script),
            h = c.map((t) => t.value),
            l = [];
          if (e.tapInternalKey && !o) {
            const r = L(t, e, i) || Uint8Array.from([]);
            if (0 === b.compare((0, g.toXOnly)(n), r)) {
              const e = a.hashForWitnessV1(t, f, h, u);
              l.push({ pubkey: n, hash: e });
            }
          }
          const p = (e.tapLeafScript || [])
            .filter((t) => (0, m.pubkeyInScript)(n, t.script))
            .map((t) => {
              const e = (0, d.tapleafHash)({
                output: t.script,
                version: t.leafVersion,
              });
              return Object.assign({ hash: e }, t);
            })
            .filter((t) => !o || 0 === b.compare(o, t.hash))
            .map((e) => {
              const r = a.hashForWitnessV1(t, f, h, u, e.hash);
              return { pubkey: n, hash: r, leafHash: e.hash };
            });
          return l.concat(p);
        }
        function H(t, e) {
          if (e && e.indexOf(t) < 0) {
            const e = (function (t) {
              let e =
                t & y.Transaction.SIGHASH_ANYONECANPAY
                  ? "SIGHASH_ANYONECANPAY | "
                  : "";
              switch (31 & t) {
                case y.Transaction.SIGHASH_ALL:
                  e += "SIGHASH_ALL";
                  break;
                case y.Transaction.SIGHASH_SINGLE:
                  e += "SIGHASH_SINGLE";
                  break;
                case y.Transaction.SIGHASH_NONE:
                  e += "SIGHASH_NONE";
              }
              return e;
            })(t);
            throw new Error(
              `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${e}`,
            );
          }
        }
        function K(t, e, r) {
          const n = (0, u.checkForInput)(e, t);
          if (!n.bip32Derivation || 0 === n.bip32Derivation.length)
            throw new Error("Need bip32Derivation to sign with HD");
          const i = n.bip32Derivation
            .map((t) =>
              0 === b.compare(t.masterFingerprint, r.fingerprint) ? t : void 0,
            )
            .filter((t) => !!t);
          if (0 === i.length)
            throw new Error(
              "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint",
            );
          return i.map((t) => {
            const e = r.derivePath(t.path);
            if (0 !== b.compare(t.pubkey, e.publicKey))
              throw new Error("pubkey did not match bip32Derivation");
            return e;
          });
        }
        function V(t) {
          let e = 0;
          function r() {
            const r = a.decode(t, e);
            return (e += a.encodingLength(r.bigintValue)), r.numberValue;
          }
          function n() {
            return (n = r()), (e += n), t.slice(e - n, e);
            var n;
          }
          return (function () {
            const t = r(),
              e = [];
            for (let r = 0; r < t; r++) e.push(n());
            return e;
          })();
        }
        function q(t, e, r) {
          t.__NON_WITNESS_UTXO_BUF_CACHE[r] = e.nonWitnessUtxo;
          const n = y.Transaction.fromBuffer(e.nonWitnessUtxo);
          t.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
          const i = t,
            o = r;
          delete e.nonWitnessUtxo,
            Object.defineProperty(e, "nonWitnessUtxo", {
              enumerable: !0,
              get() {
                const t = i.__NON_WITNESS_UTXO_BUF_CACHE[o],
                  e = i.__NON_WITNESS_UTXO_TX_CACHE[o];
                if (void 0 !== t) return t;
                {
                  const t = e.toBuffer();
                  return (i.__NON_WITNESS_UTXO_BUF_CACHE[o] = t), t;
                }
              },
              set(t) {
                i.__NON_WITNESS_UTXO_BUF_CACHE[o] = t;
              },
            });
        }
        function z(t, e, r, n) {
          let i = 0n;
          t.forEach((t, o) => {
            if (
              (n && t.finalScriptSig && (e.ins[o].script = t.finalScriptSig),
              n &&
                t.finalScriptWitness &&
                (e.ins[o].witness = V(t.finalScriptWitness)),
              t.witnessUtxo)
            )
              i += t.witnessUtxo.value;
            else if (t.nonWitnessUtxo) {
              const n = $(r, t, o),
                s = e.ins[o].index,
                a = n.outs[s];
              i += a.value;
            }
          });
          const o = e.outs.reduce((t, e) => t + e.value, 0n),
            s = i - o;
          if (s < 0) throw new Error("Outputs are spending more than Inputs");
          const a = e.virtualSize();
          (r.__FEE = s),
            (r.__EXTRACTED_TX = e),
            (r.__FEE_RATE = Math.floor(Number(s / BigInt(a))));
        }
        function $(t, e, r) {
          const n = t.__NON_WITNESS_UTXO_TX_CACHE;
          return n[r] || q(t, e, r), n[r];
        }
        function G(t, e, r) {
          const { script: n } = W(t, e, r);
          return n;
        }
        function W(t, e, r) {
          if (void 0 !== e.witnessUtxo)
            return { script: e.witnessUtxo.script, value: e.witnessUtxo.value };
          if (void 0 !== e.nonWitnessUtxo) {
            const n = $(r, e, t).outs[r.__TX.ins[t].index];
            return { script: n.script, value: n.value };
          }
          throw new Error("Can't find pubkey in input without Utxo data");
        }
        function Y(t) {
          return 33 === t.length && p.isCanonicalPubKey(t);
        }
        function X(t, e, r, n, i) {
          const o = (0, m.isP2SHScript)(t),
            s = o && n && (0, m.isP2WSHScript)(n),
            a = (0, m.isP2WSHScript)(t);
          if (o && void 0 === n)
            throw new Error("scriptPubkey is P2SH but redeemScript missing");
          if ((a || s) && void 0 === i)
            throw new Error(
              "scriptPubkey or redeemScript is P2WSH but witnessScript missing",
            );
          let u;
          return (
            s
              ? ((u = i), B(e, t, n, r), C(e, n, i, r), Z(u))
              : a
                ? ((u = i), C(e, t, i, r), Z(u))
                : o
                  ? ((u = n), B(e, t, n, r))
                  : (u = t),
            {
              meaningfulScript: u,
              type: s ? "p2sh-p2wsh" : o ? "p2sh" : a ? "p2wsh" : "raw",
            }
          );
        }
        function Z(t) {
          if ((0, m.isP2WPKH)(t) || (0, m.isP2SHScript)(t))
            throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
        }
        function J(t) {
          return (0, m.isP2WPKH)(t)
            ? "witnesspubkeyhash"
            : (0, m.isP2PKH)(t)
              ? "pubkeyhash"
              : (0, m.isP2MS)(t)
                ? "multisig"
                : (0, m.isP2PK)(t)
                  ? "pubkey"
                  : "nonstandard";
        }
        function Q(t) {
          return [...Array(t).keys()];
        }
      },
      1878: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.toXOnly = void 0),
          (e.tapScriptFinalizer = function (t, e, r) {
            const n = (function (t, e, r) {
              if (!t.tapScriptSig || !t.tapScriptSig.length)
                throw new Error(
                  `Can not finalize taproot input #${e}. No tapleaf script signature provided.`,
                );
              const n = (t.tapLeafScript || [])
                .sort((t, e) => t.controlBlock.length - e.controlBlock.length)
                .find((e) =>
                  (function (t, e, r) {
                    const n = (0, c.tapleafHash)({
                      output: t.script,
                      version: t.leafVersion,
                    });
                    return (
                      (!r || 0 === h.compare(n, r)) &&
                      void 0 !== e.find((t) => 0 === h.compare(t.leafHash, n))
                    );
                  })(e, t.tapScriptSig, r),
                );
              if (!n)
                throw new Error(
                  `Can not finalize taproot input #${e}. Signature for tapleaf script not found.`,
                );
              return n;
            })(e, t, r);
            try {
              const t = (function (t, e) {
                  const r = (0, c.tapleafHash)({
                    output: e.script,
                    version: e.leafVersion,
                  });
                  return (t.tapScriptSig || [])
                    .filter((t) => 0 === h.compare(t.leafHash, r))
                    .map((t) =>
                      (function (t, e) {
                        return Object.assign(
                          {
                            positionInScript: (0, u.pubkeyPositionInScript)(
                              e.pubkey,
                              t,
                            ),
                          },
                          e,
                        );
                      })(e.script, t),
                    )
                    .sort((t, e) => e.positionInScript - t.positionInScript)
                    .map((t) => t.signature);
                })(e, n),
                r = t.concat(n.script).concat(n.controlBlock);
              return {
                finalScriptWitness: (0, u.witnessStackToScriptWitness)(r),
              };
            } catch (e) {
              throw new Error(`Can not finalize taproot input #${t}: ${e}`);
            }
          }),
          (e.serializeTaprootSignature = function (t, e) {
            const r = e ? Uint8Array.from([e]) : Uint8Array.from([]);
            return h.concat([t, r]);
          }),
          (e.isTaprootInput = d),
          (e.isTaprootOutput = p),
          (e.checkTaprootInputFields = function (t, e, r) {
            (function (t, e, r) {
              const n = d(t) && v(e),
                i = v(t) && d(e),
                o = t === e && d(e) && v(e);
              if (n || i || o)
                throw new Error(
                  `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`,
                );
            })(t, e, r),
              (function (t, e, r) {
                if (e.tapMerkleRoot) {
                  const n = (e.tapLeafScript || []).every((t) =>
                      w(t, e.tapMerkleRoot),
                    ),
                    i = (t.tapLeafScript || []).every((t) =>
                      w(t, e.tapMerkleRoot),
                    );
                  if (!n || !i)
                    throw new Error(
                      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`,
                    );
                } else if (t.tapMerkleRoot) {
                  if (
                    !(e.tapLeafScript || []).every((e) => w(e, t.tapMerkleRoot))
                  )
                    throw new Error(
                      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`,
                    );
                }
              })(t, e, r);
          }),
          (e.checkTaprootOutputFields = function (t, e, r) {
            (function (t, e, r) {
              const n = p(t) && v(e),
                i = v(t) && p(e),
                o = t === e && p(e) && v(e);
              if (n || i || o)
                throw new Error(
                  `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`,
                );
            })(t, e, r),
              (function (t, e) {
                if (!e.tapTree && !e.tapInternalKey) return;
                const r = e.tapInternalKey || t.tapInternalKey,
                  n = e.tapTree || t.tapTree;
                if (r) {
                  const { script: e } = t,
                    i = (function (t, e) {
                      const r = e && y(e.leaves),
                        { output: n } = (0, f.p2tr)({
                          internalPubkey: t,
                          scriptTree: r,
                        });
                      return n;
                    })(r, n);
                  if (e && 0 !== h.compare(i, e))
                    throw new Error(
                      "Error adding output. Script or address mismatch.",
                    );
                }
              })(t, e);
          }),
          (e.tweakInternalPubKey = function (t, e) {
            const r = e.tapInternalKey,
              n = r && (0, c.tweakKey)(r, e.tapMerkleRoot);
            if (!n)
              throw new Error(
                `Cannot tweak tap internal key for input #${t}. Public key: ${r && h.toHex(r)}`,
              );
            return n.x;
          }),
          (e.tapTreeToList = function (t) {
            if (!(0, s.isTaptree)(t))
              throw new Error(
                "Cannot convert taptree to tapleaf list. Expecting a tapree structure.",
              );
            return m(t);
          }),
          (e.tapTreeFromList = y),
          (e.checkTaprootInputForSigs = function (t, e) {
            return (function (t) {
              const e = [];
              t.tapKeySig && e.push(t.tapKeySig);
              t.tapScriptSig &&
                e.push(...t.tapScriptSig.map((t) => t.signature));
              if (!e.length) {
                const r = (function (t) {
                  if (!t) return;
                  const e = t.slice(2);
                  if (64 === e.length || 65 === e.length) return e;
                })(t.finalScriptWitness);
                r && e.push(r);
              }
              return e;
            })(t).some((t) => (0, l.signatureBlocksAction)(t, g, e));
          });
        const s = r(90485),
          a = r(54110),
          u = r(13730),
          c = r(43011),
          f = r(96286),
          h = o(r(22333)),
          l = r(13730);
        function d(t) {
          return (
            t &&
            !!(
              t.tapInternalKey ||
              t.tapMerkleRoot ||
              (t.tapLeafScript && t.tapLeafScript.length) ||
              (t.tapBip32Derivation && t.tapBip32Derivation.length) ||
              (t.witnessUtxo && (0, u.isP2TR)(t.witnessUtxo.script))
            )
          );
        }
        function p(t, e) {
          return (
            t &&
            !!(
              t.tapInternalKey ||
              t.tapTree ||
              (t.tapBip32Derivation && t.tapBip32Derivation.length) ||
              (e && (0, u.isP2TR)(e))
            )
          );
        }
        function y(t = []) {
          return 1 === t.length && 0 === t[0].depth
            ? { output: t[0].script, version: t[0].leafVersion }
            : (function (t) {
                let e;
                for (const r of t)
                  if (((e = b(r, e)), !e))
                    throw new Error("No room left to insert tapleaf in tree");
                return e;
              })(t);
        }
        function g(t) {
          return {
            signature: t.slice(0, 64),
            hashType: t.slice(64)[0] || a.Transaction.SIGHASH_DEFAULT,
          };
        }
        function m(t, e = [], r = 0) {
          if (r > c.MAX_TAPTREE_DEPTH)
            throw new Error("Max taptree depth exceeded.");
          return t
            ? (0, s.isTapleaf)(t)
              ? (e.push({
                  depth: r,
                  leafVersion: t.version || c.LEAF_VERSION_TAPSCRIPT,
                  script: t.output,
                }),
                e)
              : (t[0] && m(t[0], e, r + 1), t[1] && m(t[1], e, r + 1), e)
            : [];
        }
        function b(t, e, r = 0) {
          if (r > c.MAX_TAPTREE_DEPTH)
            throw new Error("Max taptree depth exceeded.");
          if (t.depth === r)
            return e ? void 0 : { output: t.script, version: t.leafVersion };
          if ((0, s.isTapleaf)(e)) return;
          const n = b(t, e && e[0], r + 1);
          if (n) return [n, e && e[1]];
          const i = b(t, e && e[1], r + 1);
          return i ? [e && e[0], i] : void 0;
        }
        function w(t, e) {
          if (!e) return !0;
          const r = (0, c.tapleafHash)({
              output: t.script,
              version: t.leafVersion,
            }),
            n = (0, c.rootHashFromPath)(t.controlBlock, r);
          return 0 === h.compare(n, e);
        }
        function v(t) {
          return (
            t &&
            !!(
              t.redeemScript ||
              t.witnessScript ||
              (t.bip32Derivation && t.bip32Derivation.length)
            )
          );
        }
        e.toXOnly = (t) => (32 === t.length ? t : t.slice(1, 33));
      },
      13730: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.isP2TR =
            e.isP2SHScript =
            e.isP2WSHScript =
            e.isP2WPKH =
            e.isP2PKH =
            e.isP2PK =
            e.isP2MS =
              void 0),
          (e.witnessStackToScriptWitness = function (t) {
            let e = new Uint8Array(0);
            function r(t) {
              const r = e.length,
                n = s.encodingLength(t);
              (e = h.concat([e, new Uint8Array(n)])), s.encode(t, e, r);
            }
            function n(t) {
              r(t.length),
                (function (t) {
                  e = h.concat([e, t]);
                })(t);
            }
            return (
              (function (t) {
                r(t.length), t.forEach(n);
              })(t),
              e
            );
          }),
          (e.pubkeyPositionInScript = d),
          (e.pubkeyInScript = function (t, e) {
            return -1 !== d(t, e);
          }),
          (e.checkInputForSig = function (t, e) {
            return (function (t) {
              let e = [];
              if (0 === (t.partialSig || []).length) {
                if (!t.finalScriptSig && !t.finalScriptWitness) return [];
                e = (function (t) {
                  const e =
                      (t.finalScriptSig && a.decompile(t.finalScriptSig)) || [],
                    r =
                      (t.finalScriptWitness &&
                        a.decompile(t.finalScriptWitness)) ||
                      [];
                  return e
                    .concat(r)
                    .filter(
                      (t) =>
                        t instanceof Uint8Array &&
                        a.isCanonicalScriptSignature(t),
                    )
                    .map((t) => ({ signature: t }));
                })(t);
              } else e = t.partialSig;
              return e.map((t) => t.signature);
            })(t).some((t) => p(t, a.signature.decode, e));
          }),
          (e.signatureBlocksAction = p);
        const s = o(r(60882)),
          a = o(r(19711)),
          u = r(54110),
          c = r(5449),
          f = o(r(96286)),
          h = o(r(22333));
        function l(t) {
          return (e) => {
            try {
              return t({ output: e }), !0;
            } catch (t) {
              return !1;
            }
          };
        }
        function d(t, e) {
          const r = (0, c.hash160)(t),
            n = t.slice(1, 33),
            i = a.decompile(e);
          if (null === i) throw new Error("Unknown script error");
          return i.findIndex(
            (e) =>
              "number" != typeof e &&
              (0 === h.compare(t, e) ||
                0 === h.compare(r, e) ||
                0 === h.compare(n, e)),
          );
        }
        function p(t, e, r) {
          const { hashType: n } = e(t),
            i = [];
          n & u.Transaction.SIGHASH_ANYONECANPAY && i.push("addInput");
          switch (31 & n) {
            case u.Transaction.SIGHASH_ALL:
              break;
            case u.Transaction.SIGHASH_SINGLE:
            case u.Transaction.SIGHASH_NONE:
              i.push("addOutput"), i.push("setInputSequence");
          }
          return -1 === i.indexOf(r);
        }
        (e.isP2MS = l(f.p2ms)),
          (e.isP2PK = l(f.p2pk)),
          (e.isP2PKH = l(f.p2pkh)),
          (e.isP2WPKH = l(f.p2wpkh)),
          (e.isP2WSHScript = l(f.p2wsh)),
          (e.isP2SHScript = l(f.p2sh)),
          (e.isP2TR = l(f.p2tr));
      },
      8305: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encodingLength = u),
          (e.encode = function (t, e, r) {
            const n = u(e);
            1 === n
              ? a.writeUInt8(t, r, e)
              : 2 === n
                ? (a.writeUInt8(t, r, s.OPS.OP_PUSHDATA1),
                  a.writeUInt8(t, r + 1, e))
                : 3 === n
                  ? (a.writeUInt8(t, r, s.OPS.OP_PUSHDATA2),
                    a.writeUInt16(t, r + 1, e, "LE"))
                  : (a.writeUInt8(t, r, s.OPS.OP_PUSHDATA4),
                    a.writeUInt32(t, r + 1, e, "LE"));
            return n;
          }),
          (e.decode = function (t, e) {
            const r = a.readUInt8(t, e);
            let n, i;
            if (r < s.OPS.OP_PUSHDATA1) (n = r), (i = 1);
            else if (r === s.OPS.OP_PUSHDATA1) {
              if (e + 2 > t.length) return null;
              (n = a.readUInt8(t, e + 1)), (i = 2);
            } else if (r === s.OPS.OP_PUSHDATA2) {
              if (e + 3 > t.length) return null;
              (n = a.readUInt16(t, e + 1, "LE")), (i = 3);
            } else {
              if (e + 5 > t.length) return null;
              if (r !== s.OPS.OP_PUSHDATA4)
                throw new Error("Unexpected opcode");
              (n = a.readUInt32(t, e + 1, "LE")), (i = 5);
            }
            return { opcode: r, number: n, size: i };
          });
        const s = r(31234),
          a = o(r(22333));
        function u(t) {
          return t < s.OPS.OP_PUSHDATA1 ? 1 : t <= 255 ? 2 : t <= 65535 ? 3 : 5;
        }
      },
      19711: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.signature = e.number = e.OPS = void 0),
          (e.isPushOnly = m),
          (e.countNonPushOnlyOPs = function (t) {
            return t.length - t.filter(g).length;
          }),
          (e.compile = _),
          (e.decompile = E),
          (e.toASM = function (t) {
            w(t) && (t = E(t));
            if (!t) throw new Error("Could not convert invalid chunks to ASM");
            return t
              .map((t) => {
                if (v(t)) {
                  const e = b(t);
                  if (void 0 === e) return l.toHex(t);
                  t = e;
                }
                return a.REVERSE_OPS[t];
              })
              .join(" ");
          }),
          (e.fromASM = function (t) {
            return (
              d.parse(d.string(), t),
              _(
                t
                  .split(" ")
                  .map((t) =>
                    void 0 !== a.OPS[t]
                      ? a.OPS[t]
                      : (d.parse(h.HexSchema, t), l.fromHex(t)),
                  ),
              )
            );
          }),
          (e.toStack = function (t) {
            return (
              (t = E(t)),
              d.parse(d.custom(m), t),
              t.map((t) =>
                v(t)
                  ? t
                  : t === a.OPS.OP_0
                    ? new Uint8Array(0)
                    : c.encode(t - p),
              )
            );
          }),
          (e.isCanonicalPubKey = function (t) {
            return h.isPoint(t);
          }),
          (e.isDefinedHashType = S),
          (e.isCanonicalScriptSignature = function (t) {
            return (
              t instanceof Uint8Array &&
              !!S(t[t.length - 1]) &&
              s.check(t.slice(0, -1))
            );
          });
        const s = o(r(56607)),
          a = r(31234);
        Object.defineProperty(e, "OPS", {
          enumerable: !0,
          get: function () {
            return a.OPS;
          },
        });
        const u = o(r(8305)),
          c = o(r(34561)),
          f = o(r(56100)),
          h = o(r(90485)),
          l = o(r(22333)),
          d = o(r(51947)),
          p = a.OPS.OP_RESERVED,
          y = d.array(d.union([d.instance(Uint8Array), d.number()]));
        function g(t) {
          return (
            d.is(h.BufferSchema, t) ||
            (function (t) {
              return (
                d.is(d.number(), t) &&
                (t === a.OPS.OP_0 ||
                  (t >= a.OPS.OP_1 && t <= a.OPS.OP_16) ||
                  t === a.OPS.OP_1NEGATE)
              );
            })(t)
          );
        }
        function m(t) {
          return d.is(d.pipe(d.any(), d.everyItem(g)), t);
        }
        function b(t) {
          return 0 === t.length
            ? a.OPS.OP_0
            : 1 === t.length
              ? t[0] >= 1 && t[0] <= 16
                ? p + t[0]
                : 129 === t[0]
                  ? a.OPS.OP_1NEGATE
                  : void 0
              : void 0;
        }
        function w(t) {
          return t instanceof Uint8Array;
        }
        function v(t) {
          return t instanceof Uint8Array;
        }
        function _(t) {
          if (w(t)) return t;
          d.parse(y, t);
          const e = t.reduce(
              (t, e) =>
                v(e)
                  ? 1 === e.length && void 0 !== b(e)
                    ? t + 1
                    : t + u.encodingLength(e.length) + e.length
                  : t + 1,
              0,
            ),
            r = new Uint8Array(e);
          let n = 0;
          if (
            (t.forEach((t) => {
              if (v(t)) {
                const e = b(t);
                if (void 0 !== e) return l.writeUInt8(r, n, e), void (n += 1);
                (n += u.encode(r, t.length, n)), r.set(t, n), (n += t.length);
              } else l.writeUInt8(r, n, t), (n += 1);
            }),
            n !== r.length)
          )
            throw new Error("Could not decode chunks");
          return r;
        }
        function E(t) {
          if (((e = t), d.is(y, e))) return t;
          var e;
          d.parse(h.BufferSchema, t);
          const r = [];
          let n = 0;
          for (; n < t.length; ) {
            const e = t[n];
            if (e > a.OPS.OP_0 && e <= a.OPS.OP_PUSHDATA4) {
              const e = u.decode(t, n);
              if (null === e) return null;
              if (((n += e.size), n + e.number > t.length)) return null;
              const i = t.slice(n, n + e.number);
              n += e.number;
              const o = b(i);
              void 0 !== o ? r.push(o) : r.push(i);
            } else r.push(e), (n += 1);
          }
          return r;
        }
        function S(t) {
          const e = -129 & t;
          return e > 0 && e < 4;
        }
        (e.number = c), (e.signature = f);
      },
      34561: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = function (t, e, r) {
            (e = e || 4), (r = void 0 === r || r);
            const n = t.length;
            if (0 === n) return 0;
            if (n > e) throw new TypeError("Script number overflow");
            if (r && !(127 & t[n - 1] || (!(n <= 1) && 128 & t[n - 2])))
              throw new Error("Non-minimally encoded script number");
            if (5 === n) {
              const e = s.readUInt32(t, 0, "LE"),
                r = s.readUInt8(t, 4);
              return 128 & r
                ? -(4294967296 * (-129 & r) + e)
                : 4294967296 * r + e;
            }
            let i = 0;
            for (let e = 0; e < n; ++e) i |= t[e] << (8 * e);
            return 128 & t[n - 1] ? -(i & ~(128 << (8 * (n - 1)))) : i;
          }),
          (e.encode = function (t) {
            let e = Math.abs(t);
            const r =
                ((o = e),
                o > 2147483647
                  ? 5
                  : o > 8388607
                    ? 4
                    : o > 32767
                      ? 3
                      : o > 127
                        ? 2
                        : o > 0
                          ? 1
                          : 0),
              n = new Uint8Array(r),
              i = t < 0;
            var o;
            for (let t = 0; t < r; ++t) s.writeUInt8(n, t, 255 & e), (e >>= 8);
            128 & n[r - 1]
              ? s.writeUInt8(n, r - 1, i ? 128 : 0)
              : i && (n[r - 1] |= 128);
            return n;
          });
        const s = o(r(22333));
      },
      56100: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.decode = function (t) {
            const e = c.readUInt8(t, t.length - 1);
            if (!(0, a.isDefinedHashType)(e))
              throw new Error("Invalid hashType " + e);
            const r = s.decode(t.subarray(0, -1)),
              n = d(r.r),
              i = d(r.s);
            return { signature: c.concat([n, i]), hashType: e };
          }),
          (e.encode = function (t, e) {
            if (
              (u.parse(
                u.object({
                  signature: (0, f.NBufferSchemaFactory)(64),
                  hashType: f.UInt8Schema,
                }),
                { signature: t, hashType: e },
              ),
              !(0, a.isDefinedHashType)(e))
            )
              throw new Error("Invalid hashType " + e);
            const r = new Uint8Array(1);
            c.writeUInt8(r, 0, e);
            const n = l(t.slice(0, 32)),
              i = l(t.slice(32, 64));
            return c.concat([s.encode(n, i), r]);
          });
        const s = o(r(56607)),
          a = r(19711),
          u = o(r(51947)),
          c = o(r(22333)),
          f = r(90485),
          h = new Uint8Array(1);
        function l(t) {
          let e = 0;
          for (; 0 === t[e]; ) ++e;
          return e === t.length
            ? h
            : 128 & (t = t.slice(e))[0]
              ? c.concat([h, t])
              : t;
        }
        function d(t) {
          0 === t[0] && (t = t.slice(1));
          const e = new Uint8Array(32),
            r = Math.max(0, 32 - t.length);
          return e.set(t, r), e;
        }
      },
      54110: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Transaction = void 0);
        const s = r(44311),
          a = o(r(5449)),
          u = r(22623),
          c = o(r(19711)),
          f = r(19711),
          h = o(r(90485)),
          l = o(r(22333)),
          d = o(r(51947));
        function p(t) {
          const e = t.length;
          return s.varuint.encodingLength(e) + e;
        }
        const y = new Uint8Array(0),
          g = [],
          m = l.fromHex(
            "0000000000000000000000000000000000000000000000000000000000000000",
          ),
          b = l.fromHex(
            "0000000000000000000000000000000000000000000000000000000000000001",
          ),
          w = l.fromHex("ffffffffffffffff"),
          v = { script: y, valueBuffer: w };
        class _ {
          static DEFAULT_SEQUENCE = 4294967295;
          static SIGHASH_DEFAULT = 0;
          static SIGHASH_ALL = 1;
          static SIGHASH_NONE = 2;
          static SIGHASH_SINGLE = 3;
          static SIGHASH_ANYONECANPAY = 128;
          static SIGHASH_OUTPUT_MASK = 3;
          static SIGHASH_INPUT_MASK = 128;
          static ADVANCED_TRANSACTION_MARKER = 0;
          static ADVANCED_TRANSACTION_FLAG = 1;
          static fromBuffer(t, e) {
            const r = new s.BufferReader(t),
              n = new _();
            n.version = r.readInt32();
            const i = r.readUInt8(),
              o = r.readUInt8();
            let a = !1;
            i === _.ADVANCED_TRANSACTION_MARKER &&
            o === _.ADVANCED_TRANSACTION_FLAG
              ? (a = !0)
              : (r.offset -= 2);
            const u = r.readVarInt();
            for (let t = 0; t < u; ++t)
              n.ins.push({
                hash: r.readSlice(32),
                index: r.readUInt32(),
                script: r.readVarSlice(),
                sequence: r.readUInt32(),
                witness: g,
              });
            const c = r.readVarInt();
            for (let t = 0; t < c; ++t)
              n.outs.push({ value: r.readInt64(), script: r.readVarSlice() });
            if (a) {
              for (let t = 0; t < u; ++t) n.ins[t].witness = r.readVector();
              if (!n.hasWitnesses())
                throw new Error("Transaction has superfluous witness data");
            }
            if (((n.locktime = r.readUInt32()), e)) return n;
            if (r.offset !== t.length)
              throw new Error("Transaction has unexpected data");
            return n;
          }
          static fromHex(t) {
            return _.fromBuffer(l.fromHex(t), !1);
          }
          static isCoinbaseHash(t) {
            d.parse(h.Hash256bitSchema, t);
            for (let e = 0; e < 32; ++e) if (0 !== t[e]) return !1;
            return !0;
          }
          version = 1;
          locktime = 0;
          ins = [];
          outs = [];
          isCoinbase() {
            return 1 === this.ins.length && _.isCoinbaseHash(this.ins[0].hash);
          }
          addInput(t, e, r, n) {
            return (
              d.parse(
                d.tuple([
                  h.Hash256bitSchema,
                  h.UInt32Schema,
                  d.nullable(d.optional(h.UInt32Schema)),
                  d.nullable(d.optional(h.BufferSchema)),
                ]),
                [t, e, r, n],
              ),
              null == r && (r = _.DEFAULT_SEQUENCE),
              this.ins.push({
                hash: t,
                index: e,
                script: n || y,
                sequence: r,
                witness: g,
              }) - 1
            );
          }
          addOutput(t, e) {
            return (
              d.parse(d.tuple([h.BufferSchema, h.SatoshiSchema]), [t, e]),
              this.outs.push({ script: t, value: e }) - 1
            );
          }
          hasWitnesses() {
            return this.ins.some((t) => 0 !== t.witness.length);
          }
          weight() {
            return 3 * this.byteLength(!1) + this.byteLength(!0);
          }
          virtualSize() {
            return Math.ceil(this.weight() / 4);
          }
          byteLength(t = !0) {
            const e = t && this.hasWitnesses();
            return (
              (e ? 10 : 8) +
              s.varuint.encodingLength(this.ins.length) +
              s.varuint.encodingLength(this.outs.length) +
              this.ins.reduce((t, e) => t + 40 + p(e.script), 0) +
              this.outs.reduce((t, e) => t + 8 + p(e.script), 0) +
              (e
                ? this.ins.reduce(
                    (t, e) =>
                      t +
                      (function (t) {
                        const e = t.length;
                        return (
                          s.varuint.encodingLength(e) +
                          t.reduce((t, e) => t + p(e), 0)
                        );
                      })(e.witness),
                    0,
                  )
                : 0)
            );
          }
          clone() {
            const t = new _();
            return (
              (t.version = this.version),
              (t.locktime = this.locktime),
              (t.ins = this.ins.map((t) => ({
                hash: t.hash,
                index: t.index,
                script: t.script,
                sequence: t.sequence,
                witness: t.witness,
              }))),
              (t.outs = this.outs.map((t) => ({
                script: t.script,
                value: t.value,
              }))),
              t
            );
          }
          hashForSignature(t, e, r) {
            if (
              (d.parse(d.tuple([h.UInt32Schema, h.BufferSchema, d.number()]), [
                t,
                e,
                r,
              ]),
              t >= this.ins.length)
            )
              return b;
            const n = c.compile(
                c.decompile(e).filter((t) => t !== f.OPS.OP_CODESEPARATOR),
              ),
              i = this.clone();
            if ((31 & r) === _.SIGHASH_NONE)
              (i.outs = []),
                i.ins.forEach((e, r) => {
                  r !== t && (e.sequence = 0);
                });
            else if ((31 & r) === _.SIGHASH_SINGLE) {
              if (t >= this.outs.length) return b;
              i.outs.length = t + 1;
              for (let e = 0; e < t; e++) i.outs[e] = v;
              i.ins.forEach((e, r) => {
                r !== t && (e.sequence = 0);
              });
            }
            r & _.SIGHASH_ANYONECANPAY
              ? ((i.ins = [i.ins[t]]), (i.ins[0].script = n))
              : (i.ins.forEach((t) => {
                  t.script = y;
                }),
                (i.ins[t].script = n));
            const o = new Uint8Array(i.byteLength(!1) + 4);
            return (
              l.writeInt32(o, o.length - 4, r, "LE"),
              i.__toBuffer(o, 0, !1),
              a.hash256(o)
            );
          }
          hashForWitnessV1(t, e, r, n, i, o) {
            if (
              (d.parse(
                d.tuple([
                  h.UInt32Schema,
                  d.array(h.BufferSchema),
                  d.array(h.SatoshiSchema),
                  h.UInt32Schema,
                ]),
                [t, e, r, n],
              ),
              r.length !== this.ins.length || e.length !== this.ins.length)
            )
              throw new Error(
                "Must supply prevout script and value for all inputs",
              );
            const c =
                n === _.SIGHASH_DEFAULT
                  ? _.SIGHASH_ALL
                  : n & _.SIGHASH_OUTPUT_MASK,
              f = (n & _.SIGHASH_INPUT_MASK) === _.SIGHASH_ANYONECANPAY,
              g = c === _.SIGHASH_NONE,
              m = c === _.SIGHASH_SINGLE;
            let b = y,
              w = y,
              v = y,
              E = y,
              S = y;
            if (!f) {
              let t = s.BufferWriter.withCapacity(36 * this.ins.length);
              this.ins.forEach((e) => {
                t.writeSlice(e.hash), t.writeUInt32(e.index);
              }),
                (b = (0, u.sha256)(t.end())),
                (t = s.BufferWriter.withCapacity(8 * this.ins.length)),
                r.forEach((e) => t.writeInt64(e)),
                (w = (0, u.sha256)(t.end())),
                (t = s.BufferWriter.withCapacity(
                  e.map(p).reduce((t, e) => t + e),
                )),
                e.forEach((e) => t.writeVarSlice(e)),
                (v = (0, u.sha256)(t.end())),
                (t = s.BufferWriter.withCapacity(4 * this.ins.length)),
                this.ins.forEach((e) => t.writeUInt32(e.sequence)),
                (E = (0, u.sha256)(t.end()));
            }
            if (g || m) {
              if (m && t < this.outs.length) {
                const e = this.outs[t],
                  r = s.BufferWriter.withCapacity(8 + p(e.script));
                r.writeInt64(e.value),
                  r.writeVarSlice(e.script),
                  (S = (0, u.sha256)(r.end()));
              }
            } else {
              if (!this.outs.length)
                throw new Error(
                  "Add outputs to the transaction before signing.",
                );
              const t = this.outs
                  .map((t) => 8 + p(t.script))
                  .reduce((t, e) => t + e),
                e = s.BufferWriter.withCapacity(t);
              this.outs.forEach((t) => {
                e.writeInt64(t.value), e.writeVarSlice(t.script);
              }),
                (S = (0, u.sha256)(e.end()));
            }
            const I = (i ? 2 : 0) + (o ? 1 : 0),
              M =
                174 - (f ? 49 : 0) - (g ? 32 : 0) + (o ? 32 : 0) + (i ? 37 : 0),
              A = s.BufferWriter.withCapacity(M);
            if (
              (A.writeUInt8(n),
              A.writeInt32(this.version),
              A.writeUInt32(this.locktime),
              A.writeSlice(b),
              A.writeSlice(w),
              A.writeSlice(v),
              A.writeSlice(E),
              g || m || A.writeSlice(S),
              A.writeUInt8(I),
              f)
            ) {
              const n = this.ins[t];
              A.writeSlice(n.hash),
                A.writeUInt32(n.index),
                A.writeInt64(r[t]),
                A.writeVarSlice(e[t]),
                A.writeUInt32(n.sequence);
            } else A.writeUInt32(t);
            if (o) {
              const t = s.BufferWriter.withCapacity(p(o));
              t.writeVarSlice(o), A.writeSlice((0, u.sha256)(t.end()));
            }
            return (
              m && A.writeSlice(S),
              i &&
                (A.writeSlice(i), A.writeUInt8(0), A.writeUInt32(4294967295)),
              a.taggedHash(
                "TapSighash",
                l.concat([Uint8Array.from([0]), A.end()]),
              )
            );
          }
          hashForWitnessV0(t, e, r, n) {
            d.parse(
              d.tuple([
                h.UInt32Schema,
                h.BufferSchema,
                h.SatoshiSchema,
                h.UInt32Schema,
              ]),
              [t, e, r, n],
            );
            let i,
              o = Uint8Array.from([]),
              u = m,
              c = m,
              f = m;
            if (
              (n & _.SIGHASH_ANYONECANPAY ||
                ((o = new Uint8Array(36 * this.ins.length)),
                (i = new s.BufferWriter(o, 0)),
                this.ins.forEach((t) => {
                  i.writeSlice(t.hash), i.writeUInt32(t.index);
                }),
                (c = a.hash256(o))),
              n & _.SIGHASH_ANYONECANPAY ||
                (31 & n) === _.SIGHASH_SINGLE ||
                (31 & n) === _.SIGHASH_NONE ||
                ((o = new Uint8Array(4 * this.ins.length)),
                (i = new s.BufferWriter(o, 0)),
                this.ins.forEach((t) => {
                  i.writeUInt32(t.sequence);
                }),
                (f = a.hash256(o))),
              (31 & n) !== _.SIGHASH_SINGLE && (31 & n) !== _.SIGHASH_NONE)
            ) {
              const t = this.outs.reduce((t, e) => t + 8 + p(e.script), 0);
              (o = new Uint8Array(t)),
                (i = new s.BufferWriter(o, 0)),
                this.outs.forEach((t) => {
                  i.writeInt64(t.value), i.writeVarSlice(t.script);
                }),
                (u = a.hash256(o));
            } else if ((31 & n) === _.SIGHASH_SINGLE && t < this.outs.length) {
              const e = this.outs[t];
              (o = new Uint8Array(8 + p(e.script))),
                (i = new s.BufferWriter(o, 0)),
                i.writeInt64(e.value),
                i.writeVarSlice(e.script),
                (u = a.hash256(o));
            }
            (o = new Uint8Array(156 + p(e))), (i = new s.BufferWriter(o, 0));
            const l = this.ins[t];
            return (
              i.writeInt32(this.version),
              i.writeSlice(c),
              i.writeSlice(f),
              i.writeSlice(l.hash),
              i.writeUInt32(l.index),
              i.writeVarSlice(e),
              i.writeInt64(r),
              i.writeUInt32(l.sequence),
              i.writeSlice(u),
              i.writeUInt32(this.locktime),
              i.writeUInt32(n),
              a.hash256(o)
            );
          }
          getHash(t) {
            return t && this.isCoinbase()
              ? new Uint8Array(32)
              : a.hash256(this.__toBuffer(void 0, void 0, t));
          }
          getId() {
            return l.toHex((0, s.reverseBuffer)(this.getHash(!1)));
          }
          toBuffer(t, e) {
            return this.__toBuffer(t, e, !0);
          }
          toHex() {
            return l.toHex(this.toBuffer(void 0, void 0));
          }
          setInputScript(t, e) {
            d.parse(d.tuple([d.number(), h.BufferSchema]), [t, e]),
              (this.ins[t].script = e);
          }
          setWitness(t, e) {
            d.parse(d.tuple([d.number(), d.array(h.BufferSchema)]), [t, e]),
              (this.ins[t].witness = e);
          }
          __toBuffer(t, e, r = !1) {
            t || (t = new Uint8Array(this.byteLength(r)));
            const n = new s.BufferWriter(t, e || 0);
            n.writeInt32(this.version);
            const i = r && this.hasWitnesses();
            return (
              i &&
                (n.writeUInt8(_.ADVANCED_TRANSACTION_MARKER),
                n.writeUInt8(_.ADVANCED_TRANSACTION_FLAG)),
              n.writeVarInt(this.ins.length),
              this.ins.forEach((t) => {
                n.writeSlice(t.hash),
                  n.writeUInt32(t.index),
                  n.writeVarSlice(t.script),
                  n.writeUInt32(t.sequence);
              }),
              n.writeVarInt(this.outs.length),
              this.outs.forEach((t) => {
                void 0 !== t.value
                  ? n.writeInt64(t.value)
                  : n.writeSlice(t.valueBuffer),
                  n.writeVarSlice(t.script);
              }),
              i &&
                this.ins.forEach((t) => {
                  n.writeVector(t.witness);
                }),
              n.writeUInt32(this.locktime),
              void 0 !== e ? t.slice(e, n.offset) : t
            );
          }
        }
        e.Transaction = _;
      },
      90485: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.NullablePartial =
            e.SatoshiSchema =
            e.UInt32Schema =
            e.UInt8Schema =
            e.HexSchema =
            e.BufferSchema =
            e.Hash256bitSchema =
            e.Hash160bitSchema =
            e.Buffer256bitSchema =
            e.TAPLEAF_VERSION_MASK =
            e.NBufferSchemaFactory =
              void 0),
          (e.stacksEqual = function (t, e) {
            return (
              t.length === e.length &&
              t.every((t, r) => 0 === s.compare(t, e[r]))
            );
          }),
          (e.isPoint = function (t) {
            if (!(t instanceof Uint8Array)) return !1;
            if (t.length < 33) return !1;
            const e = t[0],
              r = t.slice(1, 33);
            if (0 === s.compare(u, r)) return !1;
            if (s.compare(r, c) >= 0) return !1;
            if ((2 === e || 3 === e) && 33 === t.length) return !0;
            const n = t.slice(33);
            return (
              0 !== s.compare(u, n) &&
              !(s.compare(n, c) >= 0) &&
              4 === e &&
              65 === t.length
            );
          }),
          (e.isTapleaf = f),
          (e.isTaptree = function t(e) {
            return Array.isArray(e)
              ? 2 === e.length && e.every((e) => t(e))
              : f(e);
          });
        const s = o(r(22333)),
          a = o(r(51947)),
          u = new Uint8Array(32),
          c = s.fromHex(
            "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
          );
        function f(t) {
          return (
            !(!t || !("output" in t)) &&
            t.output instanceof Uint8Array &&
            (void 0 === t.version ||
              (t.version & e.TAPLEAF_VERSION_MASK) === t.version)
          );
        }
        (e.NBufferSchemaFactory = (t) =>
          a.pipe(a.instance(Uint8Array), a.length(t))),
          (e.TAPLEAF_VERSION_MASK = 254),
          (e.Buffer256bitSchema = (0, e.NBufferSchemaFactory)(32)),
          (e.Hash160bitSchema = (0, e.NBufferSchemaFactory)(20)),
          (e.Hash256bitSchema = (0, e.NBufferSchemaFactory)(32)),
          (e.BufferSchema = a.instance(Uint8Array)),
          (e.HexSchema = a.pipe(a.string(), a.regex(/^([0-9a-f]{2})+$/i))),
          (e.UInt8Schema = a.pipe(
            a.number(),
            a.integer(),
            a.minValue(0),
            a.maxValue(255),
          )),
          (e.UInt32Schema = a.pipe(
            a.number(),
            a.integer(),
            a.minValue(0),
            a.maxValue(4294967295),
          )),
          (e.SatoshiSchema = a.pipe(
            a.bigint(),
            a.minValue(0n),
            a.maxValue(0x7fffffffffffffffn),
          ));
        e.NullablePartial = (t) =>
          a.object(
            Object.entries(t).reduce(
              (t, e) => ({ ...t, [e[0]]: a.nullish(e[1]) }),
              {},
            ),
          );
      },
      37393: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = n(r(96395));
        e.default = (0, i.default)(
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        );
      },
      12080: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.default = function (t) {
            function e(e) {
              var r = e.slice(0, -4),
                n = e.slice(-4),
                i = t(r);
              if (
                !((n[0] ^ i[0]) | (n[1] ^ i[1]) | (n[2] ^ i[2]) | (n[3] ^ i[3]))
              )
                return r;
            }
            return {
              encode: function (e) {
                var r = Uint8Array.from(e),
                  n = t(r),
                  o = r.length + 4,
                  s = new Uint8Array(o);
                return (
                  s.set(r, 0),
                  s.set(n.subarray(0, 4), r.length),
                  i.default.encode(s)
                );
              },
              decode: function (t) {
                var r = e(i.default.decode(t));
                if (null == r) throw new Error("Invalid checksum");
                return r;
              },
              decodeUnsafe: function (t) {
                var r = i.default.decodeUnsafe(t);
                if (null != r) return e(r);
              },
            };
          });
        var i = n(r(37393));
      },
      30681: function (t, e, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = r(22623),
          o = n(r(12080));
        e.default = (0, o.default)(function (t) {
          return (0, i.sha256)((0, i.sha256)(t));
        });
      },
      51947: (t) => {
        "use strict";
        var e,
          r = Object.defineProperty,
          n = Object.getOwnPropertyDescriptor,
          i = Object.getOwnPropertyNames,
          o = Object.prototype.hasOwnProperty,
          s = {};
        function a() {
          return {
            kind: "transformation",
            type: "await",
            reference: a,
            async: !0,
            _run: async (t) => ((t.value = await t.value), t),
          };
        }
        ((t, e) => {
          for (var n in e) r(t, n, { get: e[n], enumerable: !0 });
        })(s, {
          BASE64_REGEX: () => l,
          BIC_REGEX: () => d,
          CUID2_REGEX: () => p,
          DECIMAL_REGEX: () => y,
          EMAIL_REGEX: () => g,
          EMOJI_REGEX: () => m,
          HEXADECIMAL_REGEX: () => b,
          HEX_COLOR_REGEX: () => w,
          IMEI_REGEX: () => v,
          IPV4_REGEX: () => _,
          IPV6_REGEX: () => E,
          IP_REGEX: () => S,
          ISO_DATE_REGEX: () => I,
          ISO_DATE_TIME_REGEX: () => M,
          ISO_TIMESTAMP_REGEX: () => k,
          ISO_TIME_REGEX: () => A,
          ISO_TIME_SECOND_REGEX: () => T,
          ISO_WEEK_REGEX: () => O,
          MAC48_REGEX: () => x,
          MAC64_REGEX: () => P,
          MAC_REGEX: () => B,
          OCTAL_REGEX: () => C,
          ULID_REGEX: () => R,
          UUID_REGEX: () => N,
          ValiError: () => ot,
          _addIssue: () => Y,
          _isLuhnAlgo: () => Z,
          _isValidObjectKey: () => J,
          _joinExpects: () => Q,
          _stringify: () => W,
          any: () => tr,
          array: () => er,
          arrayAsync: () => rr,
          awaitAsync: () => a,
          base64: () => st,
          bic: () => at,
          bigint: () => nr,
          blob: () => ir,
          boolean: () => or,
          brand: () => ut,
          bytes: () => ct,
          check: () => ft,
          checkAsync: () => ht,
          checkItems: () => lt,
          config: () => He,
          creditCard: () => gt,
          cuid2: () => mt,
          custom: () => sr,
          customAsync: () => ar,
          date: () => ur,
          decimal: () => bt,
          deleteGlobalConfig: () => L,
          deleteGlobalMessage: () => H,
          deleteSchemaMessage: () => q,
          deleteSpecificMessage: () => G,
          description: () => wt,
          email: () => vt,
          emoji: () => _t,
          empty: () => Et,
          endsWith: () => St,
          entriesFromList: () => tt,
          enum: () => cr,
          enum_: () => cr,
          everyItem: () => It,
          excludes: () => Mt,
          fallback: () => Ve,
          fallbackAsync: () => qe,
          file: () => fr,
          filterItems: () => At,
          findItem: () => Tt,
          finite: () => kt,
          flatten: () => ze,
          forward: () => $e,
          forwardAsync: () => Ge,
          function: () => hr,
          function_: () => hr,
          getDefault: () => We,
          getDefaults: () => Ye,
          getDefaultsAsync: () => Xe,
          getDotPath: () => et,
          getFallback: () => Ke,
          getFallbacks: () => Ze,
          getFallbacksAsync: () => Je,
          getGlobalConfig: () => D,
          getGlobalMessage: () => F,
          getSchemaMessage: () => V,
          getSpecificMessage: () => $,
          hash: () => xt,
          hexColor: () => Bt,
          hexadecimal: () => Pt,
          imei: () => Ct,
          includes: () => Rt,
          instance: () => lr,
          integer: () => Nt,
          intersect: () => pr,
          intersectAsync: () => yr,
          ip: () => Ut,
          ipv4: () => Dt,
          ipv6: () => Lt,
          is: () => Qe,
          isOfKind: () => rt,
          isOfType: () => nt,
          isValiError: () => it,
          isoDate: () => jt,
          isoDateTime: () => Ft,
          isoTime: () => Ht,
          isoTimeSecond: () => Kt,
          isoTimestamp: () => Vt,
          isoWeek: () => qt,
          keyof: () => mn,
          lazy: () => gr,
          lazyAsync: () => mr,
          length: () => zt,
          literal: () => br,
          looseObject: () => wr,
          looseObjectAsync: () => vr,
          looseTuple: () => _r,
          looseTupleAsync: () => Er,
          mac: () => $t,
          mac48: () => Gt,
          mac64: () => Wt,
          map: () => Sr,
          mapAsync: () => Ir,
          mapItems: () => Yt,
          maxBytes: () => Xt,
          maxLength: () => Zt,
          maxSize: () => Jt,
          maxValue: () => Qt,
          mimeType: () => te,
          minBytes: () => ee,
          minLength: () => re,
          minSize: () => ne,
          minValue: () => ie,
          multipleOf: () => oe,
          nan: () => Mr,
          never: () => Ar,
          nonEmpty: () => se,
          nonNullable: () => Tr,
          nonNullableAsync: () => kr,
          nonNullish: () => Or,
          nonNullishAsync: () => xr,
          nonOptional: () => Pr,
          nonOptionalAsync: () => Br,
          normalize: () => ae,
          notBytes: () => ue,
          notLength: () => ce,
          notSize: () => fe,
          notValue: () => he,
          null: () => Cr,
          null_: () => Cr,
          nullable: () => Rr,
          nullableAsync: () => Nr,
          nullish: () => Ur,
          nullishAsync: () => Dr,
          number: () => Lr,
          object: () => jr,
          objectAsync: () => Fr,
          objectWithRest: () => Hr,
          objectWithRestAsync: () => Kr,
          octal: () => le,
          omit: () => bn,
          optional: () => Vr,
          optionalAsync: () => qr,
          parse: () => wn,
          parseAsync: () => vn,
          parser: () => _n,
          parserAsync: () => En,
          partial: () => Sn,
          partialAsync: () => In,
          partialCheck: () => pe,
          partialCheckAsync: () => ye,
          pick: () => Mn,
          picklist: () => zr,
          pipe: () => An,
          pipeAsync: () => Tn,
          promise: () => $r,
          rawCheck: () => ge,
          rawCheckAsync: () => me,
          rawTransform: () => be,
          rawTransformAsync: () => we,
          readonly: () => ve,
          record: () => Gr,
          recordAsync: () => Wr,
          reduceItems: () => _e,
          regex: () => Ee,
          required: () => kn,
          requiredAsync: () => On,
          safeInteger: () => Se,
          safeParse: () => xn,
          safeParseAsync: () => Pn,
          safeParser: () => Bn,
          safeParserAsync: () => Cn,
          set: () => Yr,
          setAsync: () => Xr,
          setGlobalConfig: () => U,
          setGlobalMessage: () => j,
          setSchemaMessage: () => K,
          setSpecificMessage: () => z,
          size: () => Ie,
          someItem: () => Me,
          sortItems: () => Ae,
          startsWith: () => Te,
          strictObject: () => Zr,
          strictObjectAsync: () => Jr,
          strictTuple: () => Qr,
          strictTupleAsync: () => tn,
          string: () => en,
          symbol: () => rn,
          toLowerCase: () => ke,
          toMaxValue: () => Oe,
          toMinValue: () => xe,
          toUpperCase: () => Pe,
          transform: () => Be,
          transformAsync: () => Ce,
          trim: () => Re,
          trimEnd: () => Ne,
          trimStart: () => Ue,
          tuple: () => nn,
          tupleAsync: () => on,
          tupleWithRest: () => sn,
          tupleWithRestAsync: () => an,
          ulid: () => De,
          undefined: () => un,
          undefined_: () => un,
          union: () => fn,
          unionAsync: () => hn,
          unknown: () => ln,
          unwrap: () => Rn,
          url: () => Le,
          uuid: () => je,
          value: () => Fe,
          variant: () => pn,
          variantAsync: () => yn,
          void: () => gn,
          void_: () => gn,
        }),
          (t.exports =
            ((e = s),
            ((t, e, s, a) => {
              if ((e && "object" == typeof e) || "function" == typeof e)
                for (let u of i(e))
                  o.call(t, u) ||
                    u === s ||
                    r(t, u, {
                      get: () => e[u],
                      enumerable: !(a = n(e, u)) || a.enumerable,
                    });
              return t;
            })(r({}, "__esModule", { value: !0 }), e)));
        var u,
          c,
          f,
          h,
          l = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu,
          d = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u,
          p = /^[a-z][\da-z]*$/u,
          y = /^\d+$/u,
          g = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu,
          m =
            /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}))*)+$/u,
          b = /^(?:0[hx])?[\da-f]+$/iu,
          w = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/iu,
          v = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u,
          _ =
            /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u,
          E =
            /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu,
          S =
            /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu,
          I = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u,
          M =
            /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u,
          A = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u,
          T = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u,
          k =
            /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u,
          O = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u,
          x =
            /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu,
          P =
            /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu,
          B =
            /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu,
          C = /^(?:0o)?[0-7]+$/iu,
          R = /^[\da-hjkmnp-tv-z]{26}$/iu,
          N = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
        function U(t) {
          u = { ...u, ...t };
        }
        function D(t) {
          return {
            lang: t?.lang ?? u?.lang,
            message: t?.message,
            abortEarly: t?.abortEarly ?? u?.abortEarly,
            abortPipeEarly: t?.abortPipeEarly ?? u?.abortPipeEarly,
          };
        }
        function L() {
          u = void 0;
        }
        function j(t, e) {
          c || (c = new Map()), c.set(e, t);
        }
        function F(t) {
          return c?.get(t);
        }
        function H(t) {
          c?.delete(t);
        }
        function K(t, e) {
          f || (f = new Map()), f.set(e, t);
        }
        function V(t) {
          return f?.get(t);
        }
        function q(t) {
          f?.delete(t);
        }
        function z(t, e, r) {
          h || (h = new Map()),
            h.get(t) || h.set(t, new Map()),
            h.get(t).set(r, e);
        }
        function $(t, e) {
          return h?.get(t)?.get(e);
        }
        function G(t, e) {
          h?.get(t)?.delete(e);
        }
        function W(t) {
          const e = typeof t;
          return "string" === e
            ? `"${t}"`
            : "number" === e || "bigint" === e || "boolean" === e
              ? `${t}`
              : "object" === e || "function" === e
                ? ((t && Object.getPrototypeOf(t)?.constructor?.name) ?? "null")
                : e;
        }
        function Y(t, e, r, n, i) {
          const o = i && "input" in i ? i.input : r.value,
            s = i?.expected ?? t.expects ?? null,
            a = i?.received ?? W(o),
            u = {
              kind: t.kind,
              type: t.type,
              input: o,
              expected: s,
              received: a,
              message: `Invalid ${e}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
              requirement: t.requirement,
              path: i?.path,
              issues: i?.issues,
              lang: n.lang,
              abortEarly: n.abortEarly,
              abortPipeEarly: n.abortPipeEarly,
            },
            c = "schema" === t.kind,
            f =
              i?.message ??
              t.message ??
              $(t.reference, u.lang) ??
              (c ? V(u.lang) : null) ??
              n.message ??
              F(u.lang);
          f && (u.message = "function" == typeof f ? f(u) : f),
            c && (r.typed = !1),
            r.issues ? r.issues.push(u) : (r.issues = [u]);
        }
        var X = /\D/gu;
        function Z(t) {
          const e = t.replace(X, "");
          let r = e.length,
            n = 1,
            i = 0;
          for (; r; ) {
            const t = +e[--r];
            (n ^= 1), (i += n ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][t] : t);
          }
          return i % 10 == 0;
        }
        function J(t, e) {
          return (
            Object.hasOwn(t, e) &&
            "__proto__" !== e &&
            "prototype" !== e &&
            "constructor" !== e
          );
        }
        function Q(t, e) {
          const r = [...new Set(t)];
          return r.length > 1 ? `(${r.join(` ${e} `)})` : (r[0] ?? "never");
        }
        function tt(t, e) {
          const r = {};
          for (const n of t) r[n] = e;
          return r;
        }
        function et(t) {
          if (t.path) {
            let e = "";
            for (const r of t.path) {
              if ("string" != typeof r.key && "number" != typeof r.key)
                return null;
              e += e ? `.${r.key}` : r.key;
            }
            return e;
          }
          return null;
        }
        function rt(t, e) {
          return e.kind === t;
        }
        function nt(t, e) {
          return e.type === t;
        }
        function it(t) {
          return t instanceof ot;
        }
        var ot = class extends Error {
          issues;
          constructor(t) {
            super(t[0].message), (this.name = "ValiError"), (this.issues = t);
          }
        };
        function st(t) {
          return {
            kind: "validation",
            type: "base64",
            reference: st,
            async: !1,
            expects: null,
            requirement: l,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "Base64", t, e),
                t
              );
            },
          };
        }
        function at(t) {
          return {
            kind: "validation",
            type: "bic",
            reference: at,
            async: !1,
            expects: null,
            requirement: d,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "BIC", t, e),
                t
              );
            },
          };
        }
        function ut(t) {
          return {
            kind: "transformation",
            type: "brand",
            reference: ut,
            async: !1,
            name: t,
            _run: (t) => t,
          };
        }
        function ct(t, e) {
          return {
            kind: "validation",
            type: "bytes",
            reference: ct,
            async: !1,
            expects: `${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              if (t.typed) {
                const r = new TextEncoder().encode(t.value).length;
                r !== this.requirement &&
                  Y(this, "bytes", t, e, { received: `${r}` });
              }
              return t;
            },
          };
        }
        function ft(t, e) {
          return {
            kind: "validation",
            type: "check",
            reference: ft,
            async: !1,
            expects: null,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed && !this.requirement(t.value) && Y(this, "input", t, e),
                t
              );
            },
          };
        }
        function ht(t, e) {
          return {
            kind: "validation",
            type: "check",
            reference: ht,
            async: !0,
            expects: null,
            requirement: t,
            message: e,
            async _run(t, e) {
              return (
                t.typed &&
                  !(await this.requirement(t.value)) &&
                  Y(this, "input", t, e),
                t
              );
            },
          };
        }
        function lt(t, e) {
          return {
            kind: "validation",
            type: "check_items",
            reference: lt,
            async: !1,
            expects: null,
            requirement: t,
            message: e,
            _run(t, e) {
              if (t.typed)
                for (let r = 0; r < t.value.length; r++) {
                  const n = t.value[r];
                  this.requirement(n, r, t.value) ||
                    Y(this, "item", t, e, {
                      input: n,
                      path: [
                        {
                          type: "array",
                          origin: "value",
                          input: t.value,
                          key: r,
                          value: n,
                        },
                      ],
                    });
                }
              return t;
            },
          };
        }
        var dt =
            /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u,
          pt = /[- ]/gu,
          yt = [
            /^3[47]\d{13}$/u,
            /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
            /^6(?:011|5\d{2})\d{12,15}$/u,
            /^(?:2131|1800|35\d{3})\d{11}$/u,
            /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
            /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
            /^4\d{12}(?:\d{3,6})?$/u,
          ];
        function gt(t) {
          return {
            kind: "validation",
            type: "credit_card",
            reference: gt,
            async: !1,
            expects: null,
            requirement(t) {
              let e;
              return (
                dt.test(t) &&
                (e = t.replace(pt, "")) &&
                yt.some((t) => t.test(e)) &&
                Z(e)
              );
            },
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement(t.value) &&
                  Y(this, "credit card", t, e),
                t
              );
            },
          };
        }
        function mt(t) {
          return {
            kind: "validation",
            type: "cuid2",
            reference: mt,
            async: !1,
            expects: null,
            requirement: p,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "Cuid2", t, e),
                t
              );
            },
          };
        }
        function bt(t) {
          return {
            kind: "validation",
            type: "decimal",
            reference: bt,
            async: !1,
            expects: null,
            requirement: y,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "decimal", t, e),
                t
              );
            },
          };
        }
        function wt(t) {
          return {
            kind: "metadata",
            type: "description",
            reference: wt,
            description: t,
          };
        }
        function vt(t) {
          return {
            kind: "validation",
            type: "email",
            reference: vt,
            expects: null,
            async: !1,
            requirement: g,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "email", t, e),
                t
              );
            },
          };
        }
        function _t(t) {
          return {
            kind: "validation",
            type: "emoji",
            reference: _t,
            async: !1,
            expects: null,
            requirement: m,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "emoji", t, e),
                t
              );
            },
          };
        }
        function Et(t) {
          return {
            kind: "validation",
            type: "empty",
            reference: Et,
            async: !1,
            expects: "0",
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.length > 0 &&
                  Y(this, "length", t, e, { received: `${t.value.length}` }),
                t
              );
            },
          };
        }
        function St(t, e) {
          return {
            kind: "validation",
            type: "ends_with",
            reference: St,
            async: !1,
            expects: `"${t}"`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !t.value.endsWith(this.requirement) &&
                  Y(this, "end", t, e, {
                    received: `"${t.value.slice(-this.requirement.length)}"`,
                  }),
                t
              );
            },
          };
        }
        function It(t, e) {
          return {
            kind: "validation",
            type: "every_item",
            reference: It,
            async: !1,
            expects: null,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !t.value.every(this.requirement) &&
                  Y(this, "item", t, e),
                t
              );
            },
          };
        }
        function Mt(t, e) {
          const r = W(t);
          return {
            kind: "validation",
            type: "excludes",
            reference: Mt,
            async: !1,
            expects: `!${r}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.includes(this.requirement) &&
                  Y(this, "content", t, e, { received: r }),
                t
              );
            },
          };
        }
        function At(t) {
          return {
            kind: "transformation",
            type: "filter_items",
            reference: At,
            async: !1,
            operation: t,
            _run(t) {
              return (t.value = t.value.filter(this.operation)), t;
            },
          };
        }
        function Tt(t) {
          return {
            kind: "transformation",
            type: "find_item",
            reference: Tt,
            async: !1,
            operation: t,
            _run(t) {
              return (t.value = t.value.find(this.operation)), t;
            },
          };
        }
        function kt(t) {
          return {
            kind: "validation",
            type: "finite",
            reference: kt,
            async: !1,
            expects: null,
            requirement: Number.isFinite,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement(t.value) &&
                  Y(this, "finite", t, e),
                t
              );
            },
          };
        }
        var Ot = {
          md4: 32,
          md5: 32,
          sha1: 40,
          sha256: 64,
          sha384: 96,
          sha512: 128,
          ripemd128: 32,
          ripemd160: 40,
          tiger128: 32,
          tiger160: 40,
          tiger192: 48,
          crc32: 8,
          crc32b: 8,
          adler32: 8,
        };
        function xt(t, e) {
          return {
            kind: "validation",
            type: "hash",
            reference: xt,
            expects: null,
            async: !1,
            requirement: RegExp(
              t.map((t) => `^[a-f0-9]{${Ot[t]}}$`).join("|"),
              "iu",
            ),
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "hash", t, e),
                t
              );
            },
          };
        }
        function Pt(t) {
          return {
            kind: "validation",
            type: "hexadecimal",
            reference: Pt,
            async: !1,
            expects: null,
            requirement: b,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "hexadecimal", t, e),
                t
              );
            },
          };
        }
        function Bt(t) {
          return {
            kind: "validation",
            type: "hex_color",
            reference: Bt,
            async: !1,
            expects: null,
            requirement: w,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "hex color", t, e),
                t
              );
            },
          };
        }
        function Ct(t) {
          return {
            kind: "validation",
            type: "imei",
            reference: Ct,
            async: !1,
            expects: null,
            requirement: (t) => v.test(t) && Z(t),
            message: t,
            _run(t, e) {
              return (
                t.typed && !this.requirement(t.value) && Y(this, "IMEI", t, e),
                t
              );
            },
          };
        }
        function Rt(t, e) {
          const r = W(t);
          return {
            kind: "validation",
            type: "includes",
            reference: Rt,
            async: !1,
            expects: r,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !t.value.includes(this.requirement) &&
                  Y(this, "content", t, e, { received: `!${r}` }),
                t
              );
            },
          };
        }
        function Nt(t) {
          return {
            kind: "validation",
            type: "integer",
            reference: Nt,
            async: !1,
            expects: null,
            requirement: Number.isInteger,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement(t.value) &&
                  Y(this, "integer", t, e),
                t
              );
            },
          };
        }
        function Ut(t) {
          return {
            kind: "validation",
            type: "ip",
            reference: Ut,
            async: !1,
            expects: null,
            requirement: S,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "IP", t, e),
                t
              );
            },
          };
        }
        function Dt(t) {
          return {
            kind: "validation",
            type: "ipv4",
            reference: Dt,
            async: !1,
            expects: null,
            requirement: _,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "IPv4", t, e),
                t
              );
            },
          };
        }
        function Lt(t) {
          return {
            kind: "validation",
            type: "ipv6",
            reference: Lt,
            async: !1,
            expects: null,
            requirement: E,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "IPv6", t, e),
                t
              );
            },
          };
        }
        function jt(t) {
          return {
            kind: "validation",
            type: "iso_date",
            reference: jt,
            async: !1,
            expects: null,
            requirement: I,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "date", t, e),
                t
              );
            },
          };
        }
        function Ft(t) {
          return {
            kind: "validation",
            type: "iso_date_time",
            reference: Ft,
            async: !1,
            expects: null,
            requirement: M,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "date-time", t, e),
                t
              );
            },
          };
        }
        function Ht(t) {
          return {
            kind: "validation",
            type: "iso_time",
            reference: Ht,
            async: !1,
            expects: null,
            requirement: A,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "time", t, e),
                t
              );
            },
          };
        }
        function Kt(t) {
          return {
            kind: "validation",
            type: "iso_time_second",
            reference: Kt,
            async: !1,
            expects: null,
            requirement: T,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "time-second", t, e),
                t
              );
            },
          };
        }
        function Vt(t) {
          return {
            kind: "validation",
            type: "iso_timestamp",
            reference: Vt,
            async: !1,
            expects: null,
            requirement: k,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "timestamp", t, e),
                t
              );
            },
          };
        }
        function qt(t) {
          return {
            kind: "validation",
            type: "iso_week",
            reference: qt,
            async: !1,
            expects: null,
            requirement: O,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "week", t, e),
                t
              );
            },
          };
        }
        function zt(t, e) {
          return {
            kind: "validation",
            type: "length",
            reference: zt,
            async: !1,
            expects: `${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.length !== this.requirement &&
                  Y(this, "length", t, e, { received: `${t.value.length}` }),
                t
              );
            },
          };
        }
        function $t(t) {
          return {
            kind: "validation",
            type: "mac",
            reference: $t,
            async: !1,
            expects: null,
            requirement: B,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "MAC", t, e),
                t
              );
            },
          };
        }
        function Gt(t) {
          return {
            kind: "validation",
            type: "mac48",
            reference: Gt,
            async: !1,
            expects: null,
            requirement: x,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "48-bit MAC", t, e),
                t
              );
            },
          };
        }
        function Wt(t) {
          return {
            kind: "validation",
            type: "mac64",
            reference: Wt,
            async: !1,
            expects: null,
            requirement: P,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "64-bit MAC", t, e),
                t
              );
            },
          };
        }
        function Yt(t) {
          return {
            kind: "transformation",
            type: "map_items",
            reference: Yt,
            async: !1,
            operation: t,
            _run(t) {
              return (t.value = t.value.map(this.operation)), t;
            },
          };
        }
        function Xt(t, e) {
          return {
            kind: "validation",
            type: "max_bytes",
            reference: Xt,
            async: !1,
            expects: `<=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              if (t.typed) {
                const r = new TextEncoder().encode(t.value).length;
                r > this.requirement &&
                  Y(this, "bytes", t, e, { received: `${r}` });
              }
              return t;
            },
          };
        }
        function Zt(t, e) {
          return {
            kind: "validation",
            type: "max_length",
            reference: Zt,
            async: !1,
            expects: `<=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.length > this.requirement &&
                  Y(this, "length", t, e, { received: `${t.value.length}` }),
                t
              );
            },
          };
        }
        function Jt(t, e) {
          return {
            kind: "validation",
            type: "max_size",
            reference: Jt,
            async: !1,
            expects: `<=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.size > this.requirement &&
                  Y(this, "size", t, e, { received: `${t.value.size}` }),
                t
              );
            },
          };
        }
        function Qt(t, e) {
          return {
            kind: "validation",
            type: "max_value",
            reference: Qt,
            async: !1,
            expects: `<=${t instanceof Date ? t.toJSON() : W(t)}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value > this.requirement &&
                  Y(this, "value", t, e, {
                    received:
                      t.value instanceof Date ? t.value.toJSON() : W(t.value),
                  }),
                t
              );
            },
          };
        }
        function te(t, e) {
          return {
            kind: "validation",
            type: "mime_type",
            reference: te,
            async: !1,
            expects: Q(
              t.map((t) => `"${t}"`),
              "|",
            ),
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.includes(t.value.type) &&
                  Y(this, "MIME type", t, e, { received: `"${t.value.type}"` }),
                t
              );
            },
          };
        }
        function ee(t, e) {
          return {
            kind: "validation",
            type: "min_bytes",
            reference: ee,
            async: !1,
            expects: `>=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              if (t.typed) {
                const r = new TextEncoder().encode(t.value).length;
                r < this.requirement &&
                  Y(this, "bytes", t, e, { received: `${r}` });
              }
              return t;
            },
          };
        }
        function re(t, e) {
          return {
            kind: "validation",
            type: "min_length",
            reference: re,
            async: !1,
            expects: `>=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.length < this.requirement &&
                  Y(this, "length", t, e, { received: `${t.value.length}` }),
                t
              );
            },
          };
        }
        function ne(t, e) {
          return {
            kind: "validation",
            type: "min_size",
            reference: ne,
            async: !1,
            expects: `>=${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.size < this.requirement &&
                  Y(this, "size", t, e, { received: `${t.value.size}` }),
                t
              );
            },
          };
        }
        function ie(t, e) {
          return {
            kind: "validation",
            type: "min_value",
            reference: ie,
            async: !1,
            expects: `>=${t instanceof Date ? t.toJSON() : W(t)}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value < this.requirement &&
                  Y(this, "value", t, e, {
                    received:
                      t.value instanceof Date ? t.value.toJSON() : W(t.value),
                  }),
                t
              );
            },
          };
        }
        function oe(t, e) {
          return {
            kind: "validation",
            type: "multiple_of",
            reference: oe,
            async: !1,
            expects: `%${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value % this.requirement != 0 &&
                  Y(this, "multiple", t, e),
                t
              );
            },
          };
        }
        function se(t) {
          return {
            kind: "validation",
            type: "non_empty",
            reference: se,
            async: !1,
            expects: "!0",
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  0 === t.value.length &&
                  Y(this, "length", t, e, { received: "0" }),
                t
              );
            },
          };
        }
        function ae(t) {
          return {
            kind: "transformation",
            type: "normalize",
            reference: ae,
            async: !1,
            form: t,
            _run(t) {
              return (t.value = t.value.normalize(this.form)), t;
            },
          };
        }
        function ue(t, e) {
          return {
            kind: "validation",
            type: "not_bytes",
            reference: ue,
            async: !1,
            expects: `!${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              if (t.typed) {
                const r = new TextEncoder().encode(t.value).length;
                r === this.requirement &&
                  Y(this, "bytes", t, e, { received: `${r}` });
              }
              return t;
            },
          };
        }
        function ce(t, e) {
          return {
            kind: "validation",
            type: "not_length",
            reference: ce,
            async: !1,
            expects: `!${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.length === this.requirement &&
                  Y(this, "length", t, e, { received: `${t.value.length}` }),
                t
              );
            },
          };
        }
        function fe(t, e) {
          return {
            kind: "validation",
            type: "not_size",
            reference: fe,
            async: !1,
            expects: `!${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.size === this.requirement &&
                  Y(this, "size", t, e, { received: `${t.value.size}` }),
                t
              );
            },
          };
        }
        function he(t, e) {
          return {
            kind: "validation",
            type: "not_value",
            reference: he,
            async: !1,
            expects: t instanceof Date ? `!${t.toJSON()}` : `!${W(t)}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  this.requirement <= t.value &&
                  this.requirement >= t.value &&
                  Y(this, "value", t, e, {
                    received:
                      t.value instanceof Date ? t.value.toJSON() : W(t.value),
                  }),
                t
              );
            },
          };
        }
        function le(t) {
          return {
            kind: "validation",
            type: "octal",
            reference: le,
            async: !1,
            expects: null,
            requirement: C,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "octal", t, e),
                t
              );
            },
          };
        }
        function de(t, e) {
          if (t.issues)
            for (const r of e)
              for (const e of t.issues) {
                let t = !1;
                const n = Math.min(r.length, e.path?.length ?? 0);
                for (let i = 0; i < n; i++)
                  if (r[i] !== e.path[i].key) {
                    t = !0;
                    break;
                  }
                if (!t) return !1;
              }
          return !0;
        }
        function pe(t, e, r) {
          return {
            kind: "validation",
            type: "partial_check",
            reference: pe,
            async: !1,
            expects: null,
            requirement: e,
            message: r,
            _run(e, r) {
              return (
                de(e, t) &&
                  !this.requirement(e.value) &&
                  Y(this, "input", e, r),
                e
              );
            },
          };
        }
        function ye(t, e, r) {
          return {
            kind: "validation",
            type: "partial_check",
            reference: ye,
            async: !0,
            expects: null,
            requirement: e,
            message: r,
            async _run(e, r) {
              return (
                de(e, t) &&
                  !(await this.requirement(e.value)) &&
                  Y(this, "input", e, r),
                e
              );
            },
          };
        }
        function ge(t) {
          return {
            kind: "validation",
            type: "raw_check",
            reference: ge,
            async: !1,
            expects: null,
            _run(e, r) {
              return (
                t({
                  dataset: e,
                  config: r,
                  addIssue: (t) => Y(this, t?.label ?? "input", e, r, t),
                }),
                e
              );
            },
          };
        }
        function me(t) {
          return {
            kind: "validation",
            type: "raw_check",
            reference: me,
            async: !0,
            expects: null,
            async _run(e, r) {
              return (
                await t({
                  dataset: e,
                  config: r,
                  addIssue: (t) => Y(this, t?.label ?? "input", e, r, t),
                }),
                e
              );
            },
          };
        }
        function be(t) {
          return {
            kind: "transformation",
            type: "raw_transform",
            reference: be,
            async: !1,
            _run(e, r) {
              const n = t({
                dataset: e,
                config: r,
                addIssue: (t) => Y(this, t?.label ?? "input", e, r, t),
                NEVER: null,
              });
              return e.issues ? (e.typed = !1) : (e.value = n), e;
            },
          };
        }
        function we(t) {
          return {
            kind: "transformation",
            type: "raw_transform",
            reference: we,
            async: !0,
            async _run(e, r) {
              const n = await t({
                dataset: e,
                config: r,
                addIssue: (t) => Y(this, t?.label ?? "input", e, r, t),
                NEVER: null,
              });
              return e.issues ? (e.typed = !1) : (e.value = n), e;
            },
          };
        }
        function ve() {
          return {
            kind: "transformation",
            type: "readonly",
            reference: ve,
            async: !1,
            _run: (t) => t,
          };
        }
        function _e(t, e) {
          return {
            kind: "transformation",
            type: "reduce_items",
            reference: _e,
            async: !1,
            operation: t,
            initial: e,
            _run(t) {
              return (
                (t.value = t.value.reduce(this.operation, this.initial)), t
              );
            },
          };
        }
        function Ee(t, e) {
          return {
            kind: "validation",
            type: "regex",
            reference: Ee,
            async: !1,
            expects: `${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "format", t, e),
                t
              );
            },
          };
        }
        function Se(t) {
          return {
            kind: "validation",
            type: "safe_integer",
            reference: Se,
            async: !1,
            expects: null,
            requirement: Number.isSafeInteger,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement(t.value) &&
                  Y(this, "safe integer", t, e),
                t
              );
            },
          };
        }
        function Ie(t, e) {
          return {
            kind: "validation",
            type: "size",
            reference: Ie,
            async: !1,
            expects: `${t}`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  t.value.size !== this.requirement &&
                  Y(this, "size", t, e, { received: `${t.value.size}` }),
                t
              );
            },
          };
        }
        function Me(t, e) {
          return {
            kind: "validation",
            type: "some_item",
            reference: Me,
            async: !1,
            expects: null,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !t.value.some(this.requirement) &&
                  Y(this, "item", t, e),
                t
              );
            },
          };
        }
        function Ae(t) {
          return {
            kind: "transformation",
            type: "sort_items",
            reference: Ae,
            async: !1,
            operation: t,
            _run(t) {
              return (t.value = t.value.sort(this.operation)), t;
            },
          };
        }
        function Te(t, e) {
          return {
            kind: "validation",
            type: "starts_with",
            reference: Te,
            async: !1,
            expects: `"${t}"`,
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                t.typed &&
                  !t.value.startsWith(this.requirement) &&
                  Y(this, "start", t, e, {
                    received: `"${t.value.slice(0, this.requirement.length)}"`,
                  }),
                t
              );
            },
          };
        }
        function ke() {
          return {
            kind: "transformation",
            type: "to_lower_case",
            reference: ke,
            async: !1,
            _run: (t) => ((t.value = t.value.toLowerCase()), t),
          };
        }
        function Oe(t) {
          return {
            kind: "transformation",
            type: "to_max_value",
            reference: Oe,
            async: !1,
            requirement: t,
            _run(t) {
              return (
                (t.value =
                  t.value > this.requirement ? this.requirement : t.value),
                t
              );
            },
          };
        }
        function xe(t) {
          return {
            kind: "transformation",
            type: "to_min_value",
            reference: xe,
            async: !1,
            requirement: t,
            _run(t) {
              return (
                (t.value =
                  t.value < this.requirement ? this.requirement : t.value),
                t
              );
            },
          };
        }
        function Pe() {
          return {
            kind: "transformation",
            type: "to_upper_case",
            reference: Pe,
            async: !1,
            _run: (t) => ((t.value = t.value.toUpperCase()), t),
          };
        }
        function Be(t) {
          return {
            kind: "transformation",
            type: "transform",
            reference: Be,
            async: !1,
            operation: t,
            _run(t) {
              return (t.value = this.operation(t.value)), t;
            },
          };
        }
        function Ce(t) {
          return {
            kind: "transformation",
            type: "transform",
            reference: Ce,
            async: !0,
            operation: t,
            async _run(t) {
              return (t.value = await this.operation(t.value)), t;
            },
          };
        }
        function Re() {
          return {
            kind: "transformation",
            type: "trim",
            reference: Re,
            async: !1,
            _run: (t) => ((t.value = t.value.trim()), t),
          };
        }
        function Ne() {
          return {
            kind: "transformation",
            type: "trim_end",
            reference: Ne,
            async: !1,
            _run: (t) => ((t.value = t.value.trimEnd()), t),
          };
        }
        function Ue() {
          return {
            kind: "transformation",
            type: "trim_start",
            reference: Ue,
            async: !1,
            _run: (t) => ((t.value = t.value.trimStart()), t),
          };
        }
        function De(t) {
          return {
            kind: "validation",
            type: "ulid",
            reference: De,
            async: !1,
            expects: null,
            requirement: R,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "ULID", t, e),
                t
              );
            },
          };
        }
        function Le(t) {
          return {
            kind: "validation",
            type: "url",
            reference: Le,
            async: !1,
            expects: null,
            requirement(t) {
              try {
                return new URL(t), !0;
              } catch {
                return !1;
              }
            },
            message: t,
            _run(t, e) {
              return (
                t.typed && !this.requirement(t.value) && Y(this, "URL", t, e), t
              );
            },
          };
        }
        function je(t) {
          return {
            kind: "validation",
            type: "uuid",
            reference: je,
            async: !1,
            expects: null,
            requirement: N,
            message: t,
            _run(t, e) {
              return (
                t.typed &&
                  !this.requirement.test(t.value) &&
                  Y(this, "UUID", t, e),
                t
              );
            },
          };
        }
        function Fe(t, e) {
          return {
            kind: "validation",
            type: "value",
            reference: Fe,
            async: !1,
            expects: t instanceof Date ? t.toJSON() : W(t),
            requirement: t,
            message: e,
            _run(t, e) {
              return (
                !t.typed ||
                  (this.requirement <= t.value &&
                    this.requirement >= t.value) ||
                  Y(this, "value", t, e, {
                    received:
                      t.value instanceof Date ? t.value.toJSON() : W(t.value),
                  }),
                t
              );
            },
          };
        }
        function He(t, e) {
          return { ...t, _run: (r, n) => t._run(r, { ...n, ...e }) };
        }
        function Ke(t, e, r) {
          return "function" == typeof t.fallback
            ? t.fallback(e, r)
            : t.fallback;
        }
        function Ve(t, e) {
          return {
            ...t,
            fallback: e,
            _run(e, r) {
              const n = t._run(e, r);
              return n.issues ? { typed: !0, value: Ke(this, n, r) } : n;
            },
          };
        }
        function qe(t, e) {
          return {
            ...t,
            fallback: e,
            async: !0,
            async _run(e, r) {
              const n = await t._run(e, r);
              return n.issues ? { typed: !0, value: await Ke(this, n, r) } : n;
            },
          };
        }
        function ze(t) {
          const e = {};
          for (const r of t)
            if (r.path) {
              const t = et(r);
              t
                ? (e.nested || (e.nested = {}),
                  e.nested[t]
                    ? e.nested[t].push(r.message)
                    : (e.nested[t] = [r.message]))
                : e.other
                  ? e.other.push(r.message)
                  : (e.other = [r.message]);
            } else e.root ? e.root.push(r.message) : (e.root = [r.message]);
          return e;
        }
        function $e(t, e) {
          return {
            ...t,
            _run(r, n) {
              const i = r.issues && [...r.issues];
              if ((t._run(r, n), r.issues))
                for (const t of r.issues)
                  if (!i?.includes(t)) {
                    let n = r.value;
                    for (const r of e) {
                      const e = n[r],
                        i = {
                          type: "unknown",
                          origin: "value",
                          input: n,
                          key: r,
                          value: e,
                        };
                      if ((t.path ? t.path.push(i) : (t.path = [i]), !e)) break;
                      n = e;
                    }
                  }
              return r;
            },
          };
        }
        function Ge(t, e) {
          return {
            ...t,
            async: !0,
            async _run(r, n) {
              const i = r.issues && [...r.issues];
              if ((await t._run(r, n), r.issues))
                for (const t of r.issues)
                  if (!i?.includes(t)) {
                    let n = r.value;
                    for (const r of e) {
                      const e = n[r],
                        i = {
                          type: "unknown",
                          origin: "value",
                          input: n,
                          key: r,
                          value: e,
                        };
                      if ((t.path ? t.path.push(i) : (t.path = [i]), !e)) break;
                      n = e;
                    }
                  }
              return r;
            },
          };
        }
        function We(t, e, r) {
          return "function" == typeof t.default ? t.default(e, r) : t.default;
        }
        function Ye(t) {
          if ("entries" in t) {
            const e = {};
            for (const r in t.entries) e[r] = Ye(t.entries[r]);
            return e;
          }
          return "items" in t ? t.items.map(Ye) : We(t);
        }
        async function Xe(t) {
          return "entries" in t
            ? Object.fromEntries(
                await Promise.all(
                  Object.entries(t.entries).map(async ([t, e]) => [
                    t,
                    await Xe(e),
                  ]),
                ),
              )
            : "items" in t
              ? Promise.all(t.items.map(Xe))
              : We(t);
        }
        function Ze(t) {
          if ("entries" in t) {
            const e = {};
            for (const r in t.entries) e[r] = Ze(t.entries[r]);
            return e;
          }
          return "items" in t ? t.items.map(Ze) : Ke(t);
        }
        async function Je(t) {
          return "entries" in t
            ? Object.fromEntries(
                await Promise.all(
                  Object.entries(t.entries).map(async ([t, e]) => [
                    t,
                    await Je(e),
                  ]),
                ),
              )
            : "items" in t
              ? Promise.all(t.items.map(Je))
              : Ke(t);
        }
        function Qe(t, e) {
          return !t._run({ typed: !1, value: e }, { abortEarly: !0 }).issues;
        }
        function tr() {
          return {
            kind: "schema",
            type: "any",
            reference: tr,
            expects: "any",
            async: !1,
            _run: (t) => ((t.typed = !0), t),
          };
        }
        function er(t, e) {
          return {
            kind: "schema",
            type: "array",
            reference: er,
            expects: "Array",
            async: !1,
            item: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                for (let n = 0; n < r.length; n++) {
                  const i = r[n],
                    o = this.item._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.push(o.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function rr(t, e) {
          return {
            kind: "schema",
            type: "array",
            reference: rr,
            expects: "Array",
            async: !0,
            item: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                const n = await Promise.all(
                  r.map((t) => this.item._run({ typed: !1, value: t }, e)),
                );
                for (let i = 0; i < n.length; i++) {
                  const o = n[i];
                  if (o.issues) {
                    const n = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: i,
                      value: r[i],
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.push(o.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function nr(t) {
          return {
            kind: "schema",
            type: "bigint",
            reference: nr,
            expects: "bigint",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "bigint" == typeof t.value
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function ir(t) {
          return {
            kind: "schema",
            type: "blob",
            reference: ir,
            expects: "Blob",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                t.value instanceof Blob
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function or(t) {
          return {
            kind: "schema",
            type: "boolean",
            reference: or,
            expects: "boolean",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "boolean" == typeof t.value
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function sr(t, e) {
          return {
            kind: "schema",
            type: "custom",
            reference: sr,
            expects: "unknown",
            async: !1,
            check: t,
            message: e,
            _run(t, e) {
              return (
                this.check(t.value) ? (t.typed = !0) : Y(this, "type", t, e), t
              );
            },
          };
        }
        function ar(t, e) {
          return {
            kind: "schema",
            type: "custom",
            reference: ar,
            expects: "unknown",
            async: !0,
            check: t,
            message: e,
            async _run(t, e) {
              return (
                (await this.check(t.value))
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function ur(t) {
          return {
            kind: "schema",
            type: "date",
            reference: ur,
            expects: "Date",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                t.value instanceof Date
                  ? isNaN(t.value)
                    ? Y(this, "type", t, e, { received: '"Invalid Date"' })
                    : (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function cr(t, e) {
          const r = Object.entries(t)
            .filter(([t]) => isNaN(+t))
            .map(([, t]) => t);
          return {
            kind: "schema",
            type: "enum",
            reference: cr,
            expects: Q(r.map(W), "|"),
            async: !1,
            enum: t,
            options: r,
            message: e,
            _run(t, e) {
              return (
                this.options.includes(t.value)
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function fr(t) {
          return {
            kind: "schema",
            type: "file",
            reference: fr,
            expects: "File",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                t.value instanceof File
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function hr(t) {
          return {
            kind: "schema",
            type: "function",
            reference: hr,
            expects: "Function",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "function" == typeof t.value
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function lr(t, e) {
          return {
            kind: "schema",
            type: "instance",
            reference: lr,
            expects: t.name,
            async: !1,
            class: t,
            message: e,
            _run(t, e) {
              return (
                t.value instanceof this.class
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function dr(t, e) {
          if (typeof t == typeof e) {
            if (t === e || (t instanceof Date && e instanceof Date && +t == +e))
              return { value: t };
            if (
              t &&
              e &&
              t.constructor === Object &&
              e.constructor === Object
            ) {
              for (const r in e)
                if (r in t) {
                  const n = dr(t[r], e[r]);
                  if (n.issue) return n;
                  t[r] = n.value;
                } else t[r] = e[r];
              return { value: t };
            }
            if (Array.isArray(t) && Array.isArray(e) && t.length === e.length) {
              for (let r = 0; r < t.length; r++) {
                const n = dr(t[r], e[r]);
                if (n.issue) return n;
                t[r] = n.value;
              }
              return { value: t };
            }
          }
          return { issue: !0 };
        }
        function pr(t, e) {
          return {
            kind: "schema",
            type: "intersect",
            reference: pr,
            expects: Q(
              t.map((t) => t.expects),
              "&",
            ),
            async: !1,
            options: t,
            message: e,
            _run(t, e) {
              if (this.options.length) {
                const r = t.value;
                let n;
                t.typed = !0;
                for (const i of this.options) {
                  const o = i._run({ typed: !1, value: r }, e);
                  if (
                    o.issues &&
                    (t.issues
                      ? t.issues.push(...o.issues)
                      : (t.issues = o.issues),
                    e.abortEarly)
                  ) {
                    t.typed = !1;
                    break;
                  }
                  o.typed || (t.typed = !1),
                    t.typed && (n ? n.push(o.value) : (n = [o.value]));
                }
                if (t.typed) {
                  t.value = n[0];
                  for (let r = 1; r < n.length; r++) {
                    const i = dr(t.value, n[r]);
                    if (i.issue) {
                      Y(this, "type", t, e, { received: "unknown" });
                      break;
                    }
                    t.value = i.value;
                  }
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function yr(t, e) {
          return {
            kind: "schema",
            type: "intersect",
            reference: yr,
            expects: Q(
              t.map((t) => t.expects),
              "&",
            ),
            async: !0,
            options: t,
            message: e,
            async _run(t, e) {
              if (this.options.length) {
                const r = t.value;
                let n;
                t.typed = !0;
                const i = await Promise.all(
                  this.options.map((t) => t._run({ typed: !1, value: r }, e)),
                );
                for (const r of i) {
                  if (
                    r.issues &&
                    (t.issues
                      ? t.issues.push(...r.issues)
                      : (t.issues = r.issues),
                    e.abortEarly)
                  ) {
                    t.typed = !1;
                    break;
                  }
                  r.typed || (t.typed = !1),
                    t.typed && (n ? n.push(r.value) : (n = [r.value]));
                }
                if (t.typed) {
                  t.value = n[0];
                  for (let r = 1; r < n.length; r++) {
                    const i = dr(t.value, n[r]);
                    if (i.issue) {
                      Y(this, "type", t, e, { received: "unknown" });
                      break;
                    }
                    t.value = i.value;
                  }
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function gr(t) {
          return {
            kind: "schema",
            type: "lazy",
            reference: gr,
            expects: "unknown",
            async: !1,
            getter: t,
            _run(t, e) {
              return this.getter(t.value)._run(t, e);
            },
          };
        }
        function mr(t) {
          return {
            kind: "schema",
            type: "lazy",
            reference: mr,
            expects: "unknown",
            async: !0,
            getter: t,
            async _run(t, e) {
              return (await this.getter(t.value))._run(t, e);
            },
          };
        }
        function br(t, e) {
          return {
            kind: "schema",
            type: "literal",
            reference: br,
            expects: W(t),
            async: !1,
            literal: t,
            message: e,
            _run(t, e) {
              return (
                t.value === this.literal
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function wr(t, e) {
          return {
            kind: "schema",
            type: "loose_object",
            reference: wr,
            expects: "Object",
            async: !1,
            entries: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                for (const n in this.entries) {
                  const i = r[n],
                    o = this.entries[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1),
                    (void 0 !== o.value || n in r) && (t.value[n] = o.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const e in r)
                    J(r, e) && !(e in this.entries) && (t.value[e] = r[e]);
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function vr(t, e) {
          return {
            kind: "schema",
            type: "loose_object",
            reference: vr,
            expects: "Object",
            async: !0,
            entries: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                const n = await Promise.all(
                  Object.entries(this.entries).map(async ([t, n]) => {
                    const i = r[t];
                    return [t, i, await n._run({ typed: !1, value: i }, e)];
                  }),
                );
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1),
                    (void 0 !== s.value || i in r) && (t.value[i] = s.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const e in r)
                    J(r, e) && !(e in this.entries) && (t.value[e] = r[e]);
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function _r(t, e) {
          return {
            kind: "schema",
            type: "loose_tuple",
            reference: _r,
            expects: "Array",
            async: !1,
            items: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                for (let n = 0; n < this.items.length; n++) {
                  const i = r[n],
                    o = this.items[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.push(o.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (let e = this.items.length; e < r.length; e++)
                    t.value.push(r[e]);
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Er(t, e) {
          return {
            kind: "schema",
            type: "loose_tuple",
            reference: Er,
            expects: "Array",
            async: !0,
            items: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                const n = await Promise.all(
                  this.items.map(async (t, n) => {
                    const i = r[n];
                    return [n, i, await t._run({ typed: !1, value: i }, e)];
                  }),
                );
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1), t.value.push(s.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (let e = this.items.length; e < r.length; e++)
                    t.value.push(r[e]);
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Sr(t, e, r) {
          return {
            kind: "schema",
            type: "map",
            reference: Sr,
            expects: "Map",
            async: !1,
            key: t,
            value: e,
            message: r,
            _run(t, e) {
              const r = t.value;
              if (r instanceof Map) {
                (t.typed = !0), (t.value = new Map());
                for (const [n, i] of r) {
                  const o = this.key._run({ typed: !1, value: n }, e);
                  if (o.issues) {
                    const s = {
                      type: "map",
                      origin: "key",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  const s = this.value._run({ typed: !1, value: i }, e);
                  if (s.issues) {
                    const o = {
                      type: "map",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(o) : (e.path = [o]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  (o.typed && s.typed) || (t.typed = !1),
                    t.value.set(o.value, s.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Ir(t, e, r) {
          return {
            kind: "schema",
            type: "map",
            reference: Ir,
            expects: "Map",
            async: !0,
            key: t,
            value: e,
            message: r,
            async _run(t, e) {
              const r = t.value;
              if (r instanceof Map) {
                (t.typed = !0), (t.value = new Map());
                const n = await Promise.all(
                  [...r].map(([t, r]) =>
                    Promise.all([
                      t,
                      r,
                      this.key._run({ typed: !1, value: t }, e),
                      this.value._run({ typed: !1, value: r }, e),
                    ]),
                  ),
                );
                for (const [i, o, s, a] of n) {
                  if (s.issues) {
                    const n = {
                      type: "map",
                      origin: "key",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  if (a.issues) {
                    const n = {
                      type: "map",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of a.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = a.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  (s.typed && a.typed) || (t.typed = !1),
                    t.value.set(s.value, a.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Mr(t) {
          return {
            kind: "schema",
            type: "nan",
            reference: Mr,
            expects: "NaN",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                Number.isNaN(t.value) ? (t.typed = !0) : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function Ar(t) {
          return {
            kind: "schema",
            type: "never",
            reference: Ar,
            expects: "never",
            async: !1,
            message: t,
            _run(t, e) {
              return Y(this, "type", t, e), t;
            },
          };
        }
        function Tr(t, e) {
          return {
            kind: "schema",
            type: "non_nullable",
            reference: Tr,
            expects: "!null",
            async: !1,
            wrapped: t,
            message: e,
            _run(t, e) {
              return null === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function kr(t, e) {
          return {
            kind: "schema",
            type: "non_nullable",
            reference: kr,
            expects: "!null",
            async: !0,
            wrapped: t,
            message: e,
            async _run(t, e) {
              return null === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function Or(t, e) {
          return {
            kind: "schema",
            type: "non_nullish",
            reference: Or,
            expects: "(!null & !undefined)",
            async: !1,
            wrapped: t,
            message: e,
            _run(t, e) {
              return null === t.value || void 0 === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function xr(t, e) {
          return {
            kind: "schema",
            type: "non_nullish",
            reference: xr,
            expects: "(!null & !undefined)",
            async: !0,
            wrapped: t,
            message: e,
            async _run(t, e) {
              return null === t.value || void 0 === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function Pr(t, e) {
          return {
            kind: "schema",
            type: "non_optional",
            reference: Pr,
            expects: "!undefined",
            async: !1,
            wrapped: t,
            message: e,
            _run(t, e) {
              return void 0 === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function Br(t, e) {
          return {
            kind: "schema",
            type: "non_optional",
            reference: Br,
            expects: "!undefined",
            async: !0,
            wrapped: t,
            message: e,
            async _run(t, e) {
              return void 0 === t.value
                ? (Y(this, "type", t, e), t)
                : this.wrapped._run(t, e);
            },
          };
        }
        function Cr(t) {
          return {
            kind: "schema",
            type: "null",
            reference: Cr,
            expects: "null",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                null === t.value ? (t.typed = !0) : Y(this, "type", t, e), t
              );
            },
          };
        }
        function Rr(t, ...e) {
          const r = {
            kind: "schema",
            type: "nullable",
            reference: Rr,
            expects: `(${t.expects} | null)`,
            async: !1,
            wrapped: t,
            _run(t, e) {
              return null === t.value &&
                ("default" in this && (t.value = We(this, t, e)),
                null === t.value)
                ? ((t.typed = !0), t)
                : this.wrapped._run(t, e);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function Nr(t, ...e) {
          const r = {
            kind: "schema",
            type: "nullable",
            reference: Nr,
            expects: `(${t.expects} | null)`,
            async: !0,
            wrapped: t,
            async _run(t, e) {
              return null === t.value &&
                ("default" in this && (t.value = await We(this, t, e)),
                null === t.value)
                ? ((t.typed = !0), t)
                : this.wrapped._run(t, e);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function Ur(t, ...e) {
          const r = {
            kind: "schema",
            type: "nullish",
            reference: Ur,
            expects: `(${t.expects} | null | undefined)`,
            async: !1,
            wrapped: t,
            _run(t, e) {
              return (null !== t.value && void 0 !== t.value) ||
                ("default" in this && (t.value = We(this, t, e)),
                null !== t.value && void 0 !== t.value)
                ? this.wrapped._run(t, e)
                : ((t.typed = !0), t);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function Dr(t, ...e) {
          const r = {
            kind: "schema",
            type: "nullish",
            reference: Dr,
            expects: `(${t.expects} | null | undefined)`,
            async: !0,
            wrapped: t,
            async _run(t, e) {
              return (null !== t.value && void 0 !== t.value) ||
                ("default" in this && (t.value = await We(this, t, e)),
                null !== t.value && void 0 !== t.value)
                ? this.wrapped._run(t, e)
                : ((t.typed = !0), t);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function Lr(t) {
          return {
            kind: "schema",
            type: "number",
            reference: Lr,
            expects: "number",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "number" != typeof t.value || isNaN(t.value)
                  ? Y(this, "type", t, e)
                  : (t.typed = !0),
                t
              );
            },
          };
        }
        function jr(t, e) {
          return {
            kind: "schema",
            type: "object",
            reference: jr,
            expects: "Object",
            async: !1,
            entries: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                for (const n in this.entries) {
                  const i = r[n],
                    o = this.entries[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1),
                    (void 0 !== o.value || n in r) && (t.value[n] = o.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Fr(t, e) {
          return {
            kind: "schema",
            type: "object",
            reference: Fr,
            expects: "Object",
            async: !0,
            entries: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                const n = await Promise.all(
                  Object.entries(this.entries).map(async ([t, n]) => {
                    const i = r[t];
                    return [t, i, await n._run({ typed: !1, value: i }, e)];
                  }),
                );
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1),
                    (void 0 !== s.value || i in r) && (t.value[i] = s.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Hr(t, e, r) {
          return {
            kind: "schema",
            type: "object_with_rest",
            reference: Hr,
            expects: "Object",
            async: !1,
            entries: t,
            rest: e,
            message: r,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                for (const n in this.entries) {
                  const i = r[n],
                    o = this.entries[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1),
                    (void 0 !== o.value || n in r) && (t.value[n] = o.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const n in r)
                    if (J(r, n) && !(n in this.entries)) {
                      const i = r[n],
                        o = this.rest._run({ typed: !1, value: i }, e);
                      if (o.issues) {
                        const s = {
                          type: "object",
                          origin: "value",
                          input: r,
                          key: n,
                          value: i,
                        };
                        for (const e of o.issues)
                          e.path ? e.path.unshift(s) : (e.path = [s]),
                            t.issues?.push(e);
                        if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                          t.typed = !1;
                          break;
                        }
                      }
                      o.typed || (t.typed = !1), (t.value[n] = o.value);
                    }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Kr(t, e, r) {
          return {
            kind: "schema",
            type: "object_with_rest",
            reference: Kr,
            expects: "Object",
            async: !0,
            entries: t,
            rest: e,
            message: r,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                const [n, i] = await Promise.all([
                  Promise.all(
                    Object.entries(this.entries).map(async ([t, n]) => {
                      const i = r[t];
                      return [t, i, await n._run({ typed: !1, value: i }, e)];
                    }),
                  ),
                  Promise.all(
                    Object.entries(r)
                      .filter(([t]) => J(r, t) && !(t in this.entries))
                      .map(async ([t, r]) => [
                        t,
                        r,
                        await this.rest._run({ typed: !1, value: r }, e),
                      ]),
                  ),
                ]);
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1),
                    (void 0 !== s.value || i in r) && (t.value[i] = s.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const [n, o, s] of i) {
                    if (s.issues) {
                      const i = {
                        type: "object",
                        origin: "value",
                        input: r,
                        key: n,
                        value: o,
                      };
                      for (const e of s.issues)
                        e.path ? e.path.unshift(i) : (e.path = [i]),
                          t.issues?.push(e);
                      if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                        t.typed = !1;
                        break;
                      }
                    }
                    s.typed || (t.typed = !1), (t.value[n] = s.value);
                  }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Vr(t, ...e) {
          const r = {
            kind: "schema",
            type: "optional",
            reference: Vr,
            expects: `(${t.expects} | undefined)`,
            async: !1,
            wrapped: t,
            _run(t, e) {
              return void 0 === t.value &&
                ("default" in this && (t.value = We(this, t, e)),
                void 0 === t.value)
                ? ((t.typed = !0), t)
                : this.wrapped._run(t, e);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function qr(t, ...e) {
          const r = {
            kind: "schema",
            type: "optional",
            reference: qr,
            expects: `(${t.expects} | undefined)`,
            async: !0,
            wrapped: t,
            async _run(t, e) {
              return void 0 === t.value &&
                ("default" in this && (t.value = await We(this, t, e)),
                void 0 === t.value)
                ? ((t.typed = !0), t)
                : this.wrapped._run(t, e);
            },
          };
          return 0 in e && (r.default = e[0]), r;
        }
        function zr(t, e) {
          return {
            kind: "schema",
            type: "picklist",
            reference: zr,
            expects: Q(t.map(W), "|"),
            async: !1,
            options: t,
            message: e,
            _run(t, e) {
              return (
                this.options.includes(t.value)
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function $r(t) {
          return {
            kind: "schema",
            type: "promise",
            reference: $r,
            expects: "Promise",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                t.value instanceof Promise
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function Gr(t, e, r) {
          return {
            kind: "schema",
            type: "record",
            reference: Gr,
            expects: "Object",
            async: !1,
            key: t,
            value: e,
            message: r,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                for (const n in r)
                  if (J(r, n)) {
                    const i = r[n],
                      o = this.key._run({ typed: !1, value: n }, e);
                    if (o.issues) {
                      const s = {
                        type: "object",
                        origin: "key",
                        input: r,
                        key: n,
                        value: i,
                      };
                      for (const e of o.issues)
                        (e.path = [s]), t.issues?.push(e);
                      if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                        t.typed = !1;
                        break;
                      }
                    }
                    const s = this.value._run({ typed: !1, value: i }, e);
                    if (s.issues) {
                      const o = {
                        type: "object",
                        origin: "value",
                        input: r,
                        key: n,
                        value: i,
                      };
                      for (const e of s.issues)
                        e.path ? e.path.unshift(o) : (e.path = [o]),
                          t.issues?.push(e);
                      if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                        t.typed = !1;
                        break;
                      }
                    }
                    (o.typed && s.typed) || (t.typed = !1),
                      o.typed && (t.value[o.value] = s.value);
                  }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Wr(t, e, r) {
          return {
            kind: "schema",
            type: "record",
            reference: Wr,
            expects: "Object",
            async: !0,
            key: t,
            value: e,
            message: r,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                const n = await Promise.all(
                  Object.entries(r)
                    .filter(([t]) => J(r, t))
                    .map(([t, r]) =>
                      Promise.all([
                        t,
                        r,
                        this.key._run({ typed: !1, value: t }, e),
                        this.value._run({ typed: !1, value: r }, e),
                      ]),
                    ),
                );
                for (const [i, o, s, a] of n) {
                  if (s.issues) {
                    const n = {
                      type: "object",
                      origin: "key",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues) (e.path = [n]), t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  if (a.issues) {
                    const n = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of a.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = a.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  (s.typed && a.typed) || (t.typed = !1),
                    s.typed && (t.value[s.value] = a.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Yr(t, e) {
          return {
            kind: "schema",
            type: "set",
            reference: Yr,
            expects: "Set",
            async: !1,
            value: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (r instanceof Set) {
                (t.typed = !0), (t.value = new Set());
                for (const n of r) {
                  const i = this.value._run({ typed: !1, value: n }, e);
                  if (i.issues) {
                    const o = {
                      type: "set",
                      origin: "value",
                      input: r,
                      key: null,
                      value: n,
                    };
                    for (const e of i.issues)
                      e.path ? e.path.unshift(o) : (e.path = [o]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = i.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  i.typed || (t.typed = !1), t.value.add(i.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Xr(t, e) {
          return {
            kind: "schema",
            type: "set",
            reference: Xr,
            expects: "Set",
            async: !0,
            value: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (r instanceof Set) {
                (t.typed = !0), (t.value = new Set());
                const n = await Promise.all(
                  [...r].map(async (t) => [
                    t,
                    await this.value._run({ typed: !1, value: t }, e),
                  ]),
                );
                for (const [i, o] of n) {
                  if (o.issues) {
                    const n = {
                      type: "set",
                      origin: "value",
                      input: r,
                      key: null,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.add(o.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Zr(t, e) {
          return {
            kind: "schema",
            type: "strict_object",
            reference: Zr,
            expects: "Object",
            async: !1,
            entries: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                for (const n in this.entries) {
                  const i = r[n],
                    o = this.entries[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1),
                    (void 0 !== o.value || n in r) && (t.value[n] = o.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const n in r)
                    if (!(n in this.entries)) {
                      const i = r[n];
                      Y(this, "type", t, e, {
                        input: i,
                        expected: "never",
                        path: [
                          {
                            type: "object",
                            origin: "value",
                            input: r,
                            key: n,
                            value: i,
                          },
                        ],
                      });
                      break;
                    }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Jr(t, e) {
          return {
            kind: "schema",
            type: "strict_object",
            reference: Jr,
            expects: "Object",
            async: !0,
            entries: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                (t.typed = !0), (t.value = {});
                const n = await Promise.all(
                  Object.entries(this.entries).map(async ([t, n]) => {
                    const i = r[t];
                    return [t, i, await n._run({ typed: !1, value: i }, e)];
                  }),
                );
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1),
                    (void 0 !== s.value || i in r) && (t.value[i] = s.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const n in r)
                    if (!(n in this.entries)) {
                      const i = r[n];
                      Y(this, "type", t, e, {
                        input: i,
                        expected: "never",
                        path: [
                          {
                            type: "object",
                            origin: "value",
                            input: r,
                            key: n,
                            value: i,
                          },
                        ],
                      });
                      break;
                    }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function Qr(t, e) {
          return {
            kind: "schema",
            type: "strict_tuple",
            reference: Qr,
            expects: "Array",
            async: !1,
            items: t,
            message: e,
            _run(e, r) {
              const n = e.value;
              if (Array.isArray(n)) {
                (e.typed = !0), (e.value = []);
                for (let t = 0; t < this.items.length; t++) {
                  const i = n[t],
                    o = this.items[t]._run({ typed: !1, value: i }, r);
                  if (o.issues) {
                    const s = {
                      type: "array",
                      origin: "value",
                      input: n,
                      key: t,
                      value: i,
                    };
                    for (const t of o.issues)
                      t.path ? t.path.unshift(s) : (t.path = [s]),
                        e.issues?.push(t);
                    if ((e.issues || (e.issues = o.issues), r.abortEarly)) {
                      e.typed = !1;
                      break;
                    }
                  }
                  o.typed || (e.typed = !1), e.value.push(o.value);
                }
                if (
                  (!e.issues || !r.abortEarly) &&
                  this.items.length < n.length
                ) {
                  const i = n[t.length];
                  Y(this, "type", e, r, {
                    input: i,
                    expected: "never",
                    path: [
                      {
                        type: "array",
                        origin: "value",
                        input: n,
                        key: this.items.length,
                        value: i,
                      },
                    ],
                  });
                }
              } else Y(this, "type", e, r);
              return e;
            },
          };
        }
        function tn(t, e) {
          return {
            kind: "schema",
            type: "strict_tuple",
            reference: tn,
            expects: "Array",
            async: !0,
            items: t,
            message: e,
            async _run(e, r) {
              const n = e.value;
              if (Array.isArray(n)) {
                (e.typed = !0), (e.value = []);
                const i = await Promise.all(
                  this.items.map(async (t, e) => {
                    const i = n[e];
                    return [e, i, await t._run({ typed: !1, value: i }, r)];
                  }),
                );
                for (const [t, o, s] of i) {
                  if (s.issues) {
                    const i = {
                      type: "array",
                      origin: "value",
                      input: n,
                      key: t,
                      value: o,
                    };
                    for (const t of s.issues)
                      t.path ? t.path.unshift(i) : (t.path = [i]),
                        e.issues?.push(t);
                    if ((e.issues || (e.issues = s.issues), r.abortEarly)) {
                      e.typed = !1;
                      break;
                    }
                  }
                  s.typed || (e.typed = !1), e.value.push(s.value);
                }
                if (
                  (!e.issues || !r.abortEarly) &&
                  this.items.length < n.length
                ) {
                  const i = n[t.length];
                  Y(this, "type", e, r, {
                    input: i,
                    expected: "never",
                    path: [
                      {
                        type: "array",
                        origin: "value",
                        input: n,
                        key: this.items.length,
                        value: i,
                      },
                    ],
                  });
                }
              } else Y(this, "type", e, r);
              return e;
            },
          };
        }
        function en(t) {
          return {
            kind: "schema",
            type: "string",
            reference: en,
            expects: "string",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "string" == typeof t.value
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function rn(t) {
          return {
            kind: "schema",
            type: "symbol",
            reference: rn,
            expects: "symbol",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                "symbol" == typeof t.value
                  ? (t.typed = !0)
                  : Y(this, "type", t, e),
                t
              );
            },
          };
        }
        function nn(t, e) {
          return {
            kind: "schema",
            type: "tuple",
            reference: nn,
            expects: "Array",
            async: !1,
            items: t,
            message: e,
            _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                for (let n = 0; n < this.items.length; n++) {
                  const i = r[n],
                    o = this.items[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.push(o.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function on(t, e) {
          return {
            kind: "schema",
            type: "tuple",
            reference: on,
            expects: "Array",
            async: !0,
            items: t,
            message: e,
            async _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                const n = await Promise.all(
                  this.items.map(async (t, n) => {
                    const i = r[n];
                    return [n, i, await t._run({ typed: !1, value: i }, e)];
                  }),
                );
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1), t.value.push(s.value);
                }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function sn(t, e, r) {
          return {
            kind: "schema",
            type: "tuple_with_rest",
            reference: sn,
            expects: "Array",
            async: !1,
            items: t,
            rest: e,
            message: r,
            _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                for (let n = 0; n < this.items.length; n++) {
                  const i = r[n],
                    o = this.items[n]._run({ typed: !1, value: i }, e);
                  if (o.issues) {
                    const s = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues)
                      e.path ? e.path.unshift(s) : (e.path = [s]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  o.typed || (t.typed = !1), t.value.push(o.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (let n = this.items.length; n < r.length; n++) {
                    const i = r[n],
                      o = this.rest._run({ typed: !1, value: i }, e);
                    if (o.issues) {
                      const s = {
                        type: "array",
                        origin: "value",
                        input: r,
                        key: n,
                        value: i,
                      };
                      for (const e of o.issues)
                        e.path ? e.path.unshift(s) : (e.path = [s]),
                          t.issues?.push(e);
                      if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                        t.typed = !1;
                        break;
                      }
                    }
                    o.typed || (t.typed = !1), t.value.push(o.value);
                  }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function an(t, e, r) {
          return {
            kind: "schema",
            type: "tuple_with_rest",
            reference: an,
            expects: "Array",
            async: !0,
            items: t,
            rest: e,
            message: r,
            async _run(t, e) {
              const r = t.value;
              if (Array.isArray(r)) {
                (t.typed = !0), (t.value = []);
                const [n, i] = await Promise.all([
                  Promise.all(
                    this.items.map(async (t, n) => {
                      const i = r[n];
                      return [n, i, await t._run({ typed: !1, value: i }, e)];
                    }),
                  ),
                  Promise.all(
                    r
                      .slice(this.items.length)
                      .map(async (t, r) => [
                        r + this.items.length,
                        t,
                        await this.rest._run({ typed: !1, value: t }, e),
                      ]),
                  ),
                ]);
                for (const [i, o, s] of n) {
                  if (s.issues) {
                    const n = {
                      type: "array",
                      origin: "value",
                      input: r,
                      key: i,
                      value: o,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(n) : (e.path = [n]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  s.typed || (t.typed = !1), t.value.push(s.value);
                }
                if (!t.issues || !e.abortEarly)
                  for (const [n, o, s] of i) {
                    if (s.issues) {
                      const i = {
                        type: "array",
                        origin: "value",
                        input: r,
                        key: n,
                        value: o,
                      };
                      for (const e of s.issues)
                        e.path ? e.path.unshift(i) : (e.path = [i]),
                          t.issues?.push(e);
                      if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                        t.typed = !1;
                        break;
                      }
                    }
                    s.typed || (t.typed = !1), t.value.push(s.value);
                  }
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function un(t) {
          return {
            kind: "schema",
            type: "undefined",
            reference: un,
            expects: "undefined",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                void 0 === t.value ? (t.typed = !0) : Y(this, "type", t, e), t
              );
            },
          };
        }
        function cn(t) {
          let e;
          if (t) for (const r of t) e ? e.push(...r.issues) : (e = r.issues);
          return e;
        }
        function fn(t, e) {
          return {
            kind: "schema",
            type: "union",
            reference: fn,
            expects: Q(
              t.map((t) => t.expects),
              "|",
            ),
            async: !1,
            options: t,
            message: e,
            _run(t, e) {
              let r, n, i;
              for (const o of this.options) {
                const s = o._run({ typed: !1, value: t.value }, e);
                if (s.typed) {
                  if (!s.issues) {
                    r = s;
                    break;
                  }
                  n ? n.push(s) : (n = [s]);
                } else i ? i.push(s) : (i = [s]);
              }
              if (r) return r;
              if (n) {
                if (1 === n.length) return n[0];
                Y(this, "type", t, e, { issues: cn(n) }), (t.typed = !0);
              } else {
                if (1 === i?.length) return i[0];
                Y(this, "type", t, e, { issues: cn(i) });
              }
              return t;
            },
          };
        }
        function hn(t, e) {
          return {
            kind: "schema",
            type: "union",
            reference: hn,
            expects: Q(
              t.map((t) => t.expects),
              "|",
            ),
            async: !0,
            options: t,
            message: e,
            async _run(t, e) {
              let r, n, i;
              for (const o of this.options) {
                const s = await o._run({ typed: !1, value: t.value }, e);
                if (s.typed) {
                  if (!s.issues) {
                    r = s;
                    break;
                  }
                  n ? n.push(s) : (n = [s]);
                } else i ? i.push(s) : (i = [s]);
              }
              if (r) return r;
              if (n) {
                if (1 === n.length) return n[0];
                Y(this, "type", t, e, { issues: cn(n) }), (t.typed = !0);
              } else {
                if (1 === i?.length) return i[0];
                Y(this, "type", t, e, { issues: cn(i) });
              }
              return t;
            },
          };
        }
        function ln() {
          return {
            kind: "schema",
            type: "unknown",
            reference: ln,
            expects: "unknown",
            async: !1,
            _run: (t) => ((t.typed = !0), t),
          };
        }
        function dn(t, e, r = []) {
          for (const n of e)
            "variant" === n.type
              ? dn(t, n.options, r)
              : r.push(n.entries[t].expects);
          return r;
        }
        function pn(t, e, r) {
          let n;
          return {
            kind: "schema",
            type: "variant",
            reference: pn,
            expects: "Object",
            async: !1,
            key: t,
            options: e,
            message: r,
            _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                const i = r[this.key];
                if (this.key in r) {
                  let t;
                  for (const n of this.options)
                    if (
                      "variant" === n.type ||
                      !n.entries[this.key]._run({ typed: !1, value: i }, e)
                        .issues
                    ) {
                      const i = n._run({ typed: !1, value: r }, e);
                      if (!i.issues) return i;
                      (!t || (!t.typed && i.typed)) && (t = i);
                    }
                  if (t) return t;
                }
                n || (n = Q(dn(this.key, this.options), "|")),
                  Y(this, "type", t, e, {
                    input: i,
                    expected: n,
                    path: [
                      {
                        type: "object",
                        origin: "value",
                        input: r,
                        key: this.key,
                        value: i,
                      },
                    ],
                  });
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function yn(t, e, r) {
          let n;
          return {
            kind: "schema",
            type: "variant",
            reference: yn,
            expects: "Object",
            async: !0,
            key: t,
            options: e,
            message: r,
            async _run(t, e) {
              const r = t.value;
              if (r && "object" == typeof r) {
                const i = r[this.key];
                if (this.key in r) {
                  let t;
                  for (const n of this.options)
                    if (
                      "variant" === n.type ||
                      !(
                        await n.entries[this.key]._run(
                          { typed: !1, value: i },
                          e,
                        )
                      ).issues
                    ) {
                      const i = await n._run({ typed: !1, value: r }, e);
                      if (!i.issues) return i;
                      (!t || (!t.typed && i.typed)) && (t = i);
                    }
                  if (t) return t;
                }
                n || (n = Q(dn(this.key, this.options), "|")),
                  Y(this, "type", t, e, {
                    input: i,
                    expected: n,
                    path: [
                      {
                        type: "object",
                        origin: "value",
                        input: r,
                        key: this.key,
                        value: i,
                      },
                    ],
                  });
              } else Y(this, "type", t, e);
              return t;
            },
          };
        }
        function gn(t) {
          return {
            kind: "schema",
            type: "void",
            reference: gn,
            expects: "void",
            async: !1,
            message: t,
            _run(t, e) {
              return (
                void 0 === t.value ? (t.typed = !0) : Y(this, "type", t, e), t
              );
            },
          };
        }
        function mn(t, e) {
          return zr(Object.keys(t.entries), e);
        }
        function bn(t, e) {
          const r = { ...t.entries };
          for (const t of e) delete r[t];
          return { ...t, entries: r };
        }
        function wn(t, e, r) {
          const n = t._run({ typed: !1, value: e }, D(r));
          if (n.issues) throw new ot(n.issues);
          return n.value;
        }
        async function vn(t, e, r) {
          const n = await t._run({ typed: !1, value: e }, D(r));
          if (n.issues) throw new ot(n.issues);
          return n.value;
        }
        function _n(t, e) {
          const r = (r) => wn(t, r, e);
          return (r.schema = t), (r.config = e), r;
        }
        function En(t, e) {
          const r = (r) => vn(t, r, e);
          return (r.schema = t), (r.config = e), r;
        }
        function Sn(t, e) {
          const r = {};
          for (const n in t.entries)
            r[n] = !e || e.includes(n) ? Vr(t.entries[n]) : t.entries[n];
          return { ...t, entries: r };
        }
        function In(t, e) {
          const r = {};
          for (const n in t.entries)
            r[n] = !e || e.includes(n) ? qr(t.entries[n]) : t.entries[n];
          return { ...t, entries: r };
        }
        function Mn(t, e) {
          const r = {};
          for (const n of e) r[n] = t.entries[n];
          return { ...t, entries: r };
        }
        function An(...t) {
          return {
            ...t[0],
            pipe: t,
            _run(e, r) {
              for (const n of t)
                if ("metadata" !== n.kind) {
                  if (
                    e.issues &&
                    ("schema" === n.kind || "transformation" === n.kind)
                  ) {
                    e.typed = !1;
                    break;
                  }
                  (e.issues && (r.abortEarly || r.abortPipeEarly)) ||
                    (e = n._run(e, r));
                }
              return e;
            },
          };
        }
        function Tn(...t) {
          return {
            ...t[0],
            pipe: t,
            async: !0,
            async _run(e, r) {
              for (const n of t)
                if ("metadata" !== n.kind) {
                  if (
                    e.issues &&
                    ("schema" === n.kind || "transformation" === n.kind)
                  ) {
                    e.typed = !1;
                    break;
                  }
                  (e.issues && (r.abortEarly || r.abortPipeEarly)) ||
                    (e = await n._run(e, r));
                }
              return e;
            },
          };
        }
        function kn(t, e, r) {
          const n = Array.isArray(e) ? e : void 0,
            i = Array.isArray(e) ? r : e,
            o = {};
          for (const e in t.entries)
            o[e] = !n || n.includes(e) ? Pr(t.entries[e], i) : t.entries[e];
          return { ...t, entries: o };
        }
        function On(t, e, r) {
          const n = Array.isArray(e) ? e : void 0,
            i = Array.isArray(e) ? r : e,
            o = {};
          for (const e in t.entries)
            o[e] = !n || n.includes(e) ? Br(t.entries[e], i) : t.entries[e];
          return { ...t, entries: o };
        }
        function xn(t, e, r) {
          const n = t._run({ typed: !1, value: e }, D(r));
          return {
            typed: n.typed,
            success: !n.issues,
            output: n.value,
            issues: n.issues,
          };
        }
        async function Pn(t, e, r) {
          const n = await t._run({ typed: !1, value: e }, D(r));
          return {
            typed: n.typed,
            success: !n.issues,
            output: n.value,
            issues: n.issues,
          };
        }
        function Bn(t, e) {
          const r = (r) => xn(t, r, e);
          return (r.schema = t), (r.config = e), r;
        }
        function Cn(t, e) {
          const r = (r) => Pn(t, r, e);
          return (r.schema = t), (r.config = e), r;
        }
        function Rn(t) {
          return t.wrapped;
        }
      },
      60882: function (t, e, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(e, r);
                  (i &&
                    !("get" in i
                      ? !e.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return e[r];
                      },
                    }),
                    Object.defineProperty(t, n, i);
                }
              : function (t, e, r, n) {
                  void 0 === n && (n = r), (t[n] = e[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", {
                    enumerable: !0,
                    value: e,
                  });
                }
              : function (t, e) {
                  t.default = e;
                }),
          o =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var r in t)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(t, r) &&
                    n(e, t, r);
              return i(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.encode = function (t, e, r) {
            u(t), void 0 === r && (r = 0);
            void 0 === e && (e = new Uint8Array(c(t)));
            let n = 0;
            t < 253
              ? (e.set([Number(t)], r), (n = 1))
              : t <= 65535
                ? (e.set([253], r),
                  s.writeUInt16(e, r + 1, Number(t), "LE"),
                  (n = 3))
                : t <= 4294967295
                  ? (e.set([254], r),
                    s.writeUInt32(e, r + 1, Number(t), "LE"),
                    (n = 5))
                  : (e.set([255], r),
                    s.writeUInt64(e, r + 1, BigInt(t), "LE"),
                    (n = 9));
            return { buffer: e, bytes: n };
          }),
          (e.decode = function (t, e) {
            void 0 === e && (e = 0);
            const r = t.at(e);
            if (void 0 === r) throw new Error("buffer too small");
            if (r < 253)
              return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
            if (253 === r) {
              const r = s.readUInt16(t, e + 1, "LE");
              return { numberValue: r, bigintValue: BigInt(r), bytes: 3 };
            }
            if (254 === r) {
              const r = s.readUInt32(t, e + 1, "LE");
              return { numberValue: r, bigintValue: BigInt(r), bytes: 5 };
            }
            {
              const r = s.readUInt64(t, e + 1, "LE");
              return {
                numberValue: r <= Number.MAX_SAFE_INTEGER ? Number(r) : null,
                bigintValue: r,
                bytes: 9,
              };
            }
          }),
          (e.encodingLength = c);
        const s = o(r(82519)),
          a = (t) => {
            if (t < 0 || t > 0xffffffffffffffffn)
              throw new RangeError("value out of range");
          };
        function u(t) {
          "number" == typeof t
            ? (function (t) {
                if (t < 0 || t > Number.MAX_SAFE_INTEGER || t % 1 != 0)
                  throw new RangeError("value out of range");
              })(t)
            : a(t);
        }
        function c(t) {
          return u(t), t < 253 ? 1 : t <= 65535 ? 3 : t <= 4294967295 ? 5 : 9;
        }
      },
      39209: (t, e, r) => {
        "use strict";
        var n = [
            "BigInt64Array",
            "BigUint64Array",
            "Float32Array",
            "Float64Array",
            "Int16Array",
            "Int32Array",
            "Int8Array",
            "Uint16Array",
            "Uint32Array",
            "Uint8Array",
            "Uint8ClampedArray",
          ],
          i = "undefined" == typeof globalThis ? r.g : globalThis;
        t.exports = function () {
          for (var t = [], e = 0; e < n.length; e++)
            "function" == typeof i[n[e]] && (t[t.length] = n[e]);
          return t;
        };
      },
      86425: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i = r(48287).Buffer;
        function o(t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        }
        const { toString: s } = Object.prototype,
          { getPrototypeOf: a } = Object,
          u =
            ((c = Object.create(null)),
            (t) => {
              const e = s.call(t);
              return c[e] || (c[e] = e.slice(8, -1).toLowerCase());
            });
        var c;
        const f = (t) => ((t = t.toLowerCase()), (e) => u(e) === t),
          h = (t) => (e) => typeof e === t,
          { isArray: l } = Array,
          d = h("undefined");
        const p = f("ArrayBuffer");
        const y = h("string"),
          g = h("function"),
          m = h("number"),
          b = (t) => null !== t && "object" == typeof t,
          w = (t) => {
            if ("object" !== u(t)) return !1;
            const e = a(t);
            return !(
              (null !== e &&
                e !== Object.prototype &&
                null !== Object.getPrototypeOf(e)) ||
              Symbol.toStringTag in t ||
              Symbol.iterator in t
            );
          },
          v = f("Date"),
          _ = f("File"),
          E = f("Blob"),
          S = f("FileList"),
          I = f("URLSearchParams"),
          [M, A, T, k] = [
            "ReadableStream",
            "Request",
            "Response",
            "Headers",
          ].map(f);
        function O(t, e, { allOwnKeys: r = !1 } = {}) {
          if (null == t) return;
          let n, i;
          if (("object" != typeof t && (t = [t]), l(t)))
            for (n = 0, i = t.length; n < i; n++) e.call(null, t[n], n, t);
          else {
            const i = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
              o = i.length;
            let s;
            for (n = 0; n < o; n++) (s = i[n]), e.call(null, t[s], s, t);
          }
        }
        function x(t, e) {
          e = e.toLowerCase();
          const r = Object.keys(t);
          let n,
            i = r.length;
          for (; i-- > 0; ) if (((n = r[i]), e === n.toLowerCase())) return n;
          return null;
        }
        const P =
            "undefined" != typeof globalThis
              ? globalThis
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window
                  ? window
                  : r.g,
          B = (t) => !d(t) && t !== P;
        const C =
          ((R = "undefined" != typeof Uint8Array && a(Uint8Array)),
          (t) => R && t instanceof R);
        var R;
        const N = f("HTMLFormElement"),
          U = (
            ({ hasOwnProperty: t }) =>
            (e, r) =>
              t.call(e, r)
          )(Object.prototype),
          D = f("RegExp"),
          L = (t, e) => {
            const r = Object.getOwnPropertyDescriptors(t),
              n = {};
            O(r, (r, i) => {
              let o;
              !1 !== (o = e(r, i, t)) && (n[i] = o || r);
            }),
              Object.defineProperties(t, n);
          },
          j = "abcdefghijklmnopqrstuvwxyz",
          F = "0123456789",
          H = { DIGIT: F, ALPHA: j, ALPHA_DIGIT: j + j.toUpperCase() + F };
        const K = f("AsyncFunction"),
          V =
            ((q = "function" == typeof setImmediate),
            (z = g(P.postMessage)),
            q
              ? setImmediate
              : z
                ? (($ = `axios@${Math.random()}`),
                  (G = []),
                  P.addEventListener(
                    "message",
                    ({ source: t, data: e }) => {
                      t === P && e === $ && G.length && G.shift()();
                    },
                    !1,
                  ),
                  (t) => {
                    G.push(t), P.postMessage($, "*");
                  })
                : (t) => setTimeout(t));
        var q, z, $, G;
        const W =
          "undefined" != typeof queueMicrotask
            ? queueMicrotask.bind(P)
            : (void 0 !== n && n.nextTick) || V;
        var Y = {
          isArray: l,
          isArrayBuffer: p,
          isBuffer: function (t) {
            return (
              null !== t &&
              !d(t) &&
              null !== t.constructor &&
              !d(t.constructor) &&
              g(t.constructor.isBuffer) &&
              t.constructor.isBuffer(t)
            );
          },
          isFormData: (t) => {
            let e;
            return (
              t &&
              (("function" == typeof FormData && t instanceof FormData) ||
                (g(t.append) &&
                  ("formdata" === (e = u(t)) ||
                    ("object" === e &&
                      g(t.toString) &&
                      "[object FormData]" === t.toString()))))
            );
          },
          isArrayBufferView: function (t) {
            let e;
            return (
              (e =
                "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t && t.buffer && p(t.buffer)),
              e
            );
          },
          isString: y,
          isNumber: m,
          isBoolean: (t) => !0 === t || !1 === t,
          isObject: b,
          isPlainObject: w,
          isReadableStream: M,
          isRequest: A,
          isResponse: T,
          isHeaders: k,
          isUndefined: d,
          isDate: v,
          isFile: _,
          isBlob: E,
          isRegExp: D,
          isFunction: g,
          isStream: (t) => b(t) && g(t.pipe),
          isURLSearchParams: I,
          isTypedArray: C,
          isFileList: S,
          forEach: O,
          merge: function t() {
            const { caseless: e } = (B(this) && this) || {},
              r = {},
              n = (n, i) => {
                const o = (e && x(r, i)) || i;
                w(r[o]) && w(n)
                  ? (r[o] = t(r[o], n))
                  : w(n)
                    ? (r[o] = t({}, n))
                    : l(n)
                      ? (r[o] = n.slice())
                      : (r[o] = n);
              };
            for (let t = 0, e = arguments.length; t < e; t++)
              arguments[t] && O(arguments[t], n);
            return r;
          },
          extend: (t, e, r, { allOwnKeys: n } = {}) => (
            O(
              e,
              (e, n) => {
                r && g(e) ? (t[n] = o(e, r)) : (t[n] = e);
              },
              { allOwnKeys: n },
            ),
            t
          ),
          trim: (t) =>
            t.trim
              ? t.trim()
              : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
          stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
          inherits: (t, e, r, n) => {
            (t.prototype = Object.create(e.prototype, n)),
              (t.prototype.constructor = t),
              Object.defineProperty(t, "super", { value: e.prototype }),
              r && Object.assign(t.prototype, r);
          },
          toFlatObject: (t, e, r, n) => {
            let i, o, s;
            const u = {};
            if (((e = e || {}), null == t)) return e;
            do {
              for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0; )
                (s = i[o]),
                  (n && !n(s, t, e)) || u[s] || ((e[s] = t[s]), (u[s] = !0));
              t = !1 !== r && a(t);
            } while (t && (!r || r(t, e)) && t !== Object.prototype);
            return e;
          },
          kindOf: u,
          kindOfTest: f,
          endsWith: (t, e, r) => {
            (t = String(t)),
              (void 0 === r || r > t.length) && (r = t.length),
              (r -= e.length);
            const n = t.indexOf(e, r);
            return -1 !== n && n === r;
          },
          toArray: (t) => {
            if (!t) return null;
            if (l(t)) return t;
            let e = t.length;
            if (!m(e)) return null;
            const r = new Array(e);
            for (; e-- > 0; ) r[e] = t[e];
            return r;
          },
          forEachEntry: (t, e) => {
            const r = (t && t[Symbol.iterator]).call(t);
            let n;
            for (; (n = r.next()) && !n.done; ) {
              const r = n.value;
              e.call(t, r[0], r[1]);
            }
          },
          matchAll: (t, e) => {
            let r;
            const n = [];
            for (; null !== (r = t.exec(e)); ) n.push(r);
            return n;
          },
          isHTMLForm: N,
          hasOwnProperty: U,
          hasOwnProp: U,
          reduceDescriptors: L,
          freezeMethods: (t) => {
            L(t, (e, r) => {
              if (g(t) && -1 !== ["arguments", "caller", "callee"].indexOf(r))
                return !1;
              const n = t[r];
              g(n) &&
                ((e.enumerable = !1),
                "writable" in e
                  ? (e.writable = !1)
                  : e.set ||
                    (e.set = () => {
                      throw Error(
                        "Can not rewrite read-only method '" + r + "'",
                      );
                    }));
            });
          },
          toObjectSet: (t, e) => {
            const r = {},
              n = (t) => {
                t.forEach((t) => {
                  r[t] = !0;
                });
              };
            return l(t) ? n(t) : n(String(t).split(e)), r;
          },
          toCamelCase: (t) =>
            t
              .toLowerCase()
              .replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, r) {
                return e.toUpperCase() + r;
              }),
          noop: () => {},
          toFiniteNumber: (t, e) =>
            null != t && Number.isFinite((t = +t)) ? t : e,
          findKey: x,
          global: P,
          isContextDefined: B,
          ALPHABET: H,
          generateString: (t = 16, e = H.ALPHA_DIGIT) => {
            let r = "";
            const { length: n } = e;
            for (; t--; ) r += e[(Math.random() * n) | 0];
            return r;
          },
          isSpecCompliantForm: function (t) {
            return !!(
              t &&
              g(t.append) &&
              "FormData" === t[Symbol.toStringTag] &&
              t[Symbol.iterator]
            );
          },
          toJSONObject: (t) => {
            const e = new Array(10),
              r = (t, n) => {
                if (b(t)) {
                  if (e.indexOf(t) >= 0) return;
                  if (!("toJSON" in t)) {
                    e[n] = t;
                    const i = l(t) ? [] : {};
                    return (
                      O(t, (t, e) => {
                        const o = r(t, n + 1);
                        !d(o) && (i[e] = o);
                      }),
                      (e[n] = void 0),
                      i
                    );
                  }
                }
                return t;
              };
            return r(t, 0);
          },
          isAsyncFn: K,
          isThenable: (t) => t && (b(t) || g(t)) && g(t.then) && g(t.catch),
          setImmediate: V,
          asap: W,
        };
        function X(t, e, r, n, i) {
          Error.call(this),
            Error.captureStackTrace
              ? Error.captureStackTrace(this, this.constructor)
              : (this.stack = new Error().stack),
            (this.message = t),
            (this.name = "AxiosError"),
            e && (this.code = e),
            r && (this.config = r),
            n && (this.request = n),
            i &&
              ((this.response = i), (this.status = i.status ? i.status : null));
        }
        Y.inherits(X, Error, {
          toJSON: function () {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: Y.toJSONObject(this.config),
              code: this.code,
              status: this.status,
            };
          },
        });
        const Z = X.prototype,
          J = {};
        [
          "ERR_BAD_OPTION_VALUE",
          "ERR_BAD_OPTION",
          "ECONNABORTED",
          "ETIMEDOUT",
          "ERR_NETWORK",
          "ERR_FR_TOO_MANY_REDIRECTS",
          "ERR_DEPRECATED",
          "ERR_BAD_RESPONSE",
          "ERR_BAD_REQUEST",
          "ERR_CANCELED",
          "ERR_NOT_SUPPORT",
          "ERR_INVALID_URL",
        ].forEach((t) => {
          J[t] = { value: t };
        }),
          Object.defineProperties(X, J),
          Object.defineProperty(Z, "isAxiosError", { value: !0 }),
          (X.from = (t, e, r, n, i, o) => {
            const s = Object.create(Z);
            return (
              Y.toFlatObject(
                t,
                s,
                function (t) {
                  return t !== Error.prototype;
                },
                (t) => "isAxiosError" !== t,
              ),
              X.call(s, t.message, e, r, n, i),
              (s.cause = t),
              (s.name = t.name),
              o && Object.assign(s, o),
              s
            );
          });
        function Q(t) {
          return Y.isPlainObject(t) || Y.isArray(t);
        }
        function tt(t) {
          return Y.endsWith(t, "[]") ? t.slice(0, -2) : t;
        }
        function et(t, e, r) {
          return t
            ? t
                .concat(e)
                .map(function (t, e) {
                  return (t = tt(t)), !r && e ? "[" + t + "]" : t;
                })
                .join(r ? "." : "")
            : e;
        }
        const rt = Y.toFlatObject(Y, {}, null, function (t) {
          return /^is[A-Z]/.test(t);
        });
        function nt(t, e, r) {
          if (!Y.isObject(t)) throw new TypeError("target must be an object");
          e = e || new FormData();
          const n = (r = Y.toFlatObject(
              r,
              { metaTokens: !0, dots: !1, indexes: !1 },
              !1,
              function (t, e) {
                return !Y.isUndefined(e[t]);
              },
            )).metaTokens,
            o = r.visitor || f,
            s = r.dots,
            a = r.indexes,
            u =
              (r.Blob || ("undefined" != typeof Blob && Blob)) &&
              Y.isSpecCompliantForm(e);
          if (!Y.isFunction(o))
            throw new TypeError("visitor must be a function");
          function c(t) {
            if (null === t) return "";
            if (Y.isDate(t)) return t.toISOString();
            if (!u && Y.isBlob(t))
              throw new X("Blob is not supported. Use a Buffer instead.");
            return Y.isArrayBuffer(t) || Y.isTypedArray(t)
              ? u && "function" == typeof Blob
                ? new Blob([t])
                : i.from(t)
              : t;
          }
          function f(t, r, i) {
            let o = t;
            if (t && !i && "object" == typeof t)
              if (Y.endsWith(r, "{}"))
                (r = n ? r : r.slice(0, -2)), (t = JSON.stringify(t));
              else if (
                (Y.isArray(t) &&
                  (function (t) {
                    return Y.isArray(t) && !t.some(Q);
                  })(t)) ||
                ((Y.isFileList(t) || Y.endsWith(r, "[]")) && (o = Y.toArray(t)))
              )
                return (
                  (r = tt(r)),
                  o.forEach(function (t, n) {
                    !Y.isUndefined(t) &&
                      null !== t &&
                      e.append(
                        !0 === a ? et([r], n, s) : null === a ? r : r + "[]",
                        c(t),
                      );
                  }),
                  !1
                );
            return !!Q(t) || (e.append(et(i, r, s), c(t)), !1);
          }
          const h = [],
            l = Object.assign(rt, {
              defaultVisitor: f,
              convertValue: c,
              isVisitable: Q,
            });
          if (!Y.isObject(t)) throw new TypeError("data must be an object");
          return (
            (function t(r, n) {
              if (!Y.isUndefined(r)) {
                if (-1 !== h.indexOf(r))
                  throw Error("Circular reference detected in " + n.join("."));
                h.push(r),
                  Y.forEach(r, function (r, i) {
                    !0 ===
                      (!(Y.isUndefined(r) || null === r) &&
                        o.call(e, r, Y.isString(i) ? i.trim() : i, n, l)) &&
                      t(r, n ? n.concat(i) : [i]);
                  }),
                  h.pop();
              }
            })(t),
            e
          );
        }
        function it(t) {
          const e = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0",
          };
          return encodeURIComponent(t).replace(
            /[!'()~]|%20|%00/g,
            function (t) {
              return e[t];
            },
          );
        }
        function ot(t, e) {
          (this._pairs = []), t && nt(t, this, e);
        }
        const st = ot.prototype;
        function at(t) {
          return encodeURIComponent(t)
            .replace(/%3A/gi, ":")
            .replace(/%24/g, "$")
            .replace(/%2C/gi, ",")
            .replace(/%20/g, "+")
            .replace(/%5B/gi, "[")
            .replace(/%5D/gi, "]");
        }
        function ut(t, e, r) {
          if (!e) return t;
          const n = (r && r.encode) || at,
            i = r && r.serialize;
          let o;
          if (
            ((o = i
              ? i(e, r)
              : Y.isURLSearchParams(e)
                ? e.toString()
                : new ot(e, r).toString(n)),
            o)
          ) {
            const e = t.indexOf("#");
            -1 !== e && (t = t.slice(0, e)),
              (t += (-1 === t.indexOf("?") ? "?" : "&") + o);
          }
          return t;
        }
        (st.append = function (t, e) {
          this._pairs.push([t, e]);
        }),
          (st.toString = function (t) {
            const e = t
              ? function (e) {
                  return t.call(this, e, it);
                }
              : it;
            return this._pairs
              .map(function (t) {
                return e(t[0]) + "=" + e(t[1]);
              }, "")
              .join("&");
          });
        var ct = class {
            constructor() {
              this.handlers = [];
            }
            use(t, e, r) {
              return (
                this.handlers.push({
                  fulfilled: t,
                  rejected: e,
                  synchronous: !!r && r.synchronous,
                  runWhen: r ? r.runWhen : null,
                }),
                this.handlers.length - 1
              );
            }
            eject(t) {
              this.handlers[t] && (this.handlers[t] = null);
            }
            clear() {
              this.handlers && (this.handlers = []);
            }
            forEach(t) {
              Y.forEach(this.handlers, function (e) {
                null !== e && t(e);
              });
            }
          },
          ft = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1,
          },
          ht = {
            isBrowser: !0,
            classes: {
              URLSearchParams:
                "undefined" != typeof URLSearchParams ? URLSearchParams : ot,
              FormData: "undefined" != typeof FormData ? FormData : null,
              Blob: "undefined" != typeof Blob ? Blob : null,
            },
            protocols: ["http", "https", "file", "blob", "url", "data"],
          };
        const lt =
            "undefined" != typeof window && "undefined" != typeof document,
          dt = ("object" == typeof navigator && navigator) || void 0,
          pt =
            lt &&
            (!dt ||
              ["ReactNative", "NativeScript", "NS"].indexOf(dt.product) < 0),
          yt =
            "undefined" != typeof WorkerGlobalScope &&
            self instanceof WorkerGlobalScope &&
            "function" == typeof self.importScripts,
          gt = (lt && window.location.href) || "http://localhost";
        var mt = {
          ...Object.freeze({
            __proto__: null,
            hasBrowserEnv: lt,
            hasStandardBrowserWebWorkerEnv: yt,
            hasStandardBrowserEnv: pt,
            navigator: dt,
            origin: gt,
          }),
          ...ht,
        };
        function bt(t) {
          function e(t, r, n, i) {
            let o = t[i++];
            if ("__proto__" === o) return !0;
            const s = Number.isFinite(+o),
              a = i >= t.length;
            if (((o = !o && Y.isArray(n) ? n.length : o), a))
              return Y.hasOwnProp(n, o) ? (n[o] = [n[o], r]) : (n[o] = r), !s;
            (n[o] && Y.isObject(n[o])) || (n[o] = []);
            return (
              e(t, r, n[o], i) &&
                Y.isArray(n[o]) &&
                (n[o] = (function (t) {
                  const e = {},
                    r = Object.keys(t);
                  let n;
                  const i = r.length;
                  let o;
                  for (n = 0; n < i; n++) (o = r[n]), (e[o] = t[o]);
                  return e;
                })(n[o])),
              !s
            );
          }
          if (Y.isFormData(t) && Y.isFunction(t.entries)) {
            const r = {};
            return (
              Y.forEachEntry(t, (t, n) => {
                e(
                  (function (t) {
                    return Y.matchAll(/\w+|\[(\w*)]/g, t).map((t) =>
                      "[]" === t[0] ? "" : t[1] || t[0],
                    );
                  })(t),
                  n,
                  r,
                  0,
                );
              }),
              r
            );
          }
          return null;
        }
        const wt = {
          transitional: ft,
          adapter: ["xhr", "http", "fetch"],
          transformRequest: [
            function (t, e) {
              const r = e.getContentType() || "",
                n = r.indexOf("application/json") > -1,
                i = Y.isObject(t);
              i && Y.isHTMLForm(t) && (t = new FormData(t));
              if (Y.isFormData(t)) return n ? JSON.stringify(bt(t)) : t;
              if (
                Y.isArrayBuffer(t) ||
                Y.isBuffer(t) ||
                Y.isStream(t) ||
                Y.isFile(t) ||
                Y.isBlob(t) ||
                Y.isReadableStream(t)
              )
                return t;
              if (Y.isArrayBufferView(t)) return t.buffer;
              if (Y.isURLSearchParams(t))
                return (
                  e.setContentType(
                    "application/x-www-form-urlencoded;charset=utf-8",
                    !1,
                  ),
                  t.toString()
                );
              let o;
              if (i) {
                if (r.indexOf("application/x-www-form-urlencoded") > -1)
                  return (function (t, e) {
                    return nt(
                      t,
                      new mt.classes.URLSearchParams(),
                      Object.assign(
                        {
                          visitor: function (t, e, r, n) {
                            return mt.isNode && Y.isBuffer(t)
                              ? (this.append(e, t.toString("base64")), !1)
                              : n.defaultVisitor.apply(this, arguments);
                          },
                        },
                        e,
                      ),
                    );
                  })(t, this.formSerializer).toString();
                if (
                  (o = Y.isFileList(t)) ||
                  r.indexOf("multipart/form-data") > -1
                ) {
                  const e = this.env && this.env.FormData;
                  return nt(
                    o ? { "files[]": t } : t,
                    e && new e(),
                    this.formSerializer,
                  );
                }
              }
              return i || n
                ? (e.setContentType("application/json", !1),
                  (function (t, e, r) {
                    if (Y.isString(t))
                      try {
                        return (e || JSON.parse)(t), Y.trim(t);
                      } catch (t) {
                        if ("SyntaxError" !== t.name) throw t;
                      }
                    return (r || JSON.stringify)(t);
                  })(t))
                : t;
            },
          ],
          transformResponse: [
            function (t) {
              const e = this.transitional || wt.transitional,
                r = e && e.forcedJSONParsing,
                n = "json" === this.responseType;
              if (Y.isResponse(t) || Y.isReadableStream(t)) return t;
              if (t && Y.isString(t) && ((r && !this.responseType) || n)) {
                const r = !(e && e.silentJSONParsing) && n;
                try {
                  return JSON.parse(t);
                } catch (t) {
                  if (r) {
                    if ("SyntaxError" === t.name)
                      throw X.from(
                        t,
                        X.ERR_BAD_RESPONSE,
                        this,
                        null,
                        this.response,
                      );
                    throw t;
                  }
                }
              }
              return t;
            },
          ],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          env: { FormData: mt.classes.FormData, Blob: mt.classes.Blob },
          validateStatus: function (t) {
            return t >= 200 && t < 300;
          },
          headers: {
            common: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": void 0,
            },
          },
        };
        Y.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
          wt.headers[t] = {};
        });
        var vt = wt;
        const _t = Y.toObjectSet([
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ]);
        const Et = Symbol("internals");
        function St(t) {
          return t && String(t).trim().toLowerCase();
        }
        function It(t) {
          return !1 === t || null == t
            ? t
            : Y.isArray(t)
              ? t.map(It)
              : String(t);
        }
        function Mt(t, e, r, n, i) {
          return Y.isFunction(n)
            ? n.call(this, e, r)
            : (i && (e = r),
              Y.isString(e)
                ? Y.isString(n)
                  ? -1 !== e.indexOf(n)
                  : Y.isRegExp(n)
                    ? n.test(e)
                    : void 0
                : void 0);
        }
        class At {
          constructor(t) {
            t && this.set(t);
          }
          set(t, e, r) {
            const n = this;
            function i(t, e, r) {
              const i = St(e);
              if (!i) throw new Error("header name must be a non-empty string");
              const o = Y.findKey(n, i);
              (!o ||
                void 0 === n[o] ||
                !0 === r ||
                (void 0 === r && !1 !== n[o])) &&
                (n[o || e] = It(t));
            }
            const o = (t, e) => Y.forEach(t, (t, r) => i(t, r, e));
            if (Y.isPlainObject(t) || t instanceof this.constructor) o(t, e);
            else if (
              Y.isString(t) &&
              (t = t.trim()) &&
              !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim())
            )
              o(
                ((t) => {
                  const e = {};
                  let r, n, i;
                  return (
                    t &&
                      t.split("\n").forEach(function (t) {
                        (i = t.indexOf(":")),
                          (r = t.substring(0, i).trim().toLowerCase()),
                          (n = t.substring(i + 1).trim()),
                          !r ||
                            (e[r] && _t[r]) ||
                            ("set-cookie" === r
                              ? e[r]
                                ? e[r].push(n)
                                : (e[r] = [n])
                              : (e[r] = e[r] ? e[r] + ", " + n : n));
                      }),
                    e
                  );
                })(t),
                e,
              );
            else if (Y.isHeaders(t))
              for (const [e, n] of t.entries()) i(n, e, r);
            else null != t && i(e, t, r);
            return this;
          }
          get(t, e) {
            if ((t = St(t))) {
              const r = Y.findKey(this, t);
              if (r) {
                const t = this[r];
                if (!e) return t;
                if (!0 === e)
                  return (function (t) {
                    const e = Object.create(null),
                      r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                    let n;
                    for (; (n = r.exec(t)); ) e[n[1]] = n[2];
                    return e;
                  })(t);
                if (Y.isFunction(e)) return e.call(this, t, r);
                if (Y.isRegExp(e)) return e.exec(t);
                throw new TypeError("parser must be boolean|regexp|function");
              }
            }
          }
          has(t, e) {
            if ((t = St(t))) {
              const r = Y.findKey(this, t);
              return !(
                !r ||
                void 0 === this[r] ||
                (e && !Mt(0, this[r], r, e))
              );
            }
            return !1;
          }
          delete(t, e) {
            const r = this;
            let n = !1;
            function i(t) {
              if ((t = St(t))) {
                const i = Y.findKey(r, t);
                !i || (e && !Mt(0, r[i], i, e)) || (delete r[i], (n = !0));
              }
            }
            return Y.isArray(t) ? t.forEach(i) : i(t), n;
          }
          clear(t) {
            const e = Object.keys(this);
            let r = e.length,
              n = !1;
            for (; r--; ) {
              const i = e[r];
              (t && !Mt(0, this[i], i, t, !0)) || (delete this[i], (n = !0));
            }
            return n;
          }
          normalize(t) {
            const e = this,
              r = {};
            return (
              Y.forEach(this, (n, i) => {
                const o = Y.findKey(r, i);
                if (o) return (e[o] = It(n)), void delete e[i];
                const s = t
                  ? (function (t) {
                      return t
                        .trim()
                        .toLowerCase()
                        .replace(
                          /([a-z\d])(\w*)/g,
                          (t, e, r) => e.toUpperCase() + r,
                        );
                    })(i)
                  : String(i).trim();
                s !== i && delete e[i], (e[s] = It(n)), (r[s] = !0);
              }),
              this
            );
          }
          concat(...t) {
            return this.constructor.concat(this, ...t);
          }
          toJSON(t) {
            const e = Object.create(null);
            return (
              Y.forEach(this, (r, n) => {
                null != r &&
                  !1 !== r &&
                  (e[n] = t && Y.isArray(r) ? r.join(", ") : r);
              }),
              e
            );
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON())
              .map(([t, e]) => t + ": " + e)
              .join("\n");
          }
          get [Symbol.toStringTag]() {
            return "AxiosHeaders";
          }
          static from(t) {
            return t instanceof this ? t : new this(t);
          }
          static concat(t, ...e) {
            const r = new this(t);
            return e.forEach((t) => r.set(t)), r;
          }
          static accessor(t) {
            const e = (this[Et] = this[Et] = { accessors: {} }).accessors,
              r = this.prototype;
            function n(t) {
              const n = St(t);
              e[n] ||
                (!(function (t, e) {
                  const r = Y.toCamelCase(" " + e);
                  ["get", "set", "has"].forEach((n) => {
                    Object.defineProperty(t, n + r, {
                      value: function (t, r, i) {
                        return this[n].call(this, e, t, r, i);
                      },
                      configurable: !0,
                    });
                  });
                })(r, t),
                (e[n] = !0));
            }
            return Y.isArray(t) ? t.forEach(n) : n(t), this;
          }
        }
        At.accessor([
          "Content-Type",
          "Content-Length",
          "Accept",
          "Accept-Encoding",
          "User-Agent",
          "Authorization",
        ]),
          Y.reduceDescriptors(At.prototype, ({ value: t }, e) => {
            let r = e[0].toUpperCase() + e.slice(1);
            return {
              get: () => t,
              set(t) {
                this[r] = t;
              },
            };
          }),
          Y.freezeMethods(At);
        var Tt = At;
        function kt(t, e) {
          const r = this || vt,
            n = e || r,
            i = Tt.from(n.headers);
          let o = n.data;
          return (
            Y.forEach(t, function (t) {
              o = t.call(r, o, i.normalize(), e ? e.status : void 0);
            }),
            i.normalize(),
            o
          );
        }
        function Ot(t) {
          return !(!t || !t.__CANCEL__);
        }
        function xt(t, e, r) {
          X.call(this, null == t ? "canceled" : t, X.ERR_CANCELED, e, r),
            (this.name = "CanceledError");
        }
        function Pt(t, e, r) {
          const n = r.config.validateStatus;
          r.status && n && !n(r.status)
            ? e(
                new X(
                  "Request failed with status code " + r.status,
                  [X.ERR_BAD_REQUEST, X.ERR_BAD_RESPONSE][
                    Math.floor(r.status / 100) - 4
                  ],
                  r.config,
                  r.request,
                  r,
                ),
              )
            : t(r);
        }
        Y.inherits(xt, X, { __CANCEL__: !0 });
        const Bt = (t, e, r = 3) => {
            let n = 0;
            const i = (function (t, e) {
              t = t || 10;
              const r = new Array(t),
                n = new Array(t);
              let i,
                o = 0,
                s = 0;
              return (
                (e = void 0 !== e ? e : 1e3),
                function (a) {
                  const u = Date.now(),
                    c = n[s];
                  i || (i = u), (r[o] = a), (n[o] = u);
                  let f = s,
                    h = 0;
                  for (; f !== o; ) (h += r[f++]), (f %= t);
                  if (
                    ((o = (o + 1) % t), o === s && (s = (s + 1) % t), u - i < e)
                  )
                    return;
                  const l = c && u - c;
                  return l ? Math.round((1e3 * h) / l) : void 0;
                }
              );
            })(50, 250);
            return (function (t, e) {
              let r,
                n,
                i = 0,
                o = 1e3 / e;
              const s = (e, o = Date.now()) => {
                (i = o),
                  (r = null),
                  n && (clearTimeout(n), (n = null)),
                  t.apply(null, e);
              };
              return [
                (...t) => {
                  const e = Date.now(),
                    a = e - i;
                  a >= o
                    ? s(t, e)
                    : ((r = t),
                      n ||
                        (n = setTimeout(() => {
                          (n = null), s(r);
                        }, o - a)));
                },
                () => r && s(r),
              ];
            })((r) => {
              const o = r.loaded,
                s = r.lengthComputable ? r.total : void 0,
                a = o - n,
                u = i(a);
              n = o;
              t({
                loaded: o,
                total: s,
                progress: s ? o / s : void 0,
                bytes: a,
                rate: u || void 0,
                estimated: u && s && o <= s ? (s - o) / u : void 0,
                event: r,
                lengthComputable: null != s,
                [e ? "download" : "upload"]: !0,
              });
            }, r);
          },
          Ct = (t, e) => {
            const r = null != t;
            return [
              (n) => e[0]({ lengthComputable: r, total: t, loaded: n }),
              e[1],
            ];
          },
          Rt =
            (t) =>
            (...e) =>
              Y.asap(() => t(...e));
        var Nt = mt.hasStandardBrowserEnv
            ? (function () {
                const t =
                    mt.navigator &&
                    /(msie|trident)/i.test(mt.navigator.userAgent),
                  e = document.createElement("a");
                let r;
                function n(r) {
                  let n = r;
                  return (
                    t && (e.setAttribute("href", n), (n = e.href)),
                    e.setAttribute("href", n),
                    {
                      href: e.href,
                      protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                      host: e.host,
                      search: e.search ? e.search.replace(/^\?/, "") : "",
                      hash: e.hash ? e.hash.replace(/^#/, "") : "",
                      hostname: e.hostname,
                      port: e.port,
                      pathname:
                        "/" === e.pathname.charAt(0)
                          ? e.pathname
                          : "/" + e.pathname,
                    }
                  );
                }
                return (
                  (r = n(window.location.href)),
                  function (t) {
                    const e = Y.isString(t) ? n(t) : t;
                    return e.protocol === r.protocol && e.host === r.host;
                  }
                );
              })()
            : function () {
                return !0;
              },
          Ut = mt.hasStandardBrowserEnv
            ? {
                write(t, e, r, n, i, o) {
                  const s = [t + "=" + encodeURIComponent(e)];
                  Y.isNumber(r) &&
                    s.push("expires=" + new Date(r).toGMTString()),
                    Y.isString(n) && s.push("path=" + n),
                    Y.isString(i) && s.push("domain=" + i),
                    !0 === o && s.push("secure"),
                    (document.cookie = s.join("; "));
                },
                read(t) {
                  const e = document.cookie.match(
                    new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"),
                  );
                  return e ? decodeURIComponent(e[3]) : null;
                },
                remove(t) {
                  this.write(t, "", Date.now() - 864e5);
                },
              }
            : { write() {}, read: () => null, remove() {} };
        function Dt(t, e) {
          return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
            ? (function (t, e) {
                return e
                  ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "")
                  : t;
              })(t, e)
            : e;
        }
        const Lt = (t) => (t instanceof Tt ? { ...t } : t);
        function jt(t, e) {
          e = e || {};
          const r = {};
          function n(t, e, r) {
            return Y.isPlainObject(t) && Y.isPlainObject(e)
              ? Y.merge.call({ caseless: r }, t, e)
              : Y.isPlainObject(e)
                ? Y.merge({}, e)
                : Y.isArray(e)
                  ? e.slice()
                  : e;
          }
          function i(t, e, r) {
            return Y.isUndefined(e)
              ? Y.isUndefined(t)
                ? void 0
                : n(void 0, t, r)
              : n(t, e, r);
          }
          function o(t, e) {
            if (!Y.isUndefined(e)) return n(void 0, e);
          }
          function s(t, e) {
            return Y.isUndefined(e)
              ? Y.isUndefined(t)
                ? void 0
                : n(void 0, t)
              : n(void 0, e);
          }
          function a(r, i, o) {
            return o in e ? n(r, i) : o in t ? n(void 0, r) : void 0;
          }
          const u = {
            url: o,
            method: o,
            data: o,
            baseURL: s,
            transformRequest: s,
            transformResponse: s,
            paramsSerializer: s,
            timeout: s,
            timeoutMessage: s,
            withCredentials: s,
            withXSRFToken: s,
            adapter: s,
            responseType: s,
            xsrfCookieName: s,
            xsrfHeaderName: s,
            onUploadProgress: s,
            onDownloadProgress: s,
            decompress: s,
            maxContentLength: s,
            maxBodyLength: s,
            beforeRedirect: s,
            transport: s,
            httpAgent: s,
            httpsAgent: s,
            cancelToken: s,
            socketPath: s,
            responseEncoding: s,
            validateStatus: a,
            headers: (t, e) => i(Lt(t), Lt(e), !0),
          };
          return (
            Y.forEach(Object.keys(Object.assign({}, t, e)), function (n) {
              const o = u[n] || i,
                s = o(t[n], e[n], n);
              (Y.isUndefined(s) && o !== a) || (r[n] = s);
            }),
            r
          );
        }
        var Ft = (t) => {
          const e = jt({}, t);
          let r,
            {
              data: n,
              withXSRFToken: i,
              xsrfHeaderName: o,
              xsrfCookieName: s,
              headers: a,
              auth: u,
            } = e;
          if (
            ((e.headers = a = Tt.from(a)),
            (e.url = ut(Dt(e.baseURL, e.url), t.params, t.paramsSerializer)),
            u &&
              a.set(
                "Authorization",
                "Basic " +
                  btoa(
                    (u.username || "") +
                      ":" +
                      (u.password
                        ? unescape(encodeURIComponent(u.password))
                        : ""),
                  ),
              ),
            Y.isFormData(n))
          )
            if (mt.hasStandardBrowserEnv || mt.hasStandardBrowserWebWorkerEnv)
              a.setContentType(void 0);
            else if (!1 !== (r = a.getContentType())) {
              const [t, ...e] = r
                ? r
                    .split(";")
                    .map((t) => t.trim())
                    .filter(Boolean)
                : [];
              a.setContentType([t || "multipart/form-data", ...e].join("; "));
            }
          if (
            mt.hasStandardBrowserEnv &&
            (i && Y.isFunction(i) && (i = i(e)), i || (!1 !== i && Nt(e.url)))
          ) {
            const t = o && s && Ut.read(s);
            t && a.set(o, t);
          }
          return e;
        };
        var Ht =
          "undefined" != typeof XMLHttpRequest &&
          function (t) {
            return new Promise(function (e, r) {
              const n = Ft(t);
              let i = n.data;
              const o = Tt.from(n.headers).normalize();
              let s,
                a,
                u,
                c,
                f,
                {
                  responseType: h,
                  onUploadProgress: l,
                  onDownloadProgress: d,
                } = n;
              function p() {
                c && c(),
                  f && f(),
                  n.cancelToken && n.cancelToken.unsubscribe(s),
                  n.signal && n.signal.removeEventListener("abort", s);
              }
              let y = new XMLHttpRequest();
              function g() {
                if (!y) return;
                const n = Tt.from(
                  "getAllResponseHeaders" in y && y.getAllResponseHeaders(),
                );
                Pt(
                  function (t) {
                    e(t), p();
                  },
                  function (t) {
                    r(t), p();
                  },
                  {
                    data:
                      h && "text" !== h && "json" !== h
                        ? y.response
                        : y.responseText,
                    status: y.status,
                    statusText: y.statusText,
                    headers: n,
                    config: t,
                    request: y,
                  },
                ),
                  (y = null);
              }
              y.open(n.method.toUpperCase(), n.url, !0),
                (y.timeout = n.timeout),
                "onloadend" in y
                  ? (y.onloadend = g)
                  : (y.onreadystatechange = function () {
                      y &&
                        4 === y.readyState &&
                        (0 !== y.status ||
                          (y.responseURL &&
                            0 === y.responseURL.indexOf("file:"))) &&
                        setTimeout(g);
                    }),
                (y.onabort = function () {
                  y &&
                    (r(new X("Request aborted", X.ECONNABORTED, t, y)),
                    (y = null));
                }),
                (y.onerror = function () {
                  r(new X("Network Error", X.ERR_NETWORK, t, y)), (y = null);
                }),
                (y.ontimeout = function () {
                  let e = n.timeout
                    ? "timeout of " + n.timeout + "ms exceeded"
                    : "timeout exceeded";
                  const i = n.transitional || ft;
                  n.timeoutErrorMessage && (e = n.timeoutErrorMessage),
                    r(
                      new X(
                        e,
                        i.clarifyTimeoutError ? X.ETIMEDOUT : X.ECONNABORTED,
                        t,
                        y,
                      ),
                    ),
                    (y = null);
                }),
                void 0 === i && o.setContentType(null),
                "setRequestHeader" in y &&
                  Y.forEach(o.toJSON(), function (t, e) {
                    y.setRequestHeader(e, t);
                  }),
                Y.isUndefined(n.withCredentials) ||
                  (y.withCredentials = !!n.withCredentials),
                h && "json" !== h && (y.responseType = n.responseType),
                d && (([u, f] = Bt(d, !0)), y.addEventListener("progress", u)),
                l &&
                  y.upload &&
                  (([a, c] = Bt(l)),
                  y.upload.addEventListener("progress", a),
                  y.upload.addEventListener("loadend", c)),
                (n.cancelToken || n.signal) &&
                  ((s = (e) => {
                    y &&
                      (r(!e || e.type ? new xt(null, t, y) : e),
                      y.abort(),
                      (y = null));
                  }),
                  n.cancelToken && n.cancelToken.subscribe(s),
                  n.signal &&
                    (n.signal.aborted
                      ? s()
                      : n.signal.addEventListener("abort", s)));
              const m = (function (t) {
                const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                return (e && e[1]) || "";
              })(n.url);
              m && -1 === mt.protocols.indexOf(m)
                ? r(
                    new X(
                      "Unsupported protocol " + m + ":",
                      X.ERR_BAD_REQUEST,
                      t,
                    ),
                  )
                : y.send(i || null);
            });
          };
        var Kt = (t, e) => {
          const { length: r } = (t = t ? t.filter(Boolean) : []);
          if (e || r) {
            let r,
              n = new AbortController();
            const i = function (t) {
              if (!r) {
                (r = !0), s();
                const e = t instanceof Error ? t : this.reason;
                n.abort(
                  e instanceof X
                    ? e
                    : new xt(e instanceof Error ? e.message : e),
                );
              }
            };
            let o =
              e &&
              setTimeout(() => {
                (o = null),
                  i(new X(`timeout ${e} of ms exceeded`, X.ETIMEDOUT));
              }, e);
            const s = () => {
              t &&
                (o && clearTimeout(o),
                (o = null),
                t.forEach((t) => {
                  t.unsubscribe
                    ? t.unsubscribe(i)
                    : t.removeEventListener("abort", i);
                }),
                (t = null));
            };
            t.forEach((t) => t.addEventListener("abort", i));
            const { signal: a } = n;
            return (a.unsubscribe = () => Y.asap(s)), a;
          }
        };
        const Vt = function* (t, e) {
            let r = t.byteLength;
            if (!e || r < e) return void (yield t);
            let n,
              i = 0;
            for (; i < r; ) (n = i + e), yield t.slice(i, n), (i = n);
          },
          qt = async function* (t) {
            if (t[Symbol.asyncIterator]) return void (yield* t);
            const e = t.getReader();
            try {
              for (;;) {
                const { done: t, value: r } = await e.read();
                if (t) break;
                yield r;
              }
            } finally {
              await e.cancel();
            }
          },
          zt = (t, e, r, n) => {
            const i = (async function* (t, e) {
              for await (const r of qt(t)) yield* Vt(r, e);
            })(t, e);
            let o,
              s = 0,
              a = (t) => {
                o || ((o = !0), n && n(t));
              };
            return new ReadableStream(
              {
                async pull(t) {
                  try {
                    const { done: e, value: n } = await i.next();
                    if (e) return a(), void t.close();
                    let o = n.byteLength;
                    if (r) {
                      let t = (s += o);
                      r(t);
                    }
                    t.enqueue(new Uint8Array(n));
                  } catch (t) {
                    throw (a(t), t);
                  }
                },
                cancel: (t) => (a(t), i.return()),
              },
              { highWaterMark: 2 },
            );
          },
          $t =
            "function" == typeof fetch &&
            "function" == typeof Request &&
            "function" == typeof Response,
          Gt = $t && "function" == typeof ReadableStream,
          Wt =
            $t &&
            ("function" == typeof TextEncoder
              ? ((Yt = new TextEncoder()), (t) => Yt.encode(t))
              : async (t) =>
                  new Uint8Array(await new Response(t).arrayBuffer()));
        var Yt;
        const Xt = (t, ...e) => {
            try {
              return !!t(...e);
            } catch (t) {
              return !1;
            }
          },
          Zt =
            Gt &&
            Xt(() => {
              let t = !1;
              const e = new Request(mt.origin, {
                body: new ReadableStream(),
                method: "POST",
                get duplex() {
                  return (t = !0), "half";
                },
              }).headers.has("Content-Type");
              return t && !e;
            }),
          Jt = Gt && Xt(() => Y.isReadableStream(new Response("").body)),
          Qt = { stream: Jt && ((t) => t.body) };
        var te;
        $t &&
          ((te = new Response()),
          ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
            !Qt[t] &&
              (Qt[t] = Y.isFunction(te[t])
                ? (e) => e[t]()
                : (e, r) => {
                    throw new X(
                      `Response type '${t}' is not supported`,
                      X.ERR_NOT_SUPPORT,
                      r,
                    );
                  });
          }));
        const ee = async (t, e) => {
          const r = Y.toFiniteNumber(t.getContentLength());
          return null == r
            ? (async (t) => {
                if (null == t) return 0;
                if (Y.isBlob(t)) return t.size;
                if (Y.isSpecCompliantForm(t)) {
                  const e = new Request(mt.origin, { method: "POST", body: t });
                  return (await e.arrayBuffer()).byteLength;
                }
                return Y.isArrayBufferView(t) || Y.isArrayBuffer(t)
                  ? t.byteLength
                  : (Y.isURLSearchParams(t) && (t += ""),
                    Y.isString(t) ? (await Wt(t)).byteLength : void 0);
              })(e)
            : r;
        };
        const re = {
          http: null,
          xhr: Ht,
          fetch:
            $t &&
            (async (t) => {
              let {
                url: e,
                method: r,
                data: n,
                signal: i,
                cancelToken: o,
                timeout: s,
                onDownloadProgress: a,
                onUploadProgress: u,
                responseType: c,
                headers: f,
                withCredentials: h = "same-origin",
                fetchOptions: l,
              } = Ft(t);
              c = c ? (c + "").toLowerCase() : "text";
              let d,
                p = Kt([i, o && o.toAbortSignal()], s);
              const y =
                p &&
                p.unsubscribe &&
                (() => {
                  p.unsubscribe();
                });
              let g;
              try {
                if (
                  u &&
                  Zt &&
                  "get" !== r &&
                  "head" !== r &&
                  0 !== (g = await ee(f, n))
                ) {
                  let t,
                    r = new Request(e, {
                      method: "POST",
                      body: n,
                      duplex: "half",
                    });
                  if (
                    (Y.isFormData(n) &&
                      (t = r.headers.get("content-type")) &&
                      f.setContentType(t),
                    r.body)
                  ) {
                    const [t, e] = Ct(g, Bt(Rt(u)));
                    n = zt(r.body, 65536, t, e);
                  }
                }
                Y.isString(h) || (h = h ? "include" : "omit");
                const i = "credentials" in Request.prototype;
                d = new Request(e, {
                  ...l,
                  signal: p,
                  method: r.toUpperCase(),
                  headers: f.normalize().toJSON(),
                  body: n,
                  duplex: "half",
                  credentials: i ? h : void 0,
                });
                let o = await fetch(d);
                const s = Jt && ("stream" === c || "response" === c);
                if (Jt && (a || (s && y))) {
                  const t = {};
                  ["status", "statusText", "headers"].forEach((e) => {
                    t[e] = o[e];
                  });
                  const e = Y.toFiniteNumber(o.headers.get("content-length")),
                    [r, n] = (a && Ct(e, Bt(Rt(a), !0))) || [];
                  o = new Response(
                    zt(o.body, 65536, r, () => {
                      n && n(), y && y();
                    }),
                    t,
                  );
                }
                c = c || "text";
                let m = await Qt[Y.findKey(Qt, c) || "text"](o, t);
                return (
                  !s && y && y(),
                  await new Promise((e, r) => {
                    Pt(e, r, {
                      data: m,
                      headers: Tt.from(o.headers),
                      status: o.status,
                      statusText: o.statusText,
                      config: t,
                      request: d,
                    });
                  })
                );
              } catch (e) {
                if (
                  (y && y(),
                  e && "TypeError" === e.name && /fetch/i.test(e.message))
                )
                  throw Object.assign(
                    new X("Network Error", X.ERR_NETWORK, t, d),
                    { cause: e.cause || e },
                  );
                throw X.from(e, e && e.code, t, d);
              }
            }),
        };
        Y.forEach(re, (t, e) => {
          if (t) {
            try {
              Object.defineProperty(t, "name", { value: e });
            } catch (t) {}
            Object.defineProperty(t, "adapterName", { value: e });
          }
        });
        const ne = (t) => `- ${t}`,
          ie = (t) => Y.isFunction(t) || null === t || !1 === t;
        var oe = (t) => {
          t = Y.isArray(t) ? t : [t];
          const { length: e } = t;
          let r, n;
          const i = {};
          for (let o = 0; o < e; o++) {
            let e;
            if (
              ((r = t[o]),
              (n = r),
              !ie(r) && ((n = re[(e = String(r)).toLowerCase()]), void 0 === n))
            )
              throw new X(`Unknown adapter '${e}'`);
            if (n) break;
            i[e || "#" + o] = n;
          }
          if (!n) {
            const t = Object.entries(i).map(
              ([t, e]) =>
                `adapter ${t} ` +
                (!1 === e
                  ? "is not supported by the environment"
                  : "is not available in the build"),
            );
            throw new X(
              "There is no suitable adapter to dispatch the request " +
                (e
                  ? t.length > 1
                    ? "since :\n" + t.map(ne).join("\n")
                    : " " + ne(t[0])
                  : "as no adapter specified"),
              "ERR_NOT_SUPPORT",
            );
          }
          return n;
        };
        function se(t) {
          if (
            (t.cancelToken && t.cancelToken.throwIfRequested(),
            t.signal && t.signal.aborted)
          )
            throw new xt(null, t);
        }
        function ae(t) {
          se(t),
            (t.headers = Tt.from(t.headers)),
            (t.data = kt.call(t, t.transformRequest)),
            -1 !== ["post", "put", "patch"].indexOf(t.method) &&
              t.headers.setContentType("application/x-www-form-urlencoded", !1);
          return oe(t.adapter || vt.adapter)(t).then(
            function (e) {
              return (
                se(t),
                (e.data = kt.call(t, t.transformResponse, e)),
                (e.headers = Tt.from(e.headers)),
                e
              );
            },
            function (e) {
              return (
                Ot(e) ||
                  (se(t),
                  e &&
                    e.response &&
                    ((e.response.data = kt.call(
                      t,
                      t.transformResponse,
                      e.response,
                    )),
                    (e.response.headers = Tt.from(e.response.headers)))),
                Promise.reject(e)
              );
            },
          );
        }
        const ue = "1.7.7",
          ce = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(
          (t, e) => {
            ce[t] = function (r) {
              return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
            };
          },
        );
        const fe = {};
        ce.transitional = function (t, e, r) {
          function n(t, e) {
            return (
              "[Axios v1.7.7] Transitional option '" +
              t +
              "'" +
              e +
              (r ? ". " + r : "")
            );
          }
          return (r, i, o) => {
            if (!1 === t)
              throw new X(
                n(i, " has been removed" + (e ? " in " + e : "")),
                X.ERR_DEPRECATED,
              );
            return (
              e &&
                !fe[i] &&
                ((fe[i] = !0),
                console.warn(
                  n(
                    i,
                    " has been deprecated since v" +
                      e +
                      " and will be removed in the near future",
                  ),
                )),
              !t || t(r, i, o)
            );
          };
        };
        var he = {
          assertOptions: function (t, e, r) {
            if ("object" != typeof t)
              throw new X("options must be an object", X.ERR_BAD_OPTION_VALUE);
            const n = Object.keys(t);
            let i = n.length;
            for (; i-- > 0; ) {
              const o = n[i],
                s = e[o];
              if (s) {
                const e = t[o],
                  r = void 0 === e || s(e, o, t);
                if (!0 !== r)
                  throw new X(
                    "option " + o + " must be " + r,
                    X.ERR_BAD_OPTION_VALUE,
                  );
              } else if (!0 !== r)
                throw new X("Unknown option " + o, X.ERR_BAD_OPTION);
            }
          },
          validators: ce,
        };
        const le = he.validators;
        class de {
          constructor(t) {
            (this.defaults = t),
              (this.interceptors = { request: new ct(), response: new ct() });
          }
          async request(t, e) {
            try {
              return await this._request(t, e);
            } catch (t) {
              if (t instanceof Error) {
                let e;
                Error.captureStackTrace
                  ? Error.captureStackTrace((e = {}))
                  : (e = new Error());
                const r = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                try {
                  t.stack
                    ? r &&
                      !String(t.stack).endsWith(r.replace(/^.+\n.+\n/, "")) &&
                      (t.stack += "\n" + r)
                    : (t.stack = r);
                } catch (t) {}
              }
              throw t;
            }
          }
          _request(t, e) {
            "string" == typeof t ? ((e = e || {}).url = t) : (e = t || {}),
              (e = jt(this.defaults, e));
            const { transitional: r, paramsSerializer: n, headers: i } = e;
            void 0 !== r &&
              he.assertOptions(
                r,
                {
                  silentJSONParsing: le.transitional(le.boolean),
                  forcedJSONParsing: le.transitional(le.boolean),
                  clarifyTimeoutError: le.transitional(le.boolean),
                },
                !1,
              ),
              null != n &&
                (Y.isFunction(n)
                  ? (e.paramsSerializer = { serialize: n })
                  : he.assertOptions(
                      n,
                      { encode: le.function, serialize: le.function },
                      !0,
                    )),
              (e.method = (
                e.method ||
                this.defaults.method ||
                "get"
              ).toLowerCase());
            let o = i && Y.merge(i.common, i[e.method]);
            i &&
              Y.forEach(
                ["delete", "get", "head", "post", "put", "patch", "common"],
                (t) => {
                  delete i[t];
                },
              ),
              (e.headers = Tt.concat(o, i));
            const s = [];
            let a = !0;
            this.interceptors.request.forEach(function (t) {
              ("function" == typeof t.runWhen && !1 === t.runWhen(e)) ||
                ((a = a && t.synchronous), s.unshift(t.fulfilled, t.rejected));
            });
            const u = [];
            let c;
            this.interceptors.response.forEach(function (t) {
              u.push(t.fulfilled, t.rejected);
            });
            let f,
              h = 0;
            if (!a) {
              const t = [ae.bind(this), void 0];
              for (
                t.unshift.apply(t, s),
                  t.push.apply(t, u),
                  f = t.length,
                  c = Promise.resolve(e);
                h < f;

              )
                c = c.then(t[h++], t[h++]);
              return c;
            }
            f = s.length;
            let l = e;
            for (h = 0; h < f; ) {
              const t = s[h++],
                e = s[h++];
              try {
                l = t(l);
              } catch (t) {
                e.call(this, t);
                break;
              }
            }
            try {
              c = ae.call(this, l);
            } catch (t) {
              return Promise.reject(t);
            }
            for (h = 0, f = u.length; h < f; ) c = c.then(u[h++], u[h++]);
            return c;
          }
          getUri(t) {
            return ut(
              Dt((t = jt(this.defaults, t)).baseURL, t.url),
              t.params,
              t.paramsSerializer,
            );
          }
        }
        Y.forEach(["delete", "get", "head", "options"], function (t) {
          de.prototype[t] = function (e, r) {
            return this.request(
              jt(r || {}, { method: t, url: e, data: (r || {}).data }),
            );
          };
        }),
          Y.forEach(["post", "put", "patch"], function (t) {
            function e(e) {
              return function (r, n, i) {
                return this.request(
                  jt(i || {}, {
                    method: t,
                    headers: e ? { "Content-Type": "multipart/form-data" } : {},
                    url: r,
                    data: n,
                  }),
                );
              };
            }
            (de.prototype[t] = e()), (de.prototype[t + "Form"] = e(!0));
          });
        var pe = de;
        class ye {
          constructor(t) {
            if ("function" != typeof t)
              throw new TypeError("executor must be a function.");
            let e;
            this.promise = new Promise(function (t) {
              e = t;
            });
            const r = this;
            this.promise.then((t) => {
              if (!r._listeners) return;
              let e = r._listeners.length;
              for (; e-- > 0; ) r._listeners[e](t);
              r._listeners = null;
            }),
              (this.promise.then = (t) => {
                let e;
                const n = new Promise((t) => {
                  r.subscribe(t), (e = t);
                }).then(t);
                return (
                  (n.cancel = function () {
                    r.unsubscribe(e);
                  }),
                  n
                );
              }),
              t(function (t, n, i) {
                r.reason || ((r.reason = new xt(t, n, i)), e(r.reason));
              });
          }
          throwIfRequested() {
            if (this.reason) throw this.reason;
          }
          subscribe(t) {
            this.reason
              ? t(this.reason)
              : this._listeners
                ? this._listeners.push(t)
                : (this._listeners = [t]);
          }
          unsubscribe(t) {
            if (!this._listeners) return;
            const e = this._listeners.indexOf(t);
            -1 !== e && this._listeners.splice(e, 1);
          }
          toAbortSignal() {
            const t = new AbortController(),
              e = (e) => {
                t.abort(e);
              };
            return (
              this.subscribe(e),
              (t.signal.unsubscribe = () => this.unsubscribe(e)),
              t.signal
            );
          }
          static source() {
            let t;
            return {
              token: new ye(function (e) {
                t = e;
              }),
              cancel: t,
            };
          }
        }
        var ge = ye;
        const me = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511,
        };
        Object.entries(me).forEach(([t, e]) => {
          me[e] = t;
        });
        var be = me;
        const we = (function t(e) {
          const r = new pe(e),
            n = o(pe.prototype.request, r);
          return (
            Y.extend(n, pe.prototype, r, { allOwnKeys: !0 }),
            Y.extend(n, r, null, { allOwnKeys: !0 }),
            (n.create = function (r) {
              return t(jt(e, r));
            }),
            n
          );
        })(vt);
        (we.Axios = pe),
          (we.CanceledError = xt),
          (we.CancelToken = ge),
          (we.isCancel = Ot),
          (we.VERSION = ue),
          (we.toFormData = nt),
          (we.AxiosError = X),
          (we.Cancel = we.CanceledError),
          (we.all = function (t) {
            return Promise.all(t);
          }),
          (we.spread = function (t) {
            return function (e) {
              return t.apply(null, e);
            };
          }),
          (we.isAxiosError = function (t) {
            return Y.isObject(t) && !0 === t.isAxiosError;
          }),
          (we.mergeConfig = jt),
          (we.AxiosHeaders = Tt),
          (we.formToJSON = (t) => bt(Y.isHTMLForm(t) ? new FormData(t) : t)),
          (we.getAdapter = oe),
          (we.HttpStatusCode = be),
          (we.default = we),
          (t.exports = we);
      },
      22333: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            compare: () => y,
            concat: () => f,
            fromBase64: () => p,
            fromHex: () => l,
            fromUtf8: () => c,
            readInt16: () => O,
            readInt32: () => x,
            readInt64: () => P,
            readInt8: () => k,
            readUInt16: () => _,
            readUInt32: () => E,
            readUInt64: () => S,
            readUInt8: () => v,
            toBase64: () => d,
            toHex: () => h,
            toUtf8: () => u,
            writeInt16: () => M,
            writeInt32: () => A,
            writeInt64: () => T,
            writeInt8: () => I,
            writeUInt16: () => m,
            writeUInt32: () => b,
            writeUInt64: () => w,
            writeUInt8: () => g,
          });
        const n = "0123456789abcdefABCDEF",
          i = n.split("").map((t) => t.codePointAt(0)),
          o = Array(256)
            .fill(!0)
            .map((t, e) => {
              const r = String.fromCodePoint(e),
                i = n.indexOf(r);
              return i < 0 ? void 0 : i < 16 ? i : i - 6;
            }),
          s = new TextEncoder(),
          a = new TextDecoder();
        function u(t) {
          return a.decode(t);
        }
        function c(t) {
          return s.encode(t);
        }
        function f(t) {
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          let n = 0;
          for (const e of t) r.set(e, n), (n += e.length);
          return r;
        }
        function h(t) {
          const e = t || new Uint8Array();
          return e.length > 512
            ? (function (t) {
                const e = new Uint8Array(2 * t.length);
                for (let r = 0; r < t.length; ++r)
                  (e[2 * r] = i[t[r] >> 4]), (e[2 * r + 1] = i[15 & t[r]]);
                return a.decode(e);
              })(e)
            : (function (t) {
                let e = "";
                for (let r = 0; r < t.length; ++r)
                  (e += n[o[i[t[r] >> 4]]]), (e += n[o[i[15 & t[r]]]]);
                return e;
              })(e);
        }
        function l(t) {
          const e = s.encode(t || ""),
            r = new Uint8Array(Math.floor(e.length / 2));
          let n;
          for (n = 0; n < r.length; n++) {
            const t = o[e[2 * n]],
              i = o[e[2 * n + 1]];
            if (void 0 === t || void 0 === i) break;
            r[n] = (t << 4) | i;
          }
          return n === r.length ? r : r.slice(0, n);
        }
        function d(t) {
          return btoa(String.fromCharCode(...t));
        }
        function p(t) {
          const e = atob(t),
            r = new Uint8Array(e.length);
          for (let t = 0; t < e.length; t++) r[t] = e.charCodeAt(t);
          return r;
        }
        function y(t, e) {
          const r = Math.min(t.length, e.length);
          for (let n = 0; n < r; ++n)
            if (t[n] !== e[n]) return t[n] < e[n] ? -1 : 1;
          return t.length === e.length ? 0 : t.length > e.length ? 1 : -1;
        }
        function g(t, e, r) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 255)
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`,
            );
          return (t[e] = r), e + 1;
        }
        function m(t, e, r, n) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 65535))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`,
            );
          return (
            "LE" === n
              ? ((t[e] = 255 & r), (t[e + 1] = (r >> 8) & 255))
              : ((t[e] = (r >> 8) & 255), (t[e + 1] = 255 & r)),
            e + 2
          );
        }
        function b(t, e, r, n) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 4294967295))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 4294967295. Received ${r}`,
            );
          return (
            "LE" === n
              ? ((t[e] = 255 & r),
                (t[e + 1] = (r >> 8) & 255),
                (t[e + 2] = (r >> 16) & 255),
                (t[e + 3] = (r >> 24) & 255))
              : ((t[e] = (r >> 24) & 255),
                (t[e + 1] = (r >> 16) & 255),
                (t[e + 2] = (r >> 8) & 255),
                (t[e + 3] = 255 & r)),
            e + 4
          );
        }
        function w(t, e, r, n) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 0xffffffffffffffffn))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${r}`,
            );
          return (
            "LE" === n
              ? ((t[e] = Number(0xffn & r)),
                (t[e + 1] = Number((r >> 8n) & 0xffn)),
                (t[e + 2] = Number((r >> 16n) & 0xffn)),
                (t[e + 3] = Number((r >> 24n) & 0xffn)),
                (t[e + 4] = Number((r >> 32n) & 0xffn)),
                (t[e + 5] = Number((r >> 40n) & 0xffn)),
                (t[e + 6] = Number((r >> 48n) & 0xffn)),
                (t[e + 7] = Number((r >> 56n) & 0xffn)))
              : ((t[e] = Number((r >> 56n) & 0xffn)),
                (t[e + 1] = Number((r >> 48n) & 0xffn)),
                (t[e + 2] = Number((r >> 40n) & 0xffn)),
                (t[e + 3] = Number((r >> 32n) & 0xffn)),
                (t[e + 4] = Number((r >> 24n) & 0xffn)),
                (t[e + 5] = Number((r >> 16n) & 0xffn)),
                (t[e + 6] = Number((r >> 8n) & 0xffn)),
                (t[e + 7] = Number(0xffn & r))),
            e + 8
          );
        }
        function v(t, e) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          return t[e];
        }
        function _(t, e, r) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0;
            return (r = (r << 8) + t[e + 1]), (r = (r << 8) + t[e]), r;
          }
          {
            let r = 0;
            return (r = (r << 8) + t[e]), (r = (r << 8) + t[e + 1]), r;
          }
        }
        function E(t, e, r) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0;
            return (
              (r = ((r << 8) + t[e + 3]) >>> 0),
              (r = ((r << 8) + t[e + 2]) >>> 0),
              (r = ((r << 8) + t[e + 1]) >>> 0),
              (r = ((r << 8) + t[e]) >>> 0),
              r
            );
          }
          {
            let r = 0;
            return (
              (r = ((r << 8) + t[e]) >>> 0),
              (r = ((r << 8) + t[e + 1]) >>> 0),
              (r = ((r << 8) + t[e + 2]) >>> 0),
              (r = ((r << 8) + t[e + 3]) >>> 0),
              r
            );
          }
        }
        function S(t, e, r) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0n;
            return (
              (r = (r << 8n) + BigInt(t[e + 7])),
              (r = (r << 8n) + BigInt(t[e + 6])),
              (r = (r << 8n) + BigInt(t[e + 5])),
              (r = (r << 8n) + BigInt(t[e + 4])),
              (r = (r << 8n) + BigInt(t[e + 3])),
              (r = (r << 8n) + BigInt(t[e + 2])),
              (r = (r << 8n) + BigInt(t[e + 1])),
              (r = (r << 8n) + BigInt(t[e])),
              r
            );
          }
          {
            let r = 0n;
            return (
              (r = (r << 8n) + BigInt(t[e])),
              (r = (r << 8n) + BigInt(t[e + 1])),
              (r = (r << 8n) + BigInt(t[e + 2])),
              (r = (r << 8n) + BigInt(t[e + 3])),
              (r = (r << 8n) + BigInt(t[e + 4])),
              (r = (r << 8n) + BigInt(t[e + 5])),
              (r = (r << 8n) + BigInt(t[e + 6])),
              (r = (r << 8n) + BigInt(t[e + 7])),
              r
            );
          }
        }
        function I(t, e, r) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 127 || r < -128)
            throw new Error(
              `The value of "value" is out of range. It must be >= -128 and <= 127. Received ${r}`,
            );
          return (t[e] = r), e + 1;
        }
        function M(t, e, r, n) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 32767 || r < -32768)
            throw new Error(
              `The value of "value" is out of range. It must be >= -32768 and <= 32767. Received ${r}`,
            );
          return (
            "LE" === (n = n.toUpperCase())
              ? ((t[e] = 255 & r), (t[e + 1] = (r >> 8) & 255))
              : ((t[e] = (r >> 8) & 255), (t[e + 1] = 255 & r)),
            e + 2
          );
        }
        function A(t, e, r, n) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 2147483647 || r < -2147483648)
            throw new Error(
              `The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`,
            );
          return (
            "LE" === (n = n.toUpperCase())
              ? ((t[e] = 255 & r),
                (t[e + 1] = (r >> 8) & 255),
                (t[e + 2] = (r >> 16) & 255),
                (t[e + 3] = (r >> 24) & 255))
              : ((t[e] = (r >> 24) & 255),
                (t[e + 1] = (r >> 16) & 255),
                (t[e + 2] = (r >> 8) & 255),
                (t[e + 3] = 255 & r)),
            e + 4
          );
        }
        function T(t, e, r, n) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
            throw new Error(
              `The value of "value" is out of range. It must be >= -9223372036854775808 and <= 9223372036854775807. Received ${r}`,
            );
          return (
            "LE" === (n = n.toUpperCase())
              ? ((t[e] = Number(0xffn & r)),
                (t[e + 1] = Number((r >> 8n) & 0xffn)),
                (t[e + 2] = Number((r >> 16n) & 0xffn)),
                (t[e + 3] = Number((r >> 24n) & 0xffn)),
                (t[e + 4] = Number((r >> 32n) & 0xffn)),
                (t[e + 5] = Number((r >> 40n) & 0xffn)),
                (t[e + 6] = Number((r >> 48n) & 0xffn)),
                (t[e + 7] = Number((r >> 56n) & 0xffn)))
              : ((t[e] = Number((r >> 56n) & 0xffn)),
                (t[e + 1] = Number((r >> 48n) & 0xffn)),
                (t[e + 2] = Number((r >> 40n) & 0xffn)),
                (t[e + 3] = Number((r >> 32n) & 0xffn)),
                (t[e + 4] = Number((r >> 24n) & 0xffn)),
                (t[e + 5] = Number((r >> 16n) & 0xffn)),
                (t[e + 6] = Number((r >> 8n) & 0xffn)),
                (t[e + 7] = Number(0xffn & r))),
            e + 8
          );
        }
        function k(t, e) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          const r = t[e];
          return r <= 127 ? r : r - 256;
        }
        function O(t, e, r) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            const r = t[e] + (t[e + 1] << 8);
            return t[e + 1] <= 127 ? r : r - 65536;
          }
          {
            const r = (t[e] << 8) + t[e + 1];
            return t[e] <= 127 ? r : r - 65536;
          }
        }
        function x(t, e, r) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            const r =
              t[e] +
              (t[e + 1] << 8) +
              (t[e + 2] << 16) +
              ((t[e + 3] << 24) >>> 0);
            return t[e + 3] <= 127 ? r : r - 4294967296;
          }
          {
            const r =
              ((t[e] << 24) >>> 0) +
              (t[e + 1] << 16) +
              (t[e + 2] << 8) +
              t[e + 3];
            return t[e] <= 127 ? r : r - 4294967296;
          }
        }
        function P(t, e, r) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          let n = 0n;
          if ("LE" === (r = r.toUpperCase()))
            return (
              (n = (n << 8n) + BigInt(t[e + 7])),
              (n = (n << 8n) + BigInt(t[e + 6])),
              (n = (n << 8n) + BigInt(t[e + 5])),
              (n = (n << 8n) + BigInt(t[e + 4])),
              (n = (n << 8n) + BigInt(t[e + 3])),
              (n = (n << 8n) + BigInt(t[e + 2])),
              (n = (n << 8n) + BigInt(t[e + 1])),
              (n = (n << 8n) + BigInt(t[e])),
              t[e + 7] <= 127 ? n : n - 0x10000000000000000n
            );
          {
            let r = 0n;
            return (
              (r = (r << 8n) + BigInt(t[e])),
              (r = (r << 8n) + BigInt(t[e + 1])),
              (r = (r << 8n) + BigInt(t[e + 2])),
              (r = (r << 8n) + BigInt(t[e + 3])),
              (r = (r << 8n) + BigInt(t[e + 4])),
              (r = (r << 8n) + BigInt(t[e + 5])),
              (r = (r << 8n) + BigInt(t[e + 6])),
              (r = (r << 8n) + BigInt(t[e + 7])),
              t[e] <= 127 ? r : r - 0x10000000000000000n
            );
          }
        }
      },
      82519: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            compare: () => y,
            concat: () => f,
            fromBase64: () => p,
            fromHex: () => l,
            fromUtf8: () => c,
            readUInt16: () => _,
            readUInt32: () => E,
            readUInt64: () => S,
            readUInt8: () => v,
            toBase64: () => d,
            toHex: () => h,
            toUtf8: () => u,
            writeUInt16: () => m,
            writeUInt32: () => b,
            writeUInt64: () => w,
            writeUInt8: () => g,
          });
        const n = "0123456789abcdefABCDEF",
          i = n.split("").map((t) => t.codePointAt(0)),
          o = Array(256)
            .fill(!0)
            .map((t, e) => {
              const r = String.fromCodePoint(e),
                i = n.indexOf(r);
              return i < 0 ? void 0 : i < 16 ? i : i - 6;
            }),
          s = new TextEncoder(),
          a = new TextDecoder();
        function u(t) {
          return a.decode(t);
        }
        function c(t) {
          return s.encode(t);
        }
        function f(t) {
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          let n = 0;
          for (const e of t) r.set(e, n), (n += e.length);
          return r;
        }
        function h(t) {
          const e = t || new Uint8Array();
          return e.length > 512
            ? (function (t) {
                const e = new Uint8Array(2 * t.length);
                for (let r = 0; r < t.length; ++r)
                  (e[2 * r] = i[t[r] >> 4]), (e[2 * r + 1] = i[15 & t[r]]);
                return a.decode(e);
              })(e)
            : (function (t) {
                let e = "";
                for (let r = 0; r < t.length; ++r)
                  (e += n[o[i[t[r] >> 4]]]), (e += n[o[i[15 & t[r]]]]);
                return e;
              })(e);
        }
        function l(t) {
          const e = s.encode(t || ""),
            r = new Uint8Array(Math.floor(e.length / 2));
          let n;
          for (n = 0; n < r.length; n++) {
            const t = o[e[2 * n]],
              i = o[e[2 * n + 1]];
            if (void 0 === t || void 0 === i) break;
            r[n] = (t << 4) | i;
          }
          return n === r.length ? r : r.slice(0, n);
        }
        function d(t) {
          return btoa(String.fromCharCode(...t));
        }
        function p(t) {
          const e = atob(t),
            r = new Uint8Array(e.length);
          for (let t = 0; t < e.length; t++) r[t] = e.charCodeAt(t);
          return r;
        }
        function y(t, e) {
          const r = Math.min(t.length, e.length);
          for (let n = 0; n < r; ++n)
            if (t[n] !== e[n]) return t[n] < e[n] ? -1 : 1;
          return t.length === e.length ? 0 : t.length > e.length ? 1 : -1;
        }
        function g(t, e, r) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (r > 255)
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`,
            );
          t[e] = r;
        }
        function m(t, e, r, n) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 65535))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`,
            );
          "LE" === n
            ? ((t[e] = 255 & r), (t[e + 1] = (r >> 8) & 255))
            : ((t[e] = (r >> 8) & 255), (t[e + 1] = 255 & r));
        }
        function b(t, e, r, n) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 4294967295))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 4294967295. Received ${r}`,
            );
          "LE" === n
            ? ((t[e] = 255 & r),
              (t[e + 1] = (r >> 8) & 255),
              (t[e + 2] = (r >> 16) & 255),
              (t[e + 3] = (r >> 24) & 255))
            : ((t[e] = (r >> 24) & 255),
              (t[e + 1] = (r >> 16) & 255),
              (t[e + 2] = (r >> 8) & 255),
              (t[e + 3] = 255 & r));
        }
        function w(t, e, r, n) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if (((n = n.toUpperCase()), r > 0xffffffffffffffffn))
            throw new Error(
              `The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${r}`,
            );
          "LE" === n
            ? ((t[e] = Number(0xffn & r)),
              (t[e + 1] = Number((r >> 8n) & 0xffn)),
              (t[e + 2] = Number((r >> 16n) & 0xffn)),
              (t[e + 3] = Number((r >> 24n) & 0xffn)),
              (t[e + 4] = Number((r >> 32n) & 0xffn)),
              (t[e + 5] = Number((r >> 40n) & 0xffn)),
              (t[e + 6] = Number((r >> 48n) & 0xffn)),
              (t[e + 7] = Number((r >> 56n) & 0xffn)))
            : ((t[e] = Number((r >> 56n) & 0xffn)),
              (t[e + 1] = Number((r >> 48n) & 0xffn)),
              (t[e + 2] = Number((r >> 40n) & 0xffn)),
              (t[e + 3] = Number((r >> 32n) & 0xffn)),
              (t[e + 4] = Number((r >> 24n) & 0xffn)),
              (t[e + 5] = Number((r >> 16n) & 0xffn)),
              (t[e + 6] = Number((r >> 8n) & 0xffn)),
              (t[e + 7] = Number(0xffn & r)));
        }
        function v(t, e) {
          if (e + 1 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          return t[e];
        }
        function _(t, e, r) {
          if (e + 2 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0;
            return (r = (r << 8) + t[e + 1]), (r = (r << 8) + t[e]), r;
          }
          {
            let r = 0;
            return (r = (r << 8) + t[e]), (r = (r << 8) + t[e + 1]), r;
          }
        }
        function E(t, e, r) {
          if (e + 4 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0;
            return (
              (r = ((r << 8) + t[e + 3]) >>> 0),
              (r = ((r << 8) + t[e + 2]) >>> 0),
              (r = ((r << 8) + t[e + 1]) >>> 0),
              (r = ((r << 8) + t[e]) >>> 0),
              r
            );
          }
          {
            let r = 0;
            return (
              (r = ((r << 8) + t[e]) >>> 0),
              (r = ((r << 8) + t[e + 1]) >>> 0),
              (r = ((r << 8) + t[e + 2]) >>> 0),
              (r = ((r << 8) + t[e + 3]) >>> 0),
              r
            );
          }
        }
        function S(t, e, r) {
          if (e + 8 > t.length)
            throw new Error("Offset is outside the bounds of Uint8Array");
          if ("LE" === (r = r.toUpperCase())) {
            let r = 0n;
            return (
              (r = (r << 8n) + BigInt(t[e + 7])),
              (r = (r << 8n) + BigInt(t[e + 6])),
              (r = (r << 8n) + BigInt(t[e + 5])),
              (r = (r << 8n) + BigInt(t[e + 4])),
              (r = (r << 8n) + BigInt(t[e + 3])),
              (r = (r << 8n) + BigInt(t[e + 2])),
              (r = (r << 8n) + BigInt(t[e + 1])),
              (r = (r << 8n) + BigInt(t[e])),
              r
            );
          }
          {
            let r = 0n;
            return (
              (r = (r << 8n) + BigInt(t[e])),
              (r = (r << 8n) + BigInt(t[e + 1])),
              (r = (r << 8n) + BigInt(t[e + 2])),
              (r = (r << 8n) + BigInt(t[e + 3])),
              (r = (r << 8n) + BigInt(t[e + 4])),
              (r = (r << 8n) + BigInt(t[e + 5])),
              (r = (r << 8n) + BigInt(t[e + 6])),
              (r = (r << 8n) + BigInt(t[e + 7])),
              r
            );
          }
        }
      },
      97883: (t, e, r) => {
        "use strict";
        var n;
        r.d(e, {
          HU: () => st,
          MX: () => ut,
          Wp: () => ht,
          bR: () => M,
          lG: () => tt,
          to: () => k,
        });
        var i = r(70495);
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const o =
            BigInt(0),
          s = BigInt(1),
          a = BigInt(2),
          u = BigInt(3),
          c = BigInt(8),
          f = Object.freeze({
            a: o,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
            ),
            h: s,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240",
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424",
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            ),
          }),
          h = (t, e) => (t + e / a) / e,
          l = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            ),
            splitScalar(t) {
              const { n: e } = f,
                r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                n = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                o = r,
                a = BigInt("0x100000000000000000000000000000000"),
                u = h(o * t, e),
                c = h(-n * t, e);
              let l = H(t - u * r - c * i, e),
                d = H(-u * n - c * o, e);
              const p = l > a,
                y = d > a;
              if ((p && (l = e - l), y && (d = e - d), l > a || d > a))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: p, k1: l, k2neg: y, k2: d };
            },
          },
          d = 32,
          p = 32,
          y = 32,
          g = d + 1,
          m = 2 * d + 1;
        function b(t) {
          const { a: e, b: r } = f,
            n = H(t * t),
            i = H(n * t);
          return H(i + e * t + r);
        }
        const w = f.a === o;
        class v extends Error {
          constructor(t) {
            super(t);
          }
        }
        function _(t) {
          if (!(t instanceof E)) throw new TypeError("JacobianPoint expected");
        }
        class E {
          constructor(t, e, r) {
            (this.x = t), (this.y = e), (this.z = r);
          }
          static fromAffine(t) {
            if (!(t instanceof M))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(M.ZERO) ? E.ZERO : new E(t.x, t.y, s);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = f.P) {
              const r = new Array(t.length),
                n = V(
                  t.reduce(
                    (t, n, i) => (n === o ? t : ((r[i] = t), H(t * n, e))),
                    s,
                  ),
                  e,
                );
              return (
                t.reduceRight(
                  (t, n, i) =>
                    n === o ? t : ((r[i] = H(t * r[i], e)), H(t * n, e)),
                  n,
                ),
                r
              );
            })(t.map((t) => t.z));
            return t.map((t, r) => t.toAffine(e[r]));
          }
          static normalizeZ(t) {
            return E.toAffineBatch(t).map(E.fromAffine);
          }
          equals(t) {
            _(t);
            const { x: e, y: r, z: n } = this,
              { x: i, y: o, z: s } = t,
              a = H(n * n),
              u = H(s * s),
              c = H(e * u),
              f = H(i * a),
              h = H(H(r * s) * u),
              l = H(H(o * n) * a);
            return c === f && h === l;
          }
          negate() {
            return new E(this.x, H(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: r } = this,
              n = H(t * t),
              i = H(e * e),
              o = H(i * i),
              s = t + i,
              f = H(a * (H(s * s) - n - o)),
              h = H(u * n),
              l = H(h * h),
              d = H(l - a * f),
              p = H(h * (f - d) - c * o),
              y = H(a * e * r);
            return new E(d, p, y);
          }
          add(t) {
            _(t);
            const { x: e, y: r, z: n } = this,
              { x: i, y: s, z: u } = t;
            if (i === o || s === o) return this;
            if (e === o || r === o) return t;
            const c = H(n * n),
              f = H(u * u),
              h = H(e * f),
              l = H(i * c),
              d = H(H(r * u) * f),
              p = H(H(s * n) * c),
              y = H(l - h),
              g = H(p - d);
            if (y === o) return g === o ? this.double() : E.ZERO;
            const m = H(y * y),
              b = H(y * m),
              w = H(h * m),
              v = H(g * g - b - a * w),
              S = H(g * (w - v) - d * b),
              I = H(n * u * y);
            return new E(v, S, I);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = E.ZERO;
            if ("bigint" == typeof t && t === o) return e;
            let r = F(t);
            if (r === s) return this;
            if (!w) {
              let t = e,
                n = this;
              for (; r > o; )
                r & s && (t = t.add(n)), (n = n.double()), (r >>= s);
              return t;
            }
            let { k1neg: n, k1: i, k2neg: a, k2: u } = l.splitScalar(r),
              c = e,
              f = e,
              h = this;
            for (; i > o || u > o; )
              i & s && (c = c.add(h)),
                u & s && (f = f.add(h)),
                (h = h.double()),
                (i >>= s),
                (u >>= s);
            return (
              n && (c = c.negate()),
              a && (f = f.negate()),
              (f = new E(H(f.x * l.beta), f.y, f.z)),
              c.add(f)
            );
          }
          precomputeWindow(t) {
            const e = w ? 128 / t + 1 : 256 / t + 1,
              r = [];
            let n = this,
              i = n;
            for (let o = 0; o < e; o++) {
              (i = n), r.push(i);
              for (let e = 1; e < 2 ** (t - 1); e++) (i = i.add(n)), r.push(i);
              n = i.double();
            }
            return r;
          }
          wNAF(t, e) {
            !e && this.equals(E.BASE) && (e = M.BASE);
            const r = (e && e._WINDOW_SIZE) || 1;
            if (256 % r)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2",
              );
            let n = e && I.get(e);
            n ||
              ((n = this.precomputeWindow(r)),
              e && 1 !== r && ((n = E.normalizeZ(n)), I.set(e, n)));
            let i = E.ZERO,
              o = E.BASE;
            const a = 1 + (w ? 128 / r : 256 / r),
              u = 2 ** (r - 1),
              c = BigInt(2 ** r - 1),
              f = 2 ** r,
              h = BigInt(r);
            for (let e = 0; e < a; e++) {
              const r = e * u;
              let a = Number(t & c);
              (t >>= h), a > u && ((a -= f), (t += s));
              const l = r,
                d = r + Math.abs(a) - 1,
                p = e % 2 != 0,
                y = a < 0;
              0 === a ? (o = o.add(S(p, n[l]))) : (i = i.add(S(y, n[d])));
            }
            return { p: i, f: o };
          }
          multiply(t, e) {
            let r,
              n,
              i = F(t);
            if (w) {
              const { k1neg: t, k1: o, k2neg: s, k2: a } = l.splitScalar(i);
              let { p: u, f: c } = this.wNAF(o, e),
                { p: f, f: h } = this.wNAF(a, e);
              (u = S(t, u)),
                (f = S(s, f)),
                (f = new E(H(f.x * l.beta), f.y, f.z)),
                (r = u.add(f)),
                (n = c.add(h));
            } else {
              const { p: t, f: o } = this.wNAF(i, e);
              (r = t), (n = o);
            }
            return E.normalizeZ([r, n])[0];
          }
          toAffine(t) {
            const { x: e, y: r, z: n } = this,
              i = this.equals(E.ZERO);
            null == t && (t = i ? c : V(n));
            const o = t,
              a = H(o * o),
              u = H(a * o),
              f = H(e * a),
              h = H(r * u),
              l = H(n * o);
            if (i) return M.ZERO;
            if (l !== s) throw new Error("invZ was invalid");
            return new M(f, h);
          }
        }
        function S(t, e) {
          const r = e.negate();
          return t ? r : e;
        }
        (E.BASE = new E(f.Gx, f.Gy, s)), (E.ZERO = new E(o, s, o));
        const I = new WeakMap();
        class M {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), I.delete(this);
          }
          hasEvenY() {
            return this.y % a === o;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              r = L(e ? t : t.subarray(1));
            if (!Y(r)) throw new Error("Point is not on curve");
            let n = (function (t) {
              const { P: e } = f,
                r = BigInt(6),
                n = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                s = BigInt(44),
                c = BigInt(88),
                h = (t * t * t) % e,
                l = (h * h * t) % e,
                d = (K(l, u) * l) % e,
                p = (K(d, u) * l) % e,
                y = (K(p, a) * h) % e,
                g = (K(y, n) * y) % e,
                m = (K(g, i) * g) % e,
                b = (K(m, s) * m) % e,
                w = (K(b, c) * b) % e,
                v = (K(w, s) * m) % e,
                _ = (K(v, u) * l) % e,
                E = (K(_, o) * g) % e,
                S = (K(E, r) * h) % e,
                I = K(S, a);
              if ((I * I) % e !== t) throw new Error("Cannot find square root");
              return I;
            })(b(r));
            const i = (n & s) === s;
            if (e) i && (n = H(-n));
            else {
              !(1 & ~t[0]) !== i && (n = H(-n));
            }
            const o = new M(r, n);
            return o.assertValidity(), o;
          }
          static fromUncompressedHex(t) {
            const e = L(t.subarray(1, d + 1)),
              r = L(t.subarray(d + 1, 2 * d + 1)),
              n = new M(e, r);
            return n.assertValidity(), n;
          }
          static fromHex(t) {
            const e = j(t),
              r = e.length,
              n = e[0];
            if (r === d) return this.fromCompressedHex(e);
            if (r === g && (2 === n || 3 === n))
              return this.fromCompressedHex(e);
            if (r === m && 4 === n) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${g} compressed bytes or ${m} uncompressed bytes, not ${r}`,
            );
          }
          static fromPrivateKey(t) {
            return M.BASE.multiply(Z(t));
          }
          static fromSignature(t, e, r) {
            const { r: n, s: i } = Q(e);
            if (![0, 1, 2, 3].includes(r))
              throw new Error("Cannot recover: invalid recovery bit");
            const o = q(j(t)),
              { n: s } = f,
              a = 2 === r || 3 === r ? n + s : n,
              u = V(a, s),
              c = H(-o * u, s),
              h = H(i * u, s),
              l = 1 & r ? "03" : "02",
              d = M.fromHex(l + C(a)),
              p = M.BASE.multiplyAndAddUnsafe(d, c, h);
            if (!p)
              throw new Error("Cannot recover signature: point at infinify");
            return p.assertValidity(), p;
          }
          toRawBytes(t = !1) {
            return D(this.toHex(t));
          }
          toHex(t = !1) {
            const e = C(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${C(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: r } = this;
            if (!Y(e) || !Y(r)) throw new Error(t);
            const n = H(r * r);
            if (H(n - b(e)) !== o) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new M(this.x, H(-this.y));
          }
          double() {
            return E.fromAffine(this).double().toAffine();
          }
          add(t) {
            return E.fromAffine(this).add(E.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return E.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, r) {
            const n = E.fromAffine(this),
              i =
                e === o || e === s || this !== M.BASE
                  ? n.multiplyUnsafe(e)
                  : n.multiply(e),
              a = E.fromAffine(t).multiplyUnsafe(r),
              u = i.add(a);
            return u.equals(E.ZERO) ? void 0 : u.toAffine();
          }
        }
        function A(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function T(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${P(t)}`);
          const e = t[1],
            r = t.subarray(2, e + 2);
          if (!e || r.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === r[0] && r[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: L(r), left: t.subarray(e + 2) };
        }
        (M.BASE = new M(f.Gx, f.Gy)), (M.ZERO = new M(o, o));
        class k {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(t) {
            const e = t instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof t && !e)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const n = e ? P(t) : t;
            if (128 !== n.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new k(U(n.slice(0, 64)), U(n.slice(64, 128)));
          }
          static fromDER(t) {
            const e = t instanceof Uint8Array;
            if ("string" != typeof t && !e)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array",
              );
            const { r, s: n } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${P(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: r } = T(t.subarray(2)),
                { data: n, left: i } = T(r);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${P(i)}`,
                );
              return { r: e, s: n };
            })(e ? t : D(t));
            return new k(r, n);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!W(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!W(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = f.n >> s;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new k(this.r, H(-this.s, f.n)) : this;
          }
          toDERRawBytes() {
            return D(this.toDERHex());
          }
          toDERHex() {
            const t = A(N(this.s)),
              e = A(N(this.r)),
              r = t.length / 2,
              n = e.length / 2,
              i = N(r),
              o = N(n);
            return `30${N(n + r + 4)}02${o}${e}02${i}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return D(this.toCompactHex());
          }
          toCompactHex() {
            return C(this.r) + C(this.s);
          }
        }
        function O(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        const x = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0"),
        );
        function P(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let r = 0; r < t.length; r++) e += x[t[r]];
          return e;
        }
        const B = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000",
        );
        function C(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(o <= t && t < B))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function R(t) {
          const e = D(C(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function N(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function U(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t,
            );
          return BigInt(`0x${t}`);
        }
        function D(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length,
            );
          const e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            const n = 2 * r,
              i = t.slice(n, n + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            e[r] = o;
          }
          return e;
        }
        function L(t) {
          return U(P(t));
        }
        function j(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : D(t);
        }
        function F(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && W(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n",
          );
        }
        function H(t, e = f.P) {
          const r = t % e;
          return r >= o ? r : e + r;
        }
        function K(t, e) {
          const { P: r } = f;
          let n = t;
          for (; e-- > o; ) (n *= n), (n %= r);
          return n;
        }
        function V(t, e = f.P) {
          if (t === o || e <= o)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`,
            );
          let r = H(t, e),
            n = e,
            i = o,
            a = s,
            u = s,
            c = o;
          for (; r !== o; ) {
            const t = n / r,
              e = n % r,
              o = i - u * t,
              s = a - c * t;
            (n = r), (r = e), (i = u), (a = c), (u = o), (c = s);
          }
          if (n !== s) throw new Error("invert: does not exist");
          return H(i, e);
        }
        function q(t, e = !1) {
          const r = (function (t) {
            const e = 8 * t.length - 8 * p,
              r = L(t);
            return e > 0 ? r >> BigInt(e) : r;
          })(t);
          if (e) return r;
          const { n } = f;
          return r >= n ? r - n : r;
        }
        let z, $;
        class G {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return ht.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return $(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof $)
              throw new v("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid",
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const r = this.v.slice();
              e.push(r), (t += this.v.length);
            }
            return O(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const r = this.v.slice();
              e.push(r), (t += this.v.length);
            }
            return O(...e);
          }
        }
        function W(t) {
          return o < t && t < f.n;
        }
        function Y(t) {
          return o < t && t < f.P;
        }
        function X(t, e, r, n = !0) {
          const { n: i } = f,
            a = q(t, !0);
          if (!W(a)) return;
          const u = V(a, i),
            c = M.BASE.multiply(a),
            h = H(c.x, i);
          if (h === o) return;
          const l = H(u * H(e + r * h, i), i);
          if (l === o) return;
          let d = new k(h, l),
            p = (c.x === d.r ? 0 : 2) | Number(c.y & s);
          return (
            n && d.hasHighS() && ((d = d.normalizeS()), (p ^= 1)),
            { sig: d, recovery: p }
          );
        }
        function Z(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (t.length !== 2 * p)
              throw new Error("Expected 32 bytes of private key");
            e = U(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== p)
              throw new Error("Expected 32 bytes of private key");
            e = L(t);
          }
          if (!W(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function J(t) {
          return t instanceof M ? (t.assertValidity(), t) : M.fromHex(t);
        }
        function Q(t) {
          if (t instanceof k) return t.assertValidity(), t;
          try {
            return k.fromDER(t);
          } catch (e) {
            return k.fromCompact(t);
          }
        }
        function tt(t, e = !1) {
          return M.fromPrivateKey(t).toRawBytes(e);
        }
        function et(t) {
          return L(t.length > d ? t.slice(0, d) : t);
        }
        function rt(t) {
          const e = et(t),
            r = H(e, f.n);
          return nt(r < o ? e : r);
        }
        function nt(t) {
          return R(t);
        }
        function it(t, e, r) {
          if (null == t)
            throw new Error(`sign: expected valid message hash, not "${t}"`);
          const n = j(t),
            i = Z(e),
            o = [nt(i), rt(n)];
          if (null != r) {
            !0 === r && (r = ht.randomBytes(d));
            const t = j(r);
            if (t.length !== d)
              throw new Error(`sign: Expected ${d} bytes of extra data`);
            o.push(t);
          }
          return { seed: O(...o), m: et(n), d: i };
        }
        function ot(t, e) {
          const { sig: r, recovery: n } = t,
            { der: i, recovered: o } = Object.assign(
              { canonical: !0, der: !0 },
              e,
            ),
            s = i ? r.toDERRawBytes() : r.toCompactRawBytes();
          return o ? [s, n] : s;
        }
        function st(t, e, r = {}) {
          const { seed: n, m: i, d: o } = it(t, e, r.extraEntropy),
            s = new G(y, p);
          let a;
          for (s.reseedSync(n); !(a = X(s.generateSync(), i, o, r.canonical)); )
            s.reseedSync();
          return ot(a, r);
        }
        const at = { strict: !0 };
        function ut(t, e, r, n = at) {
          let i;
          try {
            (i = Q(t)), (e = j(e));
          } catch (t) {
            return !1;
          }
          const { r: o, s } = i;
          if (n.strict && i.hasHighS()) return !1;
          const a = q(e);
          let u;
          try {
            u = J(r);
          } catch (t) {
            return !1;
          }
          const { n: c } = f,
            h = V(s, c),
            l = H(a * h, c),
            d = H(o * h, c),
            p = M.BASE.multiplyAndAddUnsafe(u, l, d);
          if (!p) return !1;
          return H(p.x, c) === o;
        }
        M.BASE._setWindowSize(8);
        const ct = {
            node: n || (n = r.t(i, 2)),
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          ft = {},
          ht = {
            bytesToHex: P,
            hexToBytes: D,
            concatBytes: O,
            mod: H,
            invert: V,
            isValidPrivateKey(t) {
              try {
                return Z(t), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: R,
            _normalizePrivateKey: Z,
            hashToPrivateKey: (t) => {
              t = j(t);
              const e = p + 8;
              if (t.length < e || t.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186",
                );
              return R(H(L(t), f.n - s) + s);
            },
            randomBytes: (t = 32) => {
              if (ct.web) return ct.web.getRandomValues(new Uint8Array(t));
              if (ct.node) {
                const { randomBytes: e } = ct.node;
                return Uint8Array.from(e(t));
              }
              throw new Error(
                "The environment doesn't have randomBytes function",
              );
            },
            randomPrivateKey: () => ht.hashToPrivateKey(ht.randomBytes(p + 8)),
            precompute(t = 8, e = M.BASE) {
              const r = e === M.BASE ? e : new M(e.x, e.y);
              return r._setWindowSize(t), r.multiply(u), r;
            },
            sha256: async (...t) => {
              if (ct.web) {
                const e = await ct.web.subtle.digest("SHA-256", O(...t));
                return new Uint8Array(e);
              }
              if (ct.node) {
                const { createHash: e } = ct.node,
                  r = e("sha256");
                return (
                  t.forEach((t) => r.update(t)), Uint8Array.from(r.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async (t, ...e) => {
              if (ct.web) {
                const r = await ct.web.subtle.importKey(
                    "raw",
                    t,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"],
                  ),
                  n = O(...e),
                  i = await ct.web.subtle.sign("HMAC", r, n);
                return new Uint8Array(i);
              }
              if (ct.node) {
                const { createHmac: r } = ct.node,
                  n = r("sha256", t);
                return (
                  e.forEach((t) => n.update(t)), Uint8Array.from(n.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function",
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async (t, ...e) => {
              let r = ft[t];
              if (void 0 === r) {
                const e = await ht.sha256(
                  Uint8Array.from(t, (t) => t.charCodeAt(0)),
                );
                (r = O(e, e)), (ft[t] = r);
              }
              return ht.sha256(r, ...e);
            },
            taggedHashSync: (t, ...e) => {
              if ("function" != typeof z)
                throw new v("sha256Sync is undefined, you need to set it");
              let r = ft[t];
              if (void 0 === r) {
                const e = z(Uint8Array.from(t, (t) => t.charCodeAt(0)));
                (r = O(e, e)), (ft[t] = r);
              }
              return z(r, ...e);
            },
            _JacobianPoint: E,
          };
        Object.defineProperties(ht, {
          sha256Sync: {
            configurable: !1,
            get: () => z,
            set(t) {
              z || (z = t);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => $,
            set(t) {
              $ || ($ = t);
            },
          },
        });
      },
      30539: (t, e, r) => {
        "use strict";
        function n(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`);
        }
        function i(t, ...e) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(
              `Expected Uint8Array of length ${e}, not of length=${t.length}`,
            );
        }
        r.d(e, { Ay: () => s });
        const o = {
            number: n,
            bool: function (t) {
              if ("boolean" != typeof t)
                throw new Error(`Expected boolean, not ${t}`);
            },
            bytes: i,
            hash: function (t) {
              if ("function" != typeof t || "function" != typeof t.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor",
                );
              n(t.outputLen), n(t.blockLen);
            },
            exists: function (t, e = !0) {
              if (t.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (e && t.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (t, e) {
              i(t);
              const r = e.outputLen;
              if (t.length < r)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${r}`,
                );
            },
          },
          s = o;
      },
      66421: (t, e, r) => {
        "use strict";
        r.d(e, { D: () => o });
        var n = r(30539),
          i = r(17816);
        class o extends i.Vw {
          constructor(t, e, r, n) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = r),
              (this.isLE = n),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = (0, i.O8)(this.buffer));
          }
          update(t) {
            n.Ay.exists(this);
            const { view: e, buffer: r, blockLen: o } = this,
              s = (t = (0, i.ZJ)(t)).length;
            for (let n = 0; n < s; ) {
              const a = Math.min(o - this.pos, s - n);
              if (a !== o)
                r.set(t.subarray(n, n + a), this.pos),
                  (this.pos += a),
                  (n += a),
                  this.pos === o && (this.process(e, 0), (this.pos = 0));
              else {
                const e = (0, i.O8)(t);
                for (; o <= s - n; n += o) this.process(e, n);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            n.Ay.exists(this), n.Ay.output(t, this), (this.finished = !0);
            const { buffer: e, view: r, blockLen: o, isLE: s } = this;
            let { pos: a } = this;
            (e[a++] = 128),
              this.buffer.subarray(a).fill(0),
              this.padOffset > o - a && (this.process(r, 0), (a = 0));
            for (let t = a; t < o; t++) e[t] = 0;
            !(function (t, e, r, n) {
              if ("function" == typeof t.setBigUint64)
                return t.setBigUint64(e, r, n);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((r >> i) & o),
                a = Number(r & o),
                u = n ? 4 : 0,
                c = n ? 0 : 4;
              t.setUint32(e + u, s, n), t.setUint32(e + c, a, n);
            })(r, o - 8, BigInt(8 * this.length), s),
              this.process(r, 0);
            const u = (0, i.O8)(t),
              c = this.outputLen;
            if (c % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const f = c / 4,
              h = this.get();
            if (f > h.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let t = 0; t < f; t++) u.setUint32(4 * t, h[t], s);
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const r = t.slice(0, e);
            return this.destroy(), r;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: r,
              length: n,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (t.length = n),
              (t.pos = s),
              (t.finished = i),
              (t.destroyed = o),
              n % e && t.buffer.set(r),
              t
            );
          }
        }
      },
      35021: (t, e, r) => {
        "use strict";
        r.d(e, { s: () => h });
        var n = r(66421),
          i = r(17816);
        const o = (t, e, r) => (t & e) ^ (t & r) ^ (e & r),
          s = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          a = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          u = new Uint32Array(64);
        class c extends n.D {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | a[0]),
              (this.B = 0 | a[1]),
              (this.C = 0 | a[2]),
              (this.D = 0 | a[3]),
              (this.E = 0 | a[4]),
              (this.F = 0 | a[5]),
              (this.G = 0 | a[6]),
              (this.H = 0 | a[7]);
          }
          get() {
            const { A: t, B: e, C: r, D: n, E: i, F: o, G: s, H: a } = this;
            return [t, e, r, n, i, o, s, a];
          }
          set(t, e, r, n, i, o, s, a) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | r),
              (this.D = 0 | n),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(t, e) {
            for (let r = 0; r < 16; r++, e += 4) u[r] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = u[t - 15],
                r = u[t - 2],
                n = (0, i.Ow)(e, 7) ^ (0, i.Ow)(e, 18) ^ (e >>> 3),
                o = (0, i.Ow)(r, 17) ^ (0, i.Ow)(r, 19) ^ (r >>> 10);
              u[t] = (o + u[t - 7] + n + u[t - 16]) | 0;
            }
            let { A: r, B: n, C: a, D: c, E: f, F: h, G: l, H: d } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (d +
                    ((0, i.Ow)(f, 6) ^ (0, i.Ow)(f, 11) ^ (0, i.Ow)(f, 25)) +
                    (((p = f) & h) ^ (~p & l)) +
                    s[t] +
                    u[t]) |
                  0,
                y =
                  (((0, i.Ow)(r, 2) ^ (0, i.Ow)(r, 13) ^ (0, i.Ow)(r, 22)) +
                    o(r, n, a)) |
                  0;
              (d = l),
                (l = h),
                (h = f),
                (f = (c + e) | 0),
                (c = a),
                (a = n),
                (n = r),
                (r = (e + y) | 0);
            }
            var p;
            (r = (r + this.A) | 0),
              (n = (n + this.B) | 0),
              (a = (a + this.C) | 0),
              (c = (c + this.D) | 0),
              (f = (f + this.E) | 0),
              (h = (h + this.F) | 0),
              (l = (l + this.G) | 0),
              (d = (d + this.H) | 0),
              this.set(r, n, a, c, f, h, l, d);
          }
          roundClean() {
            u.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class f extends c {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        const h = (0, i.ld)(() => new c());
        (0, i.ld)(() => new f());
      },
      17816: (t, e, r) => {
        "use strict";
        r.d(e, {
          Vw: () => s,
          O8: () => n,
          Ow: () => i,
          ZJ: () => o,
          ld: () => a,
        });
        "object" == typeof self && "crypto" in self && self.crypto;
        const n = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
          i = (t, e) => (t << (32 - e)) | (t >>> e);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        function o(t) {
          if (
            ("string" == typeof t &&
              (t = (function (t) {
                if ("string" != typeof t)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof t,
                  );
                return new TextEncoder().encode(t);
              })(t)),
            !(t instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof t})`,
            );
          return t;
        }
        class s {
          clone() {
            return this._cloneInto();
          }
        }
        function a(t) {
          const e = (e) => t().update(o(e)).digest(),
            r = t();
          return (
            (e.outputLen = r.outputLen),
            (e.blockLen = r.blockLen),
            (e.create = () => t()),
            e
          );
        }
      },
      31635: (t, e, r) => {
        "use strict";
        r.r(e),
          r.d(e, {
            __addDisposableResource: () => R,
            __assign: () => o,
            __asyncDelegator: () => M,
            __asyncGenerator: () => I,
            __asyncValues: () => A,
            __await: () => S,
            __awaiter: () => p,
            __classPrivateFieldGet: () => P,
            __classPrivateFieldIn: () => C,
            __classPrivateFieldSet: () => B,
            __createBinding: () => g,
            __decorate: () => a,
            __disposeResources: () => U,
            __esDecorate: () => c,
            __exportStar: () => m,
            __extends: () => i,
            __generator: () => y,
            __importDefault: () => x,
            __importStar: () => O,
            __makeTemplateObject: () => T,
            __metadata: () => d,
            __param: () => u,
            __propKey: () => h,
            __read: () => w,
            __rest: () => s,
            __runInitializers: () => f,
            __setFunctionName: () => l,
            __spread: () => v,
            __spreadArray: () => E,
            __spreadArrays: () => _,
            __values: () => b,
            default: () => D,
          });
        var n = function (t, e) {
          return (
            (n =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (t, e) {
                  t.__proto__ = e;
                }) ||
              function (t, e) {
                for (var r in e)
                  Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
              }),
            n(t, e)
          );
        };
        function i(t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Class extends value " +
                String(e) +
                " is not a constructor or null",
            );
          function r() {
            this.constructor = t;
          }
          n(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((r.prototype = e.prototype), new r()));
        }
        var o = function () {
          return (
            (o =
              Object.assign ||
              function (t) {
                for (var e, r = 1, n = arguments.length; r < n; r++)
                  for (var i in (e = arguments[r]))
                    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                return t;
              }),
            o.apply(this, arguments)
          );
        };
        function s(t, e) {
          var r = {};
          for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) &&
              e.indexOf(n) < 0 &&
              (r[n] = t[n]);
          if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
            var i = 0;
            for (n = Object.getOwnPropertySymbols(t); i < n.length; i++)
              e.indexOf(n[i]) < 0 &&
                Object.prototype.propertyIsEnumerable.call(t, n[i]) &&
                (r[n[i]] = t[n[i]]);
          }
          return r;
        }
        function a(t, e, r, n) {
          var i,
            o = arguments.length,
            s =
              o < 3
                ? e
                : null === n
                  ? (n = Object.getOwnPropertyDescriptor(e, r))
                  : n;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            s = Reflect.decorate(t, e, r, n);
          else
            for (var a = t.length - 1; a >= 0; a--)
              (i = t[a]) &&
                (s = (o < 3 ? i(s) : o > 3 ? i(e, r, s) : i(e, r)) || s);
          return o > 3 && s && Object.defineProperty(e, r, s), s;
        }
        function u(t, e) {
          return function (r, n) {
            e(r, n, t);
          };
        }
        function c(t, e, r, n, i, o) {
          function s(t) {
            if (void 0 !== t && "function" != typeof t)
              throw new TypeError("Function expected");
            return t;
          }
          for (
            var a,
              u = n.kind,
              c = "getter" === u ? "get" : "setter" === u ? "set" : "value",
              f = !e && t ? (n.static ? t : t.prototype) : null,
              h = e || (f ? Object.getOwnPropertyDescriptor(f, n.name) : {}),
              l = !1,
              d = r.length - 1;
            d >= 0;
            d--
          ) {
            var p = {};
            for (var y in n) p[y] = "access" === y ? {} : n[y];
            for (var y in n.access) p.access[y] = n.access[y];
            p.addInitializer = function (t) {
              if (l)
                throw new TypeError(
                  "Cannot add initializers after decoration has completed",
                );
              o.push(s(t || null));
            };
            var g = (0, r[d])(
              "accessor" === u ? { get: h.get, set: h.set } : h[c],
              p,
            );
            if ("accessor" === u) {
              if (void 0 === g) continue;
              if (null === g || "object" != typeof g)
                throw new TypeError("Object expected");
              (a = s(g.get)) && (h.get = a),
                (a = s(g.set)) && (h.set = a),
                (a = s(g.init)) && i.unshift(a);
            } else (a = s(g)) && ("field" === u ? i.unshift(a) : (h[c] = a));
          }
          f && Object.defineProperty(f, n.name, h), (l = !0);
        }
        function f(t, e, r) {
          for (var n = arguments.length > 2, i = 0; i < e.length; i++)
            r = n ? e[i].call(t, r) : e[i].call(t);
          return n ? r : void 0;
        }
        function h(t) {
          return "symbol" == typeof t ? t : "".concat(t);
        }
        function l(t, e, r) {
          return (
            "symbol" == typeof e &&
              (e = e.description ? "[".concat(e.description, "]") : ""),
            Object.defineProperty(t, "name", {
              configurable: !0,
              value: r ? "".concat(r, " ", e) : e,
            })
          );
        }
        function d(t, e) {
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.metadata
          )
            return Reflect.metadata(t, e);
        }
        function p(t, e, r, n) {
          return new (r || (r = Promise))(function (i, o) {
            function s(t) {
              try {
                u(n.next(t));
              } catch (t) {
                o(t);
              }
            }
            function a(t) {
              try {
                u(n.throw(t));
              } catch (t) {
                o(t);
              }
            }
            function u(t) {
              var e;
              t.done
                ? i(t.value)
                : ((e = t.value),
                  e instanceof r
                    ? e
                    : new r(function (t) {
                        t(e);
                      })).then(s, a);
            }
            u((n = n.apply(t, e || [])).next());
          });
        }
        function y(t, e) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: [],
            };
          return (
            (o = { next: a(0), throw: a(1), return: a(2) }),
            "function" == typeof Symbol &&
              (o[Symbol.iterator] = function () {
                return this;
              }),
            o
          );
          function a(a) {
            return function (u) {
              return (function (a) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; o && ((o = 0), a[0] && (s = 0)), s; )
                  try {
                    if (
                      ((r = 1),
                      n &&
                        (i =
                          2 & a[0]
                            ? n.return
                            : a[0]
                              ? n.throw || ((i = n.return) && i.call(n), 0)
                              : n.next) &&
                        !(i = i.call(n, a[1])).done)
                    )
                      return i;
                    switch (((n = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                      case 0:
                      case 1:
                        i = a;
                        break;
                      case 4:
                        return s.label++, { value: a[1], done: !1 };
                      case 5:
                        s.label++, (n = a[1]), (a = [0]);
                        continue;
                      case 7:
                        (a = s.ops.pop()), s.trys.pop();
                        continue;
                      default:
                        if (
                          !((i = s.trys),
                          (i = i.length > 0 && i[i.length - 1]) ||
                            (6 !== a[0] && 2 !== a[0]))
                        ) {
                          s = 0;
                          continue;
                        }
                        if (
                          3 === a[0] &&
                          (!i || (a[1] > i[0] && a[1] < i[3]))
                        ) {
                          s.label = a[1];
                          break;
                        }
                        if (6 === a[0] && s.label < i[1]) {
                          (s.label = i[1]), (i = a);
                          break;
                        }
                        if (i && s.label < i[2]) {
                          (s.label = i[2]), s.ops.push(a);
                          break;
                        }
                        i[2] && s.ops.pop(), s.trys.pop();
                        continue;
                    }
                    a = e.call(t, s);
                  } catch (t) {
                    (a = [6, t]), (n = 0);
                  } finally {
                    r = i = 0;
                  }
                if (5 & a[0]) throw a[1];
                return { value: a[0] ? a[1] : void 0, done: !0 };
              })([a, u]);
            };
          }
        }
        var g = Object.create
          ? function (t, e, r, n) {
              void 0 === n && (n = r);
              var i = Object.getOwnPropertyDescriptor(e, r);
              (i &&
                !("get" in i ? !e.__esModule : i.writable || i.configurable)) ||
                (i = {
                  enumerable: !0,
                  get: function () {
                    return e[r];
                  },
                }),
                Object.defineProperty(t, n, i);
            }
          : function (t, e, r, n) {
              void 0 === n && (n = r), (t[n] = e[r]);
            };
        function m(t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              g(e, t, r);
        }
        function b(t) {
          var e = "function" == typeof Symbol && Symbol.iterator,
            r = e && t[e],
            n = 0;
          if (r) return r.call(t);
          if (t && "number" == typeof t.length)
            return {
              next: function () {
                return (
                  t && n >= t.length && (t = void 0),
                  { value: t && t[n++], done: !t }
                );
              },
            };
          throw new TypeError(
            e ? "Object is not iterable." : "Symbol.iterator is not defined.",
          );
        }
        function w(t, e) {
          var r = "function" == typeof Symbol && t[Symbol.iterator];
          if (!r) return t;
          var n,
            i,
            o = r.call(t),
            s = [];
          try {
            for (; (void 0 === e || e-- > 0) && !(n = o.next()).done; )
              s.push(n.value);
          } catch (t) {
            i = { error: t };
          } finally {
            try {
              n && !n.done && (r = o.return) && r.call(o);
            } finally {
              if (i) throw i.error;
            }
          }
          return s;
        }
        function v() {
          for (var t = [], e = 0; e < arguments.length; e++)
            t = t.concat(w(arguments[e]));
          return t;
        }
        function _() {
          for (var t = 0, e = 0, r = arguments.length; e < r; e++)
            t += arguments[e].length;
          var n = Array(t),
            i = 0;
          for (e = 0; e < r; e++)
            for (var o = arguments[e], s = 0, a = o.length; s < a; s++, i++)
              n[i] = o[s];
          return n;
        }
        function E(t, e, r) {
          if (r || 2 === arguments.length)
            for (var n, i = 0, o = e.length; i < o; i++)
              (!n && i in e) ||
                (n || (n = Array.prototype.slice.call(e, 0, i)), (n[i] = e[i]));
          return t.concat(n || Array.prototype.slice.call(e));
        }
        function S(t) {
          return this instanceof S ? ((this.v = t), this) : new S(t);
        }
        function I(t, e, r) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n,
            i = r.apply(t, e || []),
            o = [];
          return (
            (n = {}),
            s("next"),
            s("throw"),
            s("return"),
            (n[Symbol.asyncIterator] = function () {
              return this;
            }),
            n
          );
          function s(t) {
            i[t] &&
              (n[t] = function (e) {
                return new Promise(function (r, n) {
                  o.push([t, e, r, n]) > 1 || a(t, e);
                });
              });
          }
          function a(t, e) {
            try {
              (r = i[t](e)).value instanceof S
                ? Promise.resolve(r.value.v).then(u, c)
                : f(o[0][2], r);
            } catch (t) {
              f(o[0][3], t);
            }
            var r;
          }
          function u(t) {
            a("next", t);
          }
          function c(t) {
            a("throw", t);
          }
          function f(t, e) {
            t(e), o.shift(), o.length && a(o[0][0], o[0][1]);
          }
        }
        function M(t) {
          var e, r;
          return (
            (e = {}),
            n("next"),
            n("throw", function (t) {
              throw t;
            }),
            n("return"),
            (e[Symbol.iterator] = function () {
              return this;
            }),
            e
          );
          function n(n, i) {
            e[n] = t[n]
              ? function (e) {
                  return (r = !r)
                    ? { value: S(t[n](e)), done: !1 }
                    : i
                      ? i(e)
                      : e;
                }
              : i;
          }
        }
        function A(t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var e,
            r = t[Symbol.asyncIterator];
          return r
            ? r.call(t)
            : ((t = b(t)),
              (e = {}),
              n("next"),
              n("throw"),
              n("return"),
              (e[Symbol.asyncIterator] = function () {
                return this;
              }),
              e);
          function n(r) {
            e[r] =
              t[r] &&
              function (e) {
                return new Promise(function (n, i) {
                  (function (t, e, r, n) {
                    Promise.resolve(n).then(function (e) {
                      t({ value: e, done: r });
                    }, e);
                  })(n, i, (e = t[r](e)).done, e.value);
                });
              };
          }
        }
        function T(t, e) {
          return (
            Object.defineProperty
              ? Object.defineProperty(t, "raw", { value: e })
              : (t.raw = e),
            t
          );
        }
        var k = Object.create
          ? function (t, e) {
              Object.defineProperty(t, "default", { enumerable: !0, value: e });
            }
          : function (t, e) {
              t.default = e;
            };
        function O(t) {
          if (t && t.__esModule) return t;
          var e = {};
          if (null != t)
            for (var r in t)
              "default" !== r &&
                Object.prototype.hasOwnProperty.call(t, r) &&
                g(e, t, r);
          return k(e, t), e;
        }
        function x(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function P(t, e, r, n) {
          if ("a" === r && !n)
            throw new TypeError(
              "Private accessor was defined without a getter",
            );
          if ("function" == typeof e ? t !== e || !n : !e.has(t))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it",
            );
          return "m" === r ? n : "a" === r ? n.call(t) : n ? n.value : e.get(t);
        }
        function B(t, e, r, n, i) {
          if ("m" === n) throw new TypeError("Private method is not writable");
          if ("a" === n && !i)
            throw new TypeError(
              "Private accessor was defined without a setter",
            );
          if ("function" == typeof e ? t !== e || !i : !e.has(t))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it",
            );
          return "a" === n ? i.call(t, r) : i ? (i.value = r) : e.set(t, r), r;
        }
        function C(t, e) {
          if (null === e || ("object" != typeof e && "function" != typeof e))
            throw new TypeError("Cannot use 'in' operator on non-object");
          return "function" == typeof t ? e === t : t.has(e);
        }
        function R(t, e, r) {
          if (null != e) {
            if ("object" != typeof e && "function" != typeof e)
              throw new TypeError("Object expected.");
            var n;
            if (r) {
              if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
              n = e[Symbol.asyncDispose];
            }
            if (void 0 === n) {
              if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
              n = e[Symbol.dispose];
            }
            if ("function" != typeof n)
              throw new TypeError("Object not disposable.");
            t.stack.push({ value: e, dispose: n, async: r });
          } else r && t.stack.push({ async: !0 });
          return e;
        }
        var N =
          "function" == typeof SuppressedError
            ? SuppressedError
            : function (t, e, r) {
                var n = new Error(r);
                return (
                  (n.name = "SuppressedError"),
                  (n.error = t),
                  (n.suppressed = e),
                  n
                );
              };
        function U(t) {
          function e(e) {
            (t.error = t.hasError
              ? new N(e, t.error, "An error was suppressed during disposal.")
              : e),
              (t.hasError = !0);
          }
          return (function r() {
            for (; t.stack.length; ) {
              var n = t.stack.pop();
              try {
                var i = n.dispose && n.dispose.call(n.value);
                if (n.async)
                  return Promise.resolve(i).then(r, function (t) {
                    return e(t), r();
                  });
              } catch (t) {
                e(t);
              }
            }
            if (t.hasError) throw t.error;
          })();
        }
        const D = {
          __extends: i,
          __assign: o,
          __rest: s,
          __decorate: a,
          __param: u,
          __metadata: d,
          __awaiter: p,
          __generator: y,
          __createBinding: g,
          __exportStar: m,
          __values: b,
          __read: w,
          __spread: v,
          __spreadArrays: _,
          __spreadArray: E,
          __await: S,
          __asyncGenerator: I,
          __asyncDelegator: M,
          __asyncValues: A,
          __makeTemplateObject: T,
          __importStar: O,
          __importDefault: x,
          __classPrivateFieldGet: P,
          __classPrivateFieldSet: B,
          __classPrivateFieldIn: C,
          __addDisposableResource: R,
          __disposeResources: U,
        };
      },
      3219: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}',
        );
      },
      62951: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}',
        );
      },
      64589: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}',
        );
      },
      23241: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}',
        );
      },
      1636: (t) => {
        "use strict";
        t.exports = { rE: "6.6.0" };
      },
      15579: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}',
        );
      },
      53892: (t) => {
        "use strict";
        t.exports = JSON.parse(
          '{"COMPRESSED_TYPE_INVALID":"compressed should be a boolean","EC_PRIVATE_KEY_TYPE_INVALID":"private key should be a Buffer","EC_PRIVATE_KEY_LENGTH_INVALID":"private key length is invalid","EC_PRIVATE_KEY_RANGE_INVALID":"private key range is invalid","EC_PRIVATE_KEY_TWEAK_ADD_FAIL":"tweak out of range or resulting private key is invalid","EC_PRIVATE_KEY_TWEAK_MUL_FAIL":"tweak out of range","EC_PRIVATE_KEY_EXPORT_DER_FAIL":"couldn\'t export to DER format","EC_PRIVATE_KEY_IMPORT_DER_FAIL":"couldn\'t import from DER format","EC_PUBLIC_KEYS_TYPE_INVALID":"public keys should be an Array","EC_PUBLIC_KEYS_LENGTH_INVALID":"public keys Array should have at least 1 element","EC_PUBLIC_KEY_TYPE_INVALID":"public key should be a Buffer","EC_PUBLIC_KEY_LENGTH_INVALID":"public key length is invalid","EC_PUBLIC_KEY_PARSE_FAIL":"the public key could not be parsed or is invalid","EC_PUBLIC_KEY_CREATE_FAIL":"private was invalid, try again","EC_PUBLIC_KEY_TWEAK_ADD_FAIL":"tweak out of range or resulting public key is invalid","EC_PUBLIC_KEY_TWEAK_MUL_FAIL":"tweak out of range","EC_PUBLIC_KEY_COMBINE_FAIL":"the sum of the public keys is not valid","ECDH_FAIL":"scalar was invalid (zero or overflow)","ECDSA_SIGNATURE_TYPE_INVALID":"signature should be a Buffer","ECDSA_SIGNATURE_LENGTH_INVALID":"signature length is invalid","ECDSA_SIGNATURE_PARSE_FAIL":"couldn\'t parse signature","ECDSA_SIGNATURE_PARSE_DER_FAIL":"couldn\'t parse DER signature","ECDSA_SIGNATURE_SERIALIZE_DER_FAIL":"couldn\'t serialize signature to DER format","ECDSA_SIGN_FAIL":"nonce generation function failed or private key is invalid","ECDSA_RECOVER_FAIL":"couldn\'t recover public key from signature","MSG32_TYPE_INVALID":"message should be a Buffer","MSG32_LENGTH_INVALID":"message length is invalid","OPTIONS_TYPE_INVALID":"options should be an Object","OPTIONS_DATA_TYPE_INVALID":"options.data should be a Buffer","OPTIONS_DATA_LENGTH_INVALID":"options.data length is invalid","OPTIONS_NONCEFN_TYPE_INVALID":"options.noncefn should be a Function","RECOVERY_ID_TYPE_INVALID":"recovery should be a Number","RECOVERY_ID_VALUE_INVALID":"recovery should have value between -1 and 4","TWEAK_TYPE_INVALID":"tweak should be a Buffer","TWEAK_LENGTH_INVALID":"tweak length is invalid"}',
        );
      },
    },
    n = {};
  function i(t) {
    var e = n[t];
    if (void 0 !== e) return e.exports;
    var o = (n[t] = { id: t, loaded: !1, exports: {} });
    return r[t].call(o.exports, o, o.exports, i), (o.loaded = !0), o.exports;
  }
  (i.n = (t) => {
    var e = t && t.__esModule ? () => t.default : () => t;
    return i.d(e, { a: e }), e;
  }),
    (e = Object.getPrototypeOf
      ? (t) => Object.getPrototypeOf(t)
      : (t) => t.__proto__),
    (i.t = function (r, n) {
      if ((1 & n && (r = this(r)), 8 & n)) return r;
      if ("object" == typeof r && r) {
        if (4 & n && r.__esModule) return r;
        if (16 & n && "function" == typeof r.then) return r;
      }
      var o = Object.create(null);
      i.r(o);
      var s = {};
      t = t || [null, e({}), e([]), e(e)];
      for (var a = 2 & n && r; "object" == typeof a && !~t.indexOf(a); a = e(a))
        Object.getOwnPropertyNames(a).forEach((t) => (s[t] = () => r[t]));
      return (s.default = () => r), i.d(o, s), o;
    }),
    (i.d = (t, e) => {
      for (var r in e)
        i.o(e, r) &&
          !i.o(t, r) &&
          Object.defineProperty(t, r, { enumerable: !0, get: e[r] });
    }),
    (i.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == typeof window) return window;
      }
    })()),
    (i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
    (i.r = (t) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (i.nmd = (t) => ((t.paths = []), t.children || (t.children = []), t)),
    (() => {
      "use strict";
      var t = {};
      i.r(t),
        i.d(t, {
          hasBrowserEnv: () => Gt,
          hasStandardBrowserEnv: () => Yt,
          hasStandardBrowserWebWorkerEnv: () => Xt,
          navigator: () => Wt,
          origin: () => Zt,
        });
      var e = {};
      i.r(e),
        i.d(e, {
          aK: () => Rc,
          e8: () => bc,
          DO: () => mc,
          dJ: () => Nc,
          OG: () => Uc,
          My: () => vc,
          Ph: () => Ac,
          lX: () => Tc,
          Id: () => Pc,
          fg: () => jc,
          qj: () => xc,
          aT: () => Mc,
          r4: () => Cc,
          aY: () => gc,
          x: () => Kc,
          lq: () => kc,
          z: () => Oc,
          zW: () => _c,
          Q5: () => Hc,
        });
      const r = "xverse-wallet";
      var n, o, s, a;
      !(function (t) {
        (t.transactionRequest = "transactionRequest"),
          (t.transactionResponse = "transactionResponse"),
          (t.authenticationRequest = "authenticationRequest"),
          (t.authenticationResponse = "authenticationResponse"),
          (t.signatureRequest = "signatureRequest"),
          (t.signatureResponse = "signatureResponse"),
          (t.structuredDataSignatureRequest = "structuredDataSignatureRequest");
      })(n || (n = {})),
        (function (t) {
          t.request = "request";
        })(o || (o = {})),
        (function (t) {
          t.OriginatingTabClosed = "OriginatingTabClosed";
        })(s || (s = {})),
        (function (t) {
          (t.getAddressRequest = "getAddressRequest"),
            (t.getAddressResponse = "getAddressResponse"),
            (t.signPsbtRequest = "signPsbtRequest"),
            (t.signBatchPsbtRequest = "signBatchPsbtRequest"),
            (t.signPsbtResponse = "signPsbtResponse"),
            (t.signBatchPsbtResponse = "signBatchPsbtResponse"),
            (t.signMessageRequest = "signMessageRequest"),
            (t.signMessageResponse = "signMessageResponse"),
            (t.sendBtcRequest = "sendBtcRequest"),
            (t.sendBtcResponse = "sendBtcResponse"),
            (t.createInscriptionRequest = "createInscriptionRequest"),
            (t.createInscriptionResponse = "createInscriptionResponse"),
            (t.createRepeatInscriptionsRequest =
              "createRepeatInscriptionsRequest"),
            (t.createRepeatInscriptionsResponse =
              "createRepeatInscriptionsResponse");
        })(a || (a = {}));
      var u, c, f;
      function h(t) {
        const e = typeof t;
        return "string" === e
          ? `"${t}"`
          : "number" === e || "bigint" === e || "boolean" === e
            ? `${t}`
            : "object" === e || "function" === e
              ? ((t && Object.getPrototypeOf(t)?.constructor?.name) ?? "null")
              : e;
      }
      function l(t, e, r, n, i) {
        const o = i && "input" in i ? i.input : r.value,
          s = i?.expected ?? t.expects ?? null,
          a = i?.received ?? h(o),
          l = {
            kind: t.kind,
            type: t.type,
            input: o,
            expected: s,
            received: a,
            message: `Invalid ${e}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
            requirement: t.requirement,
            path: i?.path,
            issues: i?.issues,
            lang: n.lang,
            abortEarly: n.abortEarly,
            abortPipeEarly: n.abortPipeEarly,
          },
          d = "schema" === t.kind,
          p =
            i?.message ??
            t.message ??
            ((y = t.reference), (g = l.lang), f?.get(y)?.get(g)) ??
            (d
              ? (function (t) {
                  return c?.get(t);
                })(l.lang)
              : null) ??
            n.message ??
            (function (t) {
              return u?.get(t);
            })(l.lang);
        var y, g;
        p && (l.message = "function" == typeof p ? p(l) : p),
          d && (r.typed = !1),
          r.issues ? r.issues.push(l) : (r.issues = [l]);
      }
      function d(t, e) {
        return (
          Object.hasOwn(t, e) &&
          "__proto__" !== e &&
          "prototype" !== e &&
          "constructor" !== e
        );
      }
      function p(t, e) {
        const r = [...new Set(t)];
        return r.length > 1 ? `(${r.join(` ${e} `)})` : (r[0] ?? "never");
      }
      Error;
      function y(t, e, r) {
        return "function" == typeof t.default ? t.default(e, r) : t.default;
      }
      function g(t, e) {
        return !t._run({ typed: !1, value: e }, { abortEarly: !0 }).issues;
      }
      function m(t, e) {
        return {
          kind: "schema",
          type: "array",
          reference: m,
          expects: "Array",
          async: !1,
          item: t,
          message: e,
          _run(t, e) {
            const r = t.value;
            if (Array.isArray(r)) {
              (t.typed = !0), (t.value = []);
              for (let n = 0; n < r.length; n++) {
                const i = r[n],
                  o = this.item._run({ typed: !1, value: i }, e);
                if (o.issues) {
                  const s = {
                    type: "array",
                    origin: "value",
                    input: r,
                    key: n,
                    value: i,
                  };
                  for (const e of o.issues)
                    e.path ? e.path.unshift(s) : (e.path = [s]),
                      t.issues?.push(e);
                  if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                    t.typed = !1;
                    break;
                  }
                }
                o.typed || (t.typed = !1), t.value.push(o.value);
              }
            } else l(this, "type", t, e);
            return t;
          },
        };
      }
      function b(t) {
        return {
          kind: "schema",
          type: "boolean",
          reference: b,
          expects: "boolean",
          async: !1,
          message: t,
          _run(t, e) {
            return (
              "boolean" == typeof t.value
                ? (t.typed = !0)
                : l(this, "type", t, e),
              t
            );
          },
        };
      }
      function w(t, e) {
        const r = Object.entries(t)
          .filter(([t]) => isNaN(+t))
          .map(([, t]) => t);
        return {
          kind: "schema",
          type: "enum",
          reference: w,
          expects: p(r.map(h), "|"),
          async: !1,
          enum: t,
          options: r,
          message: e,
          _run(t, e) {
            return (
              this.options.includes(t.value)
                ? (t.typed = !0)
                : l(this, "type", t, e),
              t
            );
          },
        };
      }
      function v(t, e) {
        return {
          kind: "schema",
          type: "literal",
          reference: v,
          expects: h(t),
          async: !1,
          literal: t,
          message: e,
          _run(t, e) {
            return (
              t.value === this.literal ? (t.typed = !0) : l(this, "type", t, e),
              t
            );
          },
        };
      }
      function _(t, e) {
        return {
          kind: "schema",
          type: "non_optional",
          reference: _,
          expects: "!undefined",
          async: !1,
          wrapped: t,
          message: e,
          _run(t, e) {
            return void 0 === t.value
              ? (l(this, "type", t, e), t)
              : this.wrapped._run(t, e);
          },
        };
      }
      function E(t) {
        return {
          kind: "schema",
          type: "null",
          reference: E,
          expects: "null",
          async: !1,
          message: t,
          _run(t, e) {
            return null === t.value ? (t.typed = !0) : l(this, "type", t, e), t;
          },
        };
      }
      function S(t, ...e) {
        const r = {
          kind: "schema",
          type: "nullish",
          reference: S,
          expects: `(${t.expects} | null | undefined)`,
          async: !1,
          wrapped: t,
          _run(t, e) {
            return (null !== t.value && void 0 !== t.value) ||
              ("default" in this && (t.value = y(this, t, e)),
              null !== t.value && void 0 !== t.value)
              ? this.wrapped._run(t, e)
              : ((t.typed = !0), t);
          },
        };
        return 0 in e && (r.default = e[0]), r;
      }
      function I(t) {
        return {
          kind: "schema",
          type: "number",
          reference: I,
          expects: "number",
          async: !1,
          message: t,
          _run(t, e) {
            return (
              "number" != typeof t.value || isNaN(t.value)
                ? l(this, "type", t, e)
                : (t.typed = !0),
              t
            );
          },
        };
      }
      function M(t, e) {
        return {
          kind: "schema",
          type: "object",
          reference: M,
          expects: "Object",
          async: !1,
          entries: t,
          message: e,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              (t.typed = !0), (t.value = {});
              for (const n in this.entries) {
                const i = r[n],
                  o = this.entries[n]._run({ typed: !1, value: i }, e);
                if (o.issues) {
                  const s = {
                    type: "object",
                    origin: "value",
                    input: r,
                    key: n,
                    value: i,
                  };
                  for (const e of o.issues)
                    e.path ? e.path.unshift(s) : (e.path = [s]),
                      t.issues?.push(e);
                  if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                    t.typed = !1;
                    break;
                  }
                }
                o.typed || (t.typed = !1),
                  (void 0 !== o.value || n in r) && (t.value[n] = o.value);
              }
            } else l(this, "type", t, e);
            return t;
          },
        };
      }
      function A(t, ...e) {
        const r = {
          kind: "schema",
          type: "optional",
          reference: A,
          expects: `(${t.expects} | undefined)`,
          async: !1,
          wrapped: t,
          _run(t, e) {
            return void 0 === t.value &&
              ("default" in this && (t.value = y(this, t, e)),
              void 0 === t.value)
              ? ((t.typed = !0), t)
              : this.wrapped._run(t, e);
          },
        };
        return 0 in e && (r.default = e[0]), r;
      }
      function T(t, e) {
        return {
          kind: "schema",
          type: "picklist",
          reference: T,
          expects: p(t.map(h), "|"),
          async: !1,
          options: t,
          message: e,
          _run(t, e) {
            return (
              this.options.includes(t.value)
                ? (t.typed = !0)
                : l(this, "type", t, e),
              t
            );
          },
        };
      }
      function k(t) {
        return {
          kind: "schema",
          type: "string",
          reference: k,
          expects: "string",
          async: !1,
          message: t,
          _run(t, e) {
            return (
              "string" == typeof t.value
                ? (t.typed = !0)
                : l(this, "type", t, e),
              t
            );
          },
        };
      }
      function O(t) {
        let e;
        if (t) for (const r of t) e ? e.push(...r.issues) : (e = r.issues);
        return e;
      }
      function x(t, e) {
        return {
          kind: "schema",
          type: "union",
          reference: x,
          expects: p(
            t.map((t) => t.expects),
            "|",
          ),
          async: !1,
          options: t,
          message: e,
          _run(t, e) {
            let r, n, i;
            for (const o of this.options) {
              const s = o._run({ typed: !1, value: t.value }, e);
              if (s.typed) {
                if (!s.issues) {
                  r = s;
                  break;
                }
                n ? n.push(s) : (n = [s]);
              } else i ? i.push(s) : (i = [s]);
            }
            if (r) return r;
            if (n) {
              if (1 === n.length) return n[0];
              l(this, "type", t, e, { issues: O(n) }), (t.typed = !0);
            } else {
              if (1 === i?.length) return i[0];
              l(this, "type", t, e, { issues: O(i) });
            }
            return t;
          },
        };
      }
      function P() {
        return {
          kind: "schema",
          type: "unknown",
          reference: P,
          expects: "unknown",
          async: !1,
          _run: (t) => ((t.typed = !0), t),
        };
      }
      function B(t, e, r) {
        return {
          kind: "schema",
          type: "variant",
          reference: B,
          expects: "Object",
          async: !1,
          key: t,
          options: e,
          message: r,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              let n,
                i = 0,
                o = this.key,
                s = [];
              const a = (t, u) => {
                for (const c of t.options) {
                  if ("variant" === c.type) a(c, new Set(u).add(c.key));
                  else {
                    let t = !0,
                      a = 0;
                    for (const n of u) {
                      if (
                        c.entries[n]._run({ typed: !1, value: r[n] }, e).issues
                      ) {
                        (t = !1),
                          o !== n &&
                            (i < a || (i === a && n in r && !(o in r))) &&
                            ((i = a), (o = n), (s = [])),
                          o === n && s.push(c.entries[n].expects);
                        break;
                      }
                      a++;
                    }
                    if (t) {
                      const t = c._run({ typed: !1, value: r }, e);
                      (!n || (!n.typed && t.typed)) && (n = t);
                    }
                  }
                  if (n && !n.issues) break;
                }
              };
              if ((a(this, new Set([this.key])), n)) return n;
              l(this, "type", t, e, {
                input: r[o],
                expected: p(s, "|"),
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input: r,
                    key: o,
                    value: r[o],
                  },
                ],
              });
            } else l(this, "type", t, e);
            return t;
          },
        };
      }
      function C(t, e) {
        const r = { ...t.entries };
        for (const t of e) delete r[t];
        return { ...t, entries: r };
      }
      function R(...t) {
        return {
          ...t[0],
          pipe: t,
          _run(e, r) {
            for (const n of t)
              if ("metadata" !== n.kind) {
                if (
                  e.issues &&
                  ("schema" === n.kind || "transformation" === n.kind)
                ) {
                  e.typed = !1;
                  break;
                }
                (e.issues && (r.abortEarly || r.abortPipeEarly)) ||
                  (e = n._run(e, r));
              }
            return e;
          },
        };
      }
      var N = i(69057);
      function U(t, e) {
        return function () {
          return t.apply(e, arguments);
        };
      }
      var D = i(65606);
      const { toString: L } = Object.prototype,
        { getPrototypeOf: j } = Object,
        F =
          ((H = Object.create(null)),
          (t) => {
            const e = L.call(t);
            return H[e] || (H[e] = e.slice(8, -1).toLowerCase());
          });
      var H;
      const K = (t) => ((t = t.toLowerCase()), (e) => F(e) === t),
        V = (t) => (e) => typeof e === t,
        { isArray: q } = Array,
        z = V("undefined");
      const $ = K("ArrayBuffer");
      const G = V("string"),
        W = V("function"),
        Y = V("number"),
        X = (t) => null !== t && "object" == typeof t,
        Z = (t) => {
          if ("object" !== F(t)) return !1;
          const e = j(t);
          return !(
            (null !== e &&
              e !== Object.prototype &&
              null !== Object.getPrototypeOf(e)) ||
            Symbol.toStringTag in t ||
            Symbol.iterator in t
          );
        },
        J = K("Date"),
        Q = K("File"),
        tt = K("Blob"),
        et = K("FileList"),
        rt = K("URLSearchParams"),
        [nt, it, ot, st] = [
          "ReadableStream",
          "Request",
          "Response",
          "Headers",
        ].map(K);
      function at(t, e, { allOwnKeys: r = !1 } = {}) {
        if (null == t) return;
        let n, i;
        if (("object" != typeof t && (t = [t]), q(t)))
          for (n = 0, i = t.length; n < i; n++) e.call(null, t[n], n, t);
        else {
          const i = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = i.length;
          let s;
          for (n = 0; n < o; n++) (s = i[n]), e.call(null, t[s], s, t);
        }
      }
      function ut(t, e) {
        e = e.toLowerCase();
        const r = Object.keys(t);
        let n,
          i = r.length;
        for (; i-- > 0; ) if (((n = r[i]), e === n.toLowerCase())) return n;
        return null;
      }
      const ct =
          "undefined" != typeof globalThis
            ? globalThis
            : "undefined" != typeof self
              ? self
              : "undefined" != typeof window
                ? window
                : global,
        ft = (t) => !z(t) && t !== ct;
      const ht =
        ((lt = "undefined" != typeof Uint8Array && j(Uint8Array)),
        (t) => lt && t instanceof lt);
      var lt;
      const dt = K("HTMLFormElement"),
        pt = (
          ({ hasOwnProperty: t }) =>
          (e, r) =>
            t.call(e, r)
        )(Object.prototype),
        yt = K("RegExp"),
        gt = (t, e) => {
          const r = Object.getOwnPropertyDescriptors(t),
            n = {};
          at(r, (r, i) => {
            let o;
            !1 !== (o = e(r, i, t)) && (n[i] = o || r);
          }),
            Object.defineProperties(t, n);
        },
        mt = "abcdefghijklmnopqrstuvwxyz",
        bt = "0123456789",
        wt = { DIGIT: bt, ALPHA: mt, ALPHA_DIGIT: mt + mt.toUpperCase() + bt };
      const vt = K("AsyncFunction"),
        _t =
          ((Et = "function" == typeof setImmediate),
          (St = W(ct.postMessage)),
          Et
            ? setImmediate
            : St
              ? ((It = `axios@${Math.random()}`),
                (Mt = []),
                ct.addEventListener(
                  "message",
                  ({ source: t, data: e }) => {
                    t === ct && e === It && Mt.length && Mt.shift()();
                  },
                  !1,
                ),
                (t) => {
                  Mt.push(t), ct.postMessage(It, "*");
                })
              : (t) => setTimeout(t));
      var Et, St, It, Mt;
      const At =
          "undefined" != typeof queueMicrotask
            ? queueMicrotask.bind(ct)
            : (void 0 !== D && D.nextTick) || _t,
        Tt = {
          isArray: q,
          isArrayBuffer: $,
          isBuffer: function (t) {
            return (
              null !== t &&
              !z(t) &&
              null !== t.constructor &&
              !z(t.constructor) &&
              W(t.constructor.isBuffer) &&
              t.constructor.isBuffer(t)
            );
          },
          isFormData: (t) => {
            let e;
            return (
              t &&
              (("function" == typeof FormData && t instanceof FormData) ||
                (W(t.append) &&
                  ("formdata" === (e = F(t)) ||
                    ("object" === e &&
                      W(t.toString) &&
                      "[object FormData]" === t.toString()))))
            );
          },
          isArrayBufferView: function (t) {
            let e;
            return (
              (e =
                "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t && t.buffer && $(t.buffer)),
              e
            );
          },
          isString: G,
          isNumber: Y,
          isBoolean: (t) => !0 === t || !1 === t,
          isObject: X,
          isPlainObject: Z,
          isReadableStream: nt,
          isRequest: it,
          isResponse: ot,
          isHeaders: st,
          isUndefined: z,
          isDate: J,
          isFile: Q,
          isBlob: tt,
          isRegExp: yt,
          isFunction: W,
          isStream: (t) => X(t) && W(t.pipe),
          isURLSearchParams: rt,
          isTypedArray: ht,
          isFileList: et,
          forEach: at,
          merge: function t() {
            const { caseless: e } = (ft(this) && this) || {},
              r = {},
              n = (n, i) => {
                const o = (e && ut(r, i)) || i;
                Z(r[o]) && Z(n)
                  ? (r[o] = t(r[o], n))
                  : Z(n)
                    ? (r[o] = t({}, n))
                    : q(n)
                      ? (r[o] = n.slice())
                      : (r[o] = n);
              };
            for (let t = 0, e = arguments.length; t < e; t++)
              arguments[t] && at(arguments[t], n);
            return r;
          },
          extend: (t, e, r, { allOwnKeys: n } = {}) => (
            at(
              e,
              (e, n) => {
                r && W(e) ? (t[n] = U(e, r)) : (t[n] = e);
              },
              { allOwnKeys: n },
            ),
            t
          ),
          trim: (t) =>
            t.trim
              ? t.trim()
              : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
          stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
          inherits: (t, e, r, n) => {
            (t.prototype = Object.create(e.prototype, n)),
              (t.prototype.constructor = t),
              Object.defineProperty(t, "super", { value: e.prototype }),
              r && Object.assign(t.prototype, r);
          },
          toFlatObject: (t, e, r, n) => {
            let i, o, s;
            const a = {};
            if (((e = e || {}), null == t)) return e;
            do {
              for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0; )
                (s = i[o]),
                  (n && !n(s, t, e)) || a[s] || ((e[s] = t[s]), (a[s] = !0));
              t = !1 !== r && j(t);
            } while (t && (!r || r(t, e)) && t !== Object.prototype);
            return e;
          },
          kindOf: F,
          kindOfTest: K,
          endsWith: (t, e, r) => {
            (t = String(t)),
              (void 0 === r || r > t.length) && (r = t.length),
              (r -= e.length);
            const n = t.indexOf(e, r);
            return -1 !== n && n === r;
          },
          toArray: (t) => {
            if (!t) return null;
            if (q(t)) return t;
            let e = t.length;
            if (!Y(e)) return null;
            const r = new Array(e);
            for (; e-- > 0; ) r[e] = t[e];
            return r;
          },
          forEachEntry: (t, e) => {
            const r = (t && t[Symbol.iterator]).call(t);
            let n;
            for (; (n = r.next()) && !n.done; ) {
              const r = n.value;
              e.call(t, r[0], r[1]);
            }
          },
          matchAll: (t, e) => {
            let r;
            const n = [];
            for (; null !== (r = t.exec(e)); ) n.push(r);
            return n;
          },
          isHTMLForm: dt,
          hasOwnProperty: pt,
          hasOwnProp: pt,
          reduceDescriptors: gt,
          freezeMethods: (t) => {
            gt(t, (e, r) => {
              if (W(t) && -1 !== ["arguments", "caller", "callee"].indexOf(r))
                return !1;
              const n = t[r];
              W(n) &&
                ((e.enumerable = !1),
                "writable" in e
                  ? (e.writable = !1)
                  : e.set ||
                    (e.set = () => {
                      throw Error(
                        "Can not rewrite read-only method '" + r + "'",
                      );
                    }));
            });
          },
          toObjectSet: (t, e) => {
            const r = {},
              n = (t) => {
                t.forEach((t) => {
                  r[t] = !0;
                });
              };
            return q(t) ? n(t) : n(String(t).split(e)), r;
          },
          toCamelCase: (t) =>
            t
              .toLowerCase()
              .replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, r) {
                return e.toUpperCase() + r;
              }),
          noop: () => {},
          toFiniteNumber: (t, e) =>
            null != t && Number.isFinite((t = +t)) ? t : e,
          findKey: ut,
          global: ct,
          isContextDefined: ft,
          ALPHABET: wt,
          generateString: (t = 16, e = wt.ALPHA_DIGIT) => {
            let r = "";
            const { length: n } = e;
            for (; t--; ) r += e[(Math.random() * n) | 0];
            return r;
          },
          isSpecCompliantForm: function (t) {
            return !!(
              t &&
              W(t.append) &&
              "FormData" === t[Symbol.toStringTag] &&
              t[Symbol.iterator]
            );
          },
          toJSONObject: (t) => {
            const e = new Array(10),
              r = (t, n) => {
                if (X(t)) {
                  if (e.indexOf(t) >= 0) return;
                  if (!("toJSON" in t)) {
                    e[n] = t;
                    const i = q(t) ? [] : {};
                    return (
                      at(t, (t, e) => {
                        const o = r(t, n + 1);
                        !z(o) && (i[e] = o);
                      }),
                      (e[n] = void 0),
                      i
                    );
                  }
                }
                return t;
              };
            return r(t, 0);
          },
          isAsyncFn: vt,
          isThenable: (t) => t && (X(t) || W(t)) && W(t.then) && W(t.catch),
          setImmediate: _t,
          asap: At,
        };
      function kt(t, e, r, n, i) {
        Error.call(this),
          Error.captureStackTrace
            ? Error.captureStackTrace(this, this.constructor)
            : (this.stack = new Error().stack),
          (this.message = t),
          (this.name = "AxiosError"),
          e && (this.code = e),
          r && (this.config = r),
          n && (this.request = n),
          i &&
            ((this.response = i), (this.status = i.status ? i.status : null));
      }
      Tt.inherits(kt, Error, {
        toJSON: function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Tt.toJSONObject(this.config),
            code: this.code,
            status: this.status,
          };
        },
      });
      const Ot = kt.prototype,
        xt = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL",
      ].forEach((t) => {
        xt[t] = { value: t };
      }),
        Object.defineProperties(kt, xt),
        Object.defineProperty(Ot, "isAxiosError", { value: !0 }),
        (kt.from = (t, e, r, n, i, o) => {
          const s = Object.create(Ot);
          return (
            Tt.toFlatObject(
              t,
              s,
              function (t) {
                return t !== Error.prototype;
              },
              (t) => "isAxiosError" !== t,
            ),
            kt.call(s, t.message, e, r, n, i),
            (s.cause = t),
            (s.name = t.name),
            o && Object.assign(s, o),
            s
          );
        });
      const Pt = kt;
      var Bt = i(48287).Buffer;
      function Ct(t) {
        return Tt.isPlainObject(t) || Tt.isArray(t);
      }
      function Rt(t) {
        return Tt.endsWith(t, "[]") ? t.slice(0, -2) : t;
      }
      function Nt(t, e, r) {
        return t
          ? t
              .concat(e)
              .map(function (t, e) {
                return (t = Rt(t)), !r && e ? "[" + t + "]" : t;
              })
              .join(r ? "." : "")
          : e;
      }
      const Ut = Tt.toFlatObject(Tt, {}, null, function (t) {
        return /^is[A-Z]/.test(t);
      });
      const Dt = function (t, e, r) {
        if (!Tt.isObject(t)) throw new TypeError("target must be an object");
        e = e || new FormData();
        const n = (r = Tt.toFlatObject(
            r,
            { metaTokens: !0, dots: !1, indexes: !1 },
            !1,
            function (t, e) {
              return !Tt.isUndefined(e[t]);
            },
          )).metaTokens,
          i = r.visitor || c,
          o = r.dots,
          s = r.indexes,
          a =
            (r.Blob || ("undefined" != typeof Blob && Blob)) &&
            Tt.isSpecCompliantForm(e);
        if (!Tt.isFunction(i))
          throw new TypeError("visitor must be a function");
        function u(t) {
          if (null === t) return "";
          if (Tt.isDate(t)) return t.toISOString();
          if (!a && Tt.isBlob(t))
            throw new Pt("Blob is not supported. Use a Buffer instead.");
          return Tt.isArrayBuffer(t) || Tt.isTypedArray(t)
            ? a && "function" == typeof Blob
              ? new Blob([t])
              : Bt.from(t)
            : t;
        }
        function c(t, r, i) {
          let a = t;
          if (t && !i && "object" == typeof t)
            if (Tt.endsWith(r, "{}"))
              (r = n ? r : r.slice(0, -2)), (t = JSON.stringify(t));
            else if (
              (Tt.isArray(t) &&
                (function (t) {
                  return Tt.isArray(t) && !t.some(Ct);
                })(t)) ||
              ((Tt.isFileList(t) || Tt.endsWith(r, "[]")) &&
                (a = Tt.toArray(t)))
            )
              return (
                (r = Rt(r)),
                a.forEach(function (t, n) {
                  !Tt.isUndefined(t) &&
                    null !== t &&
                    e.append(
                      !0 === s ? Nt([r], n, o) : null === s ? r : r + "[]",
                      u(t),
                    );
                }),
                !1
              );
          return !!Ct(t) || (e.append(Nt(i, r, o), u(t)), !1);
        }
        const f = [],
          h = Object.assign(Ut, {
            defaultVisitor: c,
            convertValue: u,
            isVisitable: Ct,
          });
        if (!Tt.isObject(t)) throw new TypeError("data must be an object");
        return (
          (function t(r, n) {
            if (!Tt.isUndefined(r)) {
              if (-1 !== f.indexOf(r))
                throw Error("Circular reference detected in " + n.join("."));
              f.push(r),
                Tt.forEach(r, function (r, o) {
                  !0 ===
                    (!(Tt.isUndefined(r) || null === r) &&
                      i.call(e, r, Tt.isString(o) ? o.trim() : o, n, h)) &&
                    t(r, n ? n.concat(o) : [o]);
                }),
                f.pop();
            }
          })(t),
          e
        );
      };
      function Lt(t) {
        const e = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0",
        };
        return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
          return e[t];
        });
      }
      function jt(t, e) {
        (this._pairs = []), t && Dt(t, this, e);
      }
      const Ft = jt.prototype;
      (Ft.append = function (t, e) {
        this._pairs.push([t, e]);
      }),
        (Ft.toString = function (t) {
          const e = t
            ? function (e) {
                return t.call(this, e, Lt);
              }
            : Lt;
          return this._pairs
            .map(function (t) {
              return e(t[0]) + "=" + e(t[1]);
            }, "")
            .join("&");
        });
      const Ht = jt;
      function Kt(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      function Vt(t, e, r) {
        if (!e) return t;
        const n = (r && r.encode) || Kt,
          i = r && r.serialize;
        let o;
        if (
          ((o = i
            ? i(e, r)
            : Tt.isURLSearchParams(e)
              ? e.toString()
              : new Ht(e, r).toString(n)),
          o)
        ) {
          const e = t.indexOf("#");
          -1 !== e && (t = t.slice(0, e)),
            (t += (-1 === t.indexOf("?") ? "?" : "&") + o);
        }
        return t;
      }
      const qt = class {
          constructor() {
            this.handlers = [];
          }
          use(t, e, r) {
            return (
              this.handlers.push({
                fulfilled: t,
                rejected: e,
                synchronous: !!r && r.synchronous,
                runWhen: r ? r.runWhen : null,
              }),
              this.handlers.length - 1
            );
          }
          eject(t) {
            this.handlers[t] && (this.handlers[t] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(t) {
            Tt.forEach(this.handlers, function (e) {
              null !== e && t(e);
            });
          }
        },
        zt = {
          silentJSONParsing: !0,
          forcedJSONParsing: !0,
          clarifyTimeoutError: !1,
        },
        $t = {
          isBrowser: !0,
          classes: {
            URLSearchParams:
              "undefined" != typeof URLSearchParams ? URLSearchParams : Ht,
            FormData: "undefined" != typeof FormData ? FormData : null,
            Blob: "undefined" != typeof Blob ? Blob : null,
          },
          protocols: ["http", "https", "file", "blob", "url", "data"],
        },
        Gt = "undefined" != typeof window && "undefined" != typeof document,
        Wt = ("object" == typeof navigator && navigator) || void 0,
        Yt =
          Gt &&
          (!Wt ||
            ["ReactNative", "NativeScript", "NS"].indexOf(Wt.product) < 0),
        Xt =
          "undefined" != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          "function" == typeof self.importScripts,
        Zt = (Gt && window.location.href) || "http://localhost",
        Jt = { ...t, ...$t };
      const Qt = function (t) {
        function e(t, r, n, i) {
          let o = t[i++];
          if ("__proto__" === o) return !0;
          const s = Number.isFinite(+o),
            a = i >= t.length;
          if (((o = !o && Tt.isArray(n) ? n.length : o), a))
            return Tt.hasOwnProp(n, o) ? (n[o] = [n[o], r]) : (n[o] = r), !s;
          (n[o] && Tt.isObject(n[o])) || (n[o] = []);
          return (
            e(t, r, n[o], i) &&
              Tt.isArray(n[o]) &&
              (n[o] = (function (t) {
                const e = {},
                  r = Object.keys(t);
                let n;
                const i = r.length;
                let o;
                for (n = 0; n < i; n++) (o = r[n]), (e[o] = t[o]);
                return e;
              })(n[o])),
            !s
          );
        }
        if (Tt.isFormData(t) && Tt.isFunction(t.entries)) {
          const r = {};
          return (
            Tt.forEachEntry(t, (t, n) => {
              e(
                (function (t) {
                  return Tt.matchAll(/\w+|\[(\w*)]/g, t).map((t) =>
                    "[]" === t[0] ? "" : t[1] || t[0],
                  );
                })(t),
                n,
                r,
                0,
              );
            }),
            r
          );
        }
        return null;
      };
      const te = {
        transitional: zt,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [
          function (t, e) {
            const r = e.getContentType() || "",
              n = r.indexOf("application/json") > -1,
              i = Tt.isObject(t);
            i && Tt.isHTMLForm(t) && (t = new FormData(t));
            if (Tt.isFormData(t)) return n ? JSON.stringify(Qt(t)) : t;
            if (
              Tt.isArrayBuffer(t) ||
              Tt.isBuffer(t) ||
              Tt.isStream(t) ||
              Tt.isFile(t) ||
              Tt.isBlob(t) ||
              Tt.isReadableStream(t)
            )
              return t;
            if (Tt.isArrayBufferView(t)) return t.buffer;
            if (Tt.isURLSearchParams(t))
              return (
                e.setContentType(
                  "application/x-www-form-urlencoded;charset=utf-8",
                  !1,
                ),
                t.toString()
              );
            let o;
            if (i) {
              if (r.indexOf("application/x-www-form-urlencoded") > -1)
                return (function (t, e) {
                  return Dt(
                    t,
                    new Jt.classes.URLSearchParams(),
                    Object.assign(
                      {
                        visitor: function (t, e, r, n) {
                          return Jt.isNode && Tt.isBuffer(t)
                            ? (this.append(e, t.toString("base64")), !1)
                            : n.defaultVisitor.apply(this, arguments);
                        },
                      },
                      e,
                    ),
                  );
                })(t, this.formSerializer).toString();
              if (
                (o = Tt.isFileList(t)) ||
                r.indexOf("multipart/form-data") > -1
              ) {
                const e = this.env && this.env.FormData;
                return Dt(
                  o ? { "files[]": t } : t,
                  e && new e(),
                  this.formSerializer,
                );
              }
            }
            return i || n
              ? (e.setContentType("application/json", !1),
                (function (t, e, r) {
                  if (Tt.isString(t))
                    try {
                      return (e || JSON.parse)(t), Tt.trim(t);
                    } catch (t) {
                      if ("SyntaxError" !== t.name) throw t;
                    }
                  return (r || JSON.stringify)(t);
                })(t))
              : t;
          },
        ],
        transformResponse: [
          function (t) {
            const e = this.transitional || te.transitional,
              r = e && e.forcedJSONParsing,
              n = "json" === this.responseType;
            if (Tt.isResponse(t) || Tt.isReadableStream(t)) return t;
            if (t && Tt.isString(t) && ((r && !this.responseType) || n)) {
              const r = !(e && e.silentJSONParsing) && n;
              try {
                return JSON.parse(t);
              } catch (t) {
                if (r) {
                  if ("SyntaxError" === t.name)
                    throw Pt.from(
                      t,
                      Pt.ERR_BAD_RESPONSE,
                      this,
                      null,
                      this.response,
                    );
                  throw t;
                }
              }
            }
            return t;
          },
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: { FormData: Jt.classes.FormData, Blob: Jt.classes.Blob },
        validateStatus: function (t) {
          return t >= 200 && t < 300;
        },
        headers: {
          common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0,
          },
        },
      };
      Tt.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
        te.headers[t] = {};
      });
      const ee = te,
        re = Tt.toObjectSet([
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ]),
        ne = Symbol("internals");
      function ie(t) {
        return t && String(t).trim().toLowerCase();
      }
      function oe(t) {
        return !1 === t || null == t
          ? t
          : Tt.isArray(t)
            ? t.map(oe)
            : String(t);
      }
      function se(t, e, r, n, i) {
        return Tt.isFunction(n)
          ? n.call(this, e, r)
          : (i && (e = r),
            Tt.isString(e)
              ? Tt.isString(n)
                ? -1 !== e.indexOf(n)
                : Tt.isRegExp(n)
                  ? n.test(e)
                  : void 0
              : void 0);
      }
      class ae {
        constructor(t) {
          t && this.set(t);
        }
        set(t, e, r) {
          const n = this;
          function i(t, e, r) {
            const i = ie(e);
            if (!i) throw new Error("header name must be a non-empty string");
            const o = Tt.findKey(n, i);
            (!o ||
              void 0 === n[o] ||
              !0 === r ||
              (void 0 === r && !1 !== n[o])) &&
              (n[o || e] = oe(t));
          }
          const o = (t, e) => Tt.forEach(t, (t, r) => i(t, r, e));
          if (Tt.isPlainObject(t) || t instanceof this.constructor) o(t, e);
          else if (
            Tt.isString(t) &&
            (t = t.trim()) &&
            !((t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()))(t)
          )
            o(
              ((t) => {
                const e = {};
                let r, n, i;
                return (
                  t &&
                    t.split("\n").forEach(function (t) {
                      (i = t.indexOf(":")),
                        (r = t.substring(0, i).trim().toLowerCase()),
                        (n = t.substring(i + 1).trim()),
                        !r ||
                          (e[r] && re[r]) ||
                          ("set-cookie" === r
                            ? e[r]
                              ? e[r].push(n)
                              : (e[r] = [n])
                            : (e[r] = e[r] ? e[r] + ", " + n : n));
                    }),
                  e
                );
              })(t),
              e,
            );
          else if (Tt.isHeaders(t))
            for (const [e, n] of t.entries()) i(n, e, r);
          else null != t && i(e, t, r);
          return this;
        }
        get(t, e) {
          if ((t = ie(t))) {
            const r = Tt.findKey(this, t);
            if (r) {
              const t = this[r];
              if (!e) return t;
              if (!0 === e)
                return (function (t) {
                  const e = Object.create(null),
                    r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let n;
                  for (; (n = r.exec(t)); ) e[n[1]] = n[2];
                  return e;
                })(t);
              if (Tt.isFunction(e)) return e.call(this, t, r);
              if (Tt.isRegExp(e)) return e.exec(t);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(t, e) {
          if ((t = ie(t))) {
            const r = Tt.findKey(this, t);
            return !(!r || void 0 === this[r] || (e && !se(0, this[r], r, e)));
          }
          return !1;
        }
        delete(t, e) {
          const r = this;
          let n = !1;
          function i(t) {
            if ((t = ie(t))) {
              const i = Tt.findKey(r, t);
              !i || (e && !se(0, r[i], i, e)) || (delete r[i], (n = !0));
            }
          }
          return Tt.isArray(t) ? t.forEach(i) : i(t), n;
        }
        clear(t) {
          const e = Object.keys(this);
          let r = e.length,
            n = !1;
          for (; r--; ) {
            const i = e[r];
            (t && !se(0, this[i], i, t, !0)) || (delete this[i], (n = !0));
          }
          return n;
        }
        normalize(t) {
          const e = this,
            r = {};
          return (
            Tt.forEach(this, (n, i) => {
              const o = Tt.findKey(r, i);
              if (o) return (e[o] = oe(n)), void delete e[i];
              const s = t
                ? (function (t) {
                    return t
                      .trim()
                      .toLowerCase()
                      .replace(
                        /([a-z\d])(\w*)/g,
                        (t, e, r) => e.toUpperCase() + r,
                      );
                  })(i)
                : String(i).trim();
              s !== i && delete e[i], (e[s] = oe(n)), (r[s] = !0);
            }),
            this
          );
        }
        concat(...t) {
          return this.constructor.concat(this, ...t);
        }
        toJSON(t) {
          const e = Object.create(null);
          return (
            Tt.forEach(this, (r, n) => {
              null != r &&
                !1 !== r &&
                (e[n] = t && Tt.isArray(r) ? r.join(", ") : r);
            }),
            e
          );
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON())
            .map(([t, e]) => t + ": " + e)
            .join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(t) {
          return t instanceof this ? t : new this(t);
        }
        static concat(t, ...e) {
          const r = new this(t);
          return e.forEach((t) => r.set(t)), r;
        }
        static accessor(t) {
          const e = (this[ne] = this[ne] = { accessors: {} }).accessors,
            r = this.prototype;
          function n(t) {
            const n = ie(t);
            e[n] ||
              (!(function (t, e) {
                const r = Tt.toCamelCase(" " + e);
                ["get", "set", "has"].forEach((n) => {
                  Object.defineProperty(t, n + r, {
                    value: function (t, r, i) {
                      return this[n].call(this, e, t, r, i);
                    },
                    configurable: !0,
                  });
                });
              })(r, t),
              (e[n] = !0));
          }
          return Tt.isArray(t) ? t.forEach(n) : n(t), this;
        }
      }
      ae.accessor([
        "Content-Type",
        "Content-Length",
        "Accept",
        "Accept-Encoding",
        "User-Agent",
        "Authorization",
      ]),
        Tt.reduceDescriptors(ae.prototype, ({ value: t }, e) => {
          let r = e[0].toUpperCase() + e.slice(1);
          return {
            get: () => t,
            set(t) {
              this[r] = t;
            },
          };
        }),
        Tt.freezeMethods(ae);
      const ue = ae;
      function ce(t, e) {
        const r = this || ee,
          n = e || r,
          i = ue.from(n.headers);
        let o = n.data;
        return (
          Tt.forEach(t, function (t) {
            o = t.call(r, o, i.normalize(), e ? e.status : void 0);
          }),
          i.normalize(),
          o
        );
      }
      function fe(t) {
        return !(!t || !t.__CANCEL__);
      }
      function he(t, e, r) {
        Pt.call(this, null == t ? "canceled" : t, Pt.ERR_CANCELED, e, r),
          (this.name = "CanceledError");
      }
      Tt.inherits(he, Pt, { __CANCEL__: !0 });
      const le = he;
      function de(t, e, r) {
        const n = r.config.validateStatus;
        r.status && n && !n(r.status)
          ? e(
              new Pt(
                "Request failed with status code " + r.status,
                [Pt.ERR_BAD_REQUEST, Pt.ERR_BAD_RESPONSE][
                  Math.floor(r.status / 100) - 4
                ],
                r.config,
                r.request,
                r,
              ),
            )
          : t(r);
      }
      const pe = function (t, e) {
        t = t || 10;
        const r = new Array(t),
          n = new Array(t);
        let i,
          o = 0,
          s = 0;
        return (
          (e = void 0 !== e ? e : 1e3),
          function (a) {
            const u = Date.now(),
              c = n[s];
            i || (i = u), (r[o] = a), (n[o] = u);
            let f = s,
              h = 0;
            for (; f !== o; ) (h += r[f++]), (f %= t);
            if (((o = (o + 1) % t), o === s && (s = (s + 1) % t), u - i < e))
              return;
            const l = c && u - c;
            return l ? Math.round((1e3 * h) / l) : void 0;
          }
        );
      };
      const ye = function (t, e) {
          let r,
            n,
            i = 0,
            o = 1e3 / e;
          const s = (e, o = Date.now()) => {
            (i = o),
              (r = null),
              n && (clearTimeout(n), (n = null)),
              t.apply(null, e);
          };
          return [
            (...t) => {
              const e = Date.now(),
                a = e - i;
              a >= o
                ? s(t, e)
                : ((r = t),
                  n ||
                    (n = setTimeout(() => {
                      (n = null), s(r);
                    }, o - a)));
            },
            () => r && s(r),
          ];
        },
        ge = (t, e, r = 3) => {
          let n = 0;
          const i = pe(50, 250);
          return ye((r) => {
            const o = r.loaded,
              s = r.lengthComputable ? r.total : void 0,
              a = o - n,
              u = i(a);
            n = o;
            t({
              loaded: o,
              total: s,
              progress: s ? o / s : void 0,
              bytes: a,
              rate: u || void 0,
              estimated: u && s && o <= s ? (s - o) / u : void 0,
              event: r,
              lengthComputable: null != s,
              [e ? "download" : "upload"]: !0,
            });
          }, r);
        },
        me = (t, e) => {
          const r = null != t;
          return [
            (n) => e[0]({ lengthComputable: r, total: t, loaded: n }),
            e[1],
          ];
        },
        be =
          (t) =>
          (...e) =>
            Tt.asap(() => t(...e)),
        we = Jt.hasStandardBrowserEnv
          ? (function () {
              const t =
                  Jt.navigator &&
                  /(msie|trident)/i.test(Jt.navigator.userAgent),
                e = document.createElement("a");
              let r;
              function n(r) {
                let n = r;
                return (
                  t && (e.setAttribute("href", n), (n = e.href)),
                  e.setAttribute("href", n),
                  {
                    href: e.href,
                    protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                    host: e.host,
                    search: e.search ? e.search.replace(/^\?/, "") : "",
                    hash: e.hash ? e.hash.replace(/^#/, "") : "",
                    hostname: e.hostname,
                    port: e.port,
                    pathname:
                      "/" === e.pathname.charAt(0)
                        ? e.pathname
                        : "/" + e.pathname,
                  }
                );
              }
              return (
                (r = n(window.location.href)),
                function (t) {
                  const e = Tt.isString(t) ? n(t) : t;
                  return e.protocol === r.protocol && e.host === r.host;
                }
              );
            })()
          : function () {
              return !0;
            },
        ve = Jt.hasStandardBrowserEnv
          ? {
              write(t, e, r, n, i, o) {
                const s = [t + "=" + encodeURIComponent(e)];
                Tt.isNumber(r) &&
                  s.push("expires=" + new Date(r).toGMTString()),
                  Tt.isString(n) && s.push("path=" + n),
                  Tt.isString(i) && s.push("domain=" + i),
                  !0 === o && s.push("secure"),
                  (document.cookie = s.join("; "));
              },
              read(t) {
                const e = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"),
                );
                return e ? decodeURIComponent(e[3]) : null;
              },
              remove(t) {
                this.write(t, "", Date.now() - 864e5);
              },
            }
          : { write() {}, read: () => null, remove() {} };
      function _e(t, e) {
        return t &&
          !(function (t) {
            return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
          })(e)
          ? (function (t, e) {
              return e
                ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "")
                : t;
            })(t, e)
          : e;
      }
      const Ee = (t) => (t instanceof ue ? { ...t } : t);
      function Se(t, e) {
        e = e || {};
        const r = {};
        function n(t, e, r) {
          return Tt.isPlainObject(t) && Tt.isPlainObject(e)
            ? Tt.merge.call({ caseless: r }, t, e)
            : Tt.isPlainObject(e)
              ? Tt.merge({}, e)
              : Tt.isArray(e)
                ? e.slice()
                : e;
        }
        function i(t, e, r) {
          return Tt.isUndefined(e)
            ? Tt.isUndefined(t)
              ? void 0
              : n(void 0, t, r)
            : n(t, e, r);
        }
        function o(t, e) {
          if (!Tt.isUndefined(e)) return n(void 0, e);
        }
        function s(t, e) {
          return Tt.isUndefined(e)
            ? Tt.isUndefined(t)
              ? void 0
              : n(void 0, t)
            : n(void 0, e);
        }
        function a(r, i, o) {
          return o in e ? n(r, i) : o in t ? n(void 0, r) : void 0;
        }
        const u = {
          url: o,
          method: o,
          data: o,
          baseURL: s,
          transformRequest: s,
          transformResponse: s,
          paramsSerializer: s,
          timeout: s,
          timeoutMessage: s,
          withCredentials: s,
          withXSRFToken: s,
          adapter: s,
          responseType: s,
          xsrfCookieName: s,
          xsrfHeaderName: s,
          onUploadProgress: s,
          onDownloadProgress: s,
          decompress: s,
          maxContentLength: s,
          maxBodyLength: s,
          beforeRedirect: s,
          transport: s,
          httpAgent: s,
          httpsAgent: s,
          cancelToken: s,
          socketPath: s,
          responseEncoding: s,
          validateStatus: a,
          headers: (t, e) => i(Ee(t), Ee(e), !0),
        };
        return (
          Tt.forEach(Object.keys(Object.assign({}, t, e)), function (n) {
            const o = u[n] || i,
              s = o(t[n], e[n], n);
            (Tt.isUndefined(s) && o !== a) || (r[n] = s);
          }),
          r
        );
      }
      const Ie = (t) => {
          const e = Se({}, t);
          let r,
            {
              data: n,
              withXSRFToken: i,
              xsrfHeaderName: o,
              xsrfCookieName: s,
              headers: a,
              auth: u,
            } = e;
          if (
            ((e.headers = a = ue.from(a)),
            (e.url = Vt(_e(e.baseURL, e.url), t.params, t.paramsSerializer)),
            u &&
              a.set(
                "Authorization",
                "Basic " +
                  btoa(
                    (u.username || "") +
                      ":" +
                      (u.password
                        ? unescape(encodeURIComponent(u.password))
                        : ""),
                  ),
              ),
            Tt.isFormData(n))
          )
            if (Jt.hasStandardBrowserEnv || Jt.hasStandardBrowserWebWorkerEnv)
              a.setContentType(void 0);
            else if (!1 !== (r = a.getContentType())) {
              const [t, ...e] = r
                ? r
                    .split(";")
                    .map((t) => t.trim())
                    .filter(Boolean)
                : [];
              a.setContentType([t || "multipart/form-data", ...e].join("; "));
            }
          if (
            Jt.hasStandardBrowserEnv &&
            (i && Tt.isFunction(i) && (i = i(e)), i || (!1 !== i && we(e.url)))
          ) {
            const t = o && s && ve.read(s);
            t && a.set(o, t);
          }
          return e;
        },
        Me =
          "undefined" != typeof XMLHttpRequest &&
          function (t) {
            return new Promise(function (e, r) {
              const n = Ie(t);
              let i = n.data;
              const o = ue.from(n.headers).normalize();
              let s,
                a,
                u,
                c,
                f,
                {
                  responseType: h,
                  onUploadProgress: l,
                  onDownloadProgress: d,
                } = n;
              function p() {
                c && c(),
                  f && f(),
                  n.cancelToken && n.cancelToken.unsubscribe(s),
                  n.signal && n.signal.removeEventListener("abort", s);
              }
              let y = new XMLHttpRequest();
              function g() {
                if (!y) return;
                const n = ue.from(
                  "getAllResponseHeaders" in y && y.getAllResponseHeaders(),
                );
                de(
                  function (t) {
                    e(t), p();
                  },
                  function (t) {
                    r(t), p();
                  },
                  {
                    data:
                      h && "text" !== h && "json" !== h
                        ? y.response
                        : y.responseText,
                    status: y.status,
                    statusText: y.statusText,
                    headers: n,
                    config: t,
                    request: y,
                  },
                ),
                  (y = null);
              }
              y.open(n.method.toUpperCase(), n.url, !0),
                (y.timeout = n.timeout),
                "onloadend" in y
                  ? (y.onloadend = g)
                  : (y.onreadystatechange = function () {
                      y &&
                        4 === y.readyState &&
                        (0 !== y.status ||
                          (y.responseURL &&
                            0 === y.responseURL.indexOf("file:"))) &&
                        setTimeout(g);
                    }),
                (y.onabort = function () {
                  y &&
                    (r(new Pt("Request aborted", Pt.ECONNABORTED, t, y)),
                    (y = null));
                }),
                (y.onerror = function () {
                  r(new Pt("Network Error", Pt.ERR_NETWORK, t, y)), (y = null);
                }),
                (y.ontimeout = function () {
                  let e = n.timeout
                    ? "timeout of " + n.timeout + "ms exceeded"
                    : "timeout exceeded";
                  const i = n.transitional || zt;
                  n.timeoutErrorMessage && (e = n.timeoutErrorMessage),
                    r(
                      new Pt(
                        e,
                        i.clarifyTimeoutError ? Pt.ETIMEDOUT : Pt.ECONNABORTED,
                        t,
                        y,
                      ),
                    ),
                    (y = null);
                }),
                void 0 === i && o.setContentType(null),
                "setRequestHeader" in y &&
                  Tt.forEach(o.toJSON(), function (t, e) {
                    y.setRequestHeader(e, t);
                  }),
                Tt.isUndefined(n.withCredentials) ||
                  (y.withCredentials = !!n.withCredentials),
                h && "json" !== h && (y.responseType = n.responseType),
                d && (([u, f] = ge(d, !0)), y.addEventListener("progress", u)),
                l &&
                  y.upload &&
                  (([a, c] = ge(l)),
                  y.upload.addEventListener("progress", a),
                  y.upload.addEventListener("loadend", c)),
                (n.cancelToken || n.signal) &&
                  ((s = (e) => {
                    y &&
                      (r(!e || e.type ? new le(null, t, y) : e),
                      y.abort(),
                      (y = null));
                  }),
                  n.cancelToken && n.cancelToken.subscribe(s),
                  n.signal &&
                    (n.signal.aborted
                      ? s()
                      : n.signal.addEventListener("abort", s)));
              const m = (function (t) {
                const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                return (e && e[1]) || "";
              })(n.url);
              m && -1 === Jt.protocols.indexOf(m)
                ? r(
                    new Pt(
                      "Unsupported protocol " + m + ":",
                      Pt.ERR_BAD_REQUEST,
                      t,
                    ),
                  )
                : y.send(i || null);
            });
          },
        Ae = (t, e) => {
          const { length: r } = (t = t ? t.filter(Boolean) : []);
          if (e || r) {
            let r,
              n = new AbortController();
            const i = function (t) {
              if (!r) {
                (r = !0), s();
                const e = t instanceof Error ? t : this.reason;
                n.abort(
                  e instanceof Pt
                    ? e
                    : new le(e instanceof Error ? e.message : e),
                );
              }
            };
            let o =
              e &&
              setTimeout(() => {
                (o = null),
                  i(new Pt(`timeout ${e} of ms exceeded`, Pt.ETIMEDOUT));
              }, e);
            const s = () => {
              t &&
                (o && clearTimeout(o),
                (o = null),
                t.forEach((t) => {
                  t.unsubscribe
                    ? t.unsubscribe(i)
                    : t.removeEventListener("abort", i);
                }),
                (t = null));
            };
            t.forEach((t) => t.addEventListener("abort", i));
            const { signal: a } = n;
            return (a.unsubscribe = () => Tt.asap(s)), a;
          }
        },
        Te = function* (t, e) {
          let r = t.byteLength;
          if (!e || r < e) return void (yield t);
          let n,
            i = 0;
          for (; i < r; ) (n = i + e), yield t.slice(i, n), (i = n);
        },
        ke = async function* (t) {
          if (t[Symbol.asyncIterator]) return void (yield* t);
          const e = t.getReader();
          try {
            for (;;) {
              const { done: t, value: r } = await e.read();
              if (t) break;
              yield r;
            }
          } finally {
            await e.cancel();
          }
        },
        Oe = (t, e, r, n) => {
          const i = (async function* (t, e) {
            for await (const r of ke(t)) yield* Te(r, e);
          })(t, e);
          let o,
            s = 0,
            a = (t) => {
              o || ((o = !0), n && n(t));
            };
          return new ReadableStream(
            {
              async pull(t) {
                try {
                  const { done: e, value: n } = await i.next();
                  if (e) return a(), void t.close();
                  let o = n.byteLength;
                  if (r) {
                    let t = (s += o);
                    r(t);
                  }
                  t.enqueue(new Uint8Array(n));
                } catch (t) {
                  throw (a(t), t);
                }
              },
              cancel: (t) => (a(t), i.return()),
            },
            { highWaterMark: 2 },
          );
        },
        xe =
          "function" == typeof fetch &&
          "function" == typeof Request &&
          "function" == typeof Response,
        Pe = xe && "function" == typeof ReadableStream,
        Be =
          xe &&
          ("function" == typeof TextEncoder
            ? ((Ce = new TextEncoder()), (t) => Ce.encode(t))
            : async (t) => new Uint8Array(await new Response(t).arrayBuffer()));
      var Ce;
      const Re = (t, ...e) => {
          try {
            return !!t(...e);
          } catch (t) {
            return !1;
          }
        },
        Ne =
          Pe &&
          Re(() => {
            let t = !1;
            const e = new Request(Jt.origin, {
              body: new ReadableStream(),
              method: "POST",
              get duplex() {
                return (t = !0), "half";
              },
            }).headers.has("Content-Type");
            return t && !e;
          }),
        Ue = Pe && Re(() => Tt.isReadableStream(new Response("").body)),
        De = { stream: Ue && ((t) => t.body) };
      var Le;
      xe &&
        ((Le = new Response()),
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
          !De[t] &&
            (De[t] = Tt.isFunction(Le[t])
              ? (e) => e[t]()
              : (e, r) => {
                  throw new Pt(
                    `Response type '${t}' is not supported`,
                    Pt.ERR_NOT_SUPPORT,
                    r,
                  );
                });
        }));
      const je = async (t, e) => {
          const r = Tt.toFiniteNumber(t.getContentLength());
          return null == r
            ? (async (t) => {
                if (null == t) return 0;
                if (Tt.isBlob(t)) return t.size;
                if (Tt.isSpecCompliantForm(t)) {
                  const e = new Request(Jt.origin, { method: "POST", body: t });
                  return (await e.arrayBuffer()).byteLength;
                }
                return Tt.isArrayBufferView(t) || Tt.isArrayBuffer(t)
                  ? t.byteLength
                  : (Tt.isURLSearchParams(t) && (t += ""),
                    Tt.isString(t) ? (await Be(t)).byteLength : void 0);
              })(e)
            : r;
        },
        Fe =
          xe &&
          (async (t) => {
            let {
              url: e,
              method: r,
              data: n,
              signal: i,
              cancelToken: o,
              timeout: s,
              onDownloadProgress: a,
              onUploadProgress: u,
              responseType: c,
              headers: f,
              withCredentials: h = "same-origin",
              fetchOptions: l,
            } = Ie(t);
            c = c ? (c + "").toLowerCase() : "text";
            let d,
              p = Ae([i, o && o.toAbortSignal()], s);
            const y =
              p &&
              p.unsubscribe &&
              (() => {
                p.unsubscribe();
              });
            let g;
            try {
              if (
                u &&
                Ne &&
                "get" !== r &&
                "head" !== r &&
                0 !== (g = await je(f, n))
              ) {
                let t,
                  r = new Request(e, {
                    method: "POST",
                    body: n,
                    duplex: "half",
                  });
                if (
                  (Tt.isFormData(n) &&
                    (t = r.headers.get("content-type")) &&
                    f.setContentType(t),
                  r.body)
                ) {
                  const [t, e] = me(g, ge(be(u)));
                  n = Oe(r.body, 65536, t, e);
                }
              }
              Tt.isString(h) || (h = h ? "include" : "omit");
              const i = "credentials" in Request.prototype;
              d = new Request(e, {
                ...l,
                signal: p,
                method: r.toUpperCase(),
                headers: f.normalize().toJSON(),
                body: n,
                duplex: "half",
                credentials: i ? h : void 0,
              });
              let o = await fetch(d);
              const s = Ue && ("stream" === c || "response" === c);
              if (Ue && (a || (s && y))) {
                const t = {};
                ["status", "statusText", "headers"].forEach((e) => {
                  t[e] = o[e];
                });
                const e = Tt.toFiniteNumber(o.headers.get("content-length")),
                  [r, n] = (a && me(e, ge(be(a), !0))) || [];
                o = new Response(
                  Oe(o.body, 65536, r, () => {
                    n && n(), y && y();
                  }),
                  t,
                );
              }
              c = c || "text";
              let m = await De[Tt.findKey(De, c) || "text"](o, t);
              return (
                !s && y && y(),
                await new Promise((e, r) => {
                  de(e, r, {
                    data: m,
                    headers: ue.from(o.headers),
                    status: o.status,
                    statusText: o.statusText,
                    config: t,
                    request: d,
                  });
                })
              );
            } catch (e) {
              if (
                (y && y(),
                e && "TypeError" === e.name && /fetch/i.test(e.message))
              )
                throw Object.assign(
                  new Pt("Network Error", Pt.ERR_NETWORK, t, d),
                  { cause: e.cause || e },
                );
              throw Pt.from(e, e && e.code, t, d);
            }
          }),
        He = { http: null, xhr: Me, fetch: Fe };
      Tt.forEach(He, (t, e) => {
        if (t) {
          try {
            Object.defineProperty(t, "name", { value: e });
          } catch (t) {}
          Object.defineProperty(t, "adapterName", { value: e });
        }
      });
      const Ke = (t) => `- ${t}`,
        Ve = (t) => Tt.isFunction(t) || null === t || !1 === t,
        qe = (t) => {
          t = Tt.isArray(t) ? t : [t];
          const { length: e } = t;
          let r, n;
          const i = {};
          for (let o = 0; o < e; o++) {
            let e;
            if (
              ((r = t[o]),
              (n = r),
              !Ve(r) && ((n = He[(e = String(r)).toLowerCase()]), void 0 === n))
            )
              throw new Pt(`Unknown adapter '${e}'`);
            if (n) break;
            i[e || "#" + o] = n;
          }
          if (!n) {
            const t = Object.entries(i).map(
              ([t, e]) =>
                `adapter ${t} ` +
                (!1 === e
                  ? "is not supported by the environment"
                  : "is not available in the build"),
            );
            let r = e
              ? t.length > 1
                ? "since :\n" + t.map(Ke).join("\n")
                : " " + Ke(t[0])
              : "as no adapter specified";
            throw new Pt(
              "There is no suitable adapter to dispatch the request " + r,
              "ERR_NOT_SUPPORT",
            );
          }
          return n;
        };
      function ze(t) {
        if (
          (t.cancelToken && t.cancelToken.throwIfRequested(),
          t.signal && t.signal.aborted)
        )
          throw new le(null, t);
      }
      function $e(t) {
        ze(t),
          (t.headers = ue.from(t.headers)),
          (t.data = ce.call(t, t.transformRequest)),
          -1 !== ["post", "put", "patch"].indexOf(t.method) &&
            t.headers.setContentType("application/x-www-form-urlencoded", !1);
        return qe(t.adapter || ee.adapter)(t).then(
          function (e) {
            return (
              ze(t),
              (e.data = ce.call(t, t.transformResponse, e)),
              (e.headers = ue.from(e.headers)),
              e
            );
          },
          function (e) {
            return (
              fe(e) ||
                (ze(t),
                e &&
                  e.response &&
                  ((e.response.data = ce.call(
                    t,
                    t.transformResponse,
                    e.response,
                  )),
                  (e.response.headers = ue.from(e.response.headers)))),
              Promise.reject(e)
            );
          },
        );
      }
      const Ge = "1.7.7",
        We = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        (t, e) => {
          We[t] = function (r) {
            return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
          };
        },
      );
      const Ye = {};
      We.transitional = function (t, e, r) {
        function n(t, e) {
          return (
            "[Axios v1.7.7] Transitional option '" +
            t +
            "'" +
            e +
            (r ? ". " + r : "")
          );
        }
        return (r, i, o) => {
          if (!1 === t)
            throw new Pt(
              n(i, " has been removed" + (e ? " in " + e : "")),
              Pt.ERR_DEPRECATED,
            );
          return (
            e &&
              !Ye[i] &&
              ((Ye[i] = !0),
              console.warn(
                n(
                  i,
                  " has been deprecated since v" +
                    e +
                    " and will be removed in the near future",
                ),
              )),
            !t || t(r, i, o)
          );
        };
      };
      const Xe = {
          assertOptions: function (t, e, r) {
            if ("object" != typeof t)
              throw new Pt(
                "options must be an object",
                Pt.ERR_BAD_OPTION_VALUE,
              );
            const n = Object.keys(t);
            let i = n.length;
            for (; i-- > 0; ) {
              const o = n[i],
                s = e[o];
              if (s) {
                const e = t[o],
                  r = void 0 === e || s(e, o, t);
                if (!0 !== r)
                  throw new Pt(
                    "option " + o + " must be " + r,
                    Pt.ERR_BAD_OPTION_VALUE,
                  );
              } else if (!0 !== r)
                throw new Pt("Unknown option " + o, Pt.ERR_BAD_OPTION);
            }
          },
          validators: We,
        },
        Ze = Xe.validators;
      class Je {
        constructor(t) {
          (this.defaults = t),
            (this.interceptors = { request: new qt(), response: new qt() });
        }
        async request(t, e) {
          try {
            return await this._request(t, e);
          } catch (t) {
            if (t instanceof Error) {
              let e;
              Error.captureStackTrace
                ? Error.captureStackTrace((e = {}))
                : (e = new Error());
              const r = e.stack ? e.stack.replace(/^.+\n/, "") : "";
              try {
                t.stack
                  ? r &&
                    !String(t.stack).endsWith(r.replace(/^.+\n.+\n/, "")) &&
                    (t.stack += "\n" + r)
                  : (t.stack = r);
              } catch (t) {}
            }
            throw t;
          }
        }
        _request(t, e) {
          "string" == typeof t ? ((e = e || {}).url = t) : (e = t || {}),
            (e = Se(this.defaults, e));
          const { transitional: r, paramsSerializer: n, headers: i } = e;
          void 0 !== r &&
            Xe.assertOptions(
              r,
              {
                silentJSONParsing: Ze.transitional(Ze.boolean),
                forcedJSONParsing: Ze.transitional(Ze.boolean),
                clarifyTimeoutError: Ze.transitional(Ze.boolean),
              },
              !1,
            ),
            null != n &&
              (Tt.isFunction(n)
                ? (e.paramsSerializer = { serialize: n })
                : Xe.assertOptions(
                    n,
                    { encode: Ze.function, serialize: Ze.function },
                    !0,
                  )),
            (e.method = (
              e.method ||
              this.defaults.method ||
              "get"
            ).toLowerCase());
          let o = i && Tt.merge(i.common, i[e.method]);
          i &&
            Tt.forEach(
              ["delete", "get", "head", "post", "put", "patch", "common"],
              (t) => {
                delete i[t];
              },
            ),
            (e.headers = ue.concat(o, i));
          const s = [];
          let a = !0;
          this.interceptors.request.forEach(function (t) {
            ("function" == typeof t.runWhen && !1 === t.runWhen(e)) ||
              ((a = a && t.synchronous), s.unshift(t.fulfilled, t.rejected));
          });
          const u = [];
          let c;
          this.interceptors.response.forEach(function (t) {
            u.push(t.fulfilled, t.rejected);
          });
          let f,
            h = 0;
          if (!a) {
            const t = [$e.bind(this), void 0];
            for (
              t.unshift.apply(t, s),
                t.push.apply(t, u),
                f = t.length,
                c = Promise.resolve(e);
              h < f;

            )
              c = c.then(t[h++], t[h++]);
            return c;
          }
          f = s.length;
          let l = e;
          for (h = 0; h < f; ) {
            const t = s[h++],
              e = s[h++];
            try {
              l = t(l);
            } catch (t) {
              e.call(this, t);
              break;
            }
          }
          try {
            c = $e.call(this, l);
          } catch (t) {
            return Promise.reject(t);
          }
          for (h = 0, f = u.length; h < f; ) c = c.then(u[h++], u[h++]);
          return c;
        }
        getUri(t) {
          return Vt(
            _e((t = Se(this.defaults, t)).baseURL, t.url),
            t.params,
            t.paramsSerializer,
          );
        }
      }
      Tt.forEach(["delete", "get", "head", "options"], function (t) {
        Je.prototype[t] = function (e, r) {
          return this.request(
            Se(r || {}, { method: t, url: e, data: (r || {}).data }),
          );
        };
      }),
        Tt.forEach(["post", "put", "patch"], function (t) {
          function e(e) {
            return function (r, n, i) {
              return this.request(
                Se(i || {}, {
                  method: t,
                  headers: e ? { "Content-Type": "multipart/form-data" } : {},
                  url: r,
                  data: n,
                }),
              );
            };
          }
          (Je.prototype[t] = e()), (Je.prototype[t + "Form"] = e(!0));
        });
      const Qe = Je;
      class tr {
        constructor(t) {
          if ("function" != typeof t)
            throw new TypeError("executor must be a function.");
          let e;
          this.promise = new Promise(function (t) {
            e = t;
          });
          const r = this;
          this.promise.then((t) => {
            if (!r._listeners) return;
            let e = r._listeners.length;
            for (; e-- > 0; ) r._listeners[e](t);
            r._listeners = null;
          }),
            (this.promise.then = (t) => {
              let e;
              const n = new Promise((t) => {
                r.subscribe(t), (e = t);
              }).then(t);
              return (
                (n.cancel = function () {
                  r.unsubscribe(e);
                }),
                n
              );
            }),
            t(function (t, n, i) {
              r.reason || ((r.reason = new le(t, n, i)), e(r.reason));
            });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(t) {
          this.reason
            ? t(this.reason)
            : this._listeners
              ? this._listeners.push(t)
              : (this._listeners = [t]);
        }
        unsubscribe(t) {
          if (!this._listeners) return;
          const e = this._listeners.indexOf(t);
          -1 !== e && this._listeners.splice(e, 1);
        }
        toAbortSignal() {
          const t = new AbortController(),
            e = (e) => {
              t.abort(e);
            };
          return (
            this.subscribe(e),
            (t.signal.unsubscribe = () => this.unsubscribe(e)),
            t.signal
          );
        }
        static source() {
          let t;
          const e = new tr(function (e) {
            t = e;
          });
          return { token: e, cancel: t };
        }
      }
      const er = tr;
      const rr = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511,
      };
      Object.entries(rr).forEach(([t, e]) => {
        rr[e] = t;
      });
      const nr = rr;
      const ir = (function t(e) {
        const r = new Qe(e),
          n = U(Qe.prototype.request, r);
        return (
          Tt.extend(n, Qe.prototype, r, { allOwnKeys: !0 }),
          Tt.extend(n, r, null, { allOwnKeys: !0 }),
          (n.create = function (r) {
            return t(Se(e, r));
          }),
          n
        );
      })(ee);
      (ir.Axios = Qe),
        (ir.CanceledError = le),
        (ir.CancelToken = er),
        (ir.isCancel = fe),
        (ir.VERSION = Ge),
        (ir.toFormData = Dt),
        (ir.AxiosError = Pt),
        (ir.Cancel = ir.CanceledError),
        (ir.all = function (t) {
          return Promise.all(t);
        }),
        (ir.spread = function (t) {
          return function (e) {
            return t.apply(null, e);
          };
        }),
        (ir.isAxiosError = function (t) {
          return Tt.isObject(t) && !0 === t.isAxiosError;
        }),
        (ir.mergeConfig = Se),
        (ir.AxiosHeaders = ue),
        (ir.formToJSON = (t) => Qt(Tt.isHTMLForm(t) ? new FormData(t) : t)),
        (ir.getAdapter = qe),
        (ir.HttpStatusCode = nr),
        (ir.default = ir);
      const or = ir;
      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
      var sr = function () {
          return (
            (sr =
              Object.assign ||
              function (t) {
                for (var e, r = 1, n = arguments.length; r < n; r++)
                  for (var i in (e = arguments[r]))
                    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                return t;
              }),
            sr.apply(this, arguments)
          );
        },
        ar = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      (() => {
        const t = Array(256).fill(-1);
        for (let e = 0; e < 58; ++e) t[ar.charCodeAt(e)] = e;
      })();
      var ur,
        cr,
        fr,
        hr = (t) => {
          if (!t || "string" != typeof t)
            throw new Error(`Expected base58 string but got “${t}”`);
          if (t.match(/[IOl0]/gmu))
            throw new Error(
              `Invalid base58 character “${t.match(/[IOl0]/gmu)}”`,
            );
          const e = t.match(/^1+/gmu),
            r = e ? e[0].length : 0,
            n = ((t.length - r) * (Math.log(58) / Math.log(256)) + 1) >>> 0;
          return new Uint8Array([
            ...new Uint8Array(r),
            ...t
              .match(/.{1}/gmu)
              .map((t) => ar.indexOf(t))
              .reduce(
                (t, e) =>
                  t.map((t) => {
                    const r = 58 * t + e;
                    return (e = r >> 8), r;
                  }),
                new Uint8Array(n),
              )
              .reverse()
              .filter(((i = !1), (t) => (i = i || t))),
          ]);
          var i;
        },
        lr =
          ((ur = function (t, e) {
            Object.defineProperty(e, "__esModule", { value: !0 }),
              (e.bech32m = e.bech32 = void 0);
            const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
              n = {};
            for (let t = 0; t < 32; t++) {
              const e = r.charAt(t);
              n[e] = t;
            }
            function i(t) {
              const e = t >> 25;
              return (
                ((33554431 & t) << 5) ^
                (996825010 & -(1 & e)) ^
                (642813549 & -((e >> 1) & 1)) ^
                (513874426 & -((e >> 2) & 1)) ^
                (1027748829 & -((e >> 3) & 1)) ^
                (705979059 & -((e >> 4) & 1))
              );
            }
            function o(t) {
              let e = 1;
              for (let r = 0; r < t.length; ++r) {
                const n = t.charCodeAt(r);
                if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
                e = i(e) ^ (n >> 5);
              }
              e = i(e);
              for (let r = 0; r < t.length; ++r) {
                const n = t.charCodeAt(r);
                e = i(e) ^ (31 & n);
              }
              return e;
            }
            function s(t, e, r, n) {
              let i = 0,
                o = 0;
              const s = (1 << r) - 1,
                a = [];
              for (let n = 0; n < t.length; ++n)
                for (i = (i << e) | t[n], o += e; o >= r; )
                  (o -= r), a.push((i >> o) & s);
              if (n) o > 0 && a.push((i << (r - o)) & s);
              else {
                if (o >= e) return "Excess padding";
                if ((i << (r - o)) & s) return "Non-zero padding";
              }
              return a;
            }
            function a(t) {
              return s(t, 8, 5, !0);
            }
            function u(t) {
              const e = s(t, 5, 8, !1);
              if (Array.isArray(e)) return e;
            }
            function c(t) {
              const e = s(t, 5, 8, !1);
              if (Array.isArray(e)) return e;
              throw new Error(e);
            }
            function f(t) {
              let e;
              function s(t, r) {
                if (((r = r || 90), t.length < 8)) return t + " too short";
                if (t.length > r) return "Exceeds length limit";
                const s = t.toLowerCase(),
                  a = t.toUpperCase();
                if (t !== s && t !== a) return "Mixed-case string " + t;
                const u = (t = s).lastIndexOf("1");
                if (-1 === u) return "No separator character for " + t;
                if (0 === u) return "Missing prefix for " + t;
                const c = t.slice(0, u),
                  f = t.slice(u + 1);
                if (f.length < 6) return "Data too short";
                let h = o(c);
                if ("string" == typeof h) return h;
                const l = [];
                for (let t = 0; t < f.length; ++t) {
                  const e = f.charAt(t),
                    r = n[e];
                  if (void 0 === r) return "Unknown character " + e;
                  (h = i(h) ^ r), t + 6 >= f.length || l.push(r);
                }
                return h !== e
                  ? "Invalid checksum for " + t
                  : { prefix: c, words: l };
              }
              return (
                (e = "bech32" === t ? 1 : 734539939),
                {
                  decodeUnsafe: function (t, e) {
                    const r = s(t, e);
                    if ("object" == typeof r) return r;
                  },
                  decode: function (t, e) {
                    const r = s(t, e);
                    if ("object" == typeof r) return r;
                    throw new Error(r);
                  },
                  encode: function (t, n, s) {
                    if (((s = s || 90), t.length + 7 + n.length > s))
                      throw new TypeError("Exceeds length limit");
                    let a = o((t = t.toLowerCase()));
                    if ("string" == typeof a) throw new Error(a);
                    let u = t + "1";
                    for (let t = 0; t < n.length; ++t) {
                      const e = n[t];
                      if (e >> 5) throw new Error("Non 5-bit word");
                      (a = i(a) ^ e), (u += r.charAt(e));
                    }
                    for (let t = 0; t < 6; ++t) a = i(a);
                    a ^= e;
                    for (let t = 0; t < 6; ++t)
                      u += r.charAt((a >> (5 * (5 - t))) & 31);
                    return u;
                  },
                  toWords: a,
                  fromWordsUnsafe: u,
                  fromWords: c,
                }
              );
            }
            (e.bech32 = f("bech32")), (e.bech32m = f("bech32m"));
          }),
          ur((cr = { exports: {} }), cr.exports),
          cr.exports);
      (fr = lr) &&
        fr.__esModule &&
        Object.prototype.hasOwnProperty.call(fr, "default") &&
        fr.default;
      var dr = lr.bech32m,
        pr = lr.bech32;
      const yr = [
        1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993,
        -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987,
        1925078388, -2132889090, -1680079193, -1046744716, -459576895,
        -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692,
        1996064986, -1740746414, -1473132947, -1341970488, -1084653625,
        -958395405, -710438585, 113926993, 338241895, 666307205, 773529912,
        1294757372, 1396182291, 1695183700, 1986661051, -2117940946,
        -1838011259, -1564481375, -1474664885, -1035236496, -949202525,
        -778901479, -694614492, -200395387, 275423344, 430227734, 506948616,
        659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, -2067236844, -1933114872, -1866530822,
        -1538233109, -1090935817, -965641998,
      ];
      class gr {
        constructor() {
          (this.A = 1779033703),
            (this.B = -1150833019),
            (this.C = 1013904242),
            (this.D = -1521486534),
            (this.E = 1359893119),
            (this.F = -1694144372),
            (this.G = 528734635),
            (this.H = 1541459225),
            (this._size = 0),
            (this._sp = 0),
            (!br || wr >= 8e3) && ((br = new ArrayBuffer(8e3)), (wr = 0)),
            (this._byte = new Uint8Array(br, wr, 80)),
            (this._word = new Int32Array(br, wr, 20)),
            (wr += 80);
        }
        update(t) {
          if ("string" == typeof t) return this._utf8(t);
          if (null == t) throw new TypeError("Invalid type: " + typeof t);
          const e = t.byteOffset,
            r = t.byteLength;
          let n = (r / 64) | 0,
            i = 0;
          if (n && !(3 & e) && !(this._size % 64)) {
            const r = new Int32Array(t.buffer, e, 16 * n);
            for (; n--; ) this._int32(r, i >> 2), (i += 64);
            this._size += i;
          }
          if (1 !== t.BYTES_PER_ELEMENT && t.buffer) {
            const n = new Uint8Array(t.buffer, e + i, r - i);
            return this._uint8(n);
          }
          return i === r ? this : this._uint8(t, i);
        }
        _uint8(t, e) {
          const { _byte: r, _word: n } = this,
            i = t.length;
          for (e |= 0; e < i; ) {
            const o = this._size % 64;
            let s = o;
            for (; e < i && s < 64; ) r[s++] = t[e++];
            s >= 64 && this._int32(n), (this._size += s - o);
          }
          return this;
        }
        _utf8(t) {
          const { _byte: e, _word: r } = this,
            n = t.length;
          let i = this._sp;
          for (let o = 0; o < n; ) {
            const s = this._size % 64;
            let a = s;
            for (; o < n && a < 64; ) {
              let r = 0 | t.charCodeAt(o++);
              r < 128
                ? (e[a++] = r)
                : r < 2048
                  ? ((e[a++] = 192 | (r >>> 6)), (e[a++] = 128 | (63 & r)))
                  : r < 55296 || r > 57343
                    ? ((e[a++] = 224 | (r >>> 12)),
                      (e[a++] = 128 | ((r >>> 6) & 63)),
                      (e[a++] = 128 | (63 & r)))
                    : i
                      ? ((r = ((1023 & i) << 10) + (1023 & r) + 65536),
                        (e[a++] = 240 | (r >>> 18)),
                        (e[a++] = 128 | ((r >>> 12) & 63)),
                        (e[a++] = 128 | ((r >>> 6) & 63)),
                        (e[a++] = 128 | (63 & r)),
                        (i = 0))
                      : (i = r);
            }
            a >= 64 && (this._int32(r), (r[0] = r[16])), (this._size += a - s);
          }
          return (this._sp = i), this;
        }
        _int32(t, e) {
          let { A: r, B: n, C: i, D: o, E: s, F: a, G: u, H: c } = this,
            f = 0;
          for (e |= 0; f < 16; ) mr[f++] = _r(t[e++]);
          for (f = 16; f < 64; f++)
            mr[f] =
              (Tr(mr[f - 2]) + mr[f - 7] + Ar(mr[f - 15]) + mr[f - 16]) | 0;
          for (f = 0; f < 64; f++) {
            const t = (c + Mr(s) + Er(s, a, u) + yr[f] + mr[f]) | 0,
              e = (Ir(r) + Sr(r, n, i)) | 0;
            (c = u),
              (u = a),
              (a = s),
              (s = (o + t) | 0),
              (o = i),
              (i = n),
              (n = r),
              (r = (t + e) | 0);
          }
          (this.A = (r + this.A) | 0),
            (this.B = (n + this.B) | 0),
            (this.C = (i + this.C) | 0),
            (this.D = (o + this.D) | 0),
            (this.E = (s + this.E) | 0),
            (this.F = (a + this.F) | 0),
            (this.G = (u + this.G) | 0),
            (this.H = (c + this.H) | 0);
        }
        digest(t) {
          const { _byte: e, _word: r } = this;
          let n = this._size % 64 | 0;
          for (e[n++] = 128; 3 & n; ) e[n++] = 0;
          if (((n >>= 2), n > 14)) {
            for (; n < 16; ) r[n++] = 0;
            (n = 0), this._int32(r);
          }
          for (; n < 16; ) r[n++] = 0;
          const i = 8 * this._size,
            o = (4294967295 & i) >>> 0,
            s = (i - o) / 4294967296;
          return (
            s && (r[14] = _r(s)),
            o && (r[15] = _r(o)),
            this._int32(r),
            "hex" === t ? this._hex() : this._bin()
          );
        }
        _hex() {
          const { A: t, B: e, C: r, D: n, E: i, F: o, G: s, H: a } = this;
          return vr(t) + vr(e) + vr(r) + vr(n) + vr(i) + vr(o) + vr(s) + vr(a);
        }
        _bin() {
          const {
            A: t,
            B: e,
            C: r,
            D: n,
            E: i,
            F: o,
            G: s,
            H: a,
            _byte: u,
            _word: c,
          } = this;
          return (
            (c[0] = _r(t)),
            (c[1] = _r(e)),
            (c[2] = _r(r)),
            (c[3] = _r(n)),
            (c[4] = _r(i)),
            (c[5] = _r(o)),
            (c[6] = _r(s)),
            (c[7] = _r(a)),
            u.slice(0, 32)
          );
        }
      }
      const mr = new Int32Array(64);
      let br,
        wr = 0;
      const vr = (t) => (t + 4294967296).toString(16).substr(-8),
        _r =
          254 === new Uint8Array(new Uint16Array([65279]).buffer)[0]
            ? (t) => t
            : (t) =>
                ((t << 24) & 4278190080) |
                ((t << 8) & 16711680) |
                ((t >> 8) & 65280) |
                ((t >> 24) & 255),
        Er = (t, e, r) => r ^ (t & (e ^ r)),
        Sr = (t, e, r) => (t & e) | (r & (t | e)),
        Ir = (t) =>
          ((t >>> 2) | (t << 30)) ^
          ((t >>> 13) | (t << 19)) ^
          ((t >>> 22) | (t << 10)),
        Mr = (t) =>
          ((t >>> 6) | (t << 26)) ^
          ((t >>> 11) | (t << 21)) ^
          ((t >>> 25) | (t << 7)),
        Ar = (t) =>
          ((t >>> 7) | (t << 25)) ^ ((t >>> 18) | (t << 14)) ^ (t >>> 3),
        Tr = (t) =>
          ((t >>> 17) | (t << 15)) ^ ((t >>> 19) | (t << 13)) ^ (t >>> 10);
      var kr,
        Or,
        xr = function (t) {
          return new gr().update(t).digest();
        };
      !(function (t) {
        (t.mainnet = "mainnet"),
          (t.testnet = "testnet"),
          (t.regtest = "regtest");
      })(kr || (kr = {})),
        (function (t) {
          (t.p2pkh = "p2pkh"),
            (t.p2sh = "p2sh"),
            (t.p2wpkh = "p2wpkh"),
            (t.p2wsh = "p2wsh"),
            (t.p2tr = "p2tr");
        })(Or || (Or = {}));
      var Pr,
        Br = {
          0: { type: Or.p2pkh, network: kr.mainnet },
          111: { type: Or.p2pkh, network: kr.testnet },
          5: { type: Or.p2sh, network: kr.mainnet },
          196: { type: Or.p2sh, network: kr.testnet },
        },
        Cr = function (t) {
          var e,
            r = t.substr(0, 2).toLowerCase();
          if ("bc" === r || "tb" === r)
            return (function (t) {
              var e;
              try {
                e =
                  t.startsWith("bc1p") ||
                  t.startsWith("tb1p") ||
                  t.startsWith("bcrt1p")
                    ? dr.decode(t)
                    : pr.decode(t);
              } catch (t) {
                throw new Error("Invalid address");
              }
              var r = { bc: kr.mainnet, tb: kr.testnet, bcrt: kr.regtest }[
                e.prefix
              ];
              if (void 0 === r) throw new Error("Invalid address");
              var n = e.words[0];
              if (n < 0 || n > 16) throw new Error("Invalid address");
              return {
                bech32: !0,
                network: r,
                address: t,
                type:
                  20 === pr.fromWords(e.words.slice(1)).length
                    ? Or.p2wpkh
                    : 1 === n
                      ? Or.p2tr
                      : Or.p2wsh,
              };
            })(t);
          try {
            e = hr(t);
          } catch (t) {
            throw new Error("Invalid address");
          }
          var n = e.length;
          if (25 !== n) throw new Error("Invalid address");
          var i = e[0],
            o = e.slice(n - 4, n),
            s = e.slice(0, n - 4),
            a = xr(xr(s)).slice(0, 4);
          if (
            o.some(function (t, e) {
              return t !== a[e];
            })
          )
            throw new Error("Invalid address");
          if (!Object.keys(Br).map(Number).includes(i))
            throw new Error("Invalid address");
          return sr(sr({}, Br[i]), { address: t, bech32: !1 });
        },
        Rr = i(48287),
        Nr = ((t) => (
          (t.Mainnet = "Mainnet"),
          (t.Testnet = "Testnet"),
          (t.Testnet4 = "Testnet4"),
          (t.Signet = "Signet"),
          (t.Regtest = "Regtest"),
          t
        ))(Nr || {}),
        Ur = A(x([k(), I(), E()])),
        Dr = M({
          jsonrpc: v("2.0"),
          method: k(),
          params: A(
            x([
              m(P()),
              (function t(e, r) {
                return {
                  kind: "schema",
                  type: "loose_object",
                  reference: t,
                  expects: "Object",
                  async: !1,
                  entries: e,
                  message: r,
                  _run(t, e) {
                    const r = t.value;
                    if (r && "object" == typeof r) {
                      (t.typed = !0), (t.value = {});
                      for (const n in this.entries) {
                        const i = r[n],
                          o = this.entries[n]._run({ typed: !1, value: i }, e);
                        if (o.issues) {
                          const s = {
                            type: "object",
                            origin: "value",
                            input: r,
                            key: n,
                            value: i,
                          };
                          for (const e of o.issues)
                            e.path ? e.path.unshift(s) : (e.path = [s]),
                              t.issues?.push(e);
                          if (
                            (t.issues || (t.issues = o.issues), e.abortEarly)
                          ) {
                            t.typed = !1;
                            break;
                          }
                        }
                        o.typed || (t.typed = !1),
                          (void 0 !== o.value || n in r) &&
                            (t.value[n] = o.value);
                      }
                      if (!t.issues || !e.abortEarly)
                        for (const e in r)
                          d(r, e) &&
                            !(e in this.entries) &&
                            (t.value[e] = r[e]);
                    } else l(this, "type", t, e);
                    return t;
                  },
                };
              })({}),
              E(),
            ]),
          ),
          id: ((Pr = Ur), Pr.wrapped),
        }),
        Lr = ((t) => (
          (t[(t.PARSE_ERROR = -32700)] = "PARSE_ERROR"),
          (t[(t.INVALID_REQUEST = -32600)] = "INVALID_REQUEST"),
          (t[(t.METHOD_NOT_FOUND = -32601)] = "METHOD_NOT_FOUND"),
          (t[(t.INVALID_PARAMS = -32602)] = "INVALID_PARAMS"),
          (t[(t.INTERNAL_ERROR = -32603)] = "INTERNAL_ERROR"),
          (t[(t.USER_REJECTION = -32e3)] = "USER_REJECTION"),
          (t[(t.METHOD_NOT_SUPPORTED = -32001)] = "METHOD_NOT_SUPPORTED"),
          (t[(t.ACCESS_DENIED = -32002)] = "ACCESS_DENIED"),
          t
        ))(Lr || {}),
        jr = M({ jsonrpc: v("2.0"), result: _(P()), id: Ur }),
        Fr = M({ jsonrpc: v("2.0"), error: _(P()), id: Ur }),
        Hr = x([jr, Fr]),
        Kr = B("type", [
          M({ type: v("accountChange") }),
          M({
            type: v("networkChange"),
            bitcoin: M({ name: w(Nr) }),
            stacks: M({ name: k() }),
          }),
          M({ type: v("disconnect") }),
        ]);
      function Vr(t) {
        return t?.split(".").reduce((t, e) => t?.[e], window);
      }
      var qr = "stx_callContract",
        zr = M({
          contract: k(),
          functionName: k(),
          arguments: A(m(k())),
          functionArgs: A(m(k())),
          postConditions: A(m(k())),
          postConditionMode: A(x([v("allow"), v("deny")])),
        }),
        $r =
          (M({ txid: k(), transaction: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(qr), params: zr, id: k() }).entries,
          })),
        Gr = "stx_deployContract",
        Wr = M({
          name: k(),
          clarityCode: k(),
          clarityVersion: A(k()),
          postConditions: A(m(k())),
          postConditionMode: A(x([v("allow"), v("deny")])),
        }),
        Yr =
          (M({ txid: k(), transaction: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Gr), params: Wr, id: k() }).entries,
          })),
        Xr = T(["software", "ledger", "keystone"]),
        Zr = ((t) => (
          (t.Ordinals = "ordinals"),
          (t.Payment = "payment"),
          (t.Stacks = "stacks"),
          t
        ))(Zr || {}),
        Jr = ((t) => (
          (t.p2pkh = "p2pkh"),
          (t.p2sh = "p2sh"),
          (t.p2wpkh = "p2wpkh"),
          (t.p2wsh = "p2wsh"),
          (t.p2tr = "p2tr"),
          (t.stacks = "stacks"),
          t
        ))(Jr || {}),
        Qr = M({
          address: k(),
          publicKey: k(),
          purpose: w(Zr),
          addressType: w(Jr),
          walletType: Xr,
        }),
        tn = M({ read: A(b()) }),
        en = M({ readNetwork: A(b()) }),
        rn = M({
          type: v("account"),
          resourceId: k(),
          clientId: k(),
          actions: tn,
        }),
        nn = M({
          type: v("wallet"),
          resourceId: k(),
          clientId: k(),
          actions: en,
        }),
        on = B("type", [
          M({ ...C(rn, ["clientId"]).entries }),
          M({ ...C(nn, ["clientId"]).entries }),
        ]),
        sn = B("type", [rn, nn]),
        an = "wallet_requestPermissions",
        un = S(m(on)),
        cn =
          (v(!0),
          M({
            ...Dr.entries,
            ...M({ method: v(an), params: un, id: k() }).entries,
          })),
        fn = "wallet_renouncePermissions",
        hn = S(E()),
        ln =
          (S(E()),
          M({
            ...Dr.entries,
            ...M({ method: v(fn), params: hn, id: k() }).entries,
          })),
        dn = "wallet_disconnect",
        pn = S(E()),
        yn =
          (S(E()),
          M({
            ...Dr.entries,
            ...M({ method: v(dn), params: pn, id: k() }).entries,
          })),
        gn = "wallet_getWalletType",
        mn = S(E()),
        bn = M({
          ...Dr.entries,
          ...M({ method: v(gn), params: mn, id: k() }).entries,
        }),
        wn = "wallet_getCurrentPermissions",
        vn = S(E()),
        _n =
          (m(sn),
          M({
            ...Dr.entries,
            ...M({ method: v(wn), params: vn, id: k() }).entries,
          })),
        En = "wallet_getNetwork",
        Sn = S(E()),
        In = M({ bitcoin: M({ name: w(Nr) }), stacks: M({ name: k() }) }),
        Mn = M({
          ...Dr.entries,
          ...M({ method: v(En), params: Sn, id: k() }).entries,
        }),
        An = "wallet_changeNetwork",
        Tn = M({ name: w(Nr) }),
        kn =
          (S(E()),
          M({
            ...Dr.entries,
            ...M({ method: v(An), params: Tn, id: k() }).entries,
          })),
        On = "wallet_getAccount",
        xn = S(E()),
        Pn =
          (M({ id: k(), addresses: m(Qr), walletType: Xr, network: In }),
          M({
            ...Dr.entries,
            ...M({ method: v(On), params: xn, id: k() }).entries,
          })),
        Bn = "wallet_connect",
        Cn = S(
          M({
            permissions: A(m(on)),
            addresses: A(m(w(Zr))),
            message: A(
              R(
                k(),
                (function t(e, r) {
                  return {
                    kind: "validation",
                    type: "max_length",
                    reference: t,
                    async: !1,
                    expects: `<=${e}`,
                    requirement: e,
                    message: r,
                    _run(t, e) {
                      return (
                        t.typed &&
                          t.value.length > this.requirement &&
                          l(this, "length", t, e, {
                            received: `${t.value.length}`,
                          }),
                        t
                      );
                    },
                  };
                })(80, "The message must not exceed 80 characters."),
              ),
            ),
          }),
        ),
        Rn =
          (M({ id: k(), addresses: m(Qr), walletType: Xr, network: In }),
          M({
            ...Dr.entries,
            ...M({ method: v(Bn), params: Cn, id: k() }).entries,
          })),
        Nn = "stx_getAccounts",
        Un = S(E()),
        Dn =
          (M({
            addresses: m(
              M({
                address: k(),
                publicKey: k(),
                gaiaHubUrl: k(),
                gaiaAppKey: k(),
              }),
            ),
            network: In,
          }),
          M({
            ...Dr.entries,
            ...M({ method: v(Nn), params: Un, id: k() }).entries,
          })),
        Ln = "stx_getAddresses",
        jn = S(M({ message: A(k()) })),
        Fn =
          (M({ addresses: m(Qr), network: In }),
          M({
            ...Dr.entries,
            ...M({ method: v(Ln), params: jn, id: k() }).entries,
          })),
        Hn = "stx_signMessage",
        Kn = M({
          message: k(),
          publicKey: k(),
          parameterFormatVersion: A(I()),
        }),
        Vn =
          (M({ signature: k(), publicKey: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Hn), params: Kn, id: k() }).entries,
          })),
        qn = "stx_signStructuredMessage",
        zn = M({
          domain: k(),
          message: k(),
          parameterFormatVersion: A(I()),
          publicKey: A(k()),
        }),
        $n =
          (M({ signature: k(), publicKey: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(qn), params: zn, id: k() }).entries,
          })),
        Gn = "stx_signTransaction",
        Wn = M({ transaction: k(), pubkey: A(k()), broadcast: A(b()) }),
        Yn =
          (M({ transaction: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Gn), params: Wn, id: k() }).entries,
          })),
        Xn = "stx_signTransactions",
        Zn = M({
          transactions: R(
            m(
              R(
                k(),
                (function t(e, r) {
                  return {
                    kind: "validation",
                    type: "check",
                    reference: t,
                    async: !1,
                    expects: null,
                    requirement: e,
                    message: r,
                    _run(t, e) {
                      return (
                        t.typed &&
                          !this.requirement(t.value) &&
                          l(this, "input", t, e),
                        t
                      );
                    },
                  };
                })((t) => !0, "Invalid hex-encoded Stacks transaction."),
              ),
            ),
            (function t(e, r) {
              return {
                kind: "validation",
                type: "min_length",
                reference: t,
                async: !1,
                expects: `>=${e}`,
                requirement: e,
                message: r,
                _run(t, e) {
                  return (
                    t.typed &&
                      t.value.length < this.requirement &&
                      l(this, "length", t, e, {
                        received: `${t.value.length}`,
                      }),
                    t
                  );
                },
              };
            })(1),
          ),
          broadcast: A(b()),
        }),
        Jn =
          (M({ transactions: m(k()) }),
          M({
            ...Dr.entries,
            ...M({ method: v(Xn), params: Zn, id: k() }).entries,
          })),
        Qn = "stx_transferStx",
        ti = M({
          amount: x([I(), k()]),
          recipient: k(),
          memo: A(k()),
          version: A(k()),
          postConditionMode: A(I()),
          postConditions: A(m(k())),
          pubkey: A(k()),
        }),
        ei =
          (M({ txid: k(), transaction: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Qn), params: ti, id: k() }).entries,
          })),
        ri = "getInfo",
        ni = S(E()),
        ii =
          (M({ version: k(), methods: A(m(k())), supports: m(k()) }),
          M({
            ...Dr.entries,
            ...M({ method: v(ri), params: ni, id: k() }).entries,
          })),
        oi = "getAddresses",
        si = M({ purposes: m(w(Zr)), message: A(k()) }),
        ai =
          (M({ addresses: m(Qr), network: In }),
          M({
            ...Dr.entries,
            ...M({ method: v(oi), params: si, id: k() }).entries,
          })),
        ui = "signMessage",
        ci = ((t) => ((t.ECDSA = "ECDSA"), (t.BIP322 = "BIP322"), t))(ci || {}),
        fi = M({ address: k(), message: k(), protocol: A(w(ci)) }),
        hi =
          (M({
            signature: k(),
            messageHash: k(),
            address: k(),
            protocol: w(ci),
          }),
          M({
            ...Dr.entries,
            ...M({ method: v(ui), params: fi, id: k() }).entries,
          })),
        li = "sendTransfer",
        di = M({ recipients: m(M({ address: k(), amount: I() })) }),
        pi =
          (M({ txid: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(li), params: di, id: k() }).entries,
          })),
        yi = "signPsbt",
        gi = M({
          psbt: k(),
          signInputs: (function t(e, r, n) {
            return {
              kind: "schema",
              type: "record",
              reference: t,
              expects: "Object",
              async: !1,
              key: e,
              value: r,
              message: n,
              _run(t, e) {
                const r = t.value;
                if (r && "object" == typeof r) {
                  (t.typed = !0), (t.value = {});
                  for (const n in r)
                    if (d(r, n)) {
                      const i = r[n],
                        o = this.key._run({ typed: !1, value: n }, e);
                      if (o.issues) {
                        const s = {
                          type: "object",
                          origin: "key",
                          input: r,
                          key: n,
                          value: i,
                        };
                        for (const e of o.issues)
                          (e.path = [s]), t.issues?.push(e);
                        if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                          t.typed = !1;
                          break;
                        }
                      }
                      const s = this.value._run({ typed: !1, value: i }, e);
                      if (s.issues) {
                        const o = {
                          type: "object",
                          origin: "value",
                          input: r,
                          key: n,
                          value: i,
                        };
                        for (const e of s.issues)
                          e.path ? e.path.unshift(o) : (e.path = [o]),
                            t.issues?.push(e);
                        if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                          t.typed = !1;
                          break;
                        }
                      }
                      (o.typed && s.typed) || (t.typed = !1),
                        o.typed && (t.value[o.value] = s.value);
                    }
                } else l(this, "type", t, e);
                return t;
              },
            };
          })(k(), m(I())),
          broadcast: A(b()),
        }),
        mi =
          (M({ psbt: k(), txid: A(k()) }),
          M({
            ...Dr.entries,
            ...M({ method: v(yi), params: gi, id: k() }).entries,
          })),
        bi = "getAccounts",
        wi = M({ purposes: m(w(Zr)), message: A(k()) }),
        vi =
          (m(M({ ...Qr.entries, ...M({ walletType: Xr }).entries })),
          M({
            ...Dr.entries,
            ...M({ method: v(bi), params: wi, id: k() }).entries,
          })),
        _i = "getBalance",
        Ei =
          (S(E()),
          M({ confirmed: k(), unconfirmed: k(), total: k() }),
          M({ ...Dr.entries, ...M({ method: v(_i), id: k() }).entries })),
        Si = "runes_etch",
        Ii = M({
          amount: k(),
          cap: k(),
          heightStart: A(k()),
          heightEnd: A(k()),
          offsetStart: A(k()),
          offsetEnd: A(k()),
        }),
        Mi = M({ contentType: k(), contentBase64: k() }),
        Ai = M({
          runeName: k(),
          divisibility: A(I()),
          symbol: A(k()),
          premine: A(k()),
          isMintable: b(),
          delegateInscriptionId: A(k()),
          destinationAddress: k(),
          refundAddress: k(),
          feeRate: I(),
          appServiceFee: A(I()),
          appServiceFeeAddress: A(k()),
          terms: A(Ii),
          inscriptionDetails: A(Mi),
          network: A(w(Nr)),
        }),
        Ti =
          (M({ orderId: k(), fundTransactionId: k(), fundingAddress: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Si), params: Ai, id: k() }).entries,
          })),
        ki = "runes_getBalance",
        Oi = S(E()),
        xi =
          (M({
            balances: m(
              M({
                runeName: k(),
                amount: k(),
                divisibility: I(),
                symbol: k(),
                inscriptionId: S(k()),
                spendableBalance: k(),
              }),
            ),
          }),
          M({
            ...Dr.entries,
            ...M({ method: v(ki), params: Oi, id: k() }).entries,
          })),
        Pi = "runes_mint",
        Bi = M({
          appServiceFee: A(I()),
          appServiceFeeAddress: A(k()),
          destinationAddress: k(),
          feeRate: I(),
          refundAddress: k(),
          repeats: I(),
          runeName: k(),
          network: A(w(Nr)),
        }),
        Ci =
          (M({ orderId: k(), fundTransactionId: k(), fundingAddress: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Pi), params: Bi, id: k() }).entries,
          })),
        Ri = "runes_transfer",
        Ni = M({
          recipients: m(M({ runeName: k(), amount: k(), address: k() })),
        }),
        Ui =
          (M({ txid: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Ri), params: Ni, id: k() }).entries,
          })),
        Di = "ord_getInscriptions",
        Li = M({ offset: I(), limit: I() }),
        ji =
          (M({
            total: I(),
            limit: I(),
            offset: I(),
            inscriptions: m(
              M({
                inscriptionId: k(),
                inscriptionNumber: k(),
                address: k(),
                collectionName: A(k()),
                postage: k(),
                contentLength: k(),
                contentType: k(),
                timestamp: I(),
                offset: I(),
                genesisTransaction: k(),
                output: k(),
              }),
            ),
          }),
          M({
            ...Dr.entries,
            ...M({ method: v(Di), params: Li, id: k() }).entries,
          })),
        Fi = "ord_sendInscriptions",
        Hi = M({ transfers: m(M({ address: k(), inscriptionId: k() })) }),
        Ki =
          (M({ txid: k() }),
          M({
            ...Dr.entries,
            ...M({ method: v(Fi), params: Hi, id: k() }).entries,
          })),
        Vi = async (t, e, r) => {
          let n =
            window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
          if ((r && (n = await Vr(r)), !n))
            throw new Error("no wallet provider was found");
          if (!t) throw new Error("A wallet method is required");
          const i = await n.request(t, e);
          return g(Fr, i)
            ? { status: "error", error: i.error }
            : g(jr, i)
              ? { status: "success", result: i.result }
              : {
                  status: "error",
                  error: {
                    code: -32603,
                    message: "Received unknown response from provider.",
                    data: i,
                  },
                };
        },
        qi = {
          Mainnet: "",
          Testnet: "-testnet",
          Testnet4: "-testnet4",
          Signet: "-signet",
        },
        zi = (t = "Mainnet") => {
          if ("Regtest" === t)
            throw new Error(`Ordinals API does not support ${t} network`);
          return `https://ordinals${qi[t]}.xverse.app/v1`;
        },
        $i = class {
          client;
          constructor(t) {
            this.client = or.create({ baseURL: zi(t) });
          }
          parseError = (t) => ({
            code: t.response?.status,
            message: JSON.stringify(t.response?.data),
          });
          estimateMintCost = async (t) => {
            try {
              return {
                data: (await this.client.post("/runes/mint/estimate", { ...t }))
                  .data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          estimateEtchCost = async (t) => {
            try {
              return {
                data: (await this.client.post("/runes/etch/estimate", { ...t }))
                  .data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          createMintOrder = async (t) => {
            try {
              return {
                data: (await this.client.post("/runes/mint/orders", { ...t }))
                  .data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          createEtchOrder = async (t) => {
            try {
              return {
                data: (await this.client.post("/runes/etch/orders", { ...t }))
                  .data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          executeMint = async (t, e) => {
            try {
              return {
                data: (
                  await this.client.post(`/runes/mint/orders/${t}/execute`, {
                    fundTransactionId: e,
                  })
                ).data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          executeEtch = async (t, e) => {
            try {
              return {
                data: (
                  await this.client.post(`/runes/etch/orders/${t}/execute`, {
                    fundTransactionId: e,
                  })
                ).data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          getOrder = async (t) => {
            try {
              return { data: (await this.client.get(`/orders/${t}`)).data };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
          rbfOrder = async (t) => {
            const { orderId: e, newFeeRate: r } = t;
            try {
              return {
                data: (
                  await this.client.post(`/orders/${e}/rbf-estimate`, {
                    newFeeRate: r,
                  })
                ).data,
              };
            } catch (t) {
              const e = t;
              return { error: this.parseError(e) };
            }
          };
        },
        Gi = {},
        Wi = (t = "Mainnet") => (Gi[t] || (Gi[t] = new $i(t)), Gi[t]),
        Yi = class {
          async mintRunes(t) {
            try {
              const e = await this.requestInternal("getInfo", null).catch(
                () => null,
              );
              if (e && "success" === e.status) {
                const r = e.result.methods?.includes("runes_mint");
                if (r) {
                  const e = await this.requestInternal("runes_mint", t);
                  if (e) {
                    if ("success" === e.status) return e;
                    if ("error" === e.status && -32601 !== e.error.code)
                      return e;
                  }
                }
              }
              const r = {
                  destinationAddress: t.destinationAddress,
                  feeRate: t.feeRate,
                  refundAddress: t.refundAddress,
                  repeats: t.repeats,
                  runeName: t.runeName,
                  appServiceFee: t.appServiceFee,
                  appServiceFeeAddress: t.appServiceFeeAddress,
                },
                n = await new $i(t.network).createMintOrder(r);
              if (!n.data)
                return {
                  status: "error",
                  error: {
                    code: 400 === n.error.code ? -32600 : -32603,
                    message: n.error.message,
                  },
                };
              const i = await this.requestInternal("sendTransfer", {
                recipients: [
                  { address: n.data.fundAddress, amount: n.data.fundAmount },
                ],
              });
              return "success" !== i.status
                ? i
                : (await new $i(t.network).executeMint(
                    n.data.orderId,
                    i.result.txid,
                  ),
                  {
                    status: "success",
                    result: {
                      orderId: n.data.orderId,
                      fundTransactionId: i.result.txid,
                      fundingAddress: n.data.fundAddress,
                    },
                  });
            } catch (t) {
              return {
                status: "error",
                error: { code: -32603, message: t.message },
              };
            }
          }
          async etchRunes(t) {
            const e = {
              destinationAddress: t.destinationAddress,
              refundAddress: t.refundAddress,
              feeRate: t.feeRate,
              runeName: t.runeName,
              divisibility: t.divisibility,
              symbol: t.symbol,
              premine: t.premine,
              isMintable: t.isMintable,
              terms: t.terms,
              inscriptionDetails: t.inscriptionDetails,
              delegateInscriptionId: t.delegateInscriptionId,
              appServiceFee: t.appServiceFee,
              appServiceFeeAddress: t.appServiceFeeAddress,
            };
            try {
              const r = await this.requestInternal("getInfo", null).catch(
                () => null,
              );
              if (r && "success" === r.status) {
                const e = r.result.methods?.includes("runes_etch");
                if (e) {
                  const e = await this.requestInternal("runes_etch", t);
                  if (e) {
                    if ("success" === e.status) return e;
                    if ("error" === e.status && -32601 !== e.error.code)
                      return e;
                  }
                }
              }
              const n = await new $i(t.network).createEtchOrder(e);
              if (!n.data)
                return {
                  status: "error",
                  error: {
                    code: 400 === n.error.code ? -32600 : -32603,
                    message: n.error.message,
                  },
                };
              const i = await this.requestInternal("sendTransfer", {
                recipients: [
                  { address: n.data.fundAddress, amount: n.data.fundAmount },
                ],
              });
              return "success" !== i.status
                ? i
                : (await new $i(t.network).executeEtch(
                    n.data.orderId,
                    i.result.txid,
                  ),
                  {
                    status: "success",
                    result: {
                      orderId: n.data.orderId,
                      fundTransactionId: i.result.txid,
                      fundingAddress: n.data.fundAddress,
                    },
                  });
            } catch (t) {
              return {
                status: "error",
                error: { code: -32603, message: t.message },
              };
            }
          }
          async estimateMint(t) {
            const e = {
                destinationAddress: t.destinationAddress,
                feeRate: t.feeRate,
                repeats: t.repeats,
                runeName: t.runeName,
                appServiceFee: t.appServiceFee,
                appServiceFeeAddress: t.appServiceFeeAddress,
              },
              r = await Wi(t.network).estimateMintCost(e);
            return r.data
              ? { status: "success", result: r.data }
              : {
                  status: "error",
                  error: {
                    code: 400 === r.error.code ? -32600 : -32603,
                    message: r.error.message,
                  },
                };
          }
          async estimateEtch(t) {
            const e = {
                destinationAddress: t.destinationAddress,
                feeRate: t.feeRate,
                runeName: t.runeName,
                divisibility: t.divisibility,
                symbol: t.symbol,
                premine: t.premine,
                isMintable: t.isMintable,
                terms: t.terms,
                inscriptionDetails: t.inscriptionDetails,
                delegateInscriptionId: t.delegateInscriptionId,
                appServiceFee: t.appServiceFee,
                appServiceFeeAddress: t.appServiceFeeAddress,
              },
              r = await Wi(t.network).estimateEtchCost(e);
            return r.data
              ? { status: "success", result: r.data }
              : {
                  status: "error",
                  error: {
                    code: 400 === r.error.code ? -32600 : -32603,
                    message: r.error.message,
                  },
                };
          }
          async getOrder(t) {
            const e = await Wi(t.network).getOrder(t.id);
            return e.data
              ? { status: "success", result: e.data }
              : {
                  status: "error",
                  error: {
                    code:
                      400 === e.error.code || 404 === e.error.code
                        ? -32600
                        : -32603,
                    message: e.error.message,
                  },
                };
          }
          async estimateRbfOrder(t) {
            const e = { newFeeRate: t.newFeeRate, orderId: t.orderId },
              r = await Wi(t.network).rbfOrder(e);
            return r.data
              ? {
                  status: "success",
                  result: {
                    fundingAddress: r.data.fundingAddress,
                    rbfCost: r.data.rbfCost,
                  },
                }
              : {
                  status: "error",
                  error: {
                    code:
                      400 === r.error.code || 404 === r.error.code
                        ? -32600
                        : -32603,
                    message: r.error.message,
                  },
                };
          }
          async rbfOrder(t) {
            try {
              const e = { newFeeRate: t.newFeeRate, orderId: t.orderId },
                r = await Wi(t.network).rbfOrder(e);
              if (!r.data)
                return {
                  status: "error",
                  error: {
                    code:
                      400 === r.error.code || 404 === r.error.code
                        ? -32600
                        : -32603,
                    message: r.error.message,
                  },
                };
              const n = await this.requestInternal("sendTransfer", {
                recipients: [
                  { address: r.data.fundingAddress, amount: r.data.rbfCost },
                ],
              });
              return "success" !== n.status
                ? n
                : {
                    status: "success",
                    result: {
                      fundingAddress: r.data.fundingAddress,
                      orderId: e.orderId,
                      fundRBFTransactionId: n.result.txid,
                    },
                  };
            } catch (t) {
              return {
                status: "error",
                error: { code: -32603, message: t.message },
              };
            }
          }
          async request(t, e) {
            switch (t) {
              case "runes_mint":
                return this.mintRunes(e);
              case "runes_etch":
                return this.etchRunes(e);
              case "runes_estimateMint":
                return this.estimateMint(e);
              case "runes_estimateEtch":
                return this.estimateEtch(e);
              case "runes_getOrder":
                return this.getOrder(e);
              case "runes_estimateRbfOrder":
                return this.estimateRbfOrder(e);
              case "runes_rbfOrder":
                return this.rbfOrder(e);
              default:
                return this.requestInternal(t, e);
            }
          }
        };
      function Xi(t) {
        let e = [];
        for (let r in t) {
          let n = t[r];
          for (let t of n) e.push({ index: t, address: r });
        }
        return e;
      }
      var Zi = {
        fordefi: {
          id: "FordefiProviders.UtxoProvider",
          name: "Fordefi",
          webUrl: "https://www.fordefi.com/",
          chromeWebStoreUrl:
            "https://chromewebstore.google.com/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle",
          icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
        },
        xverse: {
          id: "XverseProviders.BitcoinProvider",
          name: "Xverse",
          webUrl: "https://www.xverse.app/",
          googlePlayStoreUrl:
            "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse",
          iOSAppStoreUrl:
            "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513",
          chromeWebStoreUrl:
            "https://chromewebstore.google.com/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg",
          icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgdmlld0JveD0iMCAwIDEwMiAxMDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGlkPSJJY29uX0FydCAoRWRpdCBNZSkiPgo8cmVjdCB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgZmlsbD0iIzE4MTgxOCIvPgo8ZyBpZD0iTG9nby9FbWJsZW0iIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMF8xMjIzKSI+CjxwYXRoIGlkPSJWZWN0b3IiIGQ9Ik03NC42NTQyIDczLjg4ODNWNjUuMjMxMkM3NC42NTQyIDY0Ljg4OCA3NC41MTc3IDY0LjU2MDYgNzQuMjc0NSA2NC4zMTc0TDM3LjQzOTcgMjcuNDgyNUMzNy4xOTY1IDI3LjIzOTIgMzYuODY5MSAyNy4xMDI4IDM2LjUyNTggMjcuMTAyOEgyNy44NjlDMjcuNDQxNiAyNy4xMDI4IDI3LjA5MzggMjcuNDUwNiAyNy4wOTM4IDI3Ljg3OFYzNS45MjExQzI3LjA5MzggMzYuMjY0NCAyNy4yMzAyIDM2LjU5MTcgMjcuNDczNCAzNi44MzVMNDAuNjk1MiA1MC4wNTY3QzQwLjk5NzUgNTAuMzU5MSA0MC45OTc1IDUwLjg1MDEgNDAuNjk1MiA1MS4xNTI0TDI3LjMyMTEgNjQuNTI2NUMyNy4xNzU2IDY0LjY3MiAyNy4wOTM4IDY0Ljg2OTggMjcuMDkzOCA2NS4wNzQ0VjczLjg4ODNDMjcuMDkzOCA3NC4zMTUzIDI3LjQ0MTYgNzQuNjYzNSAyNy44NjkgNzQuNjYzNUg0Mi4zMzQyQzQyLjc2MTYgNzQuNjYzNSA0My4xMDk0IDc0LjMxNTMgNDMuMTA5NCA3My44ODgzVjY4LjY5NThDNDMuMTA5NCA2OC40OTEyIDQzLjE5MTIgNjguMjkzNSA0My4zMzY4IDY4LjE0NzlMNTAuNTExNCA2MC45NzMzQzUwLjgxMzggNjAuNjcwOSA1MS4zMDQ4IDYwLjY3MDkgNTEuNjA3MiA2MC45NzMzTDY0LjkxOTggNzQuMjg2MUM2NS4xNjMxIDc0LjUyOTMgNjUuNDkwNCA3NC42NjU4IDY1LjgzMzcgNzQuNjY1OEg3My44NzY3Qzc0LjMwNDIgNzQuNjY1OCA3NC42NTE5IDc0LjMxNzYgNzQuNjUxOSA3My44OTA2TDc0LjY1NDIgNzMuODg4M1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMiIgZD0iTTU1LjM1OCAzOC41NjcySDYyLjYwMzFDNjMuMDMyOCAzOC41NjcyIDYzLjM4MjkgMzguOTE3MyA2My4zODI5IDM5LjM0NjlWNDYuNTkyMUM2My4zODI5IDQ3LjI4NzcgNjQuMjI0IDQ3LjYzNTUgNjQuNzE1MSA0Ny4xNDIyTDc0LjY1NDEgMzcuMTg3M0M3NC43OTk0IDM3LjA0MTggNzQuODgxNiAzNi44NDQgNzQuODgxNiAzNi42MzcxVjI3LjkxODlDNzQuODgxNiAyNy40ODkyIDc0LjUzMzQgMjcuMTM5MSA3NC4xMDE3IDI3LjEzOTFMNjUuMjUzOCAyNy4xMjc3QzY1LjA0NyAyNy4xMjc3IDY0Ljg0OTIgMjcuMjA5NiA2NC43MDE0IDI3LjM1NTFMNTQuODA1NiAzNy4yMzVDNTQuMzE0NSAzNy43MjYgNTQuNjYyMyAzOC41NjcyIDU1LjM1NTcgMzguNTY3Mkg1NS4zNThaIiBmaWxsPSIjRUU3QTMwIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMF8xMjIzIj4KPHJlY3Qgd2lkdGg9IjQ3LjgxMjUiIGhlaWdodD0iNDcuODEyNSIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3LjA5MzggMjcuMDkzOCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",
        },
        unisat: {
          id: "unisat",
          name: "Unisat",
          webUrl: "https://unisat.io/",
          icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAwNTBfNDE3MSkiPgo8cGF0aCBkPSJNMTEzLjY2IDI5LjI4OTdMMTQzLjk3IDU5LjMwOTdDMTQ2LjU1IDYxLjg1OTcgMTQ3LjgyIDY0LjQzOTcgMTQ3Ljc4IDY3LjAzOTdDMTQ3Ljc0IDY5LjYzOTcgMTQ2LjYzIDcyLjAwOTcgMTQ0LjQ2IDc0LjE1OTdDMTQyLjE5IDc2LjQwOTcgMTM5Ljc0IDc3LjU0OTcgMTM3LjEyIDc3LjU5OTdDMTM0LjUgNzcuNjM5NyAxMzEuOSA3Ni4zNzk3IDEyOS4zMiA3My44Mjk3TDk4LjMxOTkgNDMuMTI5N0M5NC43OTk5IDM5LjYzOTcgOTEuMzk5OSAzNy4xNjk3IDg4LjEyOTkgMzUuNzE5N0M4NC44NTk5IDM0LjI2OTcgODEuNDE5OSAzNC4wMzk3IDc3LjgxOTkgMzUuMDM5N0M3NC4yMDk5IDM2LjAyOTcgNzAuMzM5OSAzOC41Nzk3IDY2LjE4OTkgNDIuNjc5N0M2MC40Njk5IDQ4LjM0OTcgNTcuNzM5OSA1My42Njk3IDU4LjAxOTkgNTguNjM5N0M1OC4yOTk5IDYzLjYwOTcgNjEuMTM5OSA2OC43Njk3IDY2LjUyOTkgNzQuMDk5N0w5Ny43Nzk5IDEwNS4wNkMxMDAuMzkgMTA3LjY0IDEwMS42NyAxMTAuMjIgMTAxLjYzIDExMi43OEMxMDEuNTkgMTE1LjM1IDEwMC40NyAxMTcuNzIgOTguMjU5OSAxMTkuOTFDOTYuMDU5OSAxMjIuMDkgOTMuNjI5OSAxMjMuMjMgOTAuOTg5OSAxMjMuMzJDODguMzQ5OSAxMjMuNDEgODUuNzE5OSAxMjIuMTYgODMuMTE5OSAxMTkuNThMNTIuODA5OSA4OS41NTk3QzQ3Ljg3OTkgODQuNjc5NyA0NC4zMTk5IDgwLjA1OTcgNDIuMTI5OSA3NS42OTk3QzM5LjkzOTkgNzEuMzM5NyAzOS4xMTk5IDY2LjQwOTcgMzkuNjg5OSA2MC45MDk3QzQwLjE5OTkgNTYuMTk5NyA0MS43MDk5IDUxLjYzOTcgNDQuMjI5OSA0Ny4yMTk3QzQ2LjczOTkgNDIuNzk5NyA1MC4zMzk5IDM4LjI3OTcgNTUuMDA5OSAzMy42NDk3QzYwLjU2OTkgMjguMTM5NyA2NS44Nzk5IDIzLjkxOTcgNzAuOTM5OSAyMC45Nzk3Qzc1Ljk4OTkgMTguMDM5NyA4MC44Nzk5IDE2LjQwOTcgODUuNTk5OSAxNi4wNjk3QzkwLjMyOTkgMTUuNzI5NyA5NC45ODk5IDE2LjY2OTcgOTkuNTk5OSAxOC44ODk3QzEwNC4yMSAyMS4xMDk3IDEwOC44OSAyNC41Njk3IDExMy42NSAyOS4yODk3SDExMy42NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxKSIvPgo8cGF0aCBkPSJNNjYuMTA5OSAxNTAuNDJMMzUuODA5OSAxMjAuNEMzMy4yMjk5IDExNy44NCAzMS45NTk5IDExNS4yNyAzMS45OTk5IDExMi42N0MzMi4wMzk5IDExMC4wNyAzMy4xNDk5IDEwNy43IDM1LjMxOTkgMTA1LjU1QzM3LjU4OTkgMTAzLjMgNDAuMDM5OSAxMDIuMTYgNDIuNjU5OSAxMDIuMTFDNDUuMjc5OSAxMDIuMDcgNDcuODc5OSAxMDMuMzIgNTAuNDU5OSAxMDUuODhMODEuNDQ5OSAxMzYuNThDODQuOTc5OSAxNDAuMDcgODguMzY5OSAxNDIuNTQgOTEuNjM5OSAxNDMuOTlDOTQuOTA5OSAxNDUuNDQgOTguMzQ5OSAxNDUuNjYgMTAxLjk2IDE0NC42N0MxMDUuNTcgMTQzLjY4IDEwOS40NCAxNDEuMTMgMTEzLjU5IDEzNy4wMkMxMTkuMzEgMTMxLjM1IDEyMi4wNCAxMjYuMDMgMTIxLjc2IDEyMS4wNkMxMjEuNDggMTE2LjA5IDExOC42NCAxMTAuOTMgMTEzLjI1IDEwNS41OUw5Ni41OTk5IDg5LjI0MDFDOTMuOTg5OSA4Ni42NjAxIDkyLjcwOTkgODQuMDgwMSA5Mi43NDk5IDgxLjUyMDFDOTIuNzg5OSA3OC45NTAxIDkzLjkwOTkgNzYuNTgwMSA5Ni4xMTk5IDc0LjM5MDFDOTguMzE5OSA3Mi4yMTAxIDEwMC43NSA3MS4wNzAxIDEwMy4zOSA3MC45ODAxQzEwNi4wMyA3MC44OTAxIDEwOC42NiA3Mi4xNDAxIDExMS4yNiA3NC43MjAxTDEyNi45NiA5MC4xMzAxQzEzMS44OSA5NS4wMTAxIDEzNS40NSA5OS42MzAxIDEzNy42NCAxMDMuOTlDMTM5LjgzIDEwOC4zNSAxNDAuNjUgMTEzLjI4IDE0MC4wOCAxMTguNzhDMTM5LjU3IDEyMy40OSAxMzguMDYgMTI4LjA1IDEzNS41NCAxMzIuNDdDMTMzLjAzIDEzNi44OSAxMjkuNDMgMTQxLjQxIDEyNC43NiAxNDYuMDRDMTE5LjIgMTUxLjU1IDExMy44OSAxNTUuNzcgMTA4LjgzIDE1OC43MUMxMDMuNzcgMTYxLjY1IDk4Ljg3OTkgMTYzLjI5IDk0LjE0OTkgMTYzLjYzQzg5LjQxOTkgMTYzLjk3IDg0Ljc1OTkgMTYzLjAzIDgwLjE0OTkgMTYwLjgxQzc1LjUzOTkgMTU4LjU5IDcwLjg1OTkgMTU1LjEzIDY2LjA5OTkgMTUwLjQxTDY2LjEwOTkgMTUwLjQyWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzEwMDUwXzQxNzEpIi8+CjxwYXRoIGQ9Ik04NS4wMDk5IDcyLjk1OTJDOTEuMTU2OCA3Mi45NTkyIDk2LjEzOTkgNjcuOTc2MSA5Ni4xMzk5IDYxLjgyOTJDOTYuMTM5OSA1NS42ODIzIDkxLjE1NjggNTAuNjk5MiA4NS4wMDk5IDUwLjY5OTJDNzguODYzIDUwLjY5OTIgNzMuODc5OSA1NS42ODIzIDczLjg3OTkgNjEuODI5MkM3My44Nzk5IDY3Ljk3NjEgNzguODYzIDcyLjk1OTIgODUuMDA5OSA3Mi45NTkyWiIgZmlsbD0idXJsKCNwYWludDJfcmFkaWFsXzEwMDUwXzQxNzEpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iMTM4Ljk4NSIgeTE9IjQ2Ljc3OTUiIHgyPSI0NS4wNTI5IiB5Mj0iODguNTIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjAxQzFCIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRCODUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iNDMuMzgxMiIgeTE9IjEzNC4xNjciIHgyPSIxNTIuMjMxIiB5Mj0iMTAxLjc3MSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMUYxRDFDIi8+CjxzdG9wIG9mZnNldD0iMC4zNyIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRGQjUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQyX3JhZGlhbF8xMDA1MF80MTcxIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDg1LjAwOTkgNjEuODM5Mikgc2NhbGUoMTEuMTMpIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y0Qjg1MiIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0IiBzdG9wLWNvbG9yPSIjNzczOTBEIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzIxMUMxRCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMDUwXzQxNzEiPgo8cmVjdCB3aWR0aD0iMTE1Ljc3IiBoZWlnaHQ9IjE0Ny43IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIgMTYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
        },
      };
      Zi.fordefi.id, Zi.xverse.id, Zi.unisat.id;
      class Ji {
        constructor() {
          (this.keyToValue = new Map()), (this.valueToKey = new Map());
        }
        set(t, e) {
          this.keyToValue.set(t, e), this.valueToKey.set(e, t);
        }
        getByKey(t) {
          return this.keyToValue.get(t);
        }
        getByValue(t) {
          return this.valueToKey.get(t);
        }
        clear() {
          this.keyToValue.clear(), this.valueToKey.clear();
        }
      }
      class Qi {
        constructor(t) {
          (this.generateIdentifier = t), (this.kv = new Ji());
        }
        register(t, e) {
          this.kv.getByValue(t) ||
            (e || (e = this.generateIdentifier(t)), this.kv.set(e, t));
        }
        clear() {
          this.kv.clear();
        }
        getIdentifier(t) {
          return this.kv.getByValue(t);
        }
        getValue(t) {
          return this.kv.getByKey(t);
        }
      }
      class to extends Qi {
        constructor() {
          super((t) => t.name), (this.classToAllowedProps = new Map());
        }
        register(t, e) {
          "object" == typeof e
            ? (e.allowProps && this.classToAllowedProps.set(t, e.allowProps),
              super.register(t, e.identifier))
            : super.register(t, e);
        }
        getAllowedProps(t) {
          return this.classToAllowedProps.get(t);
        }
      }
      function eo(t, e) {
        const r = (function (t) {
          if ("values" in Object) return Object.values(t);
          const e = [];
          for (const r in t) t.hasOwnProperty(r) && e.push(t[r]);
          return e;
        })(t);
        if ("find" in r) return r.find(e);
        const n = r;
        for (let t = 0; t < n.length; t++) {
          const r = n[t];
          if (e(r)) return r;
        }
      }
      function ro(t, e) {
        Object.entries(t).forEach(([t, r]) => e(r, t));
      }
      function no(t, e) {
        return -1 !== t.indexOf(e);
      }
      function io(t, e) {
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          if (e(n)) return n;
        }
      }
      class oo {
        constructor() {
          this.transfomers = {};
        }
        register(t) {
          this.transfomers[t.name] = t;
        }
        findApplicable(t) {
          return eo(this.transfomers, (e) => e.isApplicable(t));
        }
        findByName(t) {
          return this.transfomers[t];
        }
      }
      const so = (t) => void 0 === t,
        ao = (t) =>
          "object" == typeof t &&
          null !== t &&
          t !== Object.prototype &&
          (null === Object.getPrototypeOf(t) ||
            Object.getPrototypeOf(t) === Object.prototype),
        uo = (t) => ao(t) && 0 === Object.keys(t).length,
        co = (t) => Array.isArray(t),
        fo = (t) => t instanceof Map,
        ho = (t) => t instanceof Set,
        lo = (t) =>
          "Symbol" ===
          ((t) => Object.prototype.toString.call(t).slice(8, -1))(t),
        po = (t) => "number" == typeof t && isNaN(t),
        yo = (t) =>
          ((t) => "boolean" == typeof t)(t) ||
          ((t) => null === t)(t) ||
          so(t) ||
          ((t) => "number" == typeof t && !isNaN(t))(t) ||
          ((t) => "string" == typeof t)(t) ||
          lo(t),
        go = (t) => t.replace(/\./g, "\\."),
        mo = (t) => t.map(String).map(go).join("."),
        bo = (t) => {
          const e = [];
          let r = "";
          for (let n = 0; n < t.length; n++) {
            let i = t.charAt(n);
            if ("\\" === i && "." === t.charAt(n + 1)) {
              (r += "."), n++;
              continue;
            }
            "." === i ? (e.push(r), (r = "")) : (r += i);
          }
          const n = r;
          return e.push(n), e;
        };
      function wo(t, e, r, n) {
        return { isApplicable: t, annotation: e, transform: r, untransform: n };
      }
      const vo = [
        wo(
          so,
          "undefined",
          () => null,
          () => {},
        ),
        wo(
          (t) => "bigint" == typeof t,
          "bigint",
          (t) => t.toString(),
          (t) =>
            "undefined" != typeof BigInt
              ? BigInt(t)
              : (console.error("Please add a BigInt polyfill."), t),
        ),
        wo(
          (t) => t instanceof Date && !isNaN(t.valueOf()),
          "Date",
          (t) => t.toISOString(),
          (t) => new Date(t),
        ),
        wo(
          (t) => t instanceof Error,
          "Error",
          (t, e) => {
            const r = { name: t.name, message: t.message };
            return (
              e.allowedErrorProps.forEach((e) => {
                r[e] = t[e];
              }),
              r
            );
          },
          (t, e) => {
            const r = new Error(t.message);
            return (
              (r.name = t.name),
              (r.stack = t.stack),
              e.allowedErrorProps.forEach((e) => {
                r[e] = t[e];
              }),
              r
            );
          },
        ),
        wo(
          (t) => t instanceof RegExp,
          "regexp",
          (t) => "" + t,
          (t) => {
            const e = t.slice(1, t.lastIndexOf("/")),
              r = t.slice(t.lastIndexOf("/") + 1);
            return new RegExp(e, r);
          },
        ),
        wo(
          ho,
          "set",
          (t) => [...t.values()],
          (t) => new Set(t),
        ),
        wo(
          fo,
          "map",
          (t) => [...t.entries()],
          (t) => new Map(t),
        ),
        wo(
          (t) => {
            return po(t) || (e = t) === 1 / 0 || e === -1 / 0;
            var e;
          },
          "number",
          (t) => (po(t) ? "NaN" : t > 0 ? "Infinity" : "-Infinity"),
          Number,
        ),
        wo(
          (t) => 0 === t && 1 / t == -1 / 0,
          "number",
          () => "-0",
          Number,
        ),
        wo(
          (t) => t instanceof URL,
          "URL",
          (t) => t.toString(),
          (t) => new URL(t),
        ),
      ];
      function _o(t, e, r, n) {
        return { isApplicable: t, annotation: e, transform: r, untransform: n };
      }
      const Eo = _o(
          (t, e) => {
            if (lo(t)) {
              return !!e.symbolRegistry.getIdentifier(t);
            }
            return !1;
          },
          (t, e) => ["symbol", e.symbolRegistry.getIdentifier(t)],
          (t) => t.description,
          (t, e, r) => {
            const n = r.symbolRegistry.getValue(e[1]);
            if (!n) throw new Error("Trying to deserialize unknown symbol");
            return n;
          },
        ),
        So = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
          Uint8ClampedArray,
        ].reduce((t, e) => ((t[e.name] = e), t), {}),
        Io = _o(
          (t) => ArrayBuffer.isView(t) && !(t instanceof DataView),
          (t) => ["typed-array", t.constructor.name],
          (t) => [...t],
          (t, e) => {
            const r = So[e[1]];
            if (!r)
              throw new Error("Trying to deserialize unknown typed array");
            return new r(t);
          },
        );
      function Mo(t, e) {
        if (t?.constructor) {
          return !!e.classRegistry.getIdentifier(t.constructor);
        }
        return !1;
      }
      const Ao = _o(
          Mo,
          (t, e) => ["class", e.classRegistry.getIdentifier(t.constructor)],
          (t, e) => {
            const r = e.classRegistry.getAllowedProps(t.constructor);
            if (!r) return { ...t };
            const n = {};
            return (
              r.forEach((e) => {
                n[e] = t[e];
              }),
              n
            );
          },
          (t, e, r) => {
            const n = r.classRegistry.getValue(e[1]);
            if (!n)
              throw new Error(
                "Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564",
              );
            return Object.assign(Object.create(n.prototype), t);
          },
        ),
        To = _o(
          (t, e) => !!e.customTransformerRegistry.findApplicable(t),
          (t, e) => [
            "custom",
            e.customTransformerRegistry.findApplicable(t).name,
          ],
          (t, e) => e.customTransformerRegistry.findApplicable(t).serialize(t),
          (t, e, r) => {
            const n = r.customTransformerRegistry.findByName(e[1]);
            if (!n)
              throw new Error("Trying to deserialize unknown custom value");
            return n.deserialize(t);
          },
        ),
        ko = [Ao, Eo, To, Io],
        Oo = (t, e) => {
          const r = io(ko, (r) => r.isApplicable(t, e));
          if (r) return { value: r.transform(t, e), type: r.annotation(t, e) };
          const n = io(vo, (r) => r.isApplicable(t, e));
          return n ? { value: n.transform(t, e), type: n.annotation } : void 0;
        },
        xo = {};
      vo.forEach((t) => {
        xo[t.annotation] = t;
      });
      const Po = (t, e) => {
        const r = t.keys();
        for (; e > 0; ) r.next(), e--;
        return r.next().value;
      };
      function Bo(t) {
        if (no(t, "__proto__"))
          throw new Error("__proto__ is not allowed as a property");
        if (no(t, "prototype"))
          throw new Error("prototype is not allowed as a property");
        if (no(t, "constructor"))
          throw new Error("constructor is not allowed as a property");
      }
      const Co = (t, e, r) => {
        if ((Bo(e), 0 === e.length)) return r(t);
        let n = t;
        for (let t = 0; t < e.length - 1; t++) {
          const r = e[t];
          if (co(n)) {
            n = n[+r];
          } else if (ao(n)) n = n[r];
          else if (ho(n)) {
            n = Po(n, +r);
          } else if (fo(n)) {
            if (t === e.length - 2) break;
            const i = +r,
              o = 0 == +e[++t] ? "key" : "value",
              s = Po(n, i);
            switch (o) {
              case "key":
                n = s;
                break;
              case "value":
                n = n.get(s);
            }
          }
        }
        const i = e[e.length - 1];
        if ((co(n) ? (n[+i] = r(n[+i])) : ao(n) && (n[i] = r(n[i])), ho(n))) {
          const t = Po(n, +i),
            e = r(t);
          t !== e && (n.delete(t), n.add(e));
        }
        if (fo(n)) {
          const t = +e[e.length - 2],
            o = Po(n, t);
          switch (0 == +i ? "key" : "value") {
            case "key": {
              const t = r(o);
              n.set(t, n.get(o)), t !== o && n.delete(o);
              break;
            }
            case "value":
              n.set(o, r(n.get(o)));
          }
        }
        return t;
      };
      function Ro(t, e, r = []) {
        if (!t) return;
        if (!co(t)) return void ro(t, (t, n) => Ro(t, e, [...r, ...bo(n)]));
        const [n, i] = t;
        i &&
          ro(i, (t, n) => {
            Ro(t, e, [...r, ...bo(n)]);
          }),
          e(n, r);
      }
      function No(t, e, r) {
        return (
          Ro(e, (e, n) => {
            t = Co(t, n, (t) =>
              ((t, e, r) => {
                if (!co(e)) {
                  const n = xo[e];
                  if (!n) throw new Error("Unknown transformation: " + e);
                  return n.untransform(t, r);
                }
                switch (e[0]) {
                  case "symbol":
                    return Eo.untransform(t, e, r);
                  case "class":
                    return Ao.untransform(t, e, r);
                  case "custom":
                    return To.untransform(t, e, r);
                  case "typed-array":
                    return Io.untransform(t, e, r);
                  default:
                    throw new Error("Unknown transformation: " + e);
                }
              })(t, e, r),
            );
          }),
          t
        );
      }
      function Uo(t, e) {
        function r(e, r) {
          const n = ((t, e) => {
            Bo(e);
            for (let r = 0; r < e.length; r++) {
              const n = e[r];
              if (ho(t)) t = Po(t, +n);
              else if (fo(t)) {
                const i = +n,
                  o = 0 == +e[++r] ? "key" : "value",
                  s = Po(t, i);
                switch (o) {
                  case "key":
                    t = s;
                    break;
                  case "value":
                    t = t.get(s);
                }
              } else t = t[n];
            }
            return t;
          })(t, bo(r));
          e.map(bo).forEach((e) => {
            t = Co(t, e, () => n);
          });
        }
        if (co(e)) {
          const [n, i] = e;
          n.forEach((e) => {
            t = Co(t, bo(e), () => t);
          }),
            i && ro(i, r);
        } else ro(e, r);
        return t;
      }
      const Do = (t, e, r, n, i = [], o = [], s = new Map()) => {
        const a = yo(t);
        if (!a) {
          !(function (t, e, r) {
            const n = r.get(t);
            n ? n.push(e) : r.set(t, [e]);
          })(t, i, e);
          const r = s.get(t);
          if (r) return n ? { transformedValue: null } : r;
        }
        if (!((t, e) => ao(t) || co(t) || fo(t) || ho(t) || Mo(t, e))(t, r)) {
          const e = Oo(t, r),
            n = e
              ? { transformedValue: e.value, annotations: [e.type] }
              : { transformedValue: t };
          return a || s.set(t, n), n;
        }
        if (no(o, t)) return { transformedValue: null };
        const u = Oo(t, r),
          c = u?.value ?? t,
          f = co(c) ? [] : {},
          h = {};
        ro(c, (a, u) => {
          if ("__proto__" === u || "constructor" === u || "prototype" === u)
            throw new Error(
              `Detected property ${u}. This is a prototype pollution risk, please remove it from your object.`,
            );
          const c = Do(a, e, r, n, [...i, u], [...o, t], s);
          (f[u] = c.transformedValue),
            co(c.annotations)
              ? (h[u] = c.annotations)
              : ao(c.annotations) &&
                ro(c.annotations, (t, e) => {
                  h[go(u) + "." + e] = t;
                });
        });
        const l = uo(h)
          ? { transformedValue: f, annotations: u ? [u.type] : void 0 }
          : { transformedValue: f, annotations: u ? [u.type, h] : h };
        return a || s.set(t, l), l;
      };
      function Lo(t) {
        return Object.prototype.toString.call(t).slice(8, -1);
      }
      function jo(t) {
        return "Undefined" === Lo(t);
      }
      function Fo(t) {
        return "Null" === Lo(t);
      }
      function Ho(t) {
        if ("Object" !== Lo(t)) return !1;
        const e = Object.getPrototypeOf(t);
        return !!e && e.constructor === Object && e === Object.prototype;
      }
      function Ko(t) {
        return "Array" === Lo(t);
      }
      function Vo(t, e = {}) {
        if (Ko(t)) return t.map((t) => Vo(t, e));
        if (!Ho(t)) return t;
        return [
          ...Object.getOwnPropertyNames(t),
          ...Object.getOwnPropertySymbols(t),
        ].reduce((r, n) => {
          if (Ko(e.props) && !e.props.includes(n)) return r;
          return (
            (function (t, e, r, n, i) {
              const o = {}.propertyIsEnumerable.call(n, e)
                ? "enumerable"
                : "nonenumerable";
              "enumerable" === o && (t[e] = r),
                i &&
                  "nonenumerable" === o &&
                  Object.defineProperty(t, e, {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  });
            })(r, n, Vo(t[n], e), t, e.nonenumerable),
            r
          );
        }, {});
      }
      class qo {
        constructor({ dedupe: t = !1 } = {}) {
          (this.classRegistry = new to()),
            (this.symbolRegistry = new Qi((t) => t.description ?? "")),
            (this.customTransformerRegistry = new oo()),
            (this.allowedErrorProps = []),
            (this.dedupe = t);
        }
        serialize(t) {
          const e = new Map(),
            r = Do(t, e, this, this.dedupe),
            n = { json: r.transformedValue };
          r.annotations && (n.meta = { ...n.meta, values: r.annotations });
          const i = (function (t, e) {
            const r = {};
            let n;
            return (
              t.forEach((t) => {
                if (t.length <= 1) return;
                e ||
                  (t = t
                    .map((t) => t.map(String))
                    .sort((t, e) => t.length - e.length));
                const [i, ...o] = t;
                0 === i.length ? (n = o.map(mo)) : (r[mo(i)] = o.map(mo));
              }),
              n ? (uo(r) ? [n] : [n, r]) : uo(r) ? void 0 : r
            );
          })(e, this.dedupe);
          return i && (n.meta = { ...n.meta, referentialEqualities: i }), n;
        }
        deserialize(t) {
          const { json: e, meta: r } = t;
          let n = Vo(e);
          return (
            r?.values && (n = No(n, r.values, this)),
            r?.referentialEqualities && (n = Uo(n, r.referentialEqualities)),
            n
          );
        }
        stringify(t) {
          return JSON.stringify(this.serialize(t));
        }
        parse(t) {
          return this.deserialize(JSON.parse(t));
        }
        registerClass(t, e) {
          this.classRegistry.register(t, e);
        }
        registerSymbol(t, e) {
          this.symbolRegistry.register(t, e);
        }
        registerCustom(t, e) {
          this.customTransformerRegistry.register({ name: e, ...t });
        }
        allowErrorProps(...t) {
          this.allowedErrorProps.push(...t);
        }
      }
      (qo.defaultInstance = new qo()),
        (qo.serialize = qo.defaultInstance.serialize.bind(qo.defaultInstance)),
        (qo.deserialize = qo.defaultInstance.deserialize.bind(
          qo.defaultInstance,
        )),
        (qo.stringify = qo.defaultInstance.stringify.bind(qo.defaultInstance)),
        (qo.parse = qo.defaultInstance.parse.bind(qo.defaultInstance)),
        (qo.registerClass = qo.defaultInstance.registerClass.bind(
          qo.defaultInstance,
        )),
        (qo.registerSymbol = qo.defaultInstance.registerSymbol.bind(
          qo.defaultInstance,
        )),
        (qo.registerCustom = qo.defaultInstance.registerCustom.bind(
          qo.defaultInstance,
        )),
        (qo.allowErrorProps = qo.defaultInstance.allowErrorProps.bind(
          qo.defaultInstance,
        ));
      qo.serialize, qo.deserialize;
      const zo = qo.stringify;
      qo.parse,
        qo.registerClass,
        qo.registerCustom,
        qo.registerSymbol,
        qo.allowErrorProps;
      function $o(t) {
        const e = t.sender?.tab?.id;
        if (!e)
          throw new Error("Could not determine tab id from port.", {
            cause: t,
          });
        return e;
      }
      function Go(t) {
        const e = t.sender?.url
          ? new URL(t.sender.url).origin
          : t.sender?.origin;
        if (!e)
          throw new Error("Could not determine origin from port.", {
            cause: t,
          });
        return e;
      }
      function Wo(t) {
        return (0, N.createUnsecuredToken)(zo(t));
      }
      function Yo(t) {
        return chrome.runtime.sendMessage(t);
      }
      var Xo;
      !(function (t) {
        (t[(t.SMALLEST = 0)] = "SMALLEST"),
          (t[(t.SMALL = 1)] = "SMALL"),
          (t[(t.MEDIUM = 2)] = "MEDIUM"),
          (t[(t.LARGE = 3)] = "LARGE");
      })(Xo || (Xo = {}));
      const Zo = 375;
      var Jo;
      !(function (t) {
        (t.Home = "/"),
          (t.TransactionRequest = "/transaction-request"),
          (t.StxSignTransactions = "/stx-sign-transactions"),
          (t.AuthenticationRequest = "/authentication-request"),
          (t.SignatureRequest = "/signature-request"),
          (t.SignMessageRequest = "/sign-message-request"),
          (t.SignRuneDelistingMessage = "/sign-rune-delisting-message"),
          (t.AddressRequest = "/btc-select-address-request"),
          (t.StxAddressRequest = "/stx-select-address-request"),
          (t.StxAccountRequest = "/stx-select-account-request"),
          (t.SignBtcTx = "/psbt-signing-request"),
          (t.SignBatchBtcTx = "/batch-psbt-signing-request"),
          (t.RuneListingBatchSigning = "/rune-listing-batch-signing"),
          (t.SendBtcTx = "/btc-send-request"),
          (t.CreateInscription = "/create-inscription"),
          (t.CreateRepeatInscriptions = "/create-repeat-inscriptions"),
          (t.ConnectionRequest = "/connection-request"),
          (t.MintRune = "/mint-rune"),
          (t.EtchRune = "/etch-rune"),
          (t.ChangeNetworkRequest = "/change-network-request");
      })(Jo || (Jo = {}));
      const Qo = Jo;
      function ts(t, e) {
        const r = new URLSearchParams(),
          n = Go(t),
          i = $o(t);
        r.set("origin", n ?? ""), r.set("tabId", i?.toString() ?? "");
        let o = [];
        return (
          Array.isArray(e)
            ? (o = e)
            : "object" == typeof e && (o = Object.entries(e)),
          o.forEach(([t, e]) => "string" == typeof e && r.set(t, e)),
          { urlParams: r, origin: n, tabId: i }
        );
      }
      function es({ id: t, tabId: e, response: r }) {
        chrome.windows.onRemoved.addListener((n) => {
          if (n !== t || !e) return;
          const i = r;
          chrome.tabs.sendMessage(e, i);
        });
      }
      function rs({ request: t, response: e }) {
        return {
          source: r,
          method: n.signatureResponse,
          payload: { signatureRequest: t, signatureResponse: e },
        };
      }
      function ns({ tabId: t }) {
        chrome.tabs.onRemoved.addListener((e) => {
          t === e &&
            Yo({ method: s.OriginatingTabClosed, payload: { tabId: t } });
        });
      }
      async function is(t, e) {
        return (function (t) {
          const { url: e, w: r = Zo, h: n = 600 } = t;
          return new Promise((t) => {
            chrome.windows.getCurrent(async (i) => {
              const o = i.left ?? 0,
                s = i.top ?? 0,
                { width: a = 0, height: u = 0 } = i,
                c = Math.floor(a / 2 - r / 2 + o),
                f = Math.floor(u / 2 - n / 2 + s),
                h = await chrome.windows.create({
                  url: e,
                  width: r,
                  height: n,
                  top: f,
                  left: c,
                  focused: !0,
                  type: "popup",
                });
              t(h);
            });
          });
        })({ url: `/popup.html#${t}?${e.toString()}` });
      }
      var os = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
        ss = Math.ceil,
        as = Math.floor,
        us = "[BigNumber Error] ",
        cs = us + "Number primitive has more than 15 significant digits: ",
        fs = 1e14,
        hs = 14,
        ls = 9007199254740991,
        ds = [
          1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13,
        ],
        ps = 1e7,
        ys = 1e9;
      function gs(t) {
        var e = 0 | t;
        return t > 0 || t === e ? e : e - 1;
      }
      function ms(t) {
        for (var e, r, n = 1, i = t.length, o = t[0] + ""; n < i; ) {
          for (e = t[n++] + "", r = hs - e.length; r--; e = "0" + e);
          o += e;
        }
        for (i = o.length; 48 === o.charCodeAt(--i); );
        return o.slice(0, i + 1 || 1);
      }
      function bs(t, e) {
        var r,
          n,
          i = t.c,
          o = e.c,
          s = t.s,
          a = e.s,
          u = t.e,
          c = e.e;
        if (!s || !a) return null;
        if (((r = i && !i[0]), (n = o && !o[0]), r || n))
          return r ? (n ? 0 : -a) : s;
        if (s != a) return s;
        if (((r = s < 0), (n = u == c), !i || !o))
          return n ? 0 : !i ^ r ? 1 : -1;
        if (!n) return (u > c) ^ r ? 1 : -1;
        for (a = (u = i.length) < (c = o.length) ? u : c, s = 0; s < a; s++)
          if (i[s] != o[s]) return (i[s] > o[s]) ^ r ? 1 : -1;
        return u == c ? 0 : (u > c) ^ r ? 1 : -1;
      }
      function ws(t, e, r, n) {
        if (t < e || t > r || t !== as(t))
          throw Error(
            us +
              (n || "Argument") +
              ("number" == typeof t
                ? t < e || t > r
                  ? " out of range: "
                  : " not an integer: "
                : " not a primitive number: ") +
              String(t),
          );
      }
      function vs(t) {
        var e = t.c.length - 1;
        return gs(t.e / hs) == e && t.c[e] % 2 != 0;
      }
      function _s(t, e) {
        return (
          (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) +
          (e < 0 ? "e" : "e+") +
          e
        );
      }
      function Es(t, e, r) {
        var n, i;
        if (e < 0) {
          for (i = r + "."; ++e; i += r);
          t = i + t;
        } else if (++e > (n = t.length)) {
          for (i = r, e -= n; --e; i += r);
          t += i;
        } else e < n && (t = t.slice(0, e) + "." + t.slice(e));
        return t;
      }
      var Ss = (function t(e) {
        var r,
          n,
          i,
          o,
          s,
          a,
          u,
          c,
          f,
          h,
          l = (A.prototype = { constructor: A, toString: null, valueOf: null }),
          d = new A(1),
          p = 20,
          y = 4,
          g = -7,
          m = 21,
          b = -1e7,
          w = 1e7,
          v = !1,
          _ = 1,
          E = 0,
          S = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: " ",
            suffix: "",
          },
          I = "0123456789abcdefghijklmnopqrstuvwxyz",
          M = !0;
        function A(t, e) {
          var r,
            o,
            s,
            a,
            u,
            c,
            f,
            h,
            l = this;
          if (!(l instanceof A)) return new A(t, e);
          if (null == e) {
            if (t && !0 === t._isBigNumber)
              return (
                (l.s = t.s),
                void (!t.c || t.e > w
                  ? (l.c = l.e = null)
                  : t.e < b
                    ? (l.c = [(l.e = 0)])
                    : ((l.e = t.e), (l.c = t.c.slice())))
              );
            if ((c = "number" == typeof t) && 0 * t == 0) {
              if (((l.s = 1 / t < 0 ? ((t = -t), -1) : 1), t === ~~t)) {
                for (a = 0, u = t; u >= 10; u /= 10, a++);
                return void (a > w
                  ? (l.c = l.e = null)
                  : ((l.e = a), (l.c = [t])));
              }
              h = String(t);
            } else {
              if (!os.test((h = String(t)))) return i(l, h, c);
              l.s = 45 == h.charCodeAt(0) ? ((h = h.slice(1)), -1) : 1;
            }
            (a = h.indexOf(".")) > -1 && (h = h.replace(".", "")),
              (u = h.search(/e/i)) > 0
                ? (a < 0 && (a = u),
                  (a += +h.slice(u + 1)),
                  (h = h.substring(0, u)))
                : a < 0 && (a = h.length);
          } else {
            if ((ws(e, 2, I.length, "Base"), 10 == e && M))
              return x((l = new A(t)), p + l.e + 1, y);
            if (((h = String(t)), (c = "number" == typeof t))) {
              if (0 * t != 0) return i(l, h, c, e);
              if (
                ((l.s = 1 / t < 0 ? ((h = h.slice(1)), -1) : 1),
                A.DEBUG && h.replace(/^0\.0*|\./, "").length > 15)
              )
                throw Error(cs + t);
            } else l.s = 45 === h.charCodeAt(0) ? ((h = h.slice(1)), -1) : 1;
            for (r = I.slice(0, e), a = u = 0, f = h.length; u < f; u++)
              if (r.indexOf((o = h.charAt(u))) < 0) {
                if ("." == o) {
                  if (u > a) {
                    a = f;
                    continue;
                  }
                } else if (
                  !s &&
                  ((h == h.toUpperCase() && (h = h.toLowerCase())) ||
                    (h == h.toLowerCase() && (h = h.toUpperCase())))
                ) {
                  (s = !0), (u = -1), (a = 0);
                  continue;
                }
                return i(l, String(t), c, e);
              }
            (c = !1),
              (a = (h = n(h, e, 10, l.s)).indexOf(".")) > -1
                ? (h = h.replace(".", ""))
                : (a = h.length);
          }
          for (u = 0; 48 === h.charCodeAt(u); u++);
          for (f = h.length; 48 === h.charCodeAt(--f); );
          if ((h = h.slice(u, ++f))) {
            if (((f -= u), c && A.DEBUG && f > 15 && (t > ls || t !== as(t))))
              throw Error(cs + l.s * t);
            if ((a = a - u - 1) > w) l.c = l.e = null;
            else if (a < b) l.c = [(l.e = 0)];
            else {
              if (
                ((l.e = a),
                (l.c = []),
                (u = (a + 1) % hs),
                a < 0 && (u += hs),
                u < f)
              ) {
                for (u && l.c.push(+h.slice(0, u)), f -= hs; u < f; )
                  l.c.push(+h.slice(u, (u += hs)));
                u = hs - (h = h.slice(u)).length;
              } else u -= f;
              for (; u--; h += "0");
              l.c.push(+h);
            }
          } else l.c = [(l.e = 0)];
        }
        function T(t, e, r, n) {
          var i, o, s, a, u;
          if ((null == r ? (r = y) : ws(r, 0, 8), !t.c)) return t.toString();
          if (((i = t.c[0]), (s = t.e), null == e))
            (u = ms(t.c)),
              (u =
                1 == n || (2 == n && (s <= g || s >= m))
                  ? _s(u, s)
                  : Es(u, s, "0"));
          else if (
            ((o = (t = x(new A(t), e, r)).e),
            (a = (u = ms(t.c)).length),
            1 == n || (2 == n && (e <= o || o <= g)))
          ) {
            for (; a < e; u += "0", a++);
            u = _s(u, o);
          } else if (((e -= s), (u = Es(u, o, "0")), o + 1 > a)) {
            if (--e > 0) for (u += "."; e--; u += "0");
          } else if ((e += o - a) > 0)
            for (o + 1 == a && (u += "."); e--; u += "0");
          return t.s < 0 && i ? "-" + u : u;
        }
        function k(t, e) {
          for (var r, n, i = 1, o = new A(t[0]); i < t.length; i++)
            (!(n = new A(t[i])).s ||
              (r = bs(o, n)) === e ||
              (0 === r && o.s === e)) &&
              (o = n);
          return o;
        }
        function O(t, e, r) {
          for (var n = 1, i = e.length; !e[--i]; e.pop());
          for (i = e[0]; i >= 10; i /= 10, n++);
          return (
            (r = n + r * hs - 1) > w
              ? (t.c = t.e = null)
              : r < b
                ? (t.c = [(t.e = 0)])
                : ((t.e = r), (t.c = e)),
            t
          );
        }
        function x(t, e, r, n) {
          var i,
            o,
            s,
            a,
            u,
            c,
            f,
            h = t.c,
            l = ds;
          if (h) {
            t: {
              for (i = 1, a = h[0]; a >= 10; a /= 10, i++);
              if ((o = e - i) < 0)
                (o += hs),
                  (s = e),
                  (u = h[(c = 0)]),
                  (f = as((u / l[i - s - 1]) % 10));
              else if ((c = ss((o + 1) / hs)) >= h.length) {
                if (!n) break t;
                for (; h.length <= c; h.push(0));
                (u = f = 0), (i = 1), (s = (o %= hs) - hs + 1);
              } else {
                for (u = a = h[c], i = 1; a >= 10; a /= 10, i++);
                f =
                  (s = (o %= hs) - hs + i) < 0
                    ? 0
                    : as((u / l[i - s - 1]) % 10);
              }
              if (
                ((n =
                  n ||
                  e < 0 ||
                  null != h[c + 1] ||
                  (s < 0 ? u : u % l[i - s - 1])),
                (n =
                  r < 4
                    ? (f || n) && (0 == r || r == (t.s < 0 ? 3 : 2))
                    : f > 5 ||
                      (5 == f &&
                        (4 == r ||
                          n ||
                          (6 == r &&
                            (o > 0 ? (s > 0 ? u / l[i - s] : 0) : h[c - 1]) %
                              10 &
                              1) ||
                          r == (t.s < 0 ? 8 : 7)))),
                e < 1 || !h[0])
              )
                return (
                  (h.length = 0),
                  n
                    ? ((e -= t.e + 1),
                      (h[0] = l[(hs - (e % hs)) % hs]),
                      (t.e = -e || 0))
                    : (h[0] = t.e = 0),
                  t
                );
              if (
                (0 == o
                  ? ((h.length = c), (a = 1), c--)
                  : ((h.length = c + 1),
                    (a = l[hs - o]),
                    (h[c] = s > 0 ? as((u / l[i - s]) % l[s]) * a : 0)),
                n)
              )
                for (;;) {
                  if (0 == c) {
                    for (o = 1, s = h[0]; s >= 10; s /= 10, o++);
                    for (s = h[0] += a, a = 1; s >= 10; s /= 10, a++);
                    o != a && (t.e++, h[0] == fs && (h[0] = 1));
                    break;
                  }
                  if (((h[c] += a), h[c] != fs)) break;
                  (h[c--] = 0), (a = 1);
                }
              for (o = h.length; 0 === h[--o]; h.pop());
            }
            t.e > w ? (t.c = t.e = null) : t.e < b && (t.c = [(t.e = 0)]);
          }
          return t;
        }
        function P(t) {
          var e,
            r = t.e;
          return null === r
            ? t.toString()
            : ((e = ms(t.c)),
              (e = r <= g || r >= m ? _s(e, r) : Es(e, r, "0")),
              t.s < 0 ? "-" + e : e);
        }
        return (
          (A.clone = t),
          (A.ROUND_UP = 0),
          (A.ROUND_DOWN = 1),
          (A.ROUND_CEIL = 2),
          (A.ROUND_FLOOR = 3),
          (A.ROUND_HALF_UP = 4),
          (A.ROUND_HALF_DOWN = 5),
          (A.ROUND_HALF_EVEN = 6),
          (A.ROUND_HALF_CEIL = 7),
          (A.ROUND_HALF_FLOOR = 8),
          (A.EUCLID = 9),
          (A.config = A.set =
            function (t) {
              var e, r;
              if (null != t) {
                if ("object" != typeof t)
                  throw Error(us + "Object expected: " + t);
                if (
                  (t.hasOwnProperty((e = "DECIMAL_PLACES")) &&
                    (ws((r = t[e]), 0, ys, e), (p = r)),
                  t.hasOwnProperty((e = "ROUNDING_MODE")) &&
                    (ws((r = t[e]), 0, 8, e), (y = r)),
                  t.hasOwnProperty((e = "EXPONENTIAL_AT")) &&
                    ((r = t[e]) && r.pop
                      ? (ws(r[0], -ys, 0, e),
                        ws(r[1], 0, ys, e),
                        (g = r[0]),
                        (m = r[1]))
                      : (ws(r, -ys, ys, e), (g = -(m = r < 0 ? -r : r)))),
                  t.hasOwnProperty((e = "RANGE")))
                )
                  if ((r = t[e]) && r.pop)
                    ws(r[0], -ys, -1, e),
                      ws(r[1], 1, ys, e),
                      (b = r[0]),
                      (w = r[1]);
                  else {
                    if ((ws(r, -ys, ys, e), !r))
                      throw Error(us + e + " cannot be zero: " + r);
                    b = -(w = r < 0 ? -r : r);
                  }
                if (t.hasOwnProperty((e = "CRYPTO"))) {
                  if ((r = t[e]) !== !!r)
                    throw Error(us + e + " not true or false: " + r);
                  if (r) {
                    if (
                      "undefined" == typeof crypto ||
                      !crypto ||
                      (!crypto.getRandomValues && !crypto.randomBytes)
                    )
                      throw ((v = !r), Error(us + "crypto unavailable"));
                    v = r;
                  } else v = r;
                }
                if (
                  (t.hasOwnProperty((e = "MODULO_MODE")) &&
                    (ws((r = t[e]), 0, 9, e), (_ = r)),
                  t.hasOwnProperty((e = "POW_PRECISION")) &&
                    (ws((r = t[e]), 0, ys, e), (E = r)),
                  t.hasOwnProperty((e = "FORMAT")))
                ) {
                  if ("object" != typeof (r = t[e]))
                    throw Error(us + e + " not an object: " + r);
                  S = r;
                }
                if (t.hasOwnProperty((e = "ALPHABET"))) {
                  if (
                    "string" != typeof (r = t[e]) ||
                    /^.?$|[+\-.\s]|(.).*\1/.test(r)
                  )
                    throw Error(us + e + " invalid: " + r);
                  (M = "0123456789" == r.slice(0, 10)), (I = r);
                }
              }
              return {
                DECIMAL_PLACES: p,
                ROUNDING_MODE: y,
                EXPONENTIAL_AT: [g, m],
                RANGE: [b, w],
                CRYPTO: v,
                MODULO_MODE: _,
                POW_PRECISION: E,
                FORMAT: S,
                ALPHABET: I,
              };
            }),
          (A.isBigNumber = function (t) {
            if (!t || !0 !== t._isBigNumber) return !1;
            if (!A.DEBUG) return !0;
            var e,
              r,
              n = t.c,
              i = t.e,
              o = t.s;
            t: if ("[object Array]" == {}.toString.call(n)) {
              if ((1 === o || -1 === o) && i >= -ys && i <= ys && i === as(i)) {
                if (0 === n[0]) {
                  if (0 === i && 1 === n.length) return !0;
                  break t;
                }
                if (
                  ((e = (i + 1) % hs) < 1 && (e += hs),
                  String(n[0]).length == e)
                ) {
                  for (e = 0; e < n.length; e++)
                    if ((r = n[e]) < 0 || r >= fs || r !== as(r)) break t;
                  if (0 !== r) return !0;
                }
              }
            } else if (
              null === n &&
              null === i &&
              (null === o || 1 === o || -1 === o)
            )
              return !0;
            throw Error(us + "Invalid BigNumber: " + t);
          }),
          (A.maximum = A.max =
            function () {
              return k(arguments, -1);
            }),
          (A.minimum = A.min =
            function () {
              return k(arguments, 1);
            }),
          (A.random =
            ((o = 9007199254740992),
            (s =
              (Math.random() * o) & 2097151
                ? function () {
                    return as(Math.random() * o);
                  }
                : function () {
                    return (
                      8388608 * ((1073741824 * Math.random()) | 0) +
                      ((8388608 * Math.random()) | 0)
                    );
                  }),
            function (t) {
              var e,
                r,
                n,
                i,
                o,
                a = 0,
                u = [],
                c = new A(d);
              if ((null == t ? (t = p) : ws(t, 0, ys), (i = ss(t / hs)), v))
                if (crypto.getRandomValues) {
                  for (
                    e = crypto.getRandomValues(new Uint32Array((i *= 2)));
                    a < i;

                  )
                    (o = 131072 * e[a] + (e[a + 1] >>> 11)) >= 9e15
                      ? ((r = crypto.getRandomValues(new Uint32Array(2))),
                        (e[a] = r[0]),
                        (e[a + 1] = r[1]))
                      : (u.push(o % 1e14), (a += 2));
                  a = i / 2;
                } else {
                  if (!crypto.randomBytes)
                    throw ((v = !1), Error(us + "crypto unavailable"));
                  for (e = crypto.randomBytes((i *= 7)); a < i; )
                    (o =
                      281474976710656 * (31 & e[a]) +
                      1099511627776 * e[a + 1] +
                      4294967296 * e[a + 2] +
                      16777216 * e[a + 3] +
                      (e[a + 4] << 16) +
                      (e[a + 5] << 8) +
                      e[a + 6]) >= 9e15
                      ? crypto.randomBytes(7).copy(e, a)
                      : (u.push(o % 1e14), (a += 7));
                  a = i / 7;
                }
              if (!v) for (; a < i; ) (o = s()) < 9e15 && (u[a++] = o % 1e14);
              for (
                i = u[--a],
                  t %= hs,
                  i && t && ((o = ds[hs - t]), (u[a] = as(i / o) * o));
                0 === u[a];
                u.pop(), a--
              );
              if (a < 0) u = [(n = 0)];
              else {
                for (n = -1; 0 === u[0]; u.splice(0, 1), n -= hs);
                for (a = 1, o = u[0]; o >= 10; o /= 10, a++);
                a < hs && (n -= hs - a);
              }
              return (c.e = n), (c.c = u), c;
            })),
          (A.sum = function () {
            for (var t = 1, e = arguments, r = new A(e[0]); t < e.length; )
              r = r.plus(e[t++]);
            return r;
          }),
          (n = (function () {
            var t = "0123456789";
            function e(t, e, r, n) {
              for (var i, o, s = [0], a = 0, u = t.length; a < u; ) {
                for (o = s.length; o--; s[o] *= e);
                for (s[0] += n.indexOf(t.charAt(a++)), i = 0; i < s.length; i++)
                  s[i] > r - 1 &&
                    (null == s[i + 1] && (s[i + 1] = 0),
                    (s[i + 1] += (s[i] / r) | 0),
                    (s[i] %= r));
              }
              return s.reverse();
            }
            return function (n, i, o, s, a) {
              var u,
                c,
                f,
                h,
                l,
                d,
                g,
                m,
                b = n.indexOf("."),
                w = p,
                v = y;
              for (
                b >= 0 &&
                  ((h = E),
                  (E = 0),
                  (n = n.replace(".", "")),
                  (d = (m = new A(i)).pow(n.length - b)),
                  (E = h),
                  (m.c = e(Es(ms(d.c), d.e, "0"), 10, o, t)),
                  (m.e = m.c.length)),
                  f = h =
                    (g = e(n, i, o, a ? ((u = I), t) : ((u = t), I))).length;
                0 == g[--h];
                g.pop()
              );
              if (!g[0]) return u.charAt(0);
              if (
                (b < 0
                  ? --f
                  : ((d.c = g),
                    (d.e = f),
                    (d.s = s),
                    (g = (d = r(d, m, w, v, o)).c),
                    (l = d.r),
                    (f = d.e)),
                (b = g[(c = f + w + 1)]),
                (h = o / 2),
                (l = l || c < 0 || null != g[c + 1]),
                (l =
                  v < 4
                    ? (null != b || l) && (0 == v || v == (d.s < 0 ? 3 : 2))
                    : b > h ||
                      (b == h &&
                        (4 == v ||
                          l ||
                          (6 == v && 1 & g[c - 1]) ||
                          v == (d.s < 0 ? 8 : 7)))),
                c < 1 || !g[0])
              )
                n = l ? Es(u.charAt(1), -w, u.charAt(0)) : u.charAt(0);
              else {
                if (((g.length = c), l))
                  for (--o; ++g[--c] > o; )
                    (g[c] = 0), c || (++f, (g = [1].concat(g)));
                for (h = g.length; !g[--h]; );
                for (b = 0, n = ""; b <= h; n += u.charAt(g[b++]));
                n = Es(n, f, u.charAt(0));
              }
              return n;
            };
          })()),
          (r = (function () {
            function t(t, e, r) {
              var n,
                i,
                o,
                s,
                a = 0,
                u = t.length,
                c = e % ps,
                f = (e / ps) | 0;
              for (t = t.slice(); u--; )
                (a =
                  (((i =
                    c * (o = t[u] % ps) +
                    ((n = f * o + (s = (t[u] / ps) | 0) * c) % ps) * ps +
                    a) /
                    r) |
                    0) +
                  ((n / ps) | 0) +
                  f * s),
                  (t[u] = i % r);
              return a && (t = [a].concat(t)), t;
            }
            function e(t, e, r, n) {
              var i, o;
              if (r != n) o = r > n ? 1 : -1;
              else
                for (i = o = 0; i < r; i++)
                  if (t[i] != e[i]) {
                    o = t[i] > e[i] ? 1 : -1;
                    break;
                  }
              return o;
            }
            function r(t, e, r, n) {
              for (var i = 0; r--; )
                (t[r] -= i),
                  (i = t[r] < e[r] ? 1 : 0),
                  (t[r] = i * n + t[r] - e[r]);
              for (; !t[0] && t.length > 1; t.splice(0, 1));
            }
            return function (n, i, o, s, a) {
              var u,
                c,
                f,
                h,
                l,
                d,
                p,
                y,
                g,
                m,
                b,
                w,
                v,
                _,
                E,
                S,
                I,
                M = n.s == i.s ? 1 : -1,
                T = n.c,
                k = i.c;
              if (!(T && T[0] && k && k[0]))
                return new A(
                  n.s && i.s && (T ? !k || T[0] != k[0] : k)
                    ? (T && 0 == T[0]) || !k
                      ? 0 * M
                      : M / 0
                    : NaN,
                );
              for (
                g = (y = new A(M)).c = [],
                  M = o + (c = n.e - i.e) + 1,
                  a ||
                    ((a = fs),
                    (c = gs(n.e / hs) - gs(i.e / hs)),
                    (M = (M / hs) | 0)),
                  f = 0;
                k[f] == (T[f] || 0);
                f++
              );
              if ((k[f] > (T[f] || 0) && c--, M < 0)) g.push(1), (h = !0);
              else {
                for (
                  _ = T.length,
                    S = k.length,
                    f = 0,
                    M += 2,
                    (l = as(a / (k[0] + 1))) > 1 &&
                      ((k = t(k, l, a)),
                      (T = t(T, l, a)),
                      (S = k.length),
                      (_ = T.length)),
                    v = S,
                    b = (m = T.slice(0, S)).length;
                  b < S;
                  m[b++] = 0
                );
                (I = k.slice()),
                  (I = [0].concat(I)),
                  (E = k[0]),
                  k[1] >= a / 2 && E++;
                do {
                  if (((l = 0), (u = e(k, m, S, b)) < 0)) {
                    if (
                      ((w = m[0]),
                      S != b && (w = w * a + (m[1] || 0)),
                      (l = as(w / E)) > 1)
                    )
                      for (
                        l >= a && (l = a - 1),
                          p = (d = t(k, l, a)).length,
                          b = m.length;
                        1 == e(d, m, p, b);

                      )
                        l--, r(d, S < p ? I : k, p, a), (p = d.length), (u = 1);
                    else 0 == l && (u = l = 1), (p = (d = k.slice()).length);
                    if (
                      (p < b && (d = [0].concat(d)),
                      r(m, d, b, a),
                      (b = m.length),
                      -1 == u)
                    )
                      for (; e(k, m, S, b) < 1; )
                        l++, r(m, S < b ? I : k, b, a), (b = m.length);
                  } else 0 === u && (l++, (m = [0]));
                  (g[f++] = l),
                    m[0] ? (m[b++] = T[v] || 0) : ((m = [T[v]]), (b = 1));
                } while ((v++ < _ || null != m[0]) && M--);
                (h = null != m[0]), g[0] || g.splice(0, 1);
              }
              if (a == fs) {
                for (f = 1, M = g[0]; M >= 10; M /= 10, f++);
                x(y, o + (y.e = f + c * hs - 1) + 1, s, h);
              } else (y.e = c), (y.r = +h);
              return y;
            };
          })()),
          (a = /^(-?)0([xbo])(?=\w[\w.]*$)/i),
          (u = /^([^.]+)\.$/),
          (c = /^\.([^.]+)$/),
          (f = /^-?(Infinity|NaN)$/),
          (h = /^\s*\+(?=[\w.])|^\s+|\s+$/g),
          (i = function (t, e, r, n) {
            var i,
              o = r ? e : e.replace(h, "");
            if (f.test(o)) t.s = isNaN(o) ? null : o < 0 ? -1 : 1;
            else {
              if (
                !r &&
                ((o = o.replace(a, function (t, e, r) {
                  return (
                    (i = "x" == (r = r.toLowerCase()) ? 16 : "b" == r ? 2 : 8),
                    n && n != i ? t : e
                  );
                })),
                n && ((i = n), (o = o.replace(u, "$1").replace(c, "0.$1"))),
                e != o)
              )
                return new A(o, i);
              if (A.DEBUG)
                throw Error(
                  us + "Not a" + (n ? " base " + n : "") + " number: " + e,
                );
              t.s = null;
            }
            t.c = t.e = null;
          }),
          (l.absoluteValue = l.abs =
            function () {
              var t = new A(this);
              return t.s < 0 && (t.s = 1), t;
            }),
          (l.comparedTo = function (t, e) {
            return bs(this, new A(t, e));
          }),
          (l.decimalPlaces = l.dp =
            function (t, e) {
              var r,
                n,
                i,
                o = this;
              if (null != t)
                return (
                  ws(t, 0, ys),
                  null == e ? (e = y) : ws(e, 0, 8),
                  x(new A(o), t + o.e + 1, e)
                );
              if (!(r = o.c)) return null;
              if (
                ((n = ((i = r.length - 1) - gs(this.e / hs)) * hs), (i = r[i]))
              )
                for (; i % 10 == 0; i /= 10, n--);
              return n < 0 && (n = 0), n;
            }),
          (l.dividedBy = l.div =
            function (t, e) {
              return r(this, new A(t, e), p, y);
            }),
          (l.dividedToIntegerBy = l.idiv =
            function (t, e) {
              return r(this, new A(t, e), 0, 1);
            }),
          (l.exponentiatedBy = l.pow =
            function (t, e) {
              var r,
                n,
                i,
                o,
                s,
                a,
                u,
                c,
                f = this;
              if ((t = new A(t)).c && !t.isInteger())
                throw Error(us + "Exponent not an integer: " + P(t));
              if (
                (null != e && (e = new A(e)),
                (s = t.e > 14),
                !f.c ||
                  !f.c[0] ||
                  (1 == f.c[0] && !f.e && 1 == f.c.length) ||
                  !t.c ||
                  !t.c[0])
              )
                return (
                  (c = new A(Math.pow(+P(f), s ? t.s * (2 - vs(t)) : +P(t)))),
                  e ? c.mod(e) : c
                );
              if (((a = t.s < 0), e)) {
                if (e.c ? !e.c[0] : !e.s) return new A(NaN);
                (n = !a && f.isInteger() && e.isInteger()) && (f = f.mod(e));
              } else {
                if (
                  t.e > 9 &&
                  (f.e > 0 ||
                    f.e < -1 ||
                    (0 == f.e
                      ? f.c[0] > 1 || (s && f.c[1] >= 24e7)
                      : f.c[0] < 8e13 || (s && f.c[0] <= 9999975e7)))
                )
                  return (
                    (o = f.s < 0 && vs(t) ? -0 : 0),
                    f.e > -1 && (o = 1 / o),
                    new A(a ? 1 / o : o)
                  );
                E && (o = ss(E / hs + 2));
              }
              for (
                s
                  ? ((r = new A(0.5)), a && (t.s = 1), (u = vs(t)))
                  : (u = (i = Math.abs(+P(t))) % 2),
                  c = new A(d);
                ;

              ) {
                if (u) {
                  if (!(c = c.times(f)).c) break;
                  o ? c.c.length > o && (c.c.length = o) : n && (c = c.mod(e));
                }
                if (i) {
                  if (0 === (i = as(i / 2))) break;
                  u = i % 2;
                } else if ((x((t = t.times(r)), t.e + 1, 1), t.e > 14))
                  u = vs(t);
                else {
                  if (0 === (i = +P(t))) break;
                  u = i % 2;
                }
                (f = f.times(f)),
                  o
                    ? f.c && f.c.length > o && (f.c.length = o)
                    : n && (f = f.mod(e));
              }
              return n
                ? c
                : (a && (c = d.div(c)),
                  e ? c.mod(e) : o ? x(c, E, y, undefined) : c);
            }),
          (l.integerValue = function (t) {
            var e = new A(this);
            return null == t ? (t = y) : ws(t, 0, 8), x(e, e.e + 1, t);
          }),
          (l.isEqualTo = l.eq =
            function (t, e) {
              return 0 === bs(this, new A(t, e));
            }),
          (l.isFinite = function () {
            return !!this.c;
          }),
          (l.isGreaterThan = l.gt =
            function (t, e) {
              return bs(this, new A(t, e)) > 0;
            }),
          (l.isGreaterThanOrEqualTo = l.gte =
            function (t, e) {
              return 1 === (e = bs(this, new A(t, e))) || 0 === e;
            }),
          (l.isInteger = function () {
            return !!this.c && gs(this.e / hs) > this.c.length - 2;
          }),
          (l.isLessThan = l.lt =
            function (t, e) {
              return bs(this, new A(t, e)) < 0;
            }),
          (l.isLessThanOrEqualTo = l.lte =
            function (t, e) {
              return -1 === (e = bs(this, new A(t, e))) || 0 === e;
            }),
          (l.isNaN = function () {
            return !this.s;
          }),
          (l.isNegative = function () {
            return this.s < 0;
          }),
          (l.isPositive = function () {
            return this.s > 0;
          }),
          (l.isZero = function () {
            return !!this.c && 0 == this.c[0];
          }),
          (l.minus = function (t, e) {
            var r,
              n,
              i,
              o,
              s = this,
              a = s.s;
            if (((e = (t = new A(t, e)).s), !a || !e)) return new A(NaN);
            if (a != e) return (t.s = -e), s.plus(t);
            var u = s.e / hs,
              c = t.e / hs,
              f = s.c,
              h = t.c;
            if (!u || !c) {
              if (!f || !h) return f ? ((t.s = -e), t) : new A(h ? s : NaN);
              if (!f[0] || !h[0])
                return h[0]
                  ? ((t.s = -e), t)
                  : new A(f[0] ? s : 3 == y ? -0 : 0);
            }
            if (((u = gs(u)), (c = gs(c)), (f = f.slice()), (a = u - c))) {
              for (
                (o = a < 0) ? ((a = -a), (i = f)) : ((c = u), (i = h)),
                  i.reverse(),
                  e = a;
                e--;
                i.push(0)
              );
              i.reverse();
            } else
              for (
                n = (o = (a = f.length) < (e = h.length)) ? a : e, a = e = 0;
                e < n;
                e++
              )
                if (f[e] != h[e]) {
                  o = f[e] < h[e];
                  break;
                }
            if (
              (o && ((i = f), (f = h), (h = i), (t.s = -t.s)),
              (e = (n = h.length) - (r = f.length)) > 0)
            )
              for (; e--; f[r++] = 0);
            for (e = fs - 1; n > a; ) {
              if (f[--n] < h[n]) {
                for (r = n; r && !f[--r]; f[r] = e);
                --f[r], (f[n] += fs);
              }
              f[n] -= h[n];
            }
            for (; 0 == f[0]; f.splice(0, 1), --c);
            return f[0]
              ? O(t, f, c)
              : ((t.s = 3 == y ? -1 : 1), (t.c = [(t.e = 0)]), t);
          }),
          (l.modulo = l.mod =
            function (t, e) {
              var n,
                i,
                o = this;
              return (
                (t = new A(t, e)),
                !o.c || !t.s || (t.c && !t.c[0])
                  ? new A(NaN)
                  : !t.c || (o.c && !o.c[0])
                    ? new A(o)
                    : (9 == _
                        ? ((i = t.s),
                          (t.s = 1),
                          (n = r(o, t, 0, 3)),
                          (t.s = i),
                          (n.s *= i))
                        : (n = r(o, t, 0, _)),
                      (t = o.minus(n.times(t))).c[0] || 1 != _ || (t.s = o.s),
                      t)
              );
            }),
          (l.multipliedBy = l.times =
            function (t, e) {
              var r,
                n,
                i,
                o,
                s,
                a,
                u,
                c,
                f,
                h,
                l,
                d,
                p,
                y,
                g,
                m = this,
                b = m.c,
                w = (t = new A(t, e)).c;
              if (!(b && w && b[0] && w[0]))
                return (
                  !m.s || !t.s || (b && !b[0] && !w) || (w && !w[0] && !b)
                    ? (t.c = t.e = t.s = null)
                    : ((t.s *= m.s),
                      b && w ? ((t.c = [0]), (t.e = 0)) : (t.c = t.e = null)),
                  t
                );
              for (
                n = gs(m.e / hs) + gs(t.e / hs),
                  t.s *= m.s,
                  (u = b.length) < (h = w.length) &&
                    ((p = b), (b = w), (w = p), (i = u), (u = h), (h = i)),
                  i = u + h,
                  p = [];
                i--;
                p.push(0)
              );
              for (y = fs, g = ps, i = h; --i >= 0; ) {
                for (
                  r = 0, l = w[i] % g, d = (w[i] / g) | 0, o = i + (s = u);
                  o > i;

                )
                  (r =
                    (((c =
                      l * (c = b[--s] % g) +
                      ((a = d * c + (f = (b[s] / g) | 0) * l) % g) * g +
                      p[o] +
                      r) /
                      y) |
                      0) +
                    ((a / g) | 0) +
                    d * f),
                    (p[o--] = c % y);
                p[o] = r;
              }
              return r ? ++n : p.splice(0, 1), O(t, p, n);
            }),
          (l.negated = function () {
            var t = new A(this);
            return (t.s = -t.s || null), t;
          }),
          (l.plus = function (t, e) {
            var r,
              n = this,
              i = n.s;
            if (((e = (t = new A(t, e)).s), !i || !e)) return new A(NaN);
            if (i != e) return (t.s = -e), n.minus(t);
            var o = n.e / hs,
              s = t.e / hs,
              a = n.c,
              u = t.c;
            if (!o || !s) {
              if (!a || !u) return new A(i / 0);
              if (!a[0] || !u[0]) return u[0] ? t : new A(a[0] ? n : 0 * i);
            }
            if (((o = gs(o)), (s = gs(s)), (a = a.slice()), (i = o - s))) {
              for (
                i > 0 ? ((s = o), (r = u)) : ((i = -i), (r = a)), r.reverse();
                i--;
                r.push(0)
              );
              r.reverse();
            }
            for (
              (i = a.length) - (e = u.length) < 0 &&
                ((r = u), (u = a), (a = r), (e = i)),
                i = 0;
              e;

            )
              (i = ((a[--e] = a[e] + u[e] + i) / fs) | 0),
                (a[e] = fs === a[e] ? 0 : a[e] % fs);
            return i && ((a = [i].concat(a)), ++s), O(t, a, s);
          }),
          (l.precision = l.sd =
            function (t, e) {
              var r,
                n,
                i,
                o = this;
              if (null != t && t !== !!t)
                return (
                  ws(t, 1, ys),
                  null == e ? (e = y) : ws(e, 0, 8),
                  x(new A(o), t, e)
                );
              if (!(r = o.c)) return null;
              if (((n = (i = r.length - 1) * hs + 1), (i = r[i]))) {
                for (; i % 10 == 0; i /= 10, n--);
                for (i = r[0]; i >= 10; i /= 10, n++);
              }
              return t && o.e + 1 > n && (n = o.e + 1), n;
            }),
          (l.shiftedBy = function (t) {
            return ws(t, -9007199254740991, ls), this.times("1e" + t);
          }),
          (l.squareRoot = l.sqrt =
            function () {
              var t,
                e,
                n,
                i,
                o,
                s = this,
                a = s.c,
                u = s.s,
                c = s.e,
                f = p + 4,
                h = new A("0.5");
              if (1 !== u || !a || !a[0])
                return new A(
                  !u || (u < 0 && (!a || a[0])) ? NaN : a ? s : 1 / 0,
                );
              if (
                (0 == (u = Math.sqrt(+P(s))) || u == 1 / 0
                  ? (((e = ms(a)).length + c) % 2 == 0 && (e += "0"),
                    (u = Math.sqrt(+e)),
                    (c = gs((c + 1) / 2) - (c < 0 || c % 2)),
                    (n = new A(
                      (e =
                        u == 1 / 0
                          ? "5e" + c
                          : (e = u.toExponential()).slice(
                              0,
                              e.indexOf("e") + 1,
                            ) + c),
                    )))
                  : (n = new A(u + "")),
                n.c[0])
              )
                for ((u = (c = n.e) + f) < 3 && (u = 0); ; )
                  if (
                    ((o = n),
                    (n = h.times(o.plus(r(s, o, f, 1)))),
                    ms(o.c).slice(0, u) === (e = ms(n.c)).slice(0, u))
                  ) {
                    if (
                      (n.e < c && --u,
                      "9999" != (e = e.slice(u - 3, u + 1)) &&
                        (i || "4999" != e))
                    ) {
                      (+e && (+e.slice(1) || "5" != e.charAt(0))) ||
                        (x(n, n.e + p + 2, 1), (t = !n.times(n).eq(s)));
                      break;
                    }
                    if (!i && (x(o, o.e + p + 2, 0), o.times(o).eq(s))) {
                      n = o;
                      break;
                    }
                    (f += 4), (u += 4), (i = 1);
                  }
              return x(n, n.e + p + 1, y, t);
            }),
          (l.toExponential = function (t, e) {
            return null != t && (ws(t, 0, ys), t++), T(this, t, e, 1);
          }),
          (l.toFixed = function (t, e) {
            return (
              null != t && (ws(t, 0, ys), (t = t + this.e + 1)), T(this, t, e)
            );
          }),
          (l.toFormat = function (t, e, r) {
            var n,
              i = this;
            if (null == r)
              null != t && e && "object" == typeof e
                ? ((r = e), (e = null))
                : t && "object" == typeof t
                  ? ((r = t), (t = e = null))
                  : (r = S);
            else if ("object" != typeof r)
              throw Error(us + "Argument not an object: " + r);
            if (((n = i.toFixed(t, e)), i.c)) {
              var o,
                s = n.split("."),
                a = +r.groupSize,
                u = +r.secondaryGroupSize,
                c = r.groupSeparator || "",
                f = s[0],
                h = s[1],
                l = i.s < 0,
                d = l ? f.slice(1) : f,
                p = d.length;
              if (
                (u && ((o = a), (a = u), (u = o), (p -= o)), a > 0 && p > 0)
              ) {
                for (o = p % a || a, f = d.substr(0, o); o < p; o += a)
                  f += c + d.substr(o, a);
                u > 0 && (f += c + d.slice(o)), l && (f = "-" + f);
              }
              n = h
                ? f +
                  (r.decimalSeparator || "") +
                  ((u = +r.fractionGroupSize)
                    ? h.replace(
                        new RegExp("\\d{" + u + "}\\B", "g"),
                        "$&" + (r.fractionGroupSeparator || ""),
                      )
                    : h)
                : f;
            }
            return (r.prefix || "") + n + (r.suffix || "");
          }),
          (l.toFraction = function (t) {
            var e,
              n,
              i,
              o,
              s,
              a,
              u,
              c,
              f,
              h,
              l,
              p,
              g = this,
              m = g.c;
            if (
              null != t &&
              ((!(u = new A(t)).isInteger() && (u.c || 1 !== u.s)) || u.lt(d))
            )
              throw Error(
                us +
                  "Argument " +
                  (u.isInteger() ? "out of range: " : "not an integer: ") +
                  P(u),
              );
            if (!m) return new A(g);
            for (
              e = new A(d),
                f = n = new A(d),
                i = c = new A(d),
                p = ms(m),
                s = e.e = p.length - g.e - 1,
                e.c[0] = ds[(a = s % hs) < 0 ? hs + a : a],
                t = !t || u.comparedTo(e) > 0 ? (s > 0 ? e : f) : u,
                a = w,
                w = 1 / 0,
                u = new A(p),
                c.c[0] = 0;
              (h = r(u, e, 0, 1)), 1 != (o = n.plus(h.times(i))).comparedTo(t);

            )
              (n = i),
                (i = o),
                (f = c.plus(h.times((o = f)))),
                (c = o),
                (e = u.minus(h.times((o = e)))),
                (u = o);
            return (
              (o = r(t.minus(n), i, 0, 1)),
              (c = c.plus(o.times(f))),
              (n = n.plus(o.times(i))),
              (c.s = f.s = g.s),
              (l =
                r(f, i, (s *= 2), y)
                  .minus(g)
                  .abs()
                  .comparedTo(r(c, n, s, y).minus(g).abs()) < 1
                  ? [f, i]
                  : [c, n]),
              (w = a),
              l
            );
          }),
          (l.toNumber = function () {
            return +P(this);
          }),
          (l.toPrecision = function (t, e) {
            return null != t && ws(t, 1, ys), T(this, t, e, 2);
          }),
          (l.toString = function (t) {
            var e,
              r = this,
              i = r.s,
              o = r.e;
            return (
              null === o
                ? i
                  ? ((e = "Infinity"), i < 0 && (e = "-" + e))
                  : (e = "NaN")
                : (null == t
                    ? (e =
                        o <= g || o >= m ? _s(ms(r.c), o) : Es(ms(r.c), o, "0"))
                    : 10 === t && M
                      ? (e = Es(
                          ms((r = x(new A(r), p + o + 1, y)).c),
                          r.e,
                          "0",
                        ))
                      : (ws(t, 2, I.length, "Base"),
                        (e = n(Es(ms(r.c), o, "0"), 10, t, i, !0))),
                  i < 0 && r.c[0] && (e = "-" + e)),
              e
            );
          }),
          (l.valueOf = l.toJSON =
            function () {
              return P(this);
            }),
          (l._isBigNumber = !0),
          (l[Symbol.toStringTag] = "BigNumber"),
          (l[Symbol.for("nodejs.util.inspect.custom")] = l.valueOf),
          null != e && A.set(e),
          A
        );
      })();
      var Is, Ms;
      !(function (t) {
        (t.RUNES_SUPPORT = "RUNES_SUPPORT"),
          (t.RUNES_LISTING = "RUNES_LISTING"),
          (t.SWAPS = "SWAPS"),
          (t.PAYPAL = "PAYPAL"),
          (t.CROSS_CHAIN_SWAPS = "CROSS_CHAIN_SWAPS"),
          (t.STACKS_SWAPS = "STACKS_SWAPS"),
          (t.PORTFOLIO_TRACKING = "PORTFOLIO_TRACKING"),
          (t.DYNAMIC_MOBILE_ICONS = "DYNAMIC_MOBILE_ICONS"),
          (t.CLOUD_BACKUP_READ = "CLOUD_BACKUP_READ"),
          (t.CLOUD_BACKUP_WRITE = "CLOUD_BACKUP_WRITE");
      })(Is || (Is = {})),
        (function (t) {
          (t.New = "new"),
            (t.Waiting = "waiting"),
            (t.Confirming = "confirming"),
            (t.Exchanging = "exchanging"),
            (t.Sending = "sending"),
            (t.Finished = "finished"),
            (t.Failed = "failed"),
            (t.Refunded = "refunded"),
            (t.Hold = "hold"),
            (t.Overdue = "overdue"),
            (t.Expired = "expired");
        })(Ms || (Ms = {}));
      var As, Ts, ks;
      !(function (t) {
        (t[(t.InSufficientBalance = 600)] = "InSufficientBalance"),
          (t[(t.InSufficientBalanceWithTxFee = 601)] =
            "InSufficientBalanceWithTxFee"),
          (t[(t.OrdinalUtxoNotfound = 700)] = "OrdinalUtxoNotfound");
      })(As || (As = {}));
      Error;
      Error;
      !(function (t) {
        (t.ECDSA = "ECDSA"), (t.BIP322 = "BIP322");
      })(Ts || (Ts = {})),
        (function (t) {
          (t.OptOut = "Opt Out"),
            (t.CreateNewWallet = "Create new wallet"),
            (t.RestoreWallet = "Restore wallet"),
            (t.ClickApp = "click_app"),
            (t.AppConnected = "app_connected"),
            (t.TransactionConfirmed = "transaction_confirmed"),
            (t.WalletMigrated = "wallet_migrated"),
            (t.WalletSkippedMigration = "wallet_skipped_migration"),
            (t.InitiateSwapFlow = "initiate_swap_flow"),
            (t.FetchSwapQuote = "fetch_swap_quote"),
            (t.SelectSwapQuote = "select_swap_quote"),
            (t.ConfirmSwap = "confirm_swap"),
            (t.SignSwap = "sign_swap"),
            (t.SelectTokenToSwapFrom = "select_token_to_swap_from"),
            (t.SelectTokenToSwapTo = "select_token_to_swap_to"),
            (t.ListRuneInitiated = "list_rune_initiated"),
            (t.ListRuneSigned = "list_rune_signed"),
            (t.SetupWallet = "setup_wallet"),
            (t.BackupWallet = "backup_wallet"),
            (t.BackupWalletLater = "backup_wallet_later"),
            (t.InitiateBuyFlow = "initiate_buy_flow"),
            (t.SelectBuyProvider = "select_buy_provider"),
            (t.InitiateSendFlow = "initiate_send_flow"),
            (t.InitiateReceiveFlow = "initiate_receive_flow"),
            (t.VisitCollectiblesTab = "visit_collectibles_tab"),
            (t.VisitStackingTab = "visit_stacking_tab"),
            (t.VisitExplorePage = "visit_explore_page");
        })(ks || (ks = {}));
      const Os = "https://btc-1.xverse.app",
        xs = "https://btc-testnet.xverse.app",
        Ps = "https://btc-testnet4.xverse.app",
        Bs = "https://btc-signet.xverse.app",
        Cs = "https://beta.sbtc-mempool.tech/api/proxy",
        Rs = "https://beta.sbtc-mempool.tech/api/proxy",
        Ns = "https://api.testnet.hiro.so",
        Us = {
          type: "Mainnet",
          address: "https://api.hiro.so",
          btcApiUrl: Os,
          fallbackBtcApiUrl: "https://mempool.space/api",
        },
        Ds = {
          type: "Testnet",
          address: Ns,
          btcApiUrl: xs,
          fallbackBtcApiUrl: "https://mempool.space/testnet/api",
        },
        Ls = {
          type: "Testnet4",
          address: Ns,
          btcApiUrl: Ps,
          fallbackBtcApiUrl: "https://mempool.space/testnet4/api",
        },
        js = {
          type: "Signet",
          address: Ns,
          btcApiUrl: Bs,
          fallbackBtcApiUrl: "https://mempool.space/signet/api",
        },
        Fs = {
          type: "Regtest",
          address: Ns,
          btcApiUrl: Cs,
          fallbackBtcApiUrl: Rs,
        },
        Hs = [{ ...Us }, { ...Ds }, { ...Ls }, { ...js }, { ...Fs }],
        Ks = (t, e = "") => {
          switch (t) {
            case "Mainnet":
              return `${e}`;
            case "Testnet":
              return "-testnet";
            case "Testnet4":
              return "-testnet4";
            case "Signet":
            case "Regtest":
              return "-signet";
            default:
              throw new Error("Invalid network");
          }
        },
        Vs = (t) => `https://api${Ks(t, "-3")}.xverse.app`,
        qs = (t) => `https://inscribe${Ks(t)}.xverse.app`;
      var zs = i(51111);
      const $s = "axios-retry";
      function Gs(t) {
        return (
          !t.response &&
          !!t.code &&
          !["ERR_CANCELED", "ECONNABORTED"].includes(t.code) &&
          zs(t)
        );
      }
      const Ws = ["get", "head", "options"],
        Ys = Ws.concat(["put", "delete"]);
      function Xs(t) {
        return (
          "ECONNABORTED" !== t.code &&
          (!t.response ||
            429 === t.response.status ||
            (t.response.status >= 500 && t.response.status <= 599))
        );
      }
      function Zs(t) {
        return (
          !!t.config?.method && Xs(t) && -1 !== Ys.indexOf(t.config.method)
        );
      }
      function Js(t) {
        return Gs(t) || Zs(t);
      }
      function Qs(t = void 0) {
        const e = t?.response?.headers["retry-after"];
        if (!e) return 0;
        let r = 1e3 * (Number(e) || 0);
        return (
          0 === r && (r = (new Date(e).valueOf() || 0) - Date.now()),
          Math.max(0, r)
        );
      }
      const ta = {
        retries: 3,
        retryCondition: Js,
        retryDelay: function (t = 0, e = void 0) {
          return Math.max(0, Qs(e));
        },
        shouldResetTimeout: !1,
        onRetry: () => {},
        onMaxRetryTimesExceeded: () => {},
        validateResponse: null,
      };
      function ea(t, e, r = !1) {
        const n = (function (t, e) {
          return { ...ta, ...e, ...t[$s] };
        })(t, e || {});
        return (
          (n.retryCount = n.retryCount || 0),
          (n.lastRequestTime && !r) || (n.lastRequestTime = Date.now()),
          (t[$s] = n),
          n
        );
      }
      const ra = (t, e) => {
        const r = t.interceptors.request.use(
            (t) => (
              ea(t, e, !0),
              t[$s]?.validateResponse && (t.validateStatus = () => !1),
              t
            ),
          ),
          n = t.interceptors.response.use(null, async (r) => {
            const { config: n } = r;
            if (!n) return Promise.reject(r);
            const i = ea(n, e);
            return r.response && i.validateResponse?.(r.response)
              ? r.response
              : (await (async function (t, e) {
                    const { retries: r, retryCondition: n } = t,
                      i = (t.retryCount || 0) < r && n(e);
                    if ("object" == typeof i)
                      try {
                        return !1 !== (await i);
                      } catch (t) {
                        return !1;
                      }
                    return i;
                  })(i, r))
                ? (async function (t, e, r, n) {
                    e.retryCount += 1;
                    const {
                        retryDelay: i,
                        shouldResetTimeout: o,
                        onRetry: s,
                      } = e,
                      a = i(e.retryCount, r);
                    if (
                      ((function (t, e) {
                        t.defaults.agent === e.agent && delete e.agent,
                          t.defaults.httpAgent === e.httpAgent &&
                            delete e.httpAgent,
                          t.defaults.httpsAgent === e.httpsAgent &&
                            delete e.httpsAgent;
                      })(t, n),
                      !o && n.timeout && e.lastRequestTime)
                    ) {
                      const t = Date.now() - e.lastRequestTime,
                        i = n.timeout - t - a;
                      if (i <= 0) return Promise.reject(r);
                      n.timeout = i;
                    }
                    return (
                      (n.transformRequest = [(t) => t]),
                      await s(e.retryCount, r, n),
                      n.signal?.aborted
                        ? Promise.resolve(t(n))
                        : new Promise((e) => {
                            const r = () => {
                                clearTimeout(i), e(t(n));
                              },
                              i = setTimeout(() => {
                                e(t(n)),
                                  n.signal?.removeEventListener &&
                                    n.signal.removeEventListener("abort", r);
                              }, a);
                            n.signal?.addEventListener &&
                              n.signal.addEventListener("abort", r, {
                                once: !0,
                              });
                          })
                    );
                  })(t, i, r, n)
                : (await (async function (t, e) {
                    t.retryCount >= t.retries &&
                      (await t.onMaxRetryTimesExceeded(e, t.retryCount));
                  })(i, r),
                  Promise.reject(r));
          });
        return { requestInterceptorId: r, responseInterceptorId: n };
      };
      (ra.isNetworkError = Gs),
        (ra.isSafeRequestError = function (t) {
          return (
            !!t.config?.method && Xs(t) && -1 !== Ws.indexOf(t.config.method)
          );
        }),
        (ra.isIdempotentRequestError = Zs),
        (ra.isNetworkOrIdempotentRequestError = Js),
        (ra.exponentialDelay = function (t = 0, e = void 0, r = 100) {
          const n = 2 ** t * r,
            i = Math.max(n, Qs(e));
          return i + 0.2 * i * Math.random();
        }),
        (ra.linearDelay = function (t = 100) {
          return (e = 0, r = void 0) => {
            const n = e * t;
            return Math.max(n, Qs(r));
          };
        }),
        (ra.isRetryableError = Xs);
      const na = ra;
      class ia {
        queue;
        timeslotRequests;
        perMilliseconds;
        maxRequests;
        constructor(t, e) {
          (this.queue = []),
            (this.timeslotRequests = 0),
            "maxRPS" in e
              ? ((this.perMilliseconds = 1e3), (this.maxRequests = e.maxRPS))
              : ((this.perMilliseconds = e.perMilliseconds),
                (this.maxRequests = e.maxRequests)),
            t.interceptors.request.use(this.handleRequest, function (t) {
              return Promise.reject(t);
            });
        }
        handleRequest = (t) =>
          new Promise((e, r) => {
            this.push({
              resolve: function () {
                try {
                  !(function (t) {
                    t.cancelToken && t.cancelToken.throwIfRequested();
                  })(t);
                } catch (t) {
                  return r(t), !1;
                }
                return e(t), !0;
              },
            });
          });
        push = (t) => {
          this.queue.push(t), this.shift();
        };
        onRequestTimerMet = () => {
          this.timeslotRequests--, this.shift();
        };
        shift = () => {
          if (this.timeslotRequests >= this.maxRequests) return;
          const t = this.queue.shift();
          if (!t) return;
          t.resolve()
            ? (this.timeslotRequests++,
              setTimeout(this.onRequestTimerMet, this.perMilliseconds))
            : this.shift();
        };
      }
      class oa {
        bitcoinApi;
        rateLimiter;
        fallbackBitcoinApi;
        fallbackRateLimiter;
        _network;
        constructor(t) {
          const { url: e, network: r, fallbackUrl: n } = t;
          let i = e;
          if (!i)
            switch (r) {
              case "Mainnet":
                i = Os;
                break;
              case "Testnet":
                i = xs;
                break;
              case "Testnet4":
                i = Ps;
                break;
              case "Signet":
                i = Bs;
                break;
              case "Regtest":
                i = Cs;
                break;
              default:
                throw new Error("Invalid network");
            }
          const o = { baseURL: i };
          (this._network = r),
            (this.bitcoinApi = or.create(o)),
            (this.rateLimiter = new ia(this.bitcoinApi, { maxRPS: 10 })),
            na(this.bitcoinApi, {
              retries: 1,
              retryDelay: na.exponentialDelay,
              retryCondition: (t) =>
                429 === t?.response?.status ||
                (t?.response?.status ?? 0) >= 500,
            }),
            n &&
              ((this.fallbackBitcoinApi = or.create({ ...o, baseURL: n })),
              (this.fallbackRateLimiter = new ia(this.fallbackBitcoinApi, {
                maxRPS: 10,
              })),
              this.bitcoinApi.interceptors.response.use(
                (t) => t,
                (t) => {
                  if (!this.fallbackBitcoinApi) return Promise.reject(t);
                  const e = "ECONNABORTED" === t?.code,
                    r = t?.response?.status >= 500,
                    i =
                      400 === t?.response?.status &&
                      "string" == typeof t.response.data &&
                      t.response.data.includes(
                        "Too many unspent transaction outputs",
                      );
                  return e || r || i || 429 === t?.response?.status
                    ? this.fallbackBitcoinApi.request({
                        ...t.config,
                        baseURL: n,
                      })
                    : Promise.reject(t);
                },
              ));
        }
        async httpGet(t, e = {}, r = {}) {
          return (await this.bitcoinApi.get(t, { ...r, params: e })).data;
        }
        async httpPost(t, e) {
          return (await this.bitcoinApi.post(t, e)).data;
        }
        async getBalance(t) {
          const e = await this.httpGet(`/address/${t}`),
            { chain_stats: r, mempool_stats: n } = e,
            i = r.funded_txo_sum - r.spent_txo_sum,
            o = n.funded_txo_sum - n.spent_txo_sum;
          return {
            address: t,
            finalBalance: i,
            finalNTx: r.tx_count,
            totalReceived: r.funded_txo_sum,
            totalSent: r.spent_txo_sum,
            unconfirmedTx: n.tx_count,
            unconfirmedBalance: o,
          };
        }
        async getAddressData(t) {
          return await this.httpGet(`/address/${t}`);
        }
        async getUnspentUtxos(t) {
          return (await this.httpGet(`/address/${t}/utxo`)).map((e) => ({
            ...e,
            address: t,
            blockHeight: e.status.block_height,
          }));
        }
        async _getAddressTransactionCount(t) {
          const e = await this.httpGet(`/address/${t}`);
          return e.chain_stats.tx_count + e.mempool_stats.tx_count;
        }
        async getAddressTransactions(t) {
          return this.httpGet(`/address/${t}/txs`);
        }
        async getTransaction(t) {
          return this.httpGet(`/tx/${t}`);
        }
        async getTransactionHex(t) {
          const e = await this.bitcoinApi.get(`/tx/${t}/hex`, {
            validateStatus: (t) => t >= 200 && (t < 300 || 404 === t),
          });
          if (404 !== e.status) return e.data;
        }
        async getAddressMempoolTransactions(t) {
          return this.httpGet(`/address/${t}/txs/mempool`);
        }
        async sendRawTransaction(t) {
          return { tx: { hash: await this.httpPost("/tx", t) } };
        }
        async getTransactionOutspends(t) {
          const e = await this.bitcoinApi.get(`/tx/${t}/outspends`, {
            validateStatus: (t) => t >= 200 && (t < 300 || 404 === t),
          });
          if (404 !== e.status) return e.data;
        }
        async getLatestBlockHeight() {
          return await this.httpGet("/blocks/tip/height");
        }
        async getBlockHash(t) {
          return await this.httpGet(`/block-height/${t}`);
        }
      }
      let sa;
      const aa = () => sa;
      class ua {
        xordClient;
        constructor(t) {
          const { network: e } = t;
          this.xordClient = or.create({
            baseURL: `${qs(e)}/v1`,
            headers: { "X-Client-Version": aa() || void 0 },
          });
        }
        async getInscriptions(t, e, r) {
          const n = { address: t, offset: e, limit: r };
          return (await this.xordClient.get("inscriptions", { params: n }))
            .data;
        }
        async getAllInscriptions(t) {
          const e = [];
          let r = 0,
            n = 60,
            i = await this.getInscriptions(t, r, n);
          for (n = i.limit; i.results.length > 0; )
            e.push(...i.results),
              (r += n),
              (i = await this.getInscriptions(t, r, n));
          return e;
        }
        async getInscription(t) {
          return (await this.xordClient.get(`inscriptions/${t}`)).data;
        }
      }
      var ca = i(21013),
        fa = i.n(ca);
      const ha = { EXPONENTIAL_AT: 1e9 };
      Ss.config(ha);
      const la = (t) => {
          t.parse(
            '{"big":1234567890123456789012345678901234567890}',
          ).big.constructor.config(ha);
        },
        da = fa()({ alwaysParseAsBig: !0 }),
        pa = fa()();
      la(da), la(pa);
      const ya =
        (t) =>
        (e, ...r) => {
          let n = Ss.isBigNumber(e) ? e : new Ss(e.toString());
          for (const e of r) {
            const r = Ss.isBigNumber(e) ? e : new Ss(e.toString());
            (void 0 === n || (t && r.gt(n)) || (!t && r.lt(n))) && (n = r);
          }
          return n;
        };
      ya(!1), ya(!0);
      new Error("timeout while waiting for mutex to become available"),
        new Error("mutex already locked");
      const ga = new Error("request for lock canceled");
      var ma = function (t, e, r, n) {
        return new (r || (r = Promise))(function (i, o) {
          function s(t) {
            try {
              u(n.next(t));
            } catch (t) {
              o(t);
            }
          }
          function a(t) {
            try {
              u(n.throw(t));
            } catch (t) {
              o(t);
            }
          }
          function u(t) {
            t.done
              ? i(t.value)
              : (function (t) {
                  return t instanceof r
                    ? t
                    : new r(function (e) {
                        e(t);
                      });
                })(t.value).then(s, a);
          }
          u((n = n.apply(t, e || [])).next());
        });
      };
      class ba {
        constructor(t, e = ga) {
          (this._value = t),
            (this._cancelError = e),
            (this._weightedQueues = []),
            (this._weightedWaiters = []);
        }
        acquire(t = 1) {
          if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
          return new Promise((e, r) => {
            this._weightedQueues[t - 1] || (this._weightedQueues[t - 1] = []),
              this._weightedQueues[t - 1].push({ resolve: e, reject: r }),
              this._dispatch();
          });
        }
        runExclusive(t, e = 1) {
          return ma(this, void 0, void 0, function* () {
            const [r, n] = yield this.acquire(e);
            try {
              return yield t(r);
            } finally {
              n();
            }
          });
        }
        waitForUnlock(t = 1) {
          if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
          return new Promise((e) => {
            this._weightedWaiters[t - 1] || (this._weightedWaiters[t - 1] = []),
              this._weightedWaiters[t - 1].push(e),
              this._dispatch();
          });
        }
        isLocked() {
          return this._value <= 0;
        }
        getValue() {
          return this._value;
        }
        setValue(t) {
          (this._value = t), this._dispatch();
        }
        release(t = 1) {
          if (t <= 0) throw new Error(`invalid weight ${t}: must be positive`);
          (this._value += t), this._dispatch();
        }
        cancel() {
          this._weightedQueues.forEach((t) =>
            t.forEach((t) => t.reject(this._cancelError)),
          ),
            (this._weightedQueues = []);
        }
        _dispatch() {
          var t;
          for (let e = this._value; e > 0; e--) {
            const r =
              null === (t = this._weightedQueues[e - 1]) || void 0 === t
                ? void 0
                : t.shift();
            if (!r) continue;
            const n = this._value,
              i = e;
            (this._value -= e),
              (e = this._value + 1),
              r.resolve([n, this._newReleaser(i)]);
          }
          this._drainUnlockWaiters();
        }
        _newReleaser(t) {
          let e = !1;
          return () => {
            e || ((e = !0), this.release(t));
          };
        }
        _drainUnlockWaiters() {
          for (let t = this._value; t > 0; t--)
            this._weightedWaiters[t - 1] &&
              (this._weightedWaiters[t - 1].forEach((t) => t()),
              (this._weightedWaiters[t - 1] = []));
        }
      }
      var wa = function (t, e, r, n) {
        return new (r || (r = Promise))(function (i, o) {
          function s(t) {
            try {
              u(n.next(t));
            } catch (t) {
              o(t);
            }
          }
          function a(t) {
            try {
              u(n.throw(t));
            } catch (t) {
              o(t);
            }
          }
          function u(t) {
            t.done
              ? i(t.value)
              : (function (t) {
                  return t instanceof r
                    ? t
                    : new r(function (e) {
                        e(t);
                      });
                })(t.value).then(s, a);
          }
          u((n = n.apply(t, e || [])).next());
        });
      };
      class va {
        constructor(t) {
          this._semaphore = new ba(1, t);
        }
        acquire() {
          return wa(this, void 0, void 0, function* () {
            const [, t] = yield this._semaphore.acquire();
            return t;
          });
        }
        runExclusive(t) {
          return this._semaphore.runExclusive(() => t());
        }
        isLocked() {
          return this._semaphore.isLocked();
        }
        waitForUnlock() {
          return this._semaphore.waitForUnlock();
        }
        release() {
          this._semaphore.isLocked() && this._semaphore.release();
        }
        cancel() {
          return this._semaphore.cancel();
        }
      }
      const _a = { network: void 0, byName: {}, byId: new Map() },
        Ea = {},
        Sa = (t) => {
          _a.network !== t &&
            ((_a.network = t), (_a.byName = {}), (_a.byId = new Map()));
        };
      class Ia {
        clientBigNumber;
        network;
        constructor(t, e) {
          (this.clientBigNumber = or.create({
            baseURL: `${Vs(t)}`,
            headers: {
              "Content-Type": "application/json",
              "X-Client-Version": aa() || void 0,
            },
            transformResponse: (t, e, r) => (200 !== r ? t : da.parse(t)),
            transformRequest: (t) => da.stringify(t),
            adapter: e,
          })),
            (this.network = t);
        }
        async getRuneBalances(t, e = !1) {
          return (
            await this.clientBigNumber.get(`/v2/address/${t}/rune-balance`, {
              params: { includeUnconfirmed: e },
            })
          ).data;
        }
        async getRuneInfo(t) {
          const e = (Ea[(r = `runeInfo-${t}`)] || (Ea[r] = new va()), Ea[r]);
          var r;
          e.isLocked() && (await e.waitForUnlock());
          const n = ((t, e) => {
            Sa(e);
            try {
              if ("bigint" == typeof t) return _a.byId.get(t);
              if (/^[0-9]+:[0-9]+$/.test(t)) {
                const [e, r] = t.split(":").map((t) => BigInt(t)),
                  n = (e << 16n) + r;
                return _a.byId.get(n);
              }
              return _a.byName[t.toUpperCase()];
            } catch (t) {
              return;
            }
          })(t, this.network);
          if (n) return n;
          const i = await e.acquire();
          try {
            let e;
            if ("bigint" == typeof t) {
              const r = t >> 16n,
                n = t - (r << 16n);
              e = await this.clientBigNumber.get(`/v1/runes/${r}:${n}`, {
                validateStatus: (t) => 200 === t || 404 === t,
              });
            } else
              e = await this.clientBigNumber.get(
                `/v1/runes/${t.toUpperCase()}`,
                { validateStatus: (t) => 200 === t || 404 === t },
              );
            const r = 200 === e.status ? e.data : void 0;
            return (
              ((t, e) => {
                if (!t) return;
                Sa(e);
                const [r, n] = t.id.split(":").map((t) => BigInt(t)),
                  i = (r << 16n) + n;
                (_a.byName[t.entry.spaced_rune] = t), _a.byId.set(i, t);
              })(r, this.network),
              r
            );
          } finally {
            i();
          }
        }
        async getRuneFungibleTokens(t, e = !1) {
          return (await this.getRuneBalances(t, e))
            .map((t) =>
              ((t) => ({
                name: t.runeName,
                decimals: t.divisibility,
                principal: t.id,
                balance: t.amount.toString(),
                total_sent: "",
                total_received: "",
                assetName: t.runeName,
                ticker: "",
                runeSymbol: t.symbol,
                runeInscriptionId: t.inscriptionId,
                protocol: "runes",
                supported: !0,
                priceChangePercentage24h:
                  t.priceChangePercentage24h?.toString(),
                currentPrice: t.currentPrice?.toString(),
              }))(t),
            )
            .sort((t, e) =>
              t.assetName < e.assetName
                ? -1
                : t.assetName > e.assetName
                  ? 1
                  : 0,
            );
        }
        async getEncodedScriptHex(t) {
          return (
            await this.clientBigNumber.post("/v1/runes/tools/encode-edicts", {
              payload: t,
            })
          ).data.payload;
        }
        async getDecodedRuneScript(t) {
          const e = await this.clientBigNumber.post(
            "/v1/runes/tools/decode-script",
            { transactionHex: t },
            { validateStatus: (t) => 200 === t || 400 === t },
          );
          if (400 !== e.status) return e.data;
        }
        async getRunesSellOrder(t) {
          return (
            await this.clientBigNumber.post(
              "/v1/market/runes/create-sell-order",
              t,
            )
          ).data;
        }
        async submitRunesSellOrder(t) {
          return (
            await this.clientBigNumber.post(
              "/v1/market/runes/submit-sell-order",
              t,
            )
          ).data;
        }
        async cancelRunesSellOrder(t) {
          return (
            await this.clientBigNumber.post(
              "/v1/market/runes/cancel-sell-order",
              t,
            )
          ).data;
        }
        async submitCancelRunesSellOrder(t) {
          return (
            await this.clientBigNumber.post(
              "/v1/market/runes/submit-cancel-order",
              t,
            )
          ).data;
        }
        async getRunesUtxos(t) {
          return (
            await this.clientBigNumber.get(
              `/v1/market/address/${t.address}/rune/${t.rune}/utxos`,
            )
          ).data;
        }
        async getRuneMarketData(t) {
          return (
            await this.clientBigNumber.get(`/v1/market/runes/${t}/market-data`)
          ).data;
        }
        async getRuneFiatRatesByRuneIds(t, e) {
          return (
            await this.clientBigNumber.post("/v2/runes/fiat-rates", {
              currency: e,
              runeIds: t,
            })
          ).data;
        }
      }
      const Ma = {};
      i(48287).Buffer;
      Error;
      var Aa = i(73513),
        Ta = i.t(Aa, 2);
      (0, i(38700).dg)(Ta);
      function ka(t) {
        return [null, t];
      }
      function Oa(t) {
        return [t, null];
      }
      async function xa(t) {
        try {
          return ka(await t);
        } catch (t) {
          return Oa({
            name: "SafeError",
            message: "Promise rejected.",
            data: t,
          });
        }
      }
      i(55549);
      i(48287).Buffer;
      const Pa = (t, e) => {
        const r = t.btcAddresses.taproot.address,
          n = t.btcAddresses.taproot.publicKey,
          i = t.btcAddresses.taproot.xpub;
        switch (e) {
          case "nested": {
            const e = t.btcAddresses.nested;
            if (!e) throw new Error("Nested Segwit address not found");
            return {
              btcAddress: e.address,
              btcPublicKey: e.publicKey,
              btcXpub: e.xpub,
              ordinalsAddress: r,
              ordinalsPublicKey: n,
              ordinalsXpub: i,
            };
          }
          case "native":
            const e = t.btcAddresses.native;
            if (!e) throw new Error("Native Segwit address not found");
            return {
              btcAddress: e.address,
              btcPublicKey: e.publicKey,
              btcXpub: e.xpub,
              ordinalsAddress: r,
              ordinalsPublicKey: n,
              ordinalsXpub: i,
            };
          default:
            throw new Error("Unsupported payment address type");
        }
      };
      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
      var Ba = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      (() => {
        const t = Array(256).fill(-1);
        for (let e = 0; e < 58; ++e) t[Ba.charCodeAt(e)] = e;
      })();
      function Ca(t) {
        return t &&
          t.__esModule &&
          Object.prototype.hasOwnProperty.call(t, "default")
          ? t.default
          : t;
      }
      function Ra(t, e) {
        return t((e = { exports: {} }), e.exports), e.exports;
      }
      var Na = Ra(function (t, e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.bech32m = e.bech32 = void 0);
        const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
          n = {};
        for (let t = 0; t < 32; t++) {
          const e = r.charAt(t);
          n[e] = t;
        }
        function i(t) {
          const e = t >> 25;
          return (
            ((33554431 & t) << 5) ^
            (996825010 & -(1 & e)) ^
            (642813549 & -((e >> 1) & 1)) ^
            (513874426 & -((e >> 2) & 1)) ^
            (1027748829 & -((e >> 3) & 1)) ^
            (705979059 & -((e >> 4) & 1))
          );
        }
        function o(t) {
          let e = 1;
          for (let r = 0; r < t.length; ++r) {
            const n = t.charCodeAt(r);
            if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
            e = i(e) ^ (n >> 5);
          }
          e = i(e);
          for (let r = 0; r < t.length; ++r) {
            const n = t.charCodeAt(r);
            e = i(e) ^ (31 & n);
          }
          return e;
        }
        function s(t, e, r, n) {
          let i = 0,
            o = 0;
          const s = (1 << r) - 1,
            a = [];
          for (let n = 0; n < t.length; ++n)
            for (i = (i << e) | t[n], o += e; o >= r; )
              (o -= r), a.push((i >> o) & s);
          if (n) o > 0 && a.push((i << (r - o)) & s);
          else {
            if (o >= e) return "Excess padding";
            if ((i << (r - o)) & s) return "Non-zero padding";
          }
          return a;
        }
        function a(t) {
          return s(t, 8, 5, !0);
        }
        function u(t) {
          const e = s(t, 5, 8, !1);
          if (Array.isArray(e)) return e;
        }
        function c(t) {
          const e = s(t, 5, 8, !1);
          if (Array.isArray(e)) return e;
          throw new Error(e);
        }
        function f(t) {
          let e;
          function s(t, r) {
            if (((r = r || 90), t.length < 8)) return t + " too short";
            if (t.length > r) return "Exceeds length limit";
            const s = t.toLowerCase(),
              a = t.toUpperCase();
            if (t !== s && t !== a) return "Mixed-case string " + t;
            const u = (t = s).lastIndexOf("1");
            if (-1 === u) return "No separator character for " + t;
            if (0 === u) return "Missing prefix for " + t;
            const c = t.slice(0, u),
              f = t.slice(u + 1);
            if (f.length < 6) return "Data too short";
            let h = o(c);
            if ("string" == typeof h) return h;
            const l = [];
            for (let t = 0; t < f.length; ++t) {
              const e = f.charAt(t),
                r = n[e];
              if (void 0 === r) return "Unknown character " + e;
              (h = i(h) ^ r), t + 6 >= f.length || l.push(r);
            }
            return h !== e
              ? "Invalid checksum for " + t
              : { prefix: c, words: l };
          }
          return (
            (e = "bech32" === t ? 1 : 734539939),
            {
              decodeUnsafe: function (t, e) {
                const r = s(t, e);
                if ("object" == typeof r) return r;
              },
              decode: function (t, e) {
                const r = s(t, e);
                if ("object" == typeof r) return r;
                throw new Error(r);
              },
              encode: function (t, n, s) {
                if (((s = s || 90), t.length + 7 + n.length > s))
                  throw new TypeError("Exceeds length limit");
                let a = o((t = t.toLowerCase()));
                if ("string" == typeof a) throw new Error(a);
                let u = t + "1";
                for (let t = 0; t < n.length; ++t) {
                  const e = n[t];
                  if (e >> 5) throw new Error("Non 5-bit word");
                  (a = i(a) ^ e), (u += r.charAt(e));
                }
                for (let t = 0; t < 6; ++t) a = i(a);
                a ^= e;
                for (let t = 0; t < 6; ++t)
                  u += r.charAt((a >> (5 * (5 - t))) & 31);
                return u;
              },
              toWords: a,
              fromWordsUnsafe: u,
              fromWords: c,
            }
          );
        }
        (e.bech32 = f("bech32")), (e.bech32m = f("bech32m"));
      });
      Ca(Na);
      Na.bech32m, Na.bech32;
      var Ua = Ra(function (t, e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.Hash = e.createHash = void 0);
        const r = [
            1116352408, 1899447441, -1245643825, -373957723, 961987163,
            1508970993, -1841331548, -1424204075, -670586216, 310598401,
            607225278, 1426881987, 1925078388, -2132889090, -1680079193,
            -1046744716, -459576895, -272742522, 264347078, 604807628,
            770255983, 1249150122, 1555081692, 1996064986, -1740746414,
            -1473132947, -1341970488, -1084653625, -958395405, -710438585,
            113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
            1695183700, 1986661051, -2117940946, -1838011259, -1564481375,
            -1474664885, -1035236496, -949202525, -778901479, -694614492,
            -200395387, 275423344, 430227734, 506948616, 659060556, 883997877,
            958139571, 1322822218, 1537002063, 1747873779, 1955562222,
            2024104815, -2067236844, -1933114872, -1866530822, -1538233109,
            -1090935817, -965641998,
          ],
          n = { sha256: 1 };
        e.createHash = function (t) {
          if (t && !n[t] && !n[t.toLowerCase()])
            throw new Error("Digest method not supported");
          return new i();
        };
        class i {
          constructor() {
            (this.A = 1779033703),
              (this.B = -1150833019),
              (this.C = 1013904242),
              (this.D = -1521486534),
              (this.E = 1359893119),
              (this.F = -1694144372),
              (this.G = 528734635),
              (this.H = 1541459225),
              (this._size = 0),
              (this._sp = 0),
              (!s || a >= 8e3) && ((s = new ArrayBuffer(8e3)), (a = 0)),
              (this._byte = new Uint8Array(s, a, 80)),
              (this._word = new Int32Array(s, a, 20)),
              (a += 80);
          }
          update(t) {
            if ("string" == typeof t) return this._utf8(t);
            if (null == t) throw new TypeError("Invalid type: " + typeof t);
            const e = t.byteOffset,
              r = t.byteLength;
            let n = (r / 64) | 0,
              i = 0;
            if (n && !(3 & e) && !(this._size % 64)) {
              const r = new Int32Array(t.buffer, e, 16 * n);
              for (; n--; ) this._int32(r, i >> 2), (i += 64);
              this._size += i;
            }
            if (1 !== t.BYTES_PER_ELEMENT && t.buffer) {
              const n = new Uint8Array(t.buffer, e + i, r - i);
              return this._uint8(n);
            }
            return i === r ? this : this._uint8(t, i);
          }
          _uint8(t, e) {
            const { _byte: r, _word: n } = this,
              i = t.length;
            for (e |= 0; e < i; ) {
              const o = this._size % 64;
              let s = o;
              for (; e < i && s < 64; ) r[s++] = t[e++];
              s >= 64 && this._int32(n), (this._size += s - o);
            }
            return this;
          }
          _utf8(t) {
            const { _byte: e, _word: r } = this,
              n = t.length;
            let i = this._sp;
            for (let o = 0; o < n; ) {
              const s = this._size % 64;
              let a = s;
              for (; o < n && a < 64; ) {
                let r = 0 | t.charCodeAt(o++);
                r < 128
                  ? (e[a++] = r)
                  : r < 2048
                    ? ((e[a++] = 192 | (r >>> 6)), (e[a++] = 128 | (63 & r)))
                    : r < 55296 || r > 57343
                      ? ((e[a++] = 224 | (r >>> 12)),
                        (e[a++] = 128 | ((r >>> 6) & 63)),
                        (e[a++] = 128 | (63 & r)))
                      : i
                        ? ((r = ((1023 & i) << 10) + (1023 & r) + 65536),
                          (e[a++] = 240 | (r >>> 18)),
                          (e[a++] = 128 | ((r >>> 12) & 63)),
                          (e[a++] = 128 | ((r >>> 6) & 63)),
                          (e[a++] = 128 | (63 & r)),
                          (i = 0))
                        : (i = r);
              }
              a >= 64 && (this._int32(r), (r[0] = r[16])),
                (this._size += a - s);
            }
            return (this._sp = i), this;
          }
          _int32(t, e) {
            let { A: n, B: i, C: s, D: a, E: u, F: g, G: m, H: b } = this,
              w = 0;
            for (e |= 0; w < 16; ) o[w++] = c(t[e++]);
            for (w = 16; w < 64; w++)
              o[w] = (y(o[w - 2]) + o[w - 7] + p(o[w - 15]) + o[w - 16]) | 0;
            for (w = 0; w < 64; w++) {
              const t = (b + d(u) + f(u, g, m) + r[w] + o[w]) | 0,
                e = (l(n) + h(n, i, s)) | 0;
              (b = m),
                (m = g),
                (g = u),
                (u = (a + t) | 0),
                (a = s),
                (s = i),
                (i = n),
                (n = (t + e) | 0);
            }
            (this.A = (n + this.A) | 0),
              (this.B = (i + this.B) | 0),
              (this.C = (s + this.C) | 0),
              (this.D = (a + this.D) | 0),
              (this.E = (u + this.E) | 0),
              (this.F = (g + this.F) | 0),
              (this.G = (m + this.G) | 0),
              (this.H = (b + this.H) | 0);
          }
          digest(t) {
            const { _byte: e, _word: r } = this;
            let n = this._size % 64 | 0;
            for (e[n++] = 128; 3 & n; ) e[n++] = 0;
            if (((n >>= 2), n > 14)) {
              for (; n < 16; ) r[n++] = 0;
              (n = 0), this._int32(r);
            }
            for (; n < 16; ) r[n++] = 0;
            const i = 8 * this._size,
              o = (4294967295 & i) >>> 0,
              s = (i - o) / 4294967296;
            return (
              s && (r[14] = c(s)),
              o && (r[15] = c(o)),
              this._int32(r),
              "hex" === t ? this._hex() : this._bin()
            );
          }
          _hex() {
            const { A: t, B: e, C: r, D: n, E: i, F: o, G: s, H: a } = this;
            return u(t) + u(e) + u(r) + u(n) + u(i) + u(o) + u(s) + u(a);
          }
          _bin() {
            const {
              A: t,
              B: e,
              C: r,
              D: n,
              E: i,
              F: o,
              G: s,
              H: a,
              _byte: u,
              _word: f,
            } = this;
            return (
              (f[0] = c(t)),
              (f[1] = c(e)),
              (f[2] = c(r)),
              (f[3] = c(n)),
              (f[4] = c(i)),
              (f[5] = c(o)),
              (f[6] = c(s)),
              (f[7] = c(a)),
              u.slice(0, 32)
            );
          }
        }
        e.Hash = i;
        const o = new Int32Array(64);
        let s,
          a = 0;
        const u = (t) => (t + 4294967296).toString(16).substr(-8),
          c =
            254 === new Uint8Array(new Uint16Array([65279]).buffer)[0]
              ? (t) => t
              : (t) =>
                  ((t << 24) & 4278190080) |
                  ((t << 8) & 16711680) |
                  ((t >> 8) & 65280) |
                  ((t >> 24) & 255),
          f = (t, e, r) => r ^ (t & (e ^ r)),
          h = (t, e, r) => (t & e) | (r & (t | e)),
          l = (t) =>
            ((t >>> 2) | (t << 30)) ^
            ((t >>> 13) | (t << 19)) ^
            ((t >>> 22) | (t << 10)),
          d = (t) =>
            ((t >>> 6) | (t << 26)) ^
            ((t >>> 11) | (t << 21)) ^
            ((t >>> 25) | (t << 7)),
          p = (t) =>
            ((t >>> 7) | (t << 25)) ^ ((t >>> 18) | (t << 14)) ^ (t >>> 3),
          y = (t) =>
            ((t >>> 17) | (t << 15)) ^ ((t >>> 19) | (t << 13)) ^ (t >>> 10);
      });
      Ca(Ua), Ua.Hash;
      var Da, La;
      Ua.createHash;
      !(function (t) {
        (t.mainnet = "mainnet"),
          (t.testnet = "testnet"),
          (t.regtest = "regtest");
      })(Da || (Da = {})),
        (function (t) {
          (t.p2pkh = "p2pkh"),
            (t.p2sh = "p2sh"),
            (t.p2wpkh = "p2wpkh"),
            (t.p2wsh = "p2wsh"),
            (t.p2tr = "p2tr");
        })(La || (La = {}));
      La.p2pkh,
        Da.mainnet,
        La.p2pkh,
        Da.testnet,
        La.p2sh,
        Da.mainnet,
        La.p2sh,
        Da.testnet;
      /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      function ja(t) {
        return (
          t instanceof Uint8Array ||
          (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
        );
      }
      function Fa(t, e) {
        return (
          !!Array.isArray(e) &&
          (0 === e.length ||
            (t
              ? e.every((t) => "string" == typeof t)
              : e.every((t) => Number.isSafeInteger(t))))
        );
      }
      function Ha(t) {
        if ("function" != typeof t) throw new Error("function expected");
        return !0;
      }
      function Ka(t, e) {
        if ("string" != typeof e) throw new Error(`${t}: string expected`);
        return !0;
      }
      function Va(t) {
        if (!Number.isSafeInteger(t)) throw new Error(`invalid integer: ${t}`);
      }
      function qa(t) {
        if (!Array.isArray(t)) throw new Error("array expected");
      }
      function za(t, e) {
        if (!Fa(!0, e)) throw new Error(`${t}: array of strings expected`);
      }
      function $a(t, e) {
        if (!Fa(!1, e)) throw new Error(`${t}: array of numbers expected`);
      }
      function Ga(...t) {
        const e = (t) => t,
          r = (t, e) => (r) => t(e(r)),
          n = t.map((t) => t.encode).reduceRight(r, e),
          i = t.map((t) => t.decode).reduce(r, e);
        return { encode: n, decode: i };
      }
      function Wa(t) {
        const e = "string" == typeof t ? t.split("") : t,
          r = e.length;
        za("alphabet", e);
        const n = new Map(e.map((t, e) => [t, e]));
        return {
          encode: (n) => (
            qa(n),
            n.map((n) => {
              if (!Number.isSafeInteger(n) || n < 0 || n >= r)
                throw new Error(
                  `alphabet.encode: digit index outside alphabet "${n}". Allowed: ${t}`,
                );
              return e[n];
            })
          ),
          decode: (e) => (
            qa(e),
            e.map((e) => {
              Ka("alphabet.decode", e);
              const r = n.get(e);
              if (void 0 === r)
                throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);
              return r;
            })
          ),
        };
      }
      function Ya(t = "") {
        return (
          Ka("join", t),
          {
            encode: (e) => (za("join.decode", e), e.join(t)),
            decode: (e) => (Ka("join.decode", e), e.split(t)),
          }
        );
      }
      function Xa(t, e = "=") {
        return (
          Va(t),
          Ka("padding", e),
          {
            encode(r) {
              for (za("padding.encode", r); (r.length * t) % 8; ) r.push(e);
              return r;
            },
            decode(r) {
              za("padding.decode", r);
              let n = r.length;
              if ((n * t) % 8)
                throw new Error(
                  "padding: invalid, string should have whole number of bytes",
                );
              for (; n > 0 && r[n - 1] === e; n--) {
                if (((n - 1) * t) % 8 == 0)
                  throw new Error(
                    "padding: invalid, string has too much padding",
                  );
              }
              return r.slice(0, n);
            },
          }
        );
      }
      function Za(t) {
        return Ha(t), { encode: (t) => t, decode: (e) => t(e) };
      }
      function Ja(t, e, r) {
        if (e < 2)
          throw new Error(
            `convertRadix: invalid from=${e}, base cannot be less than 2`,
          );
        if (r < 2)
          throw new Error(
            `convertRadix: invalid to=${r}, base cannot be less than 2`,
          );
        if ((qa(t), !t.length)) return [];
        let n = 0;
        const i = [],
          o = Array.from(t, (t) => {
            if ((Va(t), t < 0 || t >= e))
              throw new Error(`invalid integer: ${t}`);
            return t;
          }),
          s = o.length;
        for (;;) {
          let t = 0,
            a = !0;
          for (let i = n; i < s; i++) {
            const s = o[i],
              u = e * t,
              c = u + s;
            if (!Number.isSafeInteger(c) || u / e !== t || c - s !== u)
              throw new Error("convertRadix: carry overflow");
            const f = c / r;
            t = c % r;
            const h = Math.floor(f);
            if (((o[i] = h), !Number.isSafeInteger(h) || h * r + t !== c))
              throw new Error("convertRadix: carry overflow");
            a && (h ? (a = !1) : (n = i));
          }
          if ((i.push(t), a)) break;
        }
        for (let e = 0; e < t.length - 1 && 0 === t[e]; e++) i.push(0);
        return i.reverse();
      }
      const Qa = (t, e) => (0 === e ? t : Qa(e, t % e)),
        tu = (t, e) => t + (e - Qa(t, e)),
        eu = (() => {
          let t = [];
          for (let e = 0; e < 40; e++) t.push(2 ** e);
          return t;
        })();
      function ru(t, e, r, n) {
        if ((qa(t), e <= 0 || e > 32))
          throw new Error(`convertRadix2: wrong from=${e}`);
        if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
        if (tu(e, r) > 32)
          throw new Error(
            `convertRadix2: carry overflow from=${e} to=${r} carryBits=${tu(e, r)}`,
          );
        let i = 0,
          o = 0;
        const s = eu[e],
          a = eu[r] - 1,
          u = [];
        for (const n of t) {
          if ((Va(n), n >= s))
            throw new Error(`convertRadix2: invalid data word=${n} from=${e}`);
          if (((i = (i << e) | n), o + e > 32))
            throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);
          for (o += e; o >= r; o -= r) u.push(((i >> (o - r)) & a) >>> 0);
          const t = eu[o];
          if (void 0 === t) throw new Error("invalid carry");
          i &= t - 1;
        }
        if (((i = (i << (r - o)) & a), !n && o >= e))
          throw new Error("Excess padding");
        if (!n && i > 0) throw new Error(`Non-zero padding: ${i}`);
        return n && o > 0 && u.push(i >>> 0), u;
      }
      function nu(t) {
        Va(t);
        return {
          encode: (e) => {
            if (!ja(e))
              throw new Error("radix.encode input should be Uint8Array");
            return Ja(Array.from(e), 256, t);
          },
          decode: (e) => (
            $a("radix.decode", e), Uint8Array.from(Ja(e, t, 256))
          ),
        };
      }
      function iu(t, e = !1) {
        if ((Va(t), t <= 0 || t > 32))
          throw new Error("radix2: bits should be in (0..32]");
        if (tu(8, t) > 32 || tu(t, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (r) => {
            if (!ja(r))
              throw new Error("radix2.encode input should be Uint8Array");
            return ru(Array.from(r), 8, t, !e);
          },
          decode: (r) => (
            $a("radix2.decode", r), Uint8Array.from(ru(r, t, 8, e))
          ),
        };
      }
      function ou(t) {
        return (
          Ha(t),
          function (...e) {
            try {
              return t.apply(null, e);
            } catch (t) {}
          }
        );
      }
      function su(t, e) {
        return (
          Va(t),
          Ha(e),
          {
            encode(r) {
              if (!ja(r))
                throw new Error("checksum.encode: input should be Uint8Array");
              const n = e(r).slice(0, t),
                i = new Uint8Array(r.length + t);
              return i.set(r), i.set(n, r.length), i;
            },
            decode(r) {
              if (!ja(r))
                throw new Error("checksum.decode: input should be Uint8Array");
              const n = r.slice(0, -t),
                i = r.slice(-t),
                o = e(n).slice(0, t);
              for (let e = 0; e < t; e++)
                if (o[e] !== i[e]) throw new Error("Invalid checksum");
              return n;
            },
          }
        );
      }
      Ga(iu(4), Wa("0123456789ABCDEF"), Ya("")),
        Ga(iu(5), Wa("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Xa(5), Ya("")),
        Ga(iu(5), Wa("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Ya("")),
        Ga(iu(5), Wa("0123456789ABCDEFGHIJKLMNOPQRSTUV"), Xa(5), Ya("")),
        Ga(iu(5), Wa("0123456789ABCDEFGHIJKLMNOPQRSTUV"), Ya("")),
        Ga(
          iu(5),
          Wa("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),
          Ya(""),
          Za((t) => t.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")),
        ),
        Ga(
          iu(6),
          Wa(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          ),
          Xa(6),
          Ya(""),
        ),
        Ga(
          iu(6),
          Wa(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          ),
          Ya(""),
        ),
        Ga(
          iu(6),
          Wa(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          ),
          Xa(6),
          Ya(""),
        ),
        Ga(
          iu(6),
          Wa(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          ),
          Ya(""),
        );
      const au = (t) => Ga(nu(58), Wa(t), Ya("")),
        uu = au("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
        cu =
          (au("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),
          au("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),
          (t) =>
            Ga(
              su(4, (e) => t(t(e))),
              uu,
            )),
        fu = Ga(Wa("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), Ya("")),
        hu = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function lu(t) {
        const e = t >> 25;
        let r = (33554431 & t) << 5;
        for (let t = 0; t < hu.length; t++) 1 == ((e >> t) & 1) && (r ^= hu[t]);
        return r;
      }
      function du(t, e, r = 1) {
        const n = t.length;
        let i = 1;
        for (let e = 0; e < n; e++) {
          const r = t.charCodeAt(e);
          if (r < 33 || r > 126) throw new Error(`Invalid prefix (${t})`);
          i = lu(i) ^ (r >> 5);
        }
        i = lu(i);
        for (let e = 0; e < n; e++) i = lu(i) ^ (31 & t.charCodeAt(e));
        for (let t of e) i = lu(i) ^ t;
        for (let t = 0; t < 6; t++) i = lu(i);
        return (i ^= r), fu.encode(ru([i % eu[30]], 30, 5, !1));
      }
      function pu(t) {
        const e = "bech32" === t ? 1 : 734539939,
          r = iu(5),
          n = r.decode,
          i = r.encode,
          o = ou(n);
        function s(t, r, n = 90) {
          Ka("bech32.encode prefix", t),
            ja(r) && (r = Array.from(r)),
            $a("bech32.encode", r);
          const i = t.length;
          if (0 === i) throw new TypeError(`Invalid prefix length ${i}`);
          const o = i + 7 + r.length;
          if (!1 !== n && o > n)
            throw new TypeError(`Length ${o} exceeds limit ${n}`);
          const s = t.toLowerCase(),
            a = du(s, r, e);
          return `${s}1${fu.encode(r)}${a}`;
        }
        function a(t, r = 90) {
          Ka("bech32.decode input", t);
          const n = t.length;
          if (n < 8 || (!1 !== r && n > r))
            throw new TypeError(
              `invalid string length: ${n} (${t}). Expected (8..${r})`,
            );
          const i = t.toLowerCase();
          if (t !== i && t !== t.toUpperCase())
            throw new Error("String must be lowercase or uppercase");
          const o = i.lastIndexOf("1");
          if (0 === o || -1 === o)
            throw new Error(
              'Letter "1" must be present between prefix and data only',
            );
          const s = i.slice(0, o),
            a = i.slice(o + 1);
          if (a.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const u = fu.decode(a).slice(0, -6),
            c = du(s, u, e);
          if (!a.endsWith(c))
            throw new Error(`Invalid checksum in ${t}: expected "${c}"`);
          return { prefix: s, words: u };
        }
        return {
          encode: s,
          decode: a,
          encodeFromBytes: function (t, e) {
            return s(t, i(e));
          },
          decodeToBytes: function (t) {
            const { prefix: e, words: r } = a(t, !1);
            return { prefix: e, words: r, bytes: n(r) };
          },
          decodeUnsafe: ou(a),
          fromWords: n,
          fromWordsUnsafe: o,
          toWords: i,
        };
      }
      const yu = pu("bech32"),
        gu = pu("bech32m"),
        mu = {
          encode: (t) => new TextDecoder().decode(t),
          decode: (t) => new TextEncoder().encode(t),
        },
        bu = Ga(
          iu(4),
          Wa("0123456789abcdef"),
          Ya(""),
          Za((t) => {
            if ("string" != typeof t || t.length % 2 != 0)
              throw new TypeError(
                `hex.decode: expected string, got ${typeof t} with length ${t.length}`,
              );
            return t.toLowerCase();
          }),
        );
      function wu(t) {
        if (!Number.isSafeInteger(t) || t < 0)
          throw new Error("positive integer expected, got " + t);
      }
      function vu(t, ...e) {
        if (
          !(function (t) {
            return (
              t instanceof Uint8Array ||
              (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
            );
          })(t)
        )
          throw new Error("Uint8Array expected");
        if (e.length > 0 && !e.includes(t.length))
          throw new Error(
            "Uint8Array expected of length " + e + ", got length=" + t.length,
          );
      }
      function _u(t) {
        if ("function" != typeof t || "function" != typeof t.create)
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        wu(t.outputLen), wu(t.blockLen);
      }
      function Eu(t, e = !0) {
        if (t.destroyed) throw new Error("Hash instance has been destroyed");
        if (e && t.finished)
          throw new Error("Hash#digest() has already been called");
      }
      const Su =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      function Iu(t) {
        return new DataView(t.buffer, t.byteOffset, t.byteLength);
      }
      function Mu(t, e) {
        return (t << (32 - e)) | (t >>> e);
      }
      function Au(t, e) {
        return (t << e) | ((t >>> (32 - e)) >>> 0);
      }
      const Tu = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0"),
      );
      function ku(t) {
        vu(t);
        let e = "";
        for (let r = 0; r < t.length; r++) e += Tu[t[r]];
        return e;
      }
      function Ou(t) {
        if ("string" != typeof t)
          throw new Error("utf8ToBytes expected string, got " + typeof t);
        return new Uint8Array(new TextEncoder().encode(t));
      }
      function xu(t) {
        return "string" == typeof t && (t = Ou(t)), vu(t), t;
      }
      function Pu(...t) {
        let e = 0;
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          vu(n), (e += n.length);
        }
        const r = new Uint8Array(e);
        for (let e = 0, n = 0; e < t.length; e++) {
          const i = t[e];
          r.set(i, n), (n += i.length);
        }
        return r;
      }
      class Bu {
        clone() {
          return this._cloneInto();
        }
      }
      function Cu(t) {
        const e = (e) => t().update(xu(e)).digest(),
          r = t();
        return (
          (e.outputLen = r.outputLen),
          (e.blockLen = r.blockLen),
          (e.create = () => t()),
          e
        );
      }
      function Ru(t = 32) {
        if (Su && "function" == typeof Su.getRandomValues)
          return Su.getRandomValues(new Uint8Array(t));
        if (Su && "function" == typeof Su.randomBytes) return Su.randomBytes(t);
        throw new Error("crypto.getRandomValues must be defined");
      }
      class Nu extends Bu {
        constructor(t, e) {
          super(), (this.finished = !1), (this.destroyed = !1), _u(t);
          const r = xu(e);
          if (
            ((this.iHash = t.create()), "function" != typeof this.iHash.update)
          )
            throw new Error(
              "Expected instance of class which extends utils.Hash",
            );
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          const n = this.blockLen,
            i = new Uint8Array(n);
          i.set(r.length > n ? t.create().update(r).digest() : r);
          for (let t = 0; t < i.length; t++) i[t] ^= 54;
          this.iHash.update(i), (this.oHash = t.create());
          for (let t = 0; t < i.length; t++) i[t] ^= 106;
          this.oHash.update(i), i.fill(0);
        }
        update(t) {
          return Eu(this), this.iHash.update(t), this;
        }
        digestInto(t) {
          Eu(this),
            vu(t, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(t),
            this.oHash.update(t),
            this.oHash.digestInto(t),
            this.destroy();
        }
        digest() {
          const t = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(t), t;
        }
        _cloneInto(t) {
          t || (t = Object.create(Object.getPrototypeOf(this), {}));
          const {
            oHash: e,
            iHash: r,
            finished: n,
            destroyed: i,
            blockLen: o,
            outputLen: s,
          } = this;
          return (
            (t.finished = n),
            (t.destroyed = i),
            (t.blockLen = o),
            (t.outputLen = s),
            (t.oHash = e._cloneInto(t.oHash)),
            (t.iHash = r._cloneInto(t.iHash)),
            t
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      const Uu = (t, e, r) => new Nu(t, e).update(r).digest();
      function Du(t, e, r) {
        return (t & e) ^ (~t & r);
      }
      function Lu(t, e, r) {
        return (t & e) ^ (t & r) ^ (e & r);
      }
      Uu.create = (t, e) => new Nu(t, e);
      class ju extends Bu {
        constructor(t, e, r, n) {
          super(),
            (this.blockLen = t),
            (this.outputLen = e),
            (this.padOffset = r),
            (this.isLE = n),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(t)),
            (this.view = Iu(this.buffer));
        }
        update(t) {
          Eu(this);
          const { view: e, buffer: r, blockLen: n } = this,
            i = (t = xu(t)).length;
          for (let o = 0; o < i; ) {
            const s = Math.min(n - this.pos, i - o);
            if (s !== n)
              r.set(t.subarray(o, o + s), this.pos),
                (this.pos += s),
                (o += s),
                this.pos === n && (this.process(e, 0), (this.pos = 0));
            else {
              const e = Iu(t);
              for (; n <= i - o; o += n) this.process(e, o);
            }
          }
          return (this.length += t.length), this.roundClean(), this;
        }
        digestInto(t) {
          Eu(this),
            (function (t, e) {
              vu(t);
              const r = e.outputLen;
              if (t.length < r)
                throw new Error(
                  "digestInto() expects output buffer of length at least " + r,
                );
            })(t, this),
            (this.finished = !0);
          const { buffer: e, view: r, blockLen: n, isLE: i } = this;
          let { pos: o } = this;
          (e[o++] = 128),
            this.buffer.subarray(o).fill(0),
            this.padOffset > n - o && (this.process(r, 0), (o = 0));
          for (let t = o; t < n; t++) e[t] = 0;
          !(function (t, e, r, n) {
            if ("function" == typeof t.setBigUint64)
              return t.setBigUint64(e, r, n);
            const i = BigInt(32),
              o = BigInt(4294967295),
              s = Number((r >> i) & o),
              a = Number(r & o),
              u = n ? 4 : 0,
              c = n ? 0 : 4;
            t.setUint32(e + u, s, n), t.setUint32(e + c, a, n);
          })(r, n - 8, BigInt(8 * this.length), i),
            this.process(r, 0);
          const s = Iu(t),
            a = this.outputLen;
          if (a % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const u = a / 4,
            c = this.get();
          if (u > c.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let t = 0; t < u; t++) s.setUint32(4 * t, c[t], i);
        }
        digest() {
          const { buffer: t, outputLen: e } = this;
          this.digestInto(t);
          const r = t.slice(0, e);
          return this.destroy(), r;
        }
        _cloneInto(t) {
          t || (t = new this.constructor()), t.set(...this.get());
          const {
            blockLen: e,
            buffer: r,
            length: n,
            finished: i,
            destroyed: o,
            pos: s,
          } = this;
          return (
            (t.length = n),
            (t.pos = s),
            (t.finished = i),
            (t.destroyed = o),
            n % e && t.buffer.set(r),
            t
          );
        }
      }
      const Fu = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]),
        Hu = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]),
        Ku = new Uint32Array(64);
      class Vu extends ju {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | Hu[0]),
            (this.B = 0 | Hu[1]),
            (this.C = 0 | Hu[2]),
            (this.D = 0 | Hu[3]),
            (this.E = 0 | Hu[4]),
            (this.F = 0 | Hu[5]),
            (this.G = 0 | Hu[6]),
            (this.H = 0 | Hu[7]);
        }
        get() {
          const { A: t, B: e, C: r, D: n, E: i, F: o, G: s, H: a } = this;
          return [t, e, r, n, i, o, s, a];
        }
        set(t, e, r, n, i, o, s, a) {
          (this.A = 0 | t),
            (this.B = 0 | e),
            (this.C = 0 | r),
            (this.D = 0 | n),
            (this.E = 0 | i),
            (this.F = 0 | o),
            (this.G = 0 | s),
            (this.H = 0 | a);
        }
        process(t, e) {
          for (let r = 0; r < 16; r++, e += 4) Ku[r] = t.getUint32(e, !1);
          for (let t = 16; t < 64; t++) {
            const e = Ku[t - 15],
              r = Ku[t - 2],
              n = Mu(e, 7) ^ Mu(e, 18) ^ (e >>> 3),
              i = Mu(r, 17) ^ Mu(r, 19) ^ (r >>> 10);
            Ku[t] = (i + Ku[t - 7] + n + Ku[t - 16]) | 0;
          }
          let { A: r, B: n, C: i, D: o, E: s, F: a, G: u, H: c } = this;
          for (let t = 0; t < 64; t++) {
            const e =
                (c +
                  (Mu(s, 6) ^ Mu(s, 11) ^ Mu(s, 25)) +
                  Du(s, a, u) +
                  Fu[t] +
                  Ku[t]) |
                0,
              f = ((Mu(r, 2) ^ Mu(r, 13) ^ Mu(r, 22)) + Lu(r, n, i)) | 0;
            (c = u),
              (u = a),
              (a = s),
              (s = (o + e) | 0),
              (o = i),
              (i = n),
              (n = r),
              (r = (e + f) | 0);
          }
          (r = (r + this.A) | 0),
            (n = (n + this.B) | 0),
            (i = (i + this.C) | 0),
            (o = (o + this.D) | 0),
            (s = (s + this.E) | 0),
            (a = (a + this.F) | 0),
            (u = (u + this.G) | 0),
            (c = (c + this.H) | 0),
            this.set(r, n, i, o, s, a, u, c);
        }
        roundClean() {
          Ku.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      const qu = Cu(() => new Vu()),
        zu = BigInt(2 ** 32 - 1),
        $u = BigInt(32);
      function Gu(t, e = !1) {
        return e
          ? { h: Number(t & zu), l: Number((t >> $u) & zu) }
          : { h: 0 | Number((t >> $u) & zu), l: 0 | Number(t & zu) };
      }
      const Wu = {
          fromBig: Gu,
          split: function (t, e = !1) {
            let r = new Uint32Array(t.length),
              n = new Uint32Array(t.length);
            for (let i = 0; i < t.length; i++) {
              const { h: o, l: s } = Gu(t[i], e);
              [r[i], n[i]] = [o, s];
            }
            return [r, n];
          },
          toBig: (t, e) => (BigInt(t >>> 0) << $u) | BigInt(e >>> 0),
          shrSH: (t, e, r) => t >>> r,
          shrSL: (t, e, r) => (t << (32 - r)) | (e >>> r),
          rotrSH: (t, e, r) => (t >>> r) | (e << (32 - r)),
          rotrSL: (t, e, r) => (t << (32 - r)) | (e >>> r),
          rotrBH: (t, e, r) => (t << (64 - r)) | (e >>> (r - 32)),
          rotrBL: (t, e, r) => (t >>> (r - 32)) | (e << (64 - r)),
          rotr32H: (t, e) => e,
          rotr32L: (t, e) => t,
          rotlSH: (t, e, r) => (t << r) | (e >>> (32 - r)),
          rotlSL: (t, e, r) => (e << r) | (t >>> (32 - r)),
          rotlBH: (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
          rotlBL: (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
          add: function (t, e, r, n) {
            const i = (e >>> 0) + (n >>> 0);
            return { h: (t + r + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
          },
          add3L: (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
          add3H: (t, e, r, n) => (e + r + n + ((t / 2 ** 32) | 0)) | 0,
          add4L: (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
          add4H: (t, e, r, n, i) => (e + r + n + i + ((t / 2 ** 32) | 0)) | 0,
          add5H: (t, e, r, n, i, o) =>
            (e + r + n + i + o + ((t / 2 ** 32) | 0)) | 0,
          add5L: (t, e, r, n, i) =>
            (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
        },
        Yu = Wu,
        [Xu, Zu] = (() =>
          Yu.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t)),
          ))();
      "abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo".split(
        "\n",
      );
      var Ju;
      !(function (t) {
        (t.PASSWORD_HASH = "passwordHash"),
          (t.PASSWORD_SALT = "passwordSalt"),
          (t.ENCRYPTED_KEY = "encryptedKey"),
          (t.SEED_VAULT_VERSION = "seedVaultVersion");
      })(Ju || (Ju = {}));
      const Qu = new Uint8Array([
          7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
        ]),
        tc = new Uint8Array(new Array(16).fill(0).map((t, e) => e)),
        ec = tc.map((t) => (9 * t + 5) % 16);
      let rc = [tc],
        nc = [ec];
      for (let t = 0; t < 4; t++)
        for (let e of [rc, nc]) e.push(e[t].map((t) => Qu[t]));
      const ic = [
          [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
          [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
          [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
          [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
          [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
        ].map((t) => new Uint8Array(t)),
        oc = rc.map((t, e) => t.map((t) => ic[e][t])),
        sc = nc.map((t, e) => t.map((t) => ic[e][t])),
        ac = new Uint32Array([
          0, 1518500249, 1859775393, 2400959708, 2840853838,
        ]),
        uc = new Uint32Array([
          1352829926, 1548603684, 1836072691, 2053994217, 0,
        ]);
      function cc(t, e, r, n) {
        return 0 === t
          ? e ^ r ^ n
          : 1 === t
            ? (e & r) | (~e & n)
            : 2 === t
              ? (e | ~r) ^ n
              : 3 === t
                ? (e & n) | (r & ~n)
                : e ^ (r | ~n);
      }
      const fc = new Uint32Array(16);
      class hc extends ju {
        constructor() {
          super(64, 20, 8, !0),
            (this.h0 = 1732584193),
            (this.h1 = -271733879),
            (this.h2 = -1732584194),
            (this.h3 = 271733878),
            (this.h4 = -1009589776);
        }
        get() {
          const { h0: t, h1: e, h2: r, h3: n, h4: i } = this;
          return [t, e, r, n, i];
        }
        set(t, e, r, n, i) {
          (this.h0 = 0 | t),
            (this.h1 = 0 | e),
            (this.h2 = 0 | r),
            (this.h3 = 0 | n),
            (this.h4 = 0 | i);
        }
        process(t, e) {
          for (let r = 0; r < 16; r++, e += 4) fc[r] = t.getUint32(e, !0);
          let r = 0 | this.h0,
            n = r,
            i = 0 | this.h1,
            o = i,
            s = 0 | this.h2,
            a = s,
            u = 0 | this.h3,
            c = u,
            f = 0 | this.h4,
            h = f;
          for (let t = 0; t < 5; t++) {
            const e = 4 - t,
              l = ac[t],
              d = uc[t],
              p = rc[t],
              y = nc[t],
              g = oc[t],
              m = sc[t];
            for (let e = 0; e < 16; e++) {
              const n = (Au(r + cc(t, i, s, u) + fc[p[e]] + l, g[e]) + f) | 0;
              (r = f), (f = u), (u = 0 | Au(s, 10)), (s = i), (i = n);
            }
            for (let t = 0; t < 16; t++) {
              const r = (Au(n + cc(e, o, a, c) + fc[y[t]] + d, m[t]) + h) | 0;
              (n = h), (h = c), (c = 0 | Au(a, 10)), (a = o), (o = r);
            }
          }
          this.set(
            (this.h1 + s + c) | 0,
            (this.h2 + u + h) | 0,
            (this.h3 + f + n) | 0,
            (this.h4 + r + o) | 0,
            (this.h0 + i + a) | 0,
          );
        }
        roundClean() {
          fc.fill(0);
        }
        destroy() {
          (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
        }
      }
      const lc = Cu(() => new hc()),
        dc = BigInt(0),
        pc = BigInt(1),
        yc = BigInt(2);
      function gc(t) {
        return (
          t instanceof Uint8Array ||
          (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
        );
      }
      function mc(t) {
        if (!gc(t)) throw new Error("Uint8Array expected");
      }
      function bc(t, e) {
        if ("boolean" != typeof e)
          throw new Error(t + " boolean expected, got " + e);
      }
      const wc = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0"),
      );
      function vc(t) {
        mc(t);
        let e = "";
        for (let r = 0; r < t.length; r++) e += wc[t[r]];
        return e;
      }
      function _c(t) {
        const e = t.toString(16);
        return 1 & e.length ? "0" + e : e;
      }
      function Ec(t) {
        if ("string" != typeof t)
          throw new Error("hex string expected, got " + typeof t);
        return "" === t ? dc : BigInt("0x" + t);
      }
      const Sc = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function Ic(t) {
        return t >= Sc._0 && t <= Sc._9
          ? t - Sc._0
          : t >= Sc.A && t <= Sc.F
            ? t - (Sc.A - 10)
            : t >= Sc.a && t <= Sc.f
              ? t - (Sc.a - 10)
              : void 0;
      }
      function Mc(t) {
        if ("string" != typeof t)
          throw new Error("hex string expected, got " + typeof t);
        const e = t.length,
          r = e / 2;
        if (e % 2)
          throw new Error(
            "hex string expected, got unpadded hex of length " + e,
          );
        const n = new Uint8Array(r);
        for (let e = 0, i = 0; e < r; e++, i += 2) {
          const r = Ic(t.charCodeAt(i)),
            o = Ic(t.charCodeAt(i + 1));
          if (void 0 === r || void 0 === o) {
            const e = t[i] + t[i + 1];
            throw new Error(
              'hex string expected, got non-hex character "' +
                e +
                '" at index ' +
                i,
            );
          }
          n[e] = 16 * r + o;
        }
        return n;
      }
      function Ac(t) {
        return Ec(vc(t));
      }
      function Tc(t) {
        return mc(t), Ec(vc(Uint8Array.from(t).reverse()));
      }
      function kc(t, e) {
        return Mc(t.toString(16).padStart(2 * e, "0"));
      }
      function Oc(t, e) {
        return kc(t, e).reverse();
      }
      function xc(t, e, r) {
        let n;
        if ("string" == typeof e)
          try {
            n = Mc(e);
          } catch (e) {
            throw new Error(
              t + " must be hex string or Uint8Array, cause: " + e,
            );
          }
        else {
          if (!gc(e)) throw new Error(t + " must be hex string or Uint8Array");
          n = Uint8Array.from(e);
        }
        const i = n.length;
        if ("number" == typeof r && i !== r)
          throw new Error(t + " of length " + r + " expected, got " + i);
        return n;
      }
      function Pc(...t) {
        let e = 0;
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          mc(n), (e += n.length);
        }
        const r = new Uint8Array(e);
        for (let e = 0, n = 0; e < t.length; e++) {
          const i = t[e];
          r.set(i, n), (n += i.length);
        }
        return r;
      }
      const Bc = (t) => "bigint" == typeof t && dc <= t;
      function Cc(t, e, r) {
        return Bc(t) && Bc(e) && Bc(r) && e <= t && t < r;
      }
      function Rc(t, e, r, n) {
        if (!Cc(e, r, n))
          throw new Error(
            "expected valid " + t + ": " + r + " <= n < " + n + ", got " + e,
          );
      }
      function Nc(t) {
        let e;
        for (e = 0; t > dc; t >>= pc, e += 1);
        return e;
      }
      const Uc = (t) => (yc << BigInt(t - 1)) - pc,
        Dc = (t) => new Uint8Array(t),
        Lc = (t) => Uint8Array.from(t);
      function jc(t, e, r) {
        if ("number" != typeof t || t < 2)
          throw new Error("hashLen must be a number");
        if ("number" != typeof e || e < 2)
          throw new Error("qByteLen must be a number");
        if ("function" != typeof r)
          throw new Error("hmacFn must be a function");
        let n = Dc(t),
          i = Dc(t),
          o = 0;
        const s = () => {
            n.fill(1), i.fill(0), (o = 0);
          },
          a = (...t) => r(i, n, ...t),
          u = (t = Dc()) => {
            (i = a(Lc([0]), t)),
              (n = a()),
              0 !== t.length && ((i = a(Lc([1]), t)), (n = a()));
          },
          c = () => {
            if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let t = 0;
            const r = [];
            for (; t < e; ) {
              n = a();
              const e = n.slice();
              r.push(e), (t += n.length);
            }
            return Pc(...r);
          };
        return (t, e) => {
          let r;
          for (s(), u(t); !(r = e(c())); ) u();
          return s(), r;
        };
      }
      const Fc = {
        bigint: (t) => "bigint" == typeof t,
        function: (t) => "function" == typeof t,
        boolean: (t) => "boolean" == typeof t,
        string: (t) => "string" == typeof t,
        stringOrUint8Array: (t) => "string" == typeof t || gc(t),
        isSafeInteger: (t) => Number.isSafeInteger(t),
        array: (t) => Array.isArray(t),
        field: (t, e) => e.Fp.isValid(t),
        hash: (t) =>
          "function" == typeof t && Number.isSafeInteger(t.outputLen),
      };
      function Hc(t, e, r = {}) {
        const n = (e, r, n) => {
          const i = Fc[r];
          if ("function" != typeof i)
            throw new Error("invalid validator function");
          const o = t[e];
          if (!((n && void 0 === o) || i(o, t)))
            throw new Error(
              "param " +
                String(e) +
                " is invalid. Expected " +
                r +
                ", got " +
                o,
            );
        };
        for (const [t, r] of Object.entries(e)) n(t, r, !1);
        for (const [t, e] of Object.entries(r)) n(t, e, !0);
        return t;
      }
      function Kc(t) {
        const e = new WeakMap();
        return (r, ...n) => {
          const i = e.get(r);
          if (void 0 !== i) return i;
          const o = t(r, ...n);
          return e.set(r, o), o;
        };
      }
      /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const Vc = BigInt(0),
        qc = BigInt(1),
        zc = BigInt(2),
        $c = BigInt(3),
        Gc = BigInt(4),
        Wc = BigInt(5),
        Yc = BigInt(8);
      function Xc(t, e) {
        const r = t % e;
        return r >= Vc ? r : e + r;
      }
      function Zc(t, e, r) {
        if (e < Vc) throw new Error("invalid exponent, negatives unsupported");
        if (r <= Vc) throw new Error("invalid modulus");
        if (r === qc) return Vc;
        let n = qc;
        for (; e > Vc; )
          e & qc && (n = (n * t) % r), (t = (t * t) % r), (e >>= qc);
        return n;
      }
      function Jc(t, e, r) {
        let n = t;
        for (; e-- > Vc; ) (n *= n), (n %= r);
        return n;
      }
      function Qc(t, e) {
        if (t === Vc) throw new Error("invert: expected non-zero number");
        if (e <= Vc)
          throw new Error("invert: expected positive modulus, got " + e);
        let r = Xc(t, e),
          n = e,
          i = Vc,
          o = qc,
          s = qc,
          a = Vc;
        for (; r !== Vc; ) {
          const t = n / r,
            e = n % r,
            u = i - s * t,
            c = o - a * t;
          (n = r), (r = e), (i = s), (o = a), (s = u), (a = c);
        }
        if (n !== qc) throw new Error("invert: does not exist");
        return Xc(i, e);
      }
      function tf(t) {
        if (t % Gc === $c) {
          const e = (t + qc) / Gc;
          return function (t, r) {
            const n = t.pow(r, e);
            if (!t.eql(t.sqr(n), r)) throw new Error("Cannot find square root");
            return n;
          };
        }
        if (t % Yc === Wc) {
          const e = (t - Wc) / Yc;
          return function (t, r) {
            const n = t.mul(r, zc),
              i = t.pow(n, e),
              o = t.mul(r, i),
              s = t.mul(t.mul(o, zc), i),
              a = t.mul(o, t.sub(s, t.ONE));
            if (!t.eql(t.sqr(a), r)) throw new Error("Cannot find square root");
            return a;
          };
        }
        return (function (t) {
          const e = (t - qc) / zc;
          let r, n, i;
          for (r = t - qc, n = 0; r % zc === Vc; r /= zc, n++);
          for (i = zc; i < t && Zc(i, e, t) !== t - qc; i++)
            if (i > 1e3)
              throw new Error("Cannot find square root: likely non-prime P");
          if (1 === n) {
            const e = (t + qc) / Gc;
            return function (t, r) {
              const n = t.pow(r, e);
              if (!t.eql(t.sqr(n), r))
                throw new Error("Cannot find square root");
              return n;
            };
          }
          const o = (r + qc) / zc;
          return function (t, s) {
            if (t.pow(s, e) === t.neg(t.ONE))
              throw new Error("Cannot find square root");
            let a = n,
              u = t.pow(t.mul(t.ONE, i), r),
              c = t.pow(s, o),
              f = t.pow(s, r);
            for (; !t.eql(f, t.ONE); ) {
              if (t.eql(f, t.ZERO)) return t.ZERO;
              let e = 1;
              for (let r = t.sqr(f); e < a && !t.eql(r, t.ONE); e++)
                r = t.sqr(r);
              const r = t.pow(u, qc << BigInt(a - e - 1));
              (u = t.sqr(r)), (c = t.mul(c, r)), (f = t.mul(f, u)), (a = e);
            }
            return c;
          };
        })(t);
      }
      const ef = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function rf(t, e) {
        const r = void 0 !== e ? e : t.toString(2).length;
        return { nBitLength: r, nByteLength: Math.ceil(r / 8) };
      }
      function nf(t, e, r = !1, n = {}) {
        if (t <= Vc)
          throw new Error("invalid field: expected ORDER > 0, got " + t);
        const { nBitLength: i, nByteLength: o } = rf(t, e);
        if (o > 2048)
          throw new Error("invalid field: expected ORDER of <= 2048 bytes");
        let s;
        const a = Object.freeze({
          ORDER: t,
          isLE: r,
          BITS: i,
          BYTES: o,
          MASK: Uc(i),
          ZERO: Vc,
          ONE: qc,
          create: (e) => Xc(e, t),
          isValid: (e) => {
            if ("bigint" != typeof e)
              throw new Error(
                "invalid field element: expected bigint, got " + typeof e,
              );
            return Vc <= e && e < t;
          },
          is0: (t) => t === Vc,
          isOdd: (t) => (t & qc) === qc,
          neg: (e) => Xc(-e, t),
          eql: (t, e) => t === e,
          sqr: (e) => Xc(e * e, t),
          add: (e, r) => Xc(e + r, t),
          sub: (e, r) => Xc(e - r, t),
          mul: (e, r) => Xc(e * r, t),
          pow: (t, e) =>
            (function (t, e, r) {
              if (r < Vc)
                throw new Error("invalid exponent, negatives unsupported");
              if (r === Vc) return t.ONE;
              if (r === qc) return e;
              let n = t.ONE,
                i = e;
              for (; r > Vc; )
                r & qc && (n = t.mul(n, i)), (i = t.sqr(i)), (r >>= qc);
              return n;
            })(a, t, e),
          div: (e, r) => Xc(e * Qc(r, t), t),
          sqrN: (t) => t * t,
          addN: (t, e) => t + e,
          subN: (t, e) => t - e,
          mulN: (t, e) => t * e,
          inv: (e) => Qc(e, t),
          sqrt: n.sqrt || ((e) => (s || (s = tf(t)), s(a, e))),
          invertBatch: (t) =>
            (function (t, e) {
              const r = new Array(e.length),
                n = e.reduce(
                  (e, n, i) => (t.is0(n) ? e : ((r[i] = e), t.mul(e, n))),
                  t.ONE,
                ),
                i = t.inv(n);
              return (
                e.reduceRight(
                  (e, n, i) =>
                    t.is0(n) ? e : ((r[i] = t.mul(e, r[i])), t.mul(e, n)),
                  i,
                ),
                r
              );
            })(a, t),
          cmov: (t, e, r) => (r ? e : t),
          toBytes: (t) => (r ? Oc(t, o) : kc(t, o)),
          fromBytes: (t) => {
            if (t.length !== o)
              throw new Error(
                "Field.fromBytes: expected " + o + " bytes, got " + t.length,
              );
            return r ? Tc(t) : Ac(t);
          },
        });
        return Object.freeze(a);
      }
      function of(t) {
        if ("bigint" != typeof t) throw new Error("field order must be bigint");
        const e = t.toString(2).length;
        return Math.ceil(e / 8);
      }
      function sf(t) {
        const e = of(t);
        return e + Math.ceil(e / 2);
      }
      /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const af = BigInt(0),
        uf = BigInt(1);
      function cf(t, e) {
        const r = e.negate();
        return t ? r : e;
      }
      function ff(t, e) {
        if (!Number.isSafeInteger(t) || t <= 0 || t > e)
          throw new Error(
            "invalid window size, expected [1.." + e + "], got W=" + t,
          );
      }
      function hf(t, e) {
        ff(t, e);
        return { windows: Math.ceil(e / t) + 1, windowSize: 2 ** (t - 1) };
      }
      function lf(t, e) {
        if (!Array.isArray(t)) throw new Error("array expected");
        t.forEach((t, r) => {
          if (!(t instanceof e)) throw new Error("invalid point at index " + r);
        });
      }
      function df(t, e) {
        if (!Array.isArray(t)) throw new Error("array of scalars expected");
        t.forEach((t, r) => {
          if (!e.isValid(t)) throw new Error("invalid scalar at index " + r);
        });
      }
      const pf = new WeakMap(),
        yf = new WeakMap();
      function gf(t) {
        return yf.get(t) || 1;
      }
      function mf(t) {
        return (
          (function (t) {
            const e = ef.reduce((t, e) => ((t[e] = "function"), t), {
              ORDER: "bigint",
              MASK: "bigint",
              BYTES: "isSafeInteger",
              BITS: "isSafeInteger",
            });
            Hc(t, e);
          })(t.Fp),
          Hc(
            t,
            { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
            { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" },
          ),
          Object.freeze({ ...rf(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
        );
      }
      /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      function bf(t) {
        void 0 !== t.lowS && bc("lowS", t.lowS),
          void 0 !== t.prehash && bc("prehash", t.prehash);
      }
      const { Ph: wf, aT: vf } = e;
      class _f extends Error {
        constructor(t = "") {
          super(t);
        }
      }
      const Ef = {
          Err: _f,
          _tlv: {
            encode: (t, e) => {
              const { Err: r } = Ef;
              if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
              if (1 & e.length) throw new r("tlv.encode: unpadded data");
              const n = e.length / 2,
                i = _c(n);
              if ((i.length / 2) & 128)
                throw new r("tlv.encode: long form length too big");
              const o = n > 127 ? _c((i.length / 2) | 128) : "";
              return _c(t) + o + i + e;
            },
            decode(t, e) {
              const { Err: r } = Ef;
              let n = 0;
              if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
              if (e.length < 2 || e[n++] !== t)
                throw new r("tlv.decode: wrong tlv");
              const i = e[n++];
              let o = 0;
              if (!!(128 & i)) {
                const t = 127 & i;
                if (!t)
                  throw new r(
                    "tlv.decode(long): indefinite length not supported",
                  );
                if (t > 4)
                  throw new r("tlv.decode(long): byte length is too big");
                const s = e.subarray(n, n + t);
                if (s.length !== t)
                  throw new r("tlv.decode: length bytes not complete");
                if (0 === s[0])
                  throw new r("tlv.decode(long): zero leftmost byte");
                for (const t of s) o = (o << 8) | t;
                if (((n += t), o < 128))
                  throw new r("tlv.decode(long): not minimal encoding");
              } else o = i;
              const s = e.subarray(n, n + o);
              if (s.length !== o) throw new r("tlv.decode: wrong value length");
              return { v: s, l: e.subarray(n + o) };
            },
          },
          _int: {
            encode(t) {
              const { Err: e } = Ef;
              if (t < Sf)
                throw new e("integer: negative integers are not allowed");
              let r = _c(t);
              if (
                (8 & Number.parseInt(r[0], 16) && (r = "00" + r), 1 & r.length)
              )
                throw new e("unexpected DER parsing assertion: unpadded hex");
              return r;
            },
            decode(t) {
              const { Err: e } = Ef;
              if (128 & t[0])
                throw new e("invalid signature integer: negative");
              if (0 === t[0] && !(128 & t[1]))
                throw new e(
                  "invalid signature integer: unnecessary leading zero",
                );
              return wf(t);
            },
          },
          toSig(t) {
            const { Err: e, _int: r, _tlv: n } = Ef,
              i = "string" == typeof t ? vf(t) : t;
            mc(i);
            const { v: o, l: s } = n.decode(48, i);
            if (s.length)
              throw new e("invalid signature: left bytes after parsing");
            const { v: a, l: u } = n.decode(2, o),
              { v: c, l: f } = n.decode(2, u);
            if (f.length)
              throw new e("invalid signature: left bytes after parsing");
            return { r: r.decode(a), s: r.decode(c) };
          },
          hexFromSig(t) {
            const { _tlv: e, _int: r } = Ef,
              n = e.encode(2, r.encode(t.r)) + e.encode(2, r.encode(t.s));
            return e.encode(48, n);
          },
        },
        Sf = BigInt(0),
        If = BigInt(1),
        Mf = (BigInt(2), BigInt(3));
      BigInt(4);
      function Af(t) {
        const e = (function (t) {
            const e = mf(t);
            Hc(
              e,
              { a: "field", b: "field" },
              {
                allowedPrivateKeyLengths: "array",
                wrapPrivateKey: "boolean",
                isTorsionFree: "function",
                clearCofactor: "function",
                allowInfinityPoint: "boolean",
                fromBytes: "function",
                toBytes: "function",
              },
            );
            const { endo: r, Fp: n, a: i } = e;
            if (r) {
              if (!n.eql(i, n.ZERO))
                throw new Error(
                  "invalid endomorphism, can only be defined for Koblitz curves that have a=0",
                );
              if (
                "object" != typeof r ||
                "bigint" != typeof r.beta ||
                "function" != typeof r.splitScalar
              )
                throw new Error(
                  "invalid endomorphism, expected beta: bigint and splitScalar: function",
                );
            }
            return Object.freeze({ ...e });
          })(t),
          { Fp: r } = e,
          n = nf(e.n, e.nBitLength),
          i =
            e.toBytes ||
            ((t, e, n) => {
              const i = e.toAffine();
              return Pc(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y));
            }),
          o =
            e.fromBytes ||
            ((t) => {
              const e = t.subarray(1);
              return {
                x: r.fromBytes(e.subarray(0, r.BYTES)),
                y: r.fromBytes(e.subarray(r.BYTES, 2 * r.BYTES)),
              };
            });
        function s(t) {
          const { a: n, b: i } = e,
            o = r.sqr(t),
            s = r.mul(o, t);
          return r.add(r.add(s, r.mul(t, n)), i);
        }
        if (!r.eql(r.sqr(e.Gy), s(e.Gx)))
          throw new Error("bad generator point: equation left != right");
        function a(t) {
          const {
            allowedPrivateKeyLengths: r,
            nByteLength: n,
            wrapPrivateKey: i,
            n: o,
          } = e;
          if (r && "bigint" != typeof t) {
            if (
              (gc(t) && (t = vc(t)),
              "string" != typeof t || !r.includes(t.length))
            )
              throw new Error("invalid private key");
            t = t.padStart(2 * n, "0");
          }
          let s;
          try {
            s = "bigint" == typeof t ? t : Ac(xc("private key", t, n));
          } catch (e) {
            throw new Error(
              "invalid private key, expected hex or " +
                n +
                " bytes, got " +
                typeof t,
            );
          }
          return i && (s = Xc(s, o)), Rc("private key", s, If, o), s;
        }
        function u(t) {
          if (!(t instanceof h)) throw new Error("ProjectivePoint expected");
        }
        const c = Kc((t, e) => {
            const { px: n, py: i, pz: o } = t;
            if (r.eql(o, r.ONE)) return { x: n, y: i };
            const s = t.is0();
            null == e && (e = s ? r.ONE : r.inv(o));
            const a = r.mul(n, e),
              u = r.mul(i, e),
              c = r.mul(o, e);
            if (s) return { x: r.ZERO, y: r.ZERO };
            if (!r.eql(c, r.ONE)) throw new Error("invZ was invalid");
            return { x: a, y: u };
          }),
          f = Kc((t) => {
            if (t.is0()) {
              if (e.allowInfinityPoint && !r.is0(t.py)) return;
              throw new Error("bad point: ZERO");
            }
            const { x: n, y: i } = t.toAffine();
            if (!r.isValid(n) || !r.isValid(i))
              throw new Error("bad point: x or y not FE");
            const o = r.sqr(i),
              a = s(n);
            if (!r.eql(o, a))
              throw new Error("bad point: equation left != right");
            if (!t.isTorsionFree())
              throw new Error("bad point: not in prime-order subgroup");
            return !0;
          });
        class h {
          constructor(t, e, n) {
            if (
              ((this.px = t),
              (this.py = e),
              (this.pz = n),
              null == t || !r.isValid(t))
            )
              throw new Error("x required");
            if (null == e || !r.isValid(e)) throw new Error("y required");
            if (null == n || !r.isValid(n)) throw new Error("z required");
            Object.freeze(this);
          }
          static fromAffine(t) {
            const { x: e, y: n } = t || {};
            if (!t || !r.isValid(e) || !r.isValid(n))
              throw new Error("invalid affine point");
            if (t instanceof h) throw new Error("projective point not allowed");
            const i = (t) => r.eql(t, r.ZERO);
            return i(e) && i(n) ? h.ZERO : new h(e, n, r.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(t) {
            const e = r.invertBatch(t.map((t) => t.pz));
            return t.map((t, r) => t.toAffine(e[r])).map(h.fromAffine);
          }
          static fromHex(t) {
            const e = h.fromAffine(o(xc("pointHex", t)));
            return e.assertValidity(), e;
          }
          static fromPrivateKey(t) {
            return h.BASE.multiply(a(t));
          }
          static msm(t, e) {
            return (function (t, e, r, n) {
              if ((lf(r, t), df(n, e), r.length !== n.length))
                throw new Error(
                  "arrays of points and scalars must have equal length",
                );
              const i = t.ZERO,
                o = Nc(BigInt(r.length)),
                s = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1,
                a = (1 << s) - 1,
                u = new Array(a + 1).fill(i);
              let c = i;
              for (let t = Math.floor((e.BITS - 1) / s) * s; t >= 0; t -= s) {
                u.fill(i);
                for (let e = 0; e < n.length; e++) {
                  const i = n[e],
                    o = Number((i >> BigInt(t)) & BigInt(a));
                  u[o] = u[o].add(r[e]);
                }
                let e = i;
                for (let t = u.length - 1, r = i; t > 0; t--)
                  (r = r.add(u[t])), (e = e.add(r));
                if (((c = c.add(e)), 0 !== t))
                  for (let t = 0; t < s; t++) c = c.double();
              }
              return c;
            })(h, n, t, e);
          }
          _setWindowSize(t) {
            d.setWindowSize(this, t);
          }
          assertValidity() {
            f(this);
          }
          hasEvenY() {
            const { y: t } = this.toAffine();
            if (r.isOdd) return !r.isOdd(t);
            throw new Error("Field doesn't support isOdd");
          }
          equals(t) {
            u(t);
            const { px: e, py: n, pz: i } = this,
              { px: o, py: s, pz: a } = t,
              c = r.eql(r.mul(e, a), r.mul(o, i)),
              f = r.eql(r.mul(n, a), r.mul(s, i));
            return c && f;
          }
          negate() {
            return new h(this.px, r.neg(this.py), this.pz);
          }
          double() {
            const { a: t, b: n } = e,
              i = r.mul(n, Mf),
              { px: o, py: s, pz: a } = this;
            let u = r.ZERO,
              c = r.ZERO,
              f = r.ZERO,
              l = r.mul(o, o),
              d = r.mul(s, s),
              p = r.mul(a, a),
              y = r.mul(o, s);
            return (
              (y = r.add(y, y)),
              (f = r.mul(o, a)),
              (f = r.add(f, f)),
              (u = r.mul(t, f)),
              (c = r.mul(i, p)),
              (c = r.add(u, c)),
              (u = r.sub(d, c)),
              (c = r.add(d, c)),
              (c = r.mul(u, c)),
              (u = r.mul(y, u)),
              (f = r.mul(i, f)),
              (p = r.mul(t, p)),
              (y = r.sub(l, p)),
              (y = r.mul(t, y)),
              (y = r.add(y, f)),
              (f = r.add(l, l)),
              (l = r.add(f, l)),
              (l = r.add(l, p)),
              (l = r.mul(l, y)),
              (c = r.add(c, l)),
              (p = r.mul(s, a)),
              (p = r.add(p, p)),
              (l = r.mul(p, y)),
              (u = r.sub(u, l)),
              (f = r.mul(p, d)),
              (f = r.add(f, f)),
              (f = r.add(f, f)),
              new h(u, c, f)
            );
          }
          add(t) {
            u(t);
            const { px: n, py: i, pz: o } = this,
              { px: s, py: a, pz: c } = t;
            let f = r.ZERO,
              l = r.ZERO,
              d = r.ZERO;
            const p = e.a,
              y = r.mul(e.b, Mf);
            let g = r.mul(n, s),
              m = r.mul(i, a),
              b = r.mul(o, c),
              w = r.add(n, i),
              v = r.add(s, a);
            (w = r.mul(w, v)),
              (v = r.add(g, m)),
              (w = r.sub(w, v)),
              (v = r.add(n, o));
            let _ = r.add(s, c);
            return (
              (v = r.mul(v, _)),
              (_ = r.add(g, b)),
              (v = r.sub(v, _)),
              (_ = r.add(i, o)),
              (f = r.add(a, c)),
              (_ = r.mul(_, f)),
              (f = r.add(m, b)),
              (_ = r.sub(_, f)),
              (d = r.mul(p, v)),
              (f = r.mul(y, b)),
              (d = r.add(f, d)),
              (f = r.sub(m, d)),
              (d = r.add(m, d)),
              (l = r.mul(f, d)),
              (m = r.add(g, g)),
              (m = r.add(m, g)),
              (b = r.mul(p, b)),
              (v = r.mul(y, v)),
              (m = r.add(m, b)),
              (b = r.sub(g, b)),
              (b = r.mul(p, b)),
              (v = r.add(v, b)),
              (g = r.mul(m, v)),
              (l = r.add(l, g)),
              (g = r.mul(_, v)),
              (f = r.mul(w, f)),
              (f = r.sub(f, g)),
              (g = r.mul(w, m)),
              (d = r.mul(_, d)),
              (d = r.add(d, g)),
              new h(f, l, d)
            );
          }
          subtract(t) {
            return this.add(t.negate());
          }
          is0() {
            return this.equals(h.ZERO);
          }
          wNAF(t) {
            return d.wNAFCached(this, t, h.normalizeZ);
          }
          multiplyUnsafe(t) {
            const { endo: n, n: i } = e;
            Rc("scalar", t, Sf, i);
            const o = h.ZERO;
            if (t === Sf) return o;
            if (this.is0() || t === If) return this;
            if (!n || d.hasPrecomputes(this))
              return d.wNAFCachedUnsafe(this, t, h.normalizeZ);
            let { k1neg: s, k1: a, k2neg: u, k2: c } = n.splitScalar(t),
              f = o,
              l = o,
              p = this;
            for (; a > Sf || c > Sf; )
              a & If && (f = f.add(p)),
                c & If && (l = l.add(p)),
                (p = p.double()),
                (a >>= If),
                (c >>= If);
            return (
              s && (f = f.negate()),
              u && (l = l.negate()),
              (l = new h(r.mul(l.px, n.beta), l.py, l.pz)),
              f.add(l)
            );
          }
          multiply(t) {
            const { endo: n, n: i } = e;
            let o, s;
            if ((Rc("scalar", t, If, i), n)) {
              const { k1neg: e, k1: i, k2neg: a, k2: u } = n.splitScalar(t);
              let { p: c, f } = this.wNAF(i),
                { p: l, f: p } = this.wNAF(u);
              (c = d.constTimeNegate(e, c)),
                (l = d.constTimeNegate(a, l)),
                (l = new h(r.mul(l.px, n.beta), l.py, l.pz)),
                (o = c.add(l)),
                (s = f.add(p));
            } else {
              const { p: e, f: r } = this.wNAF(t);
              (o = e), (s = r);
            }
            return h.normalizeZ([o, s])[0];
          }
          multiplyAndAddUnsafe(t, e, r) {
            const n = h.BASE,
              i = (t, e) =>
                e !== Sf && e !== If && t.equals(n)
                  ? t.multiply(e)
                  : t.multiplyUnsafe(e),
              o = i(this, e).add(i(t, r));
            return o.is0() ? void 0 : o;
          }
          toAffine(t) {
            return c(this, t);
          }
          isTorsionFree() {
            const { h: t, isTorsionFree: r } = e;
            if (t === If) return !0;
            if (r) return r(h, this);
            throw new Error(
              "isTorsionFree() has not been declared for the elliptic curve",
            );
          }
          clearCofactor() {
            const { h: t, clearCofactor: r } = e;
            return t === If ? this : r ? r(h, this) : this.multiplyUnsafe(e.h);
          }
          toRawBytes(t = !0) {
            return bc("isCompressed", t), this.assertValidity(), i(h, this, t);
          }
          toHex(t = !0) {
            return bc("isCompressed", t), vc(this.toRawBytes(t));
          }
        }
        (h.BASE = new h(e.Gx, e.Gy, r.ONE)),
          (h.ZERO = new h(r.ZERO, r.ONE, r.ZERO));
        const l = e.nBitLength,
          d = (function (t, e) {
            return {
              constTimeNegate: cf,
              hasPrecomputes: (t) => 1 !== gf(t),
              unsafeLadder(e, r, n = t.ZERO) {
                let i = e;
                for (; r > af; )
                  r & uf && (n = n.add(i)), (i = i.double()), (r >>= uf);
                return n;
              },
              precomputeWindow(t, r) {
                const { windows: n, windowSize: i } = hf(r, e),
                  o = [];
                let s = t,
                  a = s;
                for (let t = 0; t < n; t++) {
                  (a = s), o.push(a);
                  for (let t = 1; t < i; t++) (a = a.add(s)), o.push(a);
                  s = a.double();
                }
                return o;
              },
              wNAF(r, n, i) {
                const { windows: o, windowSize: s } = hf(r, e);
                let a = t.ZERO,
                  u = t.BASE;
                const c = BigInt(2 ** r - 1),
                  f = 2 ** r,
                  h = BigInt(r);
                for (let t = 0; t < o; t++) {
                  const e = t * s;
                  let r = Number(i & c);
                  (i >>= h), r > s && ((r -= f), (i += uf));
                  const o = e,
                    l = e + Math.abs(r) - 1,
                    d = t % 2 != 0,
                    p = r < 0;
                  0 === r ? (u = u.add(cf(d, n[o]))) : (a = a.add(cf(p, n[l])));
                }
                return { p: a, f: u };
              },
              wNAFUnsafe(r, n, i, o = t.ZERO) {
                const { windows: s, windowSize: a } = hf(r, e),
                  u = BigInt(2 ** r - 1),
                  c = 2 ** r,
                  f = BigInt(r);
                for (let t = 0; t < s; t++) {
                  const e = t * a;
                  if (i === af) break;
                  let r = Number(i & u);
                  if (((i >>= f), r > a && ((r -= c), (i += uf)), 0 === r))
                    continue;
                  let s = n[e + Math.abs(r) - 1];
                  r < 0 && (s = s.negate()), (o = o.add(s));
                }
                return o;
              },
              getPrecomputes(t, e, r) {
                let n = pf.get(e);
                return (
                  n ||
                    ((n = this.precomputeWindow(e, t)),
                    1 !== t && pf.set(e, r(n))),
                  n
                );
              },
              wNAFCached(t, e, r) {
                const n = gf(t);
                return this.wNAF(n, this.getPrecomputes(n, t, r), e);
              },
              wNAFCachedUnsafe(t, e, r, n) {
                const i = gf(t);
                return 1 === i
                  ? this.unsafeLadder(t, e, n)
                  : this.wNAFUnsafe(i, this.getPrecomputes(i, t, r), e, n);
              },
              setWindowSize(t, r) {
                ff(r, e), yf.set(t, r), pf.delete(t);
              },
            };
          })(h, e.endo ? Math.ceil(l / 2) : l);
        return {
          CURVE: e,
          ProjectivePoint: h,
          normPrivateKeyToScalar: a,
          weierstrassEquation: s,
          isWithinCurveOrder: function (t) {
            return Cc(t, If, e.n);
          },
        };
      }
      function Tf(t) {
        const e = (function (t) {
            const e = mf(t);
            return (
              Hc(
                e,
                { hash: "hash", hmac: "function", randomBytes: "function" },
                {
                  bits2int: "function",
                  bits2int_modN: "function",
                  lowS: "boolean",
                },
              ),
              Object.freeze({ lowS: !0, ...e })
            );
          })(t),
          { Fp: r, n } = e,
          i = r.BYTES + 1,
          o = 2 * r.BYTES + 1;
        function s(t) {
          return Xc(t, n);
        }
        function a(t) {
          return Qc(t, n);
        }
        const {
            ProjectivePoint: u,
            normPrivateKeyToScalar: c,
            weierstrassEquation: f,
            isWithinCurveOrder: h,
          } = Af({
            ...e,
            toBytes(t, e, n) {
              const i = e.toAffine(),
                o = r.toBytes(i.x),
                s = Pc;
              return (
                bc("isCompressed", n),
                n
                  ? s(Uint8Array.from([e.hasEvenY() ? 2 : 3]), o)
                  : s(Uint8Array.from([4]), o, r.toBytes(i.y))
              );
            },
            fromBytes(t) {
              const e = t.length,
                n = t[0],
                s = t.subarray(1);
              if (e !== i || (2 !== n && 3 !== n)) {
                if (e === o && 4 === n) {
                  return {
                    x: r.fromBytes(s.subarray(0, r.BYTES)),
                    y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES)),
                  };
                }
                throw new Error(
                  "invalid Point, expected length of " +
                    i +
                    ", or uncompressed " +
                    o +
                    ", got " +
                    e,
                );
              }
              {
                const t = Ac(s);
                if (!Cc(t, If, r.ORDER))
                  throw new Error("Point is not on curve");
                const e = f(t);
                let i;
                try {
                  i = r.sqrt(e);
                } catch (t) {
                  const e = t instanceof Error ? ": " + t.message : "";
                  throw new Error("Point is not on curve" + e);
                }
                return (
                  !(1 & ~n) !== ((i & If) === If) && (i = r.neg(i)),
                  { x: t, y: i }
                );
              }
            },
          }),
          l = (t) => vc(kc(t, e.nByteLength));
        function d(t) {
          return t > n >> If;
        }
        const p = (t, e, r) => Ac(t.slice(e, r));
        class y {
          constructor(t, e, r) {
            (this.r = t),
              (this.s = e),
              (this.recovery = r),
              this.assertValidity();
          }
          static fromCompact(t) {
            const r = e.nByteLength;
            return (
              (t = xc("compactSignature", t, 2 * r)),
              new y(p(t, 0, r), p(t, r, 2 * r))
            );
          }
          static fromDER(t) {
            const { r: e, s: r } = Ef.toSig(xc("DER", t));
            return new y(e, r);
          }
          assertValidity() {
            Rc("r", this.r, If, n), Rc("s", this.s, If, n);
          }
          addRecoveryBit(t) {
            return new y(this.r, this.s, t);
          }
          recoverPublicKey(t) {
            const { r: n, s: i, recovery: o } = this,
              c = w(xc("msgHash", t));
            if (null == o || ![0, 1, 2, 3].includes(o))
              throw new Error("recovery id invalid");
            const f = 2 === o || 3 === o ? n + e.n : n;
            if (f >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const h = 1 & o ? "03" : "02",
              d = u.fromHex(h + l(f)),
              p = a(f),
              y = s(-c * p),
              g = s(i * p),
              m = u.BASE.multiplyAndAddUnsafe(d, y, g);
            if (!m) throw new Error("point at infinify");
            return m.assertValidity(), m;
          }
          hasHighS() {
            return d(this.s);
          }
          normalizeS() {
            return this.hasHighS()
              ? new y(this.r, s(-this.s), this.recovery)
              : this;
          }
          toDERRawBytes() {
            return Mc(this.toDERHex());
          }
          toDERHex() {
            return Ef.hexFromSig({ r: this.r, s: this.s });
          }
          toCompactRawBytes() {
            return Mc(this.toCompactHex());
          }
          toCompactHex() {
            return l(this.r) + l(this.s);
          }
        }
        const g = {
          isValidPrivateKey(t) {
            try {
              return c(t), !0;
            } catch (t) {
              return !1;
            }
          },
          normPrivateKeyToScalar: c,
          randomPrivateKey: () => {
            const t = sf(e.n);
            return (function (t, e, r = !1) {
              const n = t.length,
                i = of(e),
                o = sf(e);
              if (n < 16 || n < o || n > 1024)
                throw new Error(
                  "expected " + o + "-1024 bytes of input, got " + n,
                );
              const s = Xc(r ? Tc(t) : Ac(t), e - qc) + qc;
              return r ? Oc(s, i) : kc(s, i);
            })(e.randomBytes(t), e.n);
          },
          precompute: (t = 8, e = u.BASE) => (
            e._setWindowSize(t), e.multiply(BigInt(3)), e
          ),
        };
        function m(t) {
          const e = gc(t),
            r = "string" == typeof t,
            n = (e || r) && t.length;
          return e
            ? n === i || n === o
            : r
              ? n === 2 * i || n === 2 * o
              : t instanceof u;
        }
        const b =
            e.bits2int ||
            function (t) {
              if (t.length > 8192) throw new Error("input is too large");
              const r = Ac(t),
                n = 8 * t.length - e.nBitLength;
              return n > 0 ? r >> BigInt(n) : r;
            },
          w =
            e.bits2int_modN ||
            function (t) {
              return s(b(t));
            },
          v = Uc(e.nBitLength);
        function _(t) {
          return Rc("num < 2^" + e.nBitLength, t, Sf, v), kc(t, e.nByteLength);
        }
        function E(t, n, i = S) {
          if (["recovered", "canonical"].some((t) => t in i))
            throw new Error("sign() legacy options not supported");
          const { hash: o, randomBytes: f } = e;
          let { lowS: l, prehash: p, extraEntropy: g } = i;
          null == l && (l = !0),
            (t = xc("msgHash", t)),
            bf(i),
            p && (t = xc("prehashed msgHash", o(t)));
          const m = w(t),
            v = c(n),
            E = [_(v), _(m)];
          if (null != g && !1 !== g) {
            const t = !0 === g ? f(r.BYTES) : g;
            E.push(xc("extraEntropy", t));
          }
          const I = Pc(...E),
            M = m;
          return {
            seed: I,
            k2sig: function (t) {
              const e = b(t);
              if (!h(e)) return;
              const r = a(e),
                n = u.BASE.multiply(e).toAffine(),
                i = s(n.x);
              if (i === Sf) return;
              const o = s(r * s(M + i * v));
              if (o === Sf) return;
              let c = (n.x === i ? 0 : 2) | Number(n.y & If),
                f = o;
              return (
                l &&
                  d(o) &&
                  ((f = (function (t) {
                    return d(t) ? s(-t) : t;
                  })(o)),
                  (c ^= 1)),
                new y(i, f, c)
              );
            },
          };
        }
        const S = { lowS: e.lowS, prehash: !1 },
          I = { lowS: e.lowS, prehash: !1 };
        return (
          u.BASE._setWindowSize(8),
          {
            CURVE: e,
            getPublicKey: function (t, e = !0) {
              return u.fromPrivateKey(t).toRawBytes(e);
            },
            getSharedSecret: function (t, e, r = !0) {
              if (m(t)) throw new Error("first arg must be private key");
              if (!m(e)) throw new Error("second arg must be public key");
              return u.fromHex(e).multiply(c(t)).toRawBytes(r);
            },
            sign: function (t, r, n = S) {
              const { seed: i, k2sig: o } = E(t, r, n),
                s = e;
              return jc(s.hash.outputLen, s.nByteLength, s.hmac)(i, o);
            },
            verify: function (t, r, n, i = I) {
              const o = t;
              (r = xc("msgHash", r)), (n = xc("publicKey", n));
              const { lowS: c, prehash: f, format: h } = i;
              if ((bf(i), "strict" in i))
                throw new Error("options.strict was renamed to lowS");
              if (void 0 !== h && "compact" !== h && "der" !== h)
                throw new Error("format must be compact or der");
              const l = "string" == typeof o || gc(o),
                d =
                  !l &&
                  !h &&
                  "object" == typeof o &&
                  null !== o &&
                  "bigint" == typeof o.r &&
                  "bigint" == typeof o.s;
              if (!l && !d)
                throw new Error(
                  "invalid signature, expected Uint8Array, hex string or Signature instance",
                );
              let p, g;
              try {
                if ((d && (p = new y(o.r, o.s)), l)) {
                  try {
                    "compact" !== h && (p = y.fromDER(o));
                  } catch (t) {
                    if (!(t instanceof Ef.Err)) throw t;
                  }
                  p || "der" === h || (p = y.fromCompact(o));
                }
                g = u.fromHex(n);
              } catch (t) {
                return !1;
              }
              if (!p) return !1;
              if (c && p.hasHighS()) return !1;
              f && (r = e.hash(r));
              const { r: m, s: b } = p,
                v = w(r),
                _ = a(b),
                E = s(v * _),
                S = s(m * _),
                M = u.BASE.multiplyAndAddUnsafe(g, E, S)?.toAffine();
              return !!M && s(M.x) === m;
            },
            ProjectivePoint: u,
            Signature: y,
            utils: g,
          }
        );
      }
      /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      function kf(t) {
        return {
          hash: t,
          hmac: (e, ...r) => Uu(t, e, Pu(...r)),
          randomBytes: Ru,
        };
      }
      /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const Of = BigInt(
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
        ),
        xf = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
        ),
        Pf = BigInt(1),
        Bf = BigInt(2),
        Cf = (t, e) => (t + e / Bf) / e;
      function Rf(t) {
        const e = Of,
          r = BigInt(3),
          n = BigInt(6),
          i = BigInt(11),
          o = BigInt(22),
          s = BigInt(23),
          a = BigInt(44),
          u = BigInt(88),
          c = (t * t * t) % e,
          f = (c * c * t) % e,
          h = (Jc(f, r, e) * f) % e,
          l = (Jc(h, r, e) * f) % e,
          d = (Jc(l, Bf, e) * c) % e,
          p = (Jc(d, i, e) * d) % e,
          y = (Jc(p, o, e) * p) % e,
          g = (Jc(y, a, e) * y) % e,
          m = (Jc(g, u, e) * g) % e,
          b = (Jc(m, a, e) * y) % e,
          w = (Jc(b, r, e) * f) % e,
          v = (Jc(w, s, e) * p) % e,
          _ = (Jc(v, n, e) * c) % e,
          E = Jc(_, Bf, e);
        if (!Nf.eql(Nf.sqr(E), t)) throw new Error("Cannot find square root");
        return E;
      }
      const Nf = nf(Of, void 0, void 0, { sqrt: Rf }),
        Uf = (function (t, e) {
          const r = (e) => Tf({ ...t, ...kf(e) });
          return { ...r(e), create: r };
        })(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: Nf,
            n: xf,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240",
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424",
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
              ),
              splitScalar: (t) => {
                const e = xf,
                  r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  n = -Pf * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  o = r,
                  s = BigInt("0x100000000000000000000000000000000"),
                  a = Cf(o * t, e),
                  u = Cf(-n * t, e);
                let c = Xc(t - a * r - u * i, e),
                  f = Xc(-a * n - u * o, e);
                const h = c > s,
                  l = f > s;
                if ((h && (c = e - c), l && (f = e - f), c > s || f > s))
                  throw new Error("splitScalar: Endomorphism failed, k=" + t);
                return { k1neg: h, k1: c, k2neg: l, k2: f };
              },
            },
          },
          qu,
        ),
        Df = BigInt(0),
        Lf = {};
      function jf(t, ...e) {
        let r = Lf[t];
        if (void 0 === r) {
          const e = qu(Uint8Array.from(t, (t) => t.charCodeAt(0)));
          (r = Pc(e, e)), (Lf[t] = r);
        }
        return qu(Pc(r, ...e));
      }
      const Ff = (t) => t.toRawBytes(!0).slice(1),
        Hf = (t) => kc(t, 32),
        Kf = (t) => Xc(t, Of),
        Vf = (t) => Xc(t, xf),
        qf = Uf.ProjectivePoint;
      function zf(t) {
        let e = Uf.utils.normPrivateKeyToScalar(t),
          r = qf.fromPrivateKey(e);
        return { scalar: r.hasEvenY() ? e : Vf(-e), bytes: Ff(r) };
      }
      function $f(t) {
        Rc("x", t, Pf, Of);
        const e = Kf(t * t);
        let r = Rf(Kf(e * t + BigInt(7)));
        r % Bf !== Df && (r = Kf(-r));
        const n = new qf(t, r, Pf);
        return n.assertValidity(), n;
      }
      const Gf = Ac;
      function Wf(...t) {
        return Vf(Gf(jf("BIP0340/challenge", ...t)));
      }
      function Yf(t) {
        return zf(t).bytes;
      }
      function Xf(t, e, r = Ru(32)) {
        const n = xc("message", t),
          { bytes: i, scalar: o } = zf(e),
          s = xc("auxRand", r, 32),
          a = Hf(o ^ Gf(jf("BIP0340/aux", s))),
          u = jf("BIP0340/nonce", a, i, n),
          c = Vf(Gf(u));
        if (c === Df) throw new Error("sign failed: k is zero");
        const { bytes: f, scalar: h } = zf(c),
          l = Wf(f, i, n),
          d = new Uint8Array(64);
        if ((d.set(f, 0), d.set(Hf(Vf(h + l * o)), 32), !Zf(d, n, i)))
          throw new Error("sign: Invalid signature produced");
        return d;
      }
      function Zf(t, e, r) {
        const n = xc("signature", t, 64),
          i = xc("message", e),
          o = xc("publicKey", r, 32);
        try {
          const t = $f(Gf(o)),
            e = Gf(n.subarray(0, 32));
          if (!Cc(e, Pf, Of)) return !1;
          const r = Gf(n.subarray(32, 64));
          if (!Cc(r, Pf, xf)) return !1;
          const s = Wf(Hf(e), Ff(t), i),
            a = ((t, e, r) => qf.BASE.multiplyAndAddUnsafe(t, e, r))(
              t,
              r,
              Vf(-s),
            );
          return !(!a || !a.hasEvenY() || a.toAffine().x !== e);
        } catch (t) {
          return !1;
        }
      }
      const Jf = (() => ({
        getPublicKey: Yf,
        sign: Xf,
        verify: Zf,
        utils: {
          randomPrivateKey: Uf.utils.randomPrivateKey,
          lift_x: $f,
          pointToBytes: Ff,
          numberToBytesBE: kc,
          bytesToNumberBE: Ac,
          taggedHash: jf,
          mod: Xc,
        },
      }))();
      Uf.ProjectivePoint, cu(qu);
      Ou("Bitcoin seed");
      i(97883), i(21757), i(1948), i(68469), i(48287).Buffer;
      i(48287).Buffer;
      i(96540);
      i(74469);
      const Qf = new Uint8Array(),
        th = new Uint8Array([0]);
      function eh(t, e) {
        if (t.length !== e.length) return !1;
        for (let r = 0; r < t.length; r++) if (t[r] !== e[r]) return !1;
        return !0;
      }
      function rh(t) {
        return (
          t instanceof Uint8Array ||
          (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
        );
      }
      const nh = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
      function ih(t) {
        return "[object Object]" === Object.prototype.toString.call(t);
      }
      function oh(t) {
        return Number.isSafeInteger(t);
      }
      const sh = eh,
        ah = rh,
        uh = function (...t) {
          let e = 0;
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            if (!rh(n)) throw new Error("Uint8Array expected");
            e += n.length;
          }
          const r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), (n += i.length);
          }
          return r;
        },
        ch = (t) => {
          if (null !== t && "string" != typeof t && !vh(t) && !rh(t) && !oh(t))
            throw new Error(
              `lengthCoder: expected null | number | Uint8Array | CoderType, got ${t} (${typeof t})`,
            );
          return {
            encodeStream(e, r) {
              if (null === t) return;
              if (vh(t)) return t.encodeStream(e, r);
              let n;
              if (
                ("number" == typeof t
                  ? (n = t)
                  : "string" == typeof t && (n = hh.resolve(e.stack, t)),
                "bigint" == typeof n && (n = Number(n)),
                void 0 === n || n !== r)
              )
                throw e.err(
                  `Wrong length: ${n} len=${t} exp=${r} (${typeof r})`,
                );
            },
            decodeStream(e) {
              let r;
              if (
                (vh(t)
                  ? (r = Number(t.decodeStream(e)))
                  : "number" == typeof t
                    ? (r = t)
                    : "string" == typeof t && (r = hh.resolve(e.stack, t)),
                "bigint" == typeof r && (r = Number(r)),
                "number" != typeof r)
              )
                throw e.err(`Wrong length: ${r}`);
              return r;
            },
          };
        },
        fh = {
          BITS: 32,
          FULL_MASK: -1 >>> 0,
          len: (t) => Math.ceil(t / 32),
          create: (t) => new Uint32Array(fh.len(t)),
          clean: (t) => t.fill(0),
          debug: (t) =>
            Array.from(t).map((t) => (t >>> 0).toString(2).padStart(32, "0")),
          checkLen: (t, e) => {
            if (fh.len(e) !== t.length)
              throw new Error(
                `wrong length=${t.length}. Expected: ${fh.len(e)}`,
              );
          },
          chunkLen: (t, e, r) => {
            if (e < 0) throw new Error(`wrong pos=${e}`);
            if (e + r > t) throw new Error(`wrong range=${e}/${r} of ${t}`);
          },
          set: (t, e, r, n = !0) => !(!n && t[e] & r) && ((t[e] |= r), !0),
          pos: (t, e) => ({
            chunk: Math.floor((t + e) / 32),
            mask: 1 << (32 - ((t + e) % 32) - 1),
          }),
          indices: (t, e, r = !1) => {
            fh.checkLen(t, e);
            const { FULL_MASK: n, BITS: i } = fh,
              o = i - (e % i),
              s = o ? (n >>> o) << o : n,
              a = [];
            for (let e = 0; e < t.length; e++) {
              let n = t[e];
              if ((r && (n = ~n), e === t.length - 1 && (n &= s), 0 !== n))
                for (let t = 0; t < i; t++) {
                  n & (1 << (i - t - 1)) && a.push(e * i + t);
                }
            }
            return a;
          },
          range: (t) => {
            const e = [];
            let r;
            for (const n of t)
              void 0 === r || n !== r.pos + r.length
                ? e.push((r = { pos: n, length: 1 }))
                : (r.length += 1);
            return e;
          },
          rangeDebug: (t, e, r = !1) =>
            `[${fh
              .range(fh.indices(t, e, r))
              .map((t) => `(${t.pos}/${t.length})`)
              .join(", ")}]`,
          setRange: (t, e, r, n, i = !0) => {
            fh.chunkLen(e, r, n);
            const { FULL_MASK: o, BITS: s } = fh,
              a = r % s ? Math.floor(r / s) : void 0,
              u = r + n,
              c = u % s ? Math.floor(u / s) : void 0;
            if (void 0 !== a && a === c)
              return fh.set(t, a, (o >>> (s - n)) << (s - n - r), i);
            if (void 0 !== a && !fh.set(t, a, o >>> r % s, i)) return !1;
            const f = void 0 !== c ? c : u / s;
            for (let e = void 0 !== a ? a + 1 : r / s; e < f; e++)
              if (!fh.set(t, e, o, i)) return !1;
            return !(
              void 0 !== c &&
              a !== c &&
              !fh.set(t, c, o << (s - (u % s)), i)
            );
          },
        },
        hh = {
          pushObj: (t, e, r) => {
            const n = { obj: e };
            t.push(n),
              r((t, e) => {
                (n.field = t), e(), (n.field = void 0);
              }),
              t.pop();
          },
          path: (t) => {
            const e = [];
            for (const r of t) void 0 !== r.field && e.push(r.field);
            return e.join("/");
          },
          err: (t, e, r) => {
            const n = new Error(
              `${t}(${hh.path(e)}): ${"string" == typeof r ? r : r.message}`,
            );
            return r instanceof Error && r.stack && (n.stack = r.stack), n;
          },
          resolve: (t, e) => {
            const r = e.split("/"),
              n = t.map((t) => t.obj);
            let i = 0;
            for (; i < r.length && ".." === r[i]; i++) n.pop();
            let o = n.pop();
            for (; i < r.length; i++) {
              if (!o || void 0 === o[r[i]]) return;
              o = o[r[i]];
            }
            return o;
          },
        };
      class lh {
        constructor(t, e = {}, r = [], n = void 0, i = 0) {
          (this.data = t),
            (this.opts = e),
            (this.stack = r),
            (this.parent = n),
            (this.parentOffset = i),
            (this.pos = 0),
            (this.bitBuf = 0),
            (this.bitPos = 0),
            (this.view = nh(t));
        }
        _enablePointers() {
          if (this.parent) return this.parent._enablePointers();
          this.bs ||
            ((this.bs = fh.create(this.data.length)),
            fh.setRange(
              this.bs,
              this.data.length,
              0,
              this.pos,
              this.opts.allowMultipleReads,
            ));
        }
        markBytesBS(t, e) {
          return this.parent
            ? this.parent.markBytesBS(this.parentOffset + t, e)
            : !e ||
                !this.bs ||
                fh.setRange(this.bs, this.data.length, t, e, !1);
        }
        markBytes(t) {
          const e = this.pos;
          this.pos += t;
          const r = this.markBytesBS(e, t);
          if (!this.opts.allowMultipleReads && !r)
            throw this.err(`multiple read pos=${this.pos} len=${t}`);
          return r;
        }
        pushObj(t, e) {
          return hh.pushObj(this.stack, t, e);
        }
        readView(t, e) {
          if (!Number.isFinite(t))
            throw this.err(`readView: wrong length=${t}`);
          if (this.pos + t > this.data.length)
            throw this.err("readView: Unexpected end of buffer");
          const r = e(this.view, this.pos);
          return this.markBytes(t), r;
        }
        absBytes(t) {
          if (t > this.data.length) throw new Error("Unexpected end of buffer");
          return this.data.subarray(t);
        }
        finish() {
          if (!this.opts.allowUnreadBytes) {
            if (this.bitPos)
              throw this.err(
                `${this.bitPos} bits left after unpack: ${bu.encode(this.data.slice(this.pos))}`,
              );
            if (!this.bs || this.parent) {
              if (!this.isEnd())
                throw this.err(
                  `${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${bu.encode(this.data.slice(this.pos))}`,
                );
            } else {
              const t = fh.indices(this.bs, this.data.length, !0);
              if (t.length) {
                const e = fh
                  .range(t)
                  .map(
                    ({ pos: t, length: e }) =>
                      `(${t}/${e})[${bu.encode(this.data.subarray(t, t + e))}]`,
                  )
                  .join(", ");
                throw this.err(
                  `unread byte ranges: ${e} (total=${this.data.length})`,
                );
              }
            }
          }
        }
        err(t) {
          return hh.err("Reader", this.stack, t);
        }
        offsetReader(t) {
          if (t > this.data.length)
            throw this.err("offsetReader: Unexpected end of buffer");
          return new lh(this.absBytes(t), this.opts, this.stack, this, t);
        }
        bytes(t, e = !1) {
          if (this.bitPos) throw this.err("readBytes: bitPos not empty");
          if (!Number.isFinite(t))
            throw this.err(`readBytes: wrong length=${t}`);
          if (this.pos + t > this.data.length)
            throw this.err("readBytes: Unexpected end of buffer");
          const r = this.data.subarray(this.pos, this.pos + t);
          return e || this.markBytes(t), r;
        }
        byte(t = !1) {
          if (this.bitPos) throw this.err("readByte: bitPos not empty");
          if (this.pos + 1 > this.data.length)
            throw this.err("readBytes: Unexpected end of buffer");
          const e = this.data[this.pos];
          return t || this.markBytes(1), e;
        }
        get leftBytes() {
          return this.data.length - this.pos;
        }
        get totalBytes() {
          return this.data.length;
        }
        isEnd() {
          return this.pos >= this.data.length && !this.bitPos;
        }
        bits(t) {
          if (t > 32)
            throw this.err(
              "BitReader: cannot read more than 32 bits in single call",
            );
          let e = 0;
          for (; t; ) {
            this.bitPos || ((this.bitBuf = this.byte()), (this.bitPos = 8));
            const r = Math.min(t, this.bitPos);
            (this.bitPos -= r),
              (e = (e << r) | ((this.bitBuf >> this.bitPos) & (2 ** r - 1))),
              (this.bitBuf &= 2 ** this.bitPos - 1),
              (t -= r);
          }
          return e >>> 0;
        }
        find(t, e = this.pos) {
          if (!rh(t)) throw this.err(`find: needle is not bytes! ${t}`);
          if (this.bitPos) throw this.err("findByte: bitPos not empty");
          if (!t.length) throw this.err("find: needle is empty");
          for (let r = e; -1 !== (r = this.data.indexOf(t[0], r)); r++) {
            if (-1 === r) return;
            if (this.data.length - r < t.length) return;
            if (eh(t, this.data.subarray(r, r + t.length))) return r;
          }
        }
      }
      class dh {
        constructor(t = []) {
          (this.stack = t),
            (this.pos = 0),
            (this.buffers = []),
            (this.ptrs = []),
            (this.bitBuf = 0),
            (this.bitPos = 0),
            (this.viewBuf = new Uint8Array(8)),
            (this.finished = !1),
            (this.view = nh(this.viewBuf));
        }
        pushObj(t, e) {
          return hh.pushObj(this.stack, t, e);
        }
        writeView(t, e) {
          if (this.finished) throw this.err("buffer: finished");
          if (!oh(t) || t > 8) throw new Error(`wrong writeView length=${t}`);
          e(this.view),
            this.bytes(this.viewBuf.slice(0, t)),
            this.viewBuf.fill(0);
        }
        err(t) {
          if (this.finished) throw this.err("buffer: finished");
          return hh.err("Reader", this.stack, t);
        }
        bytes(t) {
          if (this.finished) throw this.err("buffer: finished");
          if (this.bitPos)
            throw this.err("writeBytes: ends with non-empty bit buffer");
          this.buffers.push(t), (this.pos += t.length);
        }
        byte(t) {
          if (this.finished) throw this.err("buffer: finished");
          if (this.bitPos)
            throw this.err("writeByte: ends with non-empty bit buffer");
          this.buffers.push(new Uint8Array([t])), this.pos++;
        }
        finish(t = !0) {
          if (this.finished) throw this.err("buffer: finished");
          if (this.bitPos)
            throw this.err("buffer: ends with non-empty bit buffer");
          const e = this.buffers.concat(this.ptrs.map((t) => t.buffer)),
            r = e.map((t) => t.length).reduce((t, e) => t + e, 0),
            n = new Uint8Array(r);
          for (let t = 0, r = 0; t < e.length; t++) {
            const i = e[t];
            n.set(i, r), (r += i.length);
          }
          for (let t = this.pos, e = 0; e < this.ptrs.length; e++) {
            const r = this.ptrs[e];
            n.set(r.ptr.encode(t), r.pos), (t += r.buffer.length);
          }
          if (t) {
            this.buffers = [];
            for (const t of this.ptrs) t.buffer.fill(0);
            (this.ptrs = []), (this.finished = !0), (this.bitBuf = 0);
          }
          return n;
        }
        bits(t, e) {
          if (e > 32)
            throw this.err(
              "writeBits: cannot write more than 32 bits in single call",
            );
          if (t >= 2 ** e)
            throw this.err(`writeBits: value (${t}) >= 2**bits (${e})`);
          for (; e; ) {
            const r = Math.min(e, 8 - this.bitPos);
            (this.bitBuf = (this.bitBuf << r) | (t >> (e - r))),
              (this.bitPos += r),
              (t &= 2 ** (e -= r) - 1),
              8 === this.bitPos &&
                ((this.bitPos = 0),
                this.buffers.push(new Uint8Array([this.bitBuf])),
                this.pos++);
          }
        }
      }
      const ph = (t) => Uint8Array.from(t).reverse();
      function yh(t, e, r) {
        if (r) {
          const r = 2n ** (e - 1n);
          if (t < -r || t >= r)
            throw new Error(
              `value out of signed bounds. Expected ${-r} <= ${t} < ${r}`,
            );
        } else if (0n > t || t >= 2n ** e)
          throw new Error(
            `value out of unsigned bounds. Expected 0 <= ${t} < ${2n ** e}`,
          );
      }
      function gh(t) {
        return {
          encodeStream: t.encodeStream,
          decodeStream: t.decodeStream,
          size: t.size,
          encode: (e) => {
            const r = new dh();
            return t.encodeStream(r, e), r.finish();
          },
          decode: (e, r = {}) => {
            const n = new lh(e, r),
              i = t.decodeStream(n);
            return n.finish(), i;
          },
        };
      }
      function mh(t, e) {
        if (!vh(t)) throw new Error(`validate: invalid inner value ${t}`);
        if ("function" != typeof e)
          throw new Error("validate: fn should be function");
        return gh({
          size: t.size,
          encodeStream: (r, n) => {
            let i;
            try {
              i = e(n);
            } catch (t) {
              throw r.err(t);
            }
            t.encodeStream(r, i);
          },
          decodeStream: (r) => {
            const n = t.decodeStream(r);
            try {
              return e(n);
            } catch (t) {
              throw r.err(t);
            }
          },
        });
      }
      const bh = (t) => {
          const e = gh(t);
          return t.validate ? mh(e, t.validate) : e;
        },
        wh = (t) =>
          ih(t) &&
          "function" == typeof t.decode &&
          "function" == typeof t.encode;
      function vh(t) {
        return (
          ih(t) &&
          wh(t) &&
          "function" == typeof t.encodeStream &&
          "function" == typeof t.decodeStream &&
          (void 0 === t.size || oh(t.size))
        );
      }
      const _h = (t) => {
          if (!wh(t)) throw new Error("BaseCoder expected");
          return { encode: t.decode, decode: t.encode };
        },
        Eh = {
          dict: function () {
            return {
              encode: (t) => {
                if (!Array.isArray(t)) throw new Error("array expected");
                const e = {};
                for (const r of t) {
                  if (!Array.isArray(r) || 2 !== r.length)
                    throw new Error("array of two elements expected");
                  const t = r[0],
                    n = r[1];
                  if (void 0 !== e[t])
                    throw new Error(`key(${t}) appears twice in struct`);
                  e[t] = n;
                }
                return e;
              },
              decode: (t) => {
                if (!ih(t)) throw new Error(`expected plain object, got ${t}`);
                return Object.entries(t);
              },
            };
          },
          numberBigint: {
            encode: (t) => {
              if ("bigint" != typeof t)
                throw new Error("expected bigint, got " + typeof t);
              if (t > BigInt(Number.MAX_SAFE_INTEGER))
                throw new Error(`element bigger than MAX_SAFE_INTEGER=${t}`);
              return Number(t);
            },
            decode: (t) => {
              if (!oh(t)) throw new Error("element is not a safe integer");
              return BigInt(t);
            },
          },
          tsEnum: function (t) {
            if (!ih(t)) throw new Error("plain object expected");
            return {
              encode: (e) => {
                if (!oh(e) || !(e in t)) throw new Error(`wrong value ${e}`);
                return t[e];
              },
              decode: (e) => {
                if ("string" != typeof e)
                  throw new Error("wrong value " + typeof e);
                return t[e];
              },
            };
          },
          decimal: function (t, e = !1) {
            if (!oh(t)) throw new Error(`decimal/precision: wrong value ${t}`);
            if ("boolean" != typeof e)
              throw new Error(
                "decimal/round: expected boolean, got " + typeof e,
              );
            const r = 10n ** BigInt(t);
            return {
              encode: (e) => {
                if ("bigint" != typeof e)
                  throw new Error("expected bigint, got " + typeof e);
                let r = (e < 0n ? -e : e).toString(10),
                  n = r.length - t;
                n < 0 && ((r = r.padStart(r.length - n, "0")), (n = 0));
                let i = r.length - 1;
                for (; i >= n && "0" === r[i]; i--);
                let o = r.slice(0, n),
                  s = r.slice(n, i + 1);
                return (
                  o || (o = "0"), e < 0n && (o = "-" + o), s ? `${o}.${s}` : o
                );
              },
              decode: (n) => {
                if ("string" != typeof n)
                  throw new Error("expected string, got " + typeof n);
                if ("-0" === n) throw new Error("negative zero is not allowed");
                let i = !1;
                if (
                  (n.startsWith("-") && ((i = !0), (n = n.slice(1))),
                  !/^(0|[1-9]\d*)(\.\d+)?$/.test(n))
                )
                  throw new Error(`wrong string value=${n}`);
                let o = n.indexOf(".");
                o = -1 === o ? n.length : o;
                const s = n.slice(0, o),
                  a = n.slice(o + 1).replace(/0+$/, ""),
                  u = BigInt(s) * r;
                if (!e && a.length > t)
                  throw new Error(
                    `fractional part cannot be represented with this precision (num=${n}, prec=${t})`,
                  );
                const c = Math.min(a.length, t),
                  f = u + BigInt(a.slice(0, c)) * 10n ** BigInt(t - c);
                return i ? -f : f;
              },
            };
          },
          match: function (t) {
            if (!Array.isArray(t))
              throw new Error("expected array, got " + typeof t);
            for (const e of t)
              if (!wh(e)) throw new Error(`wrong base coder ${e}`);
            return {
              encode: (e) => {
                for (const r of t) {
                  const t = r.encode(e);
                  if (void 0 !== t) return t;
                }
                throw new Error(`match/encode: cannot find match in ${e}`);
              },
              decode: (e) => {
                for (const r of t) {
                  const t = r.decode(e);
                  if (void 0 !== t) return t;
                }
                throw new Error(`match/decode: cannot find match in ${e}`);
              },
            };
          },
          reverse: _h,
        },
        Sh = (t, e = !1, r = !1, n = !0) => {
          if (!oh(t)) throw new Error(`bigint/size: wrong value ${t}`);
          if ("boolean" != typeof e)
            throw new Error("bigint/le: expected boolean, got " + typeof e);
          if ("boolean" != typeof r)
            throw new Error("bigint/signed: expected boolean, got " + typeof r);
          if ("boolean" != typeof n)
            throw new Error("bigint/sized: expected boolean, got " + typeof n);
          const i = BigInt(t),
            o = 2n ** (8n * i - 1n);
          return bh({
            size: n ? t : void 0,
            encodeStream: (i, s) => {
              r && s < 0 && (s |= o);
              const a = [];
              for (let e = 0; e < t; e++) a.push(Number(255n & s)), (s >>= 8n);
              let u = new Uint8Array(a).reverse();
              if (!n) {
                let t = 0;
                for (t = 0; t < u.length && 0 === u[t]; t++);
                u = u.subarray(t);
              }
              i.bytes(e ? u.reverse() : u);
            },
            decodeStream: (i) => {
              const s = i.bytes(n ? t : Math.min(t, i.leftBytes)),
                a = e ? s : ph(s);
              let u = 0n;
              for (let t = 0; t < a.length; t++)
                u |= BigInt(a[t]) << (8n * BigInt(t));
              return r && u & o && (u = (u ^ o) - o), u;
            },
            validate: (t) => {
              if ("bigint" != typeof t)
                throw new Error(`bigint: invalid value: ${t}`);
              return yh(t, 8n * i, !!r), t;
            },
          });
        },
        Ih = Sh(32, !1),
        Mh = Sh(8, !0),
        Ah = Sh(8, !0, !0),
        Th = (t, e) =>
          bh({
            size: t,
            encodeStream: (r, n) => r.writeView(t, (t) => e.write(t, n)),
            decodeStream: (r) => r.readView(t, e.read),
            validate: (t) => {
              if ("number" != typeof t)
                throw new Error("viewCoder: expected number, got " + typeof t);
              return e.validate && e.validate(t), t;
            },
          }),
        kh = (t, e, r) => {
          const n = 8 * t,
            i = 2 ** (n - 1),
            o = 2 ** n;
          return Th(t, {
            write: r.write,
            read: r.read,
            validate: e
              ? (t) => {
                  if (!oh(t))
                    throw new Error(
                      `sintView: value is not safe integer: ${t}`,
                    );
                  if (t < -i || t >= i)
                    throw new Error(
                      `sintView: value out of bounds. Expected ${-i} <= ${t} < ${i}`,
                    );
                }
              : (t) => {
                  if (!oh(t))
                    throw new Error(
                      `uintView: value is not safe integer: ${t}`,
                    );
                  if (0 > t || t >= o)
                    throw new Error(
                      `uintView: value out of bounds. Expected 0 <= ${t} < ${o}`,
                    );
                },
          });
        },
        Oh = kh(4, !1, {
          read: (t, e) => t.getUint32(e, !0),
          write: (t, e) => t.setUint32(0, e, !0),
        }),
        xh = kh(4, !1, {
          read: (t, e) => t.getUint32(e, !1),
          write: (t, e) => t.setUint32(0, e, !1),
        }),
        Ph = kh(4, !0, {
          read: (t, e) => t.getInt32(e, !0),
          write: (t, e) => t.setInt32(0, e, !0),
        }),
        Bh = kh(2, !1, {
          read: (t, e) => t.getUint16(e, !0),
          write: (t, e) => t.setUint16(0, e, !0),
        }),
        Ch = kh(1, !1, {
          read: (t, e) => t.getUint8(e),
          write: (t, e) => t.setUint8(0, e),
        }),
        Rh = (t, e = !1) => {
          if ("boolean" != typeof e)
            throw new Error("bytes/le: expected boolean, got " + typeof e);
          const r = ch(t),
            n = rh(t);
          return bh({
            size: "number" == typeof t ? t : void 0,
            encodeStream: (i, o) => {
              n || r.encodeStream(i, o.length),
                i.bytes(e ? ph(o) : o),
                n && i.bytes(t);
            },
            decodeStream: (i) => {
              let o;
              if (n) {
                const e = i.find(t);
                if (!e) throw i.err("bytes: cannot find terminator");
                (o = i.bytes(e - i.pos)), i.bytes(t.length);
              } else o = i.bytes(null === t ? i.leftBytes : r.decodeStream(i));
              return e ? ph(o) : o;
            },
            validate: (t) => {
              if (!rh(t)) throw new Error(`bytes: invalid value ${t}`);
              return t;
            },
          });
        };
      const Nh = (t, e = !1) =>
        mh(Uh(Rh(t, e), mu), (t) => {
          if ("string" != typeof t)
            throw new Error("expected string, got " + typeof t);
          return t;
        });
      function Uh(t, e) {
        if (!vh(t)) throw new Error(`apply: invalid inner value ${t}`);
        if (!wh(e)) throw new Error(`apply: invalid base value ${t}`);
        return bh({
          size: t.size,
          encodeStream: (r, n) => {
            let i;
            try {
              i = e.decode(n);
            } catch (t) {
              throw r.err("" + t);
            }
            return t.encodeStream(r, i);
          },
          decodeStream: (r) => {
            const n = t.decodeStream(r);
            try {
              return e.encode(n);
            } catch (t) {
              throw r.err("" + t);
            }
          },
        });
      }
      function Dh(t, e, r = !0) {
        if (!vh(t)) throw new Error(`magic: invalid inner value ${t}`);
        if ("boolean" != typeof r)
          throw new Error("magic: expected boolean, got " + typeof r);
        return bh({
          size: t.size,
          encodeStream: (r, n) => t.encodeStream(r, e),
          decodeStream: (n) => {
            const i = t.decodeStream(n);
            if ((r && "object" != typeof i && i !== e) || (rh(e) && !eh(e, i)))
              throw n.err(`magic: invalid value: ${i} !== ${e}`);
          },
          validate: (t) => {
            if (void 0 !== t) throw new Error("magic: wrong value=" + typeof t);
            return t;
          },
        });
      }
      function Lh(t) {
        let e = 0;
        for (const r of t) {
          if (void 0 === r.size) return;
          if (!oh(r.size)) throw new Error(`sizeof: wrong element size=${e}`);
          e += r.size;
        }
        return e;
      }
      function jh(t) {
        if (!ih(t)) throw new Error(`struct: expected plain object, got ${t}`);
        for (const e in t)
          if (!vh(t[e])) throw new Error(`struct: field ${e} is not CoderType`);
        return bh({
          size: Lh(Object.values(t)),
          encodeStream: (e, r) => {
            e.pushObj(r, (n) => {
              for (const i in t) n(i, () => t[i].encodeStream(e, r[i]));
            });
          },
          decodeStream: (e) => {
            const r = {};
            return (
              e.pushObj(r, (n) => {
                for (const i in t) n(i, () => (r[i] = t[i].decodeStream(e)));
              }),
              r
            );
          },
          validate: (t) => {
            if ("object" != typeof t || null === t)
              throw new Error(`struct: invalid value ${t}`);
            return t;
          },
        });
      }
      function Fh(t, e) {
        if (!vh(e)) throw new Error(`array: invalid inner value ${e}`);
        const r = ch("string" == typeof t ? `../${t}` : t);
        return bh({
          size: "number" == typeof t && e.size ? t * e.size : void 0,
          encodeStream: (n, i) => {
            const o = n;
            o.pushObj(i, (s) => {
              rh(t) || r.encodeStream(n, i.length);
              for (let r = 0; r < i.length; r++)
                s(`${r}`, () => {
                  const s = i[r],
                    a = n.pos;
                  if ((e.encodeStream(n, s), rh(t))) {
                    if (t.length > o.pos - a) return;
                    const e = o.finish(!1).subarray(a, o.pos);
                    if (eh(e.subarray(0, t.length), t))
                      throw o.err(
                        `array: inner element encoding same as separator. elm=${s} data=${e}`,
                      );
                  }
                });
            }),
              rh(t) && n.bytes(t);
          },
          decodeStream: (n) => {
            const i = [];
            return (
              n.pushObj(i, (o) => {
                if (null === t)
                  for (
                    let t = 0;
                    !n.isEnd() &&
                    (o(`${t}`, () => i.push(e.decodeStream(n))),
                    !(e.size && n.leftBytes < e.size));
                    t++
                  );
                else if (rh(t))
                  for (let r = 0; ; r++) {
                    if (eh(n.bytes(t.length, !0), t)) {
                      n.bytes(t.length);
                      break;
                    }
                    o(`${r}`, () => i.push(e.decodeStream(n)));
                  }
                else {
                  let t;
                  o("arrayLen", () => (t = r.decodeStream(n)));
                  for (let r = 0; r < t; r++)
                    o(`${r}`, () => i.push(e.decodeStream(n)));
                }
              }),
              i
            );
          },
          validate: (t) => {
            if (!Array.isArray(t)) throw new Error(`array: invalid value ${t}`);
            return t;
          },
        });
      }
      const Hh = Uf.ProjectivePoint,
        Kh = Uf.CURVE.n,
        Vh = ah,
        qh = uh,
        zh = sh,
        $h = (t) => lc(qu(t)),
        Gh = (...t) => qu(qu(qh(...t))),
        Wh = (Jf.utils.randomPrivateKey, Jf.getPublicKey),
        Yh = Uf.getPublicKey,
        Xh = (t) => t.r < Kh / 2n;
      const Zh = Jf.sign,
        Jh = Jf.utils.taggedHash;
      var Qh;
      function tl(t, e) {
        const r = t.length;
        if (e === Qh.ecdsa) {
          if (32 === r) throw new Error("Expected non-Schnorr key");
          return Hh.fromHex(t), t;
        }
        if (e === Qh.schnorr) {
          if (32 !== r) throw new Error("Expected 32-byte Schnorr key");
          return Jf.utils.lift_x(Jf.utils.bytesToNumberBE(t)), t;
        }
        throw new Error("Unknown key type");
      }
      function el(t, e) {
        const r = Jf.utils,
          n = r.taggedHash("TapTweak", t, e),
          i = r.bytesToNumberBE(n);
        if (i >= Kh) throw new Error("tweak higher than curve order");
        return i;
      }
      function rl(t, e = new Uint8Array()) {
        const r = Jf.utils,
          n = r.bytesToNumberBE(t),
          i = Hh.fromPrivateKey(n),
          o = i.hasEvenY() ? n : r.mod(-n, Kh),
          s = el(r.pointToBytes(i), e);
        return r.numberToBytesBE(r.mod(o + s, Kh), 32);
      }
      function nl(t, e) {
        const r = Jf.utils,
          n = el(t, e),
          i = r.lift_x(r.bytesToNumberBE(t)).add(Hh.fromPrivateKey(n)),
          o = i.hasEvenY() ? 0 : 1;
        return [r.pointToBytes(i), o];
      }
      !(function (t) {
        (t[(t.ecdsa = 0)] = "ecdsa"), (t[(t.schnorr = 1)] = "schnorr");
      })(Qh || (Qh = {}));
      qu(Hh.BASE.toRawBytes(!1));
      const il = { bech32: "bc", pubKeyHash: 0, scriptHash: 5, wif: 128 };
      function ol(t, e) {
        if (!Vh(t) || !Vh(e))
          throw new Error(`cmp: wrong type a=${typeof t} b=${typeof e}`);
        const r = Math.min(t.length, e.length);
        for (let n = 0; n < r; n++)
          if (t[n] != e[n]) return Math.sign(t[n] - e[n]);
        return Math.sign(t.length - e.length);
      }
      var sl;
      function al(t = 6, e = !1) {
        return bh({
          encodeStream: (t, e) => {
            if (0n === e) return;
            const r = e < 0,
              n = BigInt(e),
              i = [];
            for (let t = r ? -n : n; t; t >>= 8n) i.push(Number(0xffn & t));
            i[i.length - 1] >= 128
              ? i.push(r ? 128 : 0)
              : r && (i[i.length - 1] |= 128),
              t.bytes(new Uint8Array(i));
          },
          decodeStream: (r) => {
            const n = r.leftBytes;
            if (n > t)
              throw new Error(
                `ScriptNum: number (${n}) bigger than limit=${t}`,
              );
            if (0 === n) return 0n;
            if (e) {
              const t = r.bytes(n, !0);
              if (
                !(127 & t[t.length - 1] || (!(n <= 1) && 128 & t[t.length - 2]))
              )
                throw new Error("Non-minimally encoded ScriptNum");
            }
            let i = 0,
              o = 0n;
            for (let t = 0; t < n; ++t)
              (i = r.byte()), (o |= BigInt(i) << (8n * BigInt(t)));
            return (
              i >= 128 && ((o &= (2n ** BigInt(8 * n) - 1n) >> 1n), (o = -o)), o
            );
          },
        });
      }
      !(function (t) {
        (t[(t.OP_0 = 0)] = "OP_0"),
          (t[(t.PUSHDATA1 = 76)] = "PUSHDATA1"),
          (t[(t.PUSHDATA2 = 77)] = "PUSHDATA2"),
          (t[(t.PUSHDATA4 = 78)] = "PUSHDATA4"),
          (t[(t["1NEGATE"] = 79)] = "1NEGATE"),
          (t[(t.RESERVED = 80)] = "RESERVED"),
          (t[(t.OP_1 = 81)] = "OP_1"),
          (t[(t.OP_2 = 82)] = "OP_2"),
          (t[(t.OP_3 = 83)] = "OP_3"),
          (t[(t.OP_4 = 84)] = "OP_4"),
          (t[(t.OP_5 = 85)] = "OP_5"),
          (t[(t.OP_6 = 86)] = "OP_6"),
          (t[(t.OP_7 = 87)] = "OP_7"),
          (t[(t.OP_8 = 88)] = "OP_8"),
          (t[(t.OP_9 = 89)] = "OP_9"),
          (t[(t.OP_10 = 90)] = "OP_10"),
          (t[(t.OP_11 = 91)] = "OP_11"),
          (t[(t.OP_12 = 92)] = "OP_12"),
          (t[(t.OP_13 = 93)] = "OP_13"),
          (t[(t.OP_14 = 94)] = "OP_14"),
          (t[(t.OP_15 = 95)] = "OP_15"),
          (t[(t.OP_16 = 96)] = "OP_16"),
          (t[(t.NOP = 97)] = "NOP"),
          (t[(t.VER = 98)] = "VER"),
          (t[(t.IF = 99)] = "IF"),
          (t[(t.NOTIF = 100)] = "NOTIF"),
          (t[(t.VERIF = 101)] = "VERIF"),
          (t[(t.VERNOTIF = 102)] = "VERNOTIF"),
          (t[(t.ELSE = 103)] = "ELSE"),
          (t[(t.ENDIF = 104)] = "ENDIF"),
          (t[(t.VERIFY = 105)] = "VERIFY"),
          (t[(t.RETURN = 106)] = "RETURN"),
          (t[(t.TOALTSTACK = 107)] = "TOALTSTACK"),
          (t[(t.FROMALTSTACK = 108)] = "FROMALTSTACK"),
          (t[(t["2DROP"] = 109)] = "2DROP"),
          (t[(t["2DUP"] = 110)] = "2DUP"),
          (t[(t["3DUP"] = 111)] = "3DUP"),
          (t[(t["2OVER"] = 112)] = "2OVER"),
          (t[(t["2ROT"] = 113)] = "2ROT"),
          (t[(t["2SWAP"] = 114)] = "2SWAP"),
          (t[(t.IFDUP = 115)] = "IFDUP"),
          (t[(t.DEPTH = 116)] = "DEPTH"),
          (t[(t.DROP = 117)] = "DROP"),
          (t[(t.DUP = 118)] = "DUP"),
          (t[(t.NIP = 119)] = "NIP"),
          (t[(t.OVER = 120)] = "OVER"),
          (t[(t.PICK = 121)] = "PICK"),
          (t[(t.ROLL = 122)] = "ROLL"),
          (t[(t.ROT = 123)] = "ROT"),
          (t[(t.SWAP = 124)] = "SWAP"),
          (t[(t.TUCK = 125)] = "TUCK"),
          (t[(t.CAT = 126)] = "CAT"),
          (t[(t.SUBSTR = 127)] = "SUBSTR"),
          (t[(t.LEFT = 128)] = "LEFT"),
          (t[(t.RIGHT = 129)] = "RIGHT"),
          (t[(t.SIZE = 130)] = "SIZE"),
          (t[(t.INVERT = 131)] = "INVERT"),
          (t[(t.AND = 132)] = "AND"),
          (t[(t.OR = 133)] = "OR"),
          (t[(t.XOR = 134)] = "XOR"),
          (t[(t.EQUAL = 135)] = "EQUAL"),
          (t[(t.EQUALVERIFY = 136)] = "EQUALVERIFY"),
          (t[(t.RESERVED1 = 137)] = "RESERVED1"),
          (t[(t.RESERVED2 = 138)] = "RESERVED2"),
          (t[(t["1ADD"] = 139)] = "1ADD"),
          (t[(t["1SUB"] = 140)] = "1SUB"),
          (t[(t["2MUL"] = 141)] = "2MUL"),
          (t[(t["2DIV"] = 142)] = "2DIV"),
          (t[(t.NEGATE = 143)] = "NEGATE"),
          (t[(t.ABS = 144)] = "ABS"),
          (t[(t.NOT = 145)] = "NOT"),
          (t[(t["0NOTEQUAL"] = 146)] = "0NOTEQUAL"),
          (t[(t.ADD = 147)] = "ADD"),
          (t[(t.SUB = 148)] = "SUB"),
          (t[(t.MUL = 149)] = "MUL"),
          (t[(t.DIV = 150)] = "DIV"),
          (t[(t.MOD = 151)] = "MOD"),
          (t[(t.LSHIFT = 152)] = "LSHIFT"),
          (t[(t.RSHIFT = 153)] = "RSHIFT"),
          (t[(t.BOOLAND = 154)] = "BOOLAND"),
          (t[(t.BOOLOR = 155)] = "BOOLOR"),
          (t[(t.NUMEQUAL = 156)] = "NUMEQUAL"),
          (t[(t.NUMEQUALVERIFY = 157)] = "NUMEQUALVERIFY"),
          (t[(t.NUMNOTEQUAL = 158)] = "NUMNOTEQUAL"),
          (t[(t.LESSTHAN = 159)] = "LESSTHAN"),
          (t[(t.GREATERTHAN = 160)] = "GREATERTHAN"),
          (t[(t.LESSTHANOREQUAL = 161)] = "LESSTHANOREQUAL"),
          (t[(t.GREATERTHANOREQUAL = 162)] = "GREATERTHANOREQUAL"),
          (t[(t.MIN = 163)] = "MIN"),
          (t[(t.MAX = 164)] = "MAX"),
          (t[(t.WITHIN = 165)] = "WITHIN"),
          (t[(t.RIPEMD160 = 166)] = "RIPEMD160"),
          (t[(t.SHA1 = 167)] = "SHA1"),
          (t[(t.SHA256 = 168)] = "SHA256"),
          (t[(t.HASH160 = 169)] = "HASH160"),
          (t[(t.HASH256 = 170)] = "HASH256"),
          (t[(t.CODESEPARATOR = 171)] = "CODESEPARATOR"),
          (t[(t.CHECKSIG = 172)] = "CHECKSIG"),
          (t[(t.CHECKSIGVERIFY = 173)] = "CHECKSIGVERIFY"),
          (t[(t.CHECKMULTISIG = 174)] = "CHECKMULTISIG"),
          (t[(t.CHECKMULTISIGVERIFY = 175)] = "CHECKMULTISIGVERIFY"),
          (t[(t.NOP1 = 176)] = "NOP1"),
          (t[(t.CHECKLOCKTIMEVERIFY = 177)] = "CHECKLOCKTIMEVERIFY"),
          (t[(t.CHECKSEQUENCEVERIFY = 178)] = "CHECKSEQUENCEVERIFY"),
          (t[(t.NOP4 = 179)] = "NOP4"),
          (t[(t.NOP5 = 180)] = "NOP5"),
          (t[(t.NOP6 = 181)] = "NOP6"),
          (t[(t.NOP7 = 182)] = "NOP7"),
          (t[(t.NOP8 = 183)] = "NOP8"),
          (t[(t.NOP9 = 184)] = "NOP9"),
          (t[(t.NOP10 = 185)] = "NOP10"),
          (t[(t.CHECKSIGADD = 186)] = "CHECKSIGADD"),
          (t[(t.INVALID = 255)] = "INVALID");
      })(sl || (sl = {}));
      const ul = bh({
          encodeStream: (t, e) => {
            for (let r of e) {
              if ("string" == typeof r) {
                if (void 0 === sl[r]) throw new Error(`Unknown opcode=${r}`);
                t.byte(sl[r]);
                continue;
              }
              if ("number" == typeof r) {
                if (0 === r) {
                  t.byte(0);
                  continue;
                }
                if (1 <= r && r <= 16) {
                  t.byte(sl.OP_1 - 1 + r);
                  continue;
                }
              }
              if (
                ("number" == typeof r && (r = al().encode(BigInt(r))), !Vh(r))
              )
                throw new Error(`Wrong Script OP=${r} (${typeof r})`);
              const e = r.length;
              e < sl.PUSHDATA1
                ? t.byte(e)
                : e <= 255
                  ? (t.byte(sl.PUSHDATA1), t.byte(e))
                  : e <= 65535
                    ? (t.byte(sl.PUSHDATA2), t.bytes(Bh.encode(e)))
                    : (t.byte(sl.PUSHDATA4), t.bytes(Oh.encode(e))),
                t.bytes(r);
            }
          },
          decodeStream: (t) => {
            const e = [];
            for (; !t.isEnd(); ) {
              const r = t.byte();
              if (sl.OP_0 < r && r <= sl.PUSHDATA4) {
                let n;
                if (r < sl.PUSHDATA1) n = r;
                else if (r === sl.PUSHDATA1) n = Ch.decodeStream(t);
                else if (r === sl.PUSHDATA2) n = Bh.decodeStream(t);
                else {
                  if (r !== sl.PUSHDATA4)
                    throw new Error("Should be not possible");
                  n = Oh.decodeStream(t);
                }
                e.push(t.bytes(n));
              } else if (0 === r) e.push(0);
              else if (sl.OP_1 <= r && r <= sl.OP_16) e.push(r - (sl.OP_1 - 1));
              else {
                const t = sl[r];
                if (void 0 === t)
                  throw new Error(`Unknown opcode=${r.toString(16)}`);
                e.push(t);
              }
            }
            return e;
          },
        }),
        cl = {
          253: [253, 2, 253n, 65535n],
          254: [254, 4, 65536n, 4294967295n],
          255: [255, 8, 4294967296n, 18446744073709551615n],
        },
        fl = bh({
          encodeStream: (t, e) => {
            if (("number" == typeof e && (e = BigInt(e)), 0n <= e && e <= 252n))
              return t.byte(Number(e));
            for (const [r, n, i, o] of Object.values(cl))
              if (!(i > e || e > o)) {
                t.byte(r);
                for (let r = 0; r < n; r++)
                  t.byte(Number((e >> (8n * BigInt(r))) & 0xffn));
                return;
              }
            throw t.err(`VarInt too big: ${e}`);
          },
          decodeStream: (t) => {
            const e = t.byte();
            if (e <= 252) return BigInt(e);
            const [r, n, i] = cl[e];
            let o = 0n;
            for (let e = 0; e < n; e++)
              o |= BigInt(t.byte()) << (8n * BigInt(e));
            if (o < i) throw t.err(`Wrong CompactSize(${8 * n})`);
            return o;
          },
        }),
        hl = Uh(fl, Eh.numberBigint),
        ll = Rh(fl),
        dl = Fh(hl, ll),
        pl = (t) => Fh(fl, t),
        yl = jh({
          txid: Rh(32, !0),
          index: Oh,
          finalScriptSig: ll,
          sequence: Oh,
        }),
        gl = jh({ amount: Mh, script: ll }),
        ml = jh({
          version: Ph,
          segwitFlag: ((t, e = !1) => {
            if (!rh(t))
              throw new Error(
                "flag/flagValue: expected Uint8Array, got " + typeof t,
              );
            if ("boolean" != typeof e)
              throw new Error("flag/xor: expected boolean, got " + typeof e);
            return bh({
              size: t.length,
              encodeStream: (r, n) => {
                !!n !== e && r.bytes(t);
              },
              decodeStream: (r) => {
                let n = r.leftBytes >= t.length;
                return (
                  n &&
                    ((n = eh(r.bytes(t.length, !0), t)),
                    n && r.bytes(t.length)),
                  n !== e
                );
              },
              validate: (t) => {
                if (void 0 !== t && "boolean" != typeof t)
                  throw new Error(
                    "flag: expected boolean value or undefined, got " +
                      typeof t,
                  );
                return t;
              },
            });
          })(new Uint8Array([0, 1])),
          inputs: pl(yl),
          outputs: pl(gl),
          witnesses: (function (t, e, r) {
            if (!vh(e)) throw new Error(`flagged: invalid inner value ${e}`);
            if ("string" != typeof t && !vh(e))
              throw new Error(`flagged: wrong path=${t}`);
            return bh({
              encodeStream: (n, i) => {
                "string" == typeof t
                  ? hh.resolve(n.stack, t)
                    ? e.encodeStream(n, i)
                    : r && e.encodeStream(n, r)
                  : (t.encodeStream(n, !!i),
                    i ? e.encodeStream(n, i) : r && e.encodeStream(n, r));
              },
              decodeStream: (n) => {
                let i = !1;
                if (
                  ((i =
                    "string" == typeof t
                      ? !!hh.resolve(n.stack, t)
                      : t.decodeStream(n)),
                  i)
                )
                  return e.decodeStream(n);
                r && e.decodeStream(n);
              },
            });
          })("segwitFlag", Fh("inputs/length", dl)),
          lockTime: Oh,
        });
      const bl = mh(ml, function (t) {
          if (t.segwitFlag && t.witnesses && !t.witnesses.length)
            throw new Error("Segwit flag with empty witnesses array");
          return t;
        }),
        wl = jh({ version: Ph, inputs: pl(yl), outputs: pl(gl), lockTime: Oh });
      function vl(t) {
        if (t.nonWitnessUtxo) {
          if (void 0 === t.index) throw new Error("Unknown input index");
          return t.nonWitnessUtxo.outputs[t.index];
        }
        if (t.witnessUtxo) return t.witnessUtxo;
        throw new Error("Cannot find previous output info");
      }
      function _l(t, e, r, n = !1) {
        let { nonWitnessUtxo: i, txid: o } = t;
        "string" == typeof i && (i = bu.decode(i)),
          Vh(i) && (i = bl.decode(i)),
          "nonWitnessUtxo" in t || void 0 !== i || (i = e?.nonWitnessUtxo),
          "string" == typeof o && (o = bu.decode(o)),
          void 0 === o && (o = e?.txid);
        let s,
          a = { ...e, ...t, nonWitnessUtxo: i, txid: o };
        return (
          "nonWitnessUtxo" in t ||
            void 0 !== a.nonWitnessUtxo ||
            delete a.nonWitnessUtxo,
          void 0 === a.sequence && (a.sequence = Al),
          null === a.tapMerkleRoot && delete a.tapMerkleRoot,
          (a = dd(Zl, a, e, r)),
          od.encode(a),
          a.nonWitnessUtxo && void 0 !== a.index
            ? (s = a.nonWitnessUtxo.outputs[a.index])
            : a.witnessUtxo && (s = a.witnessUtxo),
          s && !n && xd(s && s.script, a.redeemScript, a.witnessScript),
          a
        );
      }
      function El(t, e = !1) {
        let r = "legacy",
          n = Ol.ALL;
        const i = vl(t),
          o = kd.decode(i.script);
        let s = o.type,
          a = o;
        const u = [o];
        if ("tr" === o.type)
          return (
            (n = Ol.DEFAULT),
            {
              txType: "taproot",
              type: "tr",
              last: o,
              lastScript: i.script,
              defaultSighash: n,
              sighash: t.sighashType || n,
            }
          );
        {
          if (
            (("wpkh" !== o.type && "wsh" !== o.type) || (r = "segwit"),
            "sh" === o.type)
          ) {
            if (!t.redeemScript)
              throw new Error("inputType: sh without redeemScript");
            let e = kd.decode(t.redeemScript);
            ("wpkh" !== e.type && "wsh" !== e.type) || (r = "segwit"),
              u.push(e),
              (a = e),
              (s += `-${e.type}`);
          }
          if ("wsh" === a.type) {
            if (!t.witnessScript)
              throw new Error("inputType: wsh without witnessScript");
            let e = kd.decode(t.witnessScript);
            "wsh" === e.type && (r = "segwit"),
              u.push(e),
              (a = e),
              (s += `-${e.type}`);
          }
          const i = u[u.length - 1];
          if ("sh" === i.type || "wsh" === i.type)
            throw new Error("inputType: sh/wsh cannot be terminal type");
          const c = {
            type: s,
            txType: r,
            last: i,
            lastScript: kd.encode(i),
            defaultSighash: n,
            sighash: t.sighashType || n,
          };
          if ("legacy" === r && !e && !t.nonWitnessUtxo)
            throw new Error(
              "Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure",
            );
          return c;
        }
      }
      const Sl = (t) => Math.ceil(t / 4);
      const Il = new Uint8Array(32),
        Ml = { amount: 0xffffffffffffffffn, script: Qf },
        Al = 4294967295,
        Tl = (Eh.decimal(8), (t, e) => (void 0 === t ? e : t));
      function kl(t) {
        if (Array.isArray(t)) return t.map((t) => kl(t));
        if (Vh(t)) return Uint8Array.from(t);
        if (
          ["number", "bigint", "boolean", "string", "undefined"].includes(
            typeof t,
          )
        )
          return t;
        if (null === t) return t;
        if ("object" == typeof t)
          return Object.fromEntries(
            Object.entries(t).map(([t, e]) => [t, kl(e)]),
          );
        throw new Error(`cloneDeep: unknown type=${t} (${typeof t})`);
      }
      var Ol, xl;
      function Pl(t) {
        if (void 0 === t.script || void 0 === t.amount)
          throw new Error("Transaction/output: script and amount required");
        return { script: t.script, amount: t.amount };
      }
      function Bl(t) {
        if (void 0 === t.txid || void 0 === t.index)
          throw new Error("Transaction/input: txid and index required");
        return {
          txid: t.txid,
          index: t.index,
          sequence: Tl(t.sequence, Al),
          finalScriptSig: Tl(t.finalScriptSig, Qf),
        };
      }
      function Cl(t) {
        for (const e in t) {
          const r = e;
          Jl.includes(r) || delete t[r];
        }
      }
      !(function (t) {
        (t[(t.DEFAULT = 0)] = "DEFAULT"),
          (t[(t.ALL = 1)] = "ALL"),
          (t[(t.NONE = 2)] = "NONE"),
          (t[(t.SINGLE = 3)] = "SINGLE"),
          (t[(t.ANYONECANPAY = 128)] = "ANYONECANPAY");
      })(Ol || (Ol = {})),
        (function (t) {
          (t[(t.DEFAULT = 0)] = "DEFAULT"),
            (t[(t.ALL = 1)] = "ALL"),
            (t[(t.NONE = 2)] = "NONE"),
            (t[(t.SINGLE = 3)] = "SINGLE"),
            (t[(t.DEFAULT_ANYONECANPAY = 128)] = "DEFAULT_ANYONECANPAY"),
            (t[(t.ALL_ANYONECANPAY = 129)] = "ALL_ANYONECANPAY"),
            (t[(t.NONE_ANYONECANPAY = 130)] = "NONE_ANYONECANPAY"),
            (t[(t.SINGLE_ANYONECANPAY = 131)] = "SINGLE_ANYONECANPAY");
        })(xl || (xl = {}));
      const Rl = jh({ txid: Rh(32, !0), index: Oh });
      function Nl(t) {
        if ("number" != typeof t || "string" != typeof xl[t])
          throw new Error(`Invalid SigHash=${t}`);
        return t;
      }
      function Ul(t) {
        const e = 31 & t;
        return {
          isAny: !!(t & Ol.ANYONECANPAY),
          isNone: e === Ol.NONE,
          isSingle: e === Ol.SINGLE,
        };
      }
      class Dl {
        constructor(t = {}) {
          (this.global = {}), (this.inputs = []), (this.outputs = []);
          const e = (this.opts = (function (t) {
            if (void 0 !== t && "[object Object]" !== {}.toString.call(t))
              throw new Error(
                `Wrong object type for transaction options: ${t}`,
              );
            const e = {
              ...t,
              version: Tl(t.version, 2),
              lockTime: Tl(t.lockTime, 0),
              PSBTVersion: Tl(t.PSBTVersion, 0),
            };
            if (
              (void 0 !== e.allowUnknowInput &&
                (t.allowUnknownInputs = e.allowUnknowInput),
              void 0 !== e.allowUnknowOutput &&
                (t.allowUnknownOutputs = e.allowUnknowOutput),
              ![-1, 0, 1, 2, 3].includes(e.version))
            )
              throw new Error(`Unknown version: ${e.version}`);
            if ("number" != typeof e.lockTime)
              throw new Error("Transaction lock time should be number");
            if (
              (Oh.encode(e.lockTime),
              0 !== e.PSBTVersion && 2 !== e.PSBTVersion)
            )
              throw new Error(`Unknown PSBT version ${e.PSBTVersion}`);
            for (const t of [
              "allowUnknownOutputs",
              "allowUnknownInputs",
              "disableScriptCheck",
              "bip174jsCompat",
              "allowLegacyWitnessUtxo",
              "lowR",
            ]) {
              const r = e[t];
              if (void 0 !== r && "boolean" != typeof r)
                throw new Error(
                  `Transation options wrong type: ${t}=${r} (${typeof r})`,
                );
            }
            if (void 0 !== e.customScripts) {
              const t = e.customScripts;
              if (!Array.isArray(t))
                throw new Error(
                  `wrong custom scripts type (expected array): customScripts=${t} (${typeof t})`,
                );
              for (const e of t) {
                if (
                  "function" != typeof e.encode ||
                  "function" != typeof e.decode
                )
                  throw new Error(`wrong script=${e} (${typeof e})`);
                if (
                  void 0 !== e.finalizeTaproot &&
                  "function" != typeof e.finalizeTaproot
                )
                  throw new Error(`wrong script=${e} (${typeof e})`);
              }
            }
            return Object.freeze(e);
          })(t));
          0 !== e.lockTime && (this.global.fallbackLocktime = e.lockTime),
            (this.global.txVersion = e.version);
        }
        static fromRaw(t, e = {}) {
          const r = bl.decode(t),
            n = new Dl({ ...e, version: r.version, lockTime: r.lockTime });
          for (const t of r.outputs) n.addOutput(t);
          if (((n.outputs = r.outputs), (n.inputs = r.inputs), r.witnesses))
            for (let t = 0; t < r.witnesses.length; t++)
              n.inputs[t].finalScriptWitness = r.witnesses[t];
          return n;
        }
        static fromPSBT(t, e = {}) {
          let r;
          try {
            r = pd.decode(t);
          } catch (e) {
            try {
              r = yd.decode(t);
            } catch (t) {
              throw e;
            }
          }
          const n = r.global.version || 0;
          if (0 !== n && 2 !== n) throw new Error(`Wrong PSBT version=${n}`);
          const i = r.global.unsignedTx,
            o = 0 === n ? i?.version : r.global.txVersion,
            s = 0 === n ? i?.lockTime : r.global.fallbackLocktime,
            a = new Dl({ ...e, version: o, lockTime: s, PSBTVersion: n }),
            u = 0 === n ? i?.inputs.length : r.global.inputCount;
          a.inputs = r.inputs.slice(0, u).map((t, e) => ({
            finalScriptSig: Qf,
            ...r.global.unsignedTx?.inputs[e],
            ...t,
          }));
          const c = 0 === n ? i?.outputs.length : r.global.outputCount;
          return (
            (a.outputs = r.outputs
              .slice(0, c)
              .map((t, e) => ({ ...t, ...r.global.unsignedTx?.outputs[e] }))),
            (a.global = { ...r.global, txVersion: o }),
            0 !== s && (a.global.fallbackLocktime = s),
            a
          );
        }
        toPSBT(t = this.opts.PSBTVersion) {
          if (0 !== t && 2 !== t) throw new Error(`Wrong PSBT version=${t}`);
          const e = this.inputs.map((e) => hd(t, Zl, e));
          for (const t of e)
            t.partialSig && !t.partialSig.length && delete t.partialSig,
              t.finalScriptSig &&
                !t.finalScriptSig.length &&
                delete t.finalScriptSig,
              t.finalScriptWitness &&
                !t.finalScriptWitness.length &&
                delete t.finalScriptWitness;
          const r = this.outputs.map((e) => hd(t, td, e)),
            n = { ...this.global };
          return (
            0 === t
              ? ((n.unsignedTx = wl.decode(
                  wl.encode({
                    version: this.version,
                    lockTime: this.lockTime,
                    inputs: this.inputs
                      .map(Bl)
                      .map((t) => ({ ...t, finalScriptSig: Qf })),
                    outputs: this.outputs.map(Pl),
                  }),
                )),
                delete n.fallbackLocktime,
                delete n.txVersion)
              : ((n.version = t),
                (n.txVersion = this.version),
                (n.inputCount = this.inputs.length),
                (n.outputCount = this.outputs.length),
                n.fallbackLocktime &&
                  0 === n.fallbackLocktime &&
                  delete n.fallbackLocktime),
            this.opts.bip174jsCompat &&
              (e.length || e.push({}), r.length || r.push({})),
            (0 === t ? pd : yd).encode({ global: n, inputs: e, outputs: r })
          );
        }
        get lockTime() {
          let t = 0,
            e = 0,
            r = 0,
            n = 0;
          for (const i of this.inputs)
            i.requiredHeightLocktime &&
              ((t = Math.max(t, i.requiredHeightLocktime)), e++),
              i.requiredTimeLocktime &&
                ((r = Math.max(r, i.requiredTimeLocktime)), n++);
          return e && e >= n
            ? t
            : 0 !== r
              ? r
              : this.global.fallbackLocktime || 0;
        }
        get version() {
          if (void 0 === this.global.txVersion)
            throw new Error("No global.txVersion");
          return this.global.txVersion;
        }
        inputStatus(t) {
          this.checkInputIdx(t);
          const e = this.inputs[t];
          return (e.finalScriptSig && e.finalScriptSig.length) ||
            (e.finalScriptWitness && e.finalScriptWitness.length)
            ? "finalized"
            : e.tapKeySig ||
                (e.tapScriptSig && e.tapScriptSig.length) ||
                (e.partialSig && e.partialSig.length)
              ? "signed"
              : "unsigned";
        }
        inputSighash(t) {
          this.checkInputIdx(t);
          const e = this.inputs[t].sighashType,
            r = void 0 === e ? Ol.DEFAULT : e,
            n = r === Ol.DEFAULT ? Ol.ALL : 3 & r;
          return { sigInputs: r & Ol.ANYONECANPAY, sigOutputs: n };
        }
        signStatus() {
          let t = !0,
            e = !0,
            r = [],
            n = [];
          for (let i = 0; i < this.inputs.length; i++) {
            if ("unsigned" === this.inputStatus(i)) continue;
            const { sigInputs: o, sigOutputs: s } = this.inputSighash(i);
            if ((o === Ol.ANYONECANPAY ? r.push(i) : (t = !1), s === Ol.ALL))
              e = !1;
            else if (s === Ol.SINGLE) n.push(i);
            else if (s !== Ol.NONE)
              throw new Error(`Wrong signature hash output type: ${s}`);
          }
          return { addInput: t, addOutput: e, inputs: r, outputs: n };
        }
        get isFinal() {
          for (let t = 0; t < this.inputs.length; t++)
            if ("finalized" !== this.inputStatus(t)) return !1;
          return !0;
        }
        get hasWitnesses() {
          let t = !1;
          for (const e of this.inputs)
            e.finalScriptWitness && e.finalScriptWitness.length && (t = !0);
          return t;
        }
        get weight() {
          if (!this.isFinal) throw new Error("Transaction is not finalized");
          let t = 32;
          const e = this.outputs.map(Pl);
          t += 4 * hl.encode(this.outputs.length).length;
          for (const r of e) t += 32 + 4 * ll.encode(r.script).length;
          this.hasWitnesses && (t += 2),
            (t += 4 * hl.encode(this.inputs.length).length);
          for (const e of this.inputs)
            (t += 160 + 4 * ll.encode(e.finalScriptSig || Qf).length),
              this.hasWitnesses &&
                e.finalScriptWitness &&
                (t += dl.encode(e.finalScriptWitness).length);
          return t;
        }
        get vsize() {
          return Sl(this.weight);
        }
        toBytes(t = !1, e = !1) {
          return bl.encode({
            version: this.version,
            lockTime: this.lockTime,
            inputs: this.inputs.map(Bl).map((e) => ({
              ...e,
              finalScriptSig: (t && e.finalScriptSig) || Qf,
            })),
            outputs: this.outputs.map(Pl),
            witnesses: this.inputs.map((t) => t.finalScriptWitness || []),
            segwitFlag: e && this.hasWitnesses,
          });
        }
        get unsignedTx() {
          return this.toBytes(!1, !1);
        }
        get hex() {
          return bu.encode(this.toBytes(!0, this.hasWitnesses));
        }
        get hash() {
          if (!this.isFinal) throw new Error("Transaction is not finalized");
          return bu.encode(Gh(this.toBytes(!0)));
        }
        get id() {
          if (!this.isFinal) throw new Error("Transaction is not finalized");
          return bu.encode(Gh(this.toBytes(!0)).reverse());
        }
        checkInputIdx(t) {
          if (!Number.isSafeInteger(t) || 0 > t || t >= this.inputs.length)
            throw new Error(`Wrong input index=${t}`);
        }
        getInput(t) {
          return this.checkInputIdx(t), kl(this.inputs[t]);
        }
        get inputsLength() {
          return this.inputs.length;
        }
        addInput(t, e = !1) {
          if (!e && !this.signStatus().addInput)
            throw new Error("Tx has signed inputs, cannot add new one");
          return (
            this.inputs.push(
              _l(t, void 0, void 0, this.opts.disableScriptCheck),
            ),
            this.inputs.length - 1
          );
        }
        updateInput(t, e, r = !1) {
          let n;
          if ((this.checkInputIdx(t), !r)) {
            const e = this.signStatus();
            (e.addInput && !e.inputs.includes(t)) || (n = Ql);
          }
          this.inputs[t] = _l(
            e,
            this.inputs[t],
            n,
            this.opts.disableScriptCheck,
          );
        }
        checkOutputIdx(t) {
          if (!Number.isSafeInteger(t) || 0 > t || t >= this.outputs.length)
            throw new Error(`Wrong output index=${t}`);
        }
        getOutput(t) {
          return this.checkOutputIdx(t), kl(this.outputs[t]);
        }
        getOutputAddress(t, e = il) {
          const r = this.getOutput(t);
          if (r.script) return Ud(e).encode(kd.decode(r.script));
        }
        get outputsLength() {
          return this.outputs.length;
        }
        normalizeOutput(t, e, r) {
          let { amount: n, script: i } = t;
          if ((void 0 === n && (n = e?.amount), "bigint" != typeof n))
            throw new Error(
              `Wrong amount type, should be of type bigint in sats, but got ${n} of type ${typeof n}`,
            );
          "string" == typeof i && (i = bu.decode(i)),
            void 0 === i && (i = e?.script);
          let o = { ...e, ...t, amount: n, script: i };
          if (
            (void 0 === o.amount && delete o.amount,
            (o = dd(td, o, e, r)),
            sd.encode(o),
            o.script &&
              !this.opts.allowUnknownOutputs &&
              "unknown" === kd.decode(o.script).type)
          )
            throw new Error(
              "Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure",
            );
          return (
            this.opts.disableScriptCheck ||
              xd(o.script, o.redeemScript, o.witnessScript),
            o
          );
        }
        addOutput(t, e = !1) {
          if (!e && !this.signStatus().addOutput)
            throw new Error("Tx has signed outputs, cannot add new one");
          return (
            this.outputs.push(this.normalizeOutput(t)), this.outputs.length - 1
          );
        }
        updateOutput(t, e, r = !1) {
          let n;
          if ((this.checkOutputIdx(t), !r)) {
            const e = this.signStatus();
            (e.addOutput && !e.outputs.includes(t)) || (n = ed);
          }
          this.outputs[t] = this.normalizeOutput(e, this.outputs[t], n);
        }
        addOutputAddress(t, e, r = il) {
          return this.addOutput({
            script: kd.encode(Ud(r).decode(t)),
            amount: e,
          });
        }
        get fee() {
          let t = 0n;
          for (const e of this.inputs) {
            const r = vl(e);
            if (!r) throw new Error("Empty input amount");
            t += r.amount;
          }
          const e = this.outputs.map(Pl);
          for (const r of e) t -= r.amount;
          return t;
        }
        preimageLegacy(t, e, r) {
          const { isAny: n, isNone: i, isSingle: o } = Ul(r);
          if (t < 0 || !Number.isSafeInteger(t))
            throw new Error(`Invalid input idx=${t}`);
          if ((o && t >= this.outputs.length) || t >= this.inputs.length)
            return Ih.encode(1n);
          e = ul.encode(ul.decode(e).filter((t) => "CODESEPARATOR" !== t));
          let s = this.inputs
            .map(Bl)
            .map((r, n) => ({ ...r, finalScriptSig: n === t ? e : Qf }));
          n
            ? (s = [s[t]])
            : (i || o) &&
              (s = s.map((e, r) => ({
                ...e,
                sequence: r === t ? e.sequence : 0,
              })));
          let a = this.outputs.map(Pl);
          i ? (a = []) : o && (a = a.slice(0, t).fill(Ml).concat([a[t]]));
          const u = bl.encode({
            lockTime: this.lockTime,
            version: this.version,
            segwitFlag: !1,
            inputs: s,
            outputs: a,
          });
          return Gh(u, Ph.encode(r));
        }
        preimageWitnessV0(t, e, r, n) {
          const { isAny: i, isNone: o, isSingle: s } = Ul(r);
          let a = Il,
            u = Il,
            c = Il;
          const f = this.inputs.map(Bl),
            h = this.outputs.map(Pl);
          i || (a = Gh(...f.map(Rl.encode))),
            i || s || o || (u = Gh(...f.map((t) => Oh.encode(t.sequence)))),
            s || o
              ? s && t < h.length && (c = Gh(gl.encode(h[t])))
              : (c = Gh(...h.map(gl.encode)));
          const l = f[t];
          return Gh(
            Ph.encode(this.version),
            a,
            u,
            Rh(32, !0).encode(l.txid),
            Oh.encode(l.index),
            ll.encode(e),
            Mh.encode(n),
            Oh.encode(l.sequence),
            c,
            Oh.encode(this.lockTime),
            Oh.encode(r),
          );
        }
        preimageWitnessV1(t, e, r, n, i = -1, o, s = 192, a) {
          if (!Array.isArray(n) || this.inputs.length !== n.length)
            throw new Error(`Invalid amounts array=${n}`);
          if (!Array.isArray(e) || this.inputs.length !== e.length)
            throw new Error(`Invalid prevOutScript array=${e}`);
          const u = [
              Ch.encode(0),
              Ch.encode(r),
              Ph.encode(this.version),
              Oh.encode(this.lockTime),
            ],
            c = r === Ol.DEFAULT ? Ol.ALL : 3 & r,
            f = r & Ol.ANYONECANPAY,
            h = this.inputs.map(Bl),
            l = this.outputs.map(Pl);
          f !== Ol.ANYONECANPAY &&
            u.push(
              ...[
                h.map(Rl.encode),
                n.map(Mh.encode),
                e.map(ll.encode),
                h.map((t) => Oh.encode(t.sequence)),
              ].map((t) => qu(qh(...t))),
            ),
            c === Ol.ALL && u.push(qu(qh(...l.map(gl.encode))));
          const d = (a ? 1 : 0) | (o ? 2 : 0);
          if ((u.push(new Uint8Array([d])), f === Ol.ANYONECANPAY)) {
            const r = h[t];
            u.push(
              Rl.encode(r),
              Mh.encode(n[t]),
              ll.encode(e[t]),
              Oh.encode(r.sequence),
            );
          } else u.push(Oh.encode(t));
          return (
            1 & d && u.push(qu(ll.encode(a || Qf))),
            c === Ol.SINGLE && u.push(t < l.length ? qu(gl.encode(l[t])) : Il),
            o && u.push(Pd(o, s), Ch.encode(0), Ph.encode(i)),
            Jh("TapSighash", ...u)
          );
        }
        signIdx(t, e, r, n) {
          this.checkInputIdx(e);
          const i = this.inputs[e],
            o = El(i, this.opts.allowLegacyWitnessUtxo);
          if (!Vh(t)) {
            if (!i.bip32Derivation || !i.bip32Derivation.length)
              throw new Error("bip32Derivation: empty");
            const r = i.bip32Derivation
              .filter((e) => e[1].fingerprint == t.fingerprint)
              .map(([e, { path: r }]) => {
                let n = t;
                for (const t of r) n = n.deriveChild(t);
                if (!zh(n.publicKey, e))
                  throw new Error("bip32Derivation: wrong pubKey");
                if (!n.privateKey)
                  throw new Error("bip32Derivation: no privateKey");
                return n;
              });
            if (!r.length)
              throw new Error(
                `bip32Derivation: no items with fingerprint=${t.fingerprint}`,
              );
            let n = !1;
            for (const t of r) this.signIdx(t.privateKey, e) && (n = !0);
            return n;
          }
          r ? r.forEach(Nl) : (r = [o.defaultSighash]);
          const s = o.sighash;
          if (!r.includes(s))
            throw new Error(
              `Input with not allowed sigHash=${s}. Allowed: ${r.join(", ")}`,
            );
          const { sigOutputs: a } = this.inputSighash(e);
          if (a === Ol.SINGLE && e >= this.outputs.length)
            throw new Error(
              `Input with sighash SINGLE, but there is no output with corresponding index=${e}`,
            );
          const u = vl(i);
          if ("taproot" === o.txType) {
            const r = this.inputs.map(vl),
              o = r.map((t) => t.script),
              a = r.map((t) => t.amount);
            let u = !1,
              c = Wh(t),
              f = i.tapMerkleRoot || Qf;
            if (i.tapInternalKey) {
              const { pubKey: r, privKey: h } = (function (t, e, r, n = Qf) {
                  return (
                    zh(r, e) && ((t = rl(t, n)), (e = Wh(t))),
                    { privKey: t, pubKey: e }
                  );
                })(t, c, i.tapInternalKey, f),
                [l, d] = nl(i.tapInternalKey, f);
              if (zh(l, r)) {
                const t = this.preimageWitnessV1(e, o, s, a),
                  r = qh(
                    Zh(t, h, n),
                    s !== Ol.DEFAULT ? new Uint8Array([s]) : Qf,
                  );
                this.updateInput(e, { tapKeySig: r }, !0), (u = !0);
              }
            }
            if (i.tapLeafScript) {
              i.tapScriptSig = i.tapScriptSig || [];
              for (const [r, f] of i.tapLeafScript) {
                const r = f.subarray(0, -1),
                  i = ul.decode(r),
                  h = f[f.length - 1],
                  l = Pd(r, h),
                  d = i.findIndex((t) => Vh(t) && zh(t, c));
                if (-1 === d) continue;
                const p = this.preimageWitnessV1(e, o, s, a, void 0, r, h),
                  y = qh(
                    Zh(p, t, n),
                    s !== Ol.DEFAULT ? new Uint8Array([s]) : Qf,
                  );
                this.updateInput(
                  e,
                  { tapScriptSig: [[{ pubKey: c, leafHash: l }, y]] },
                  !0,
                ),
                  (u = !0);
              }
            }
            if (!u) throw new Error("No taproot scripts signed");
            return !0;
          }
          {
            const r = Yh(t);
            let n = !1;
            const i = $h(r);
            for (const t of ul.decode(o.lastScript))
              Vh(t) && (zh(t, r) || zh(t, i)) && (n = !0);
            if (!n)
              throw new Error(
                `Input script doesn't have pubKey: ${o.lastScript}`,
              );
            let a;
            if ("legacy" === o.txType)
              a = this.preimageLegacy(e, o.lastScript, s);
            else {
              if ("segwit" !== o.txType)
                throw new Error(
                  `Transaction/sign: unknown tx type: ${o.txType}`,
                );
              {
                let t = o.lastScript;
                "wpkh" === o.last.type &&
                  (t = kd.encode({ type: "pkh", hash: o.last.hash })),
                  (a = this.preimageWitnessV0(e, t, s, u.amount));
              }
            }
            const c = (function (t, e, r = !1) {
              let n = Uf.sign(t, e);
              if (r && !Xh(n)) {
                const r = new Uint8Array(32);
                let i = 0;
                for (; !Xh(n); )
                  if (
                    (r.set(Oh.encode(i++)),
                    (n = Uf.sign(t, e, { extraEntropy: r })),
                    i > 4294967295)
                  )
                    throw new Error("lowR counter overflow: report the error");
              }
              return n.toDERRawBytes();
            })(a, t, this.opts.lowR);
            this.updateInput(
              e,
              { partialSig: [[r, qh(c, new Uint8Array([s]))]] },
              !0,
            );
          }
          return !0;
        }
        sign(t, e, r) {
          let n = 0;
          for (let i = 0; i < this.inputs.length; i++)
            try {
              this.signIdx(t, i, e, r) && n++;
            } catch (t) {}
          if (!n) throw new Error("No inputs signed");
          return n;
        }
        finalizeIdx(t) {
          if ((this.checkInputIdx(t), this.fee < 0n))
            throw new Error("Outputs spends more than inputs amount");
          const e = this.inputs[t],
            r = El(e, this.opts.allowLegacyWitnessUtxo);
          if ("taproot" === r.txType) {
            if (e.tapKeySig) e.finalScriptWitness = [e.tapKeySig];
            else {
              if (!e.tapLeafScript || !e.tapScriptSig)
                throw new Error("finalize/taproot: unknown input");
              {
                const t = e.tapLeafScript.sort(
                  (t, e) => zl.encode(t[0]).length - zl.encode(e[0]).length,
                );
                for (const [r, n] of t) {
                  const t = n.slice(0, -1),
                    i = n[n.length - 1],
                    o = kd.decode(t),
                    s = Pd(t, i),
                    a = e.tapScriptSig.filter((t) => zh(t[0].leafHash, s));
                  let u = [];
                  if ("tr_ms" === o.type) {
                    const t = o.m,
                      e = o.pubkeys;
                    let r = 0;
                    for (const n of e) {
                      const e = a.findIndex((t) => zh(t[0].pubKey, n));
                      r !== t && -1 !== e ? (u.push(a[e][1]), r++) : u.push(Qf);
                    }
                    if (r !== t) continue;
                  } else if ("tr_ns" === o.type) {
                    for (const t of o.pubkeys) {
                      const e = a.findIndex((e) => zh(e[0].pubKey, t));
                      -1 !== e && u.push(a[e][1]);
                    }
                    if (u.length !== o.pubkeys.length) continue;
                  } else {
                    if ("unknown" !== o.type || !this.opts.allowUnknownInputs) {
                      const n = this.opts.customScripts;
                      if (n)
                        for (const i of n) {
                          if (!i.finalizeTaproot) continue;
                          const n = ul.decode(t),
                            o = i.encode(n);
                          if (void 0 === o) continue;
                          const s = i.finalizeTaproot(t, o, a);
                          if (s)
                            return (
                              (e.finalScriptWitness = s.concat(zl.encode(r))),
                              (e.finalScriptSig = Qf),
                              void Cl(e)
                            );
                        }
                      throw new Error("Finalize: Unknown tapLeafScript");
                    }
                    {
                      const e = ul.decode(t);
                      if (
                        ((u = a
                          .map(([{ pubKey: t }, r]) => {
                            const n = e.findIndex((e) => Vh(e) && zh(e, t));
                            if (-1 === n)
                              throw new Error(
                                "finalize/taproot: cannot find position of pubkey in script",
                              );
                            return { signature: r, pos: n };
                          })
                          .sort((t, e) => t.pos - e.pos)
                          .map((t) => t.signature)),
                        !u.length)
                      )
                        continue;
                    }
                  }
                  e.finalScriptWitness = u.reverse().concat([t, zl.encode(r)]);
                  break;
                }
                if (!e.finalScriptWitness)
                  throw new Error("finalize/taproot: empty witness");
              }
            }
            return (e.finalScriptSig = Qf), void Cl(e);
          }
          if (!e.partialSig || !e.partialSig.length)
            throw new Error("Not enough partial sign");
          let n,
            i,
            o = Qf,
            s = [];
          if ("ms" === r.last.type) {
            const t = r.last.m,
              n = r.last.pubkeys;
            let i = [];
            for (const t of n) {
              const r = e.partialSig.find((e) => zh(t, e[0]));
              r && i.push(r[1]);
            }
            if (((i = i.slice(0, t)), i.length !== t))
              throw new Error(
                `Multisig: wrong signatures count, m=${t} n=${n.length} signatures=${i.length}`,
              );
            o = ul.encode([0, ...i]);
          } else if ("pk" === r.last.type) o = ul.encode([e.partialSig[0][1]]);
          else if ("pkh" === r.last.type)
            o = ul.encode([e.partialSig[0][1], e.partialSig[0][0]]);
          else if ("wpkh" === r.last.type)
            (o = Qf), (s = [e.partialSig[0][1], e.partialSig[0][0]]);
          else if ("unknown" === r.last.type && !this.opts.allowUnknownInputs)
            throw new Error("Unknown inputs not allowed");
          if (
            (r.type.includes("wsh-") &&
              (o.length &&
                r.lastScript.length &&
                (s = ul.decode(o).map((t) => {
                  if (0 === t) return Qf;
                  if (Vh(t)) return t;
                  throw new Error(`Wrong witness op=${t}`);
                })),
              (s = s.concat(r.lastScript))),
            "segwit" === r.txType && (i = s),
            r.type.startsWith("sh-wsh-")
              ? (n = ul.encode([ul.encode([0, qu(r.lastScript)])]))
              : r.type.startsWith("sh-")
                ? (n = ul.encode([...ul.decode(o), r.lastScript]))
                : r.type.startsWith("wsh-") ||
                  ("segwit" !== r.txType && (n = o)),
            !n && !i)
          )
            throw new Error("Unknown error finalizing input");
          n && (e.finalScriptSig = n), i && (e.finalScriptWitness = i), Cl(e);
        }
        finalize() {
          for (let t = 0; t < this.inputs.length; t++) this.finalizeIdx(t);
        }
        extract() {
          if (!this.isFinal)
            throw new Error("Transaction has unfinalized inputs");
          if (!this.outputs.length)
            throw new Error("Transaction has no outputs");
          if (this.fee < 0n)
            throw new Error("Outputs spends more than inputs amount");
          return this.toBytes(!0, !0);
        }
        combine(t) {
          for (const e of ["PSBTVersion", "version", "lockTime"])
            if (this.opts[e] !== t.opts[e])
              throw new Error(
                `Transaction/combine: different ${e} this=${this.opts[e]} other=${t.opts[e]}`,
              );
          for (const e of ["inputs", "outputs"])
            if (this[e].length !== t[e].length)
              throw new Error(
                `Transaction/combine: different ${e} length this=${this[e].length} other=${t[e].length}`,
              );
          const e = this.global.unsignedTx
              ? wl.encode(this.global.unsignedTx)
              : Qf,
            r = t.global.unsignedTx ? wl.encode(t.global.unsignedTx) : Qf;
          if (!zh(e, r))
            throw new Error("Transaction/combine: different unsigned tx");
          this.global = dd(Xl, this.global, t.global);
          for (let e = 0; e < this.inputs.length; e++)
            this.updateInput(e, t.inputs[e], !0);
          for (let e = 0; e < this.outputs.length; e++)
            this.updateOutput(e, t.outputs[e], !0);
          return this;
        }
        clone() {
          return Dl.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
        }
      }
      const Ll = mh(Rh(null), (t) => tl(t, Qh.ecdsa)),
        jl = mh(Rh(32), (t) => tl(t, Qh.schnorr)),
        Fl = mh(Rh(null), (t) => {
          if (64 !== t.length && 65 !== t.length)
            throw new Error("Schnorr signature should be 64 or 65 bytes long");
          return t;
        }),
        Hl = jh({ fingerprint: xh, path: Fh(null, Oh) }),
        Kl = jh({ hashes: Fh(hl, Rh(32)), der: Hl }),
        Vl = Rh(78),
        ql = jh({ pubKey: jl, leafHash: Rh(32) }),
        zl = mh(
          jh({
            version: Ch,
            internalKey: Rh(32),
            merklePath: Fh(null, Rh(32)),
          }),
          (t) => {
            if (t.merklePath.length > 128)
              throw new Error(
                "TaprootControlBlock: merklePath should be of length 0..128 (inclusive)",
              );
            return t;
          },
        ),
        $l = Fh(null, jh({ depth: Ch, version: Ch, script: ll })),
        Gl = Rh(null),
        Wl = Rh(20),
        Yl = Rh(32),
        Xl = {
          unsignedTx: [0, !1, wl, [0], [0], !1],
          xpub: [1, Vl, Hl, [], [0, 2], !1],
          txVersion: [2, !1, Oh, [2], [2], !1],
          fallbackLocktime: [3, !1, Oh, [], [2], !1],
          inputCount: [4, !1, hl, [2], [2], !1],
          outputCount: [5, !1, hl, [2], [2], !1],
          txModifiable: [6, !1, Ch, [], [2], !1],
          version: [251, !1, Oh, [], [0, 2], !1],
          proprietary: [252, Gl, Gl, [], [0, 2], !1],
        },
        Zl = {
          nonWitnessUtxo: [0, !1, bl, [], [0, 2], !1],
          witnessUtxo: [1, !1, gl, [], [0, 2], !1],
          partialSig: [2, Ll, Gl, [], [0, 2], !1],
          sighashType: [3, !1, Oh, [], [0, 2], !1],
          redeemScript: [4, !1, Gl, [], [0, 2], !1],
          witnessScript: [5, !1, Gl, [], [0, 2], !1],
          bip32Derivation: [6, Ll, Hl, [], [0, 2], !1],
          finalScriptSig: [7, !1, Gl, [], [0, 2], !1],
          finalScriptWitness: [8, !1, dl, [], [0, 2], !1],
          porCommitment: [9, !1, Gl, [], [0, 2], !1],
          ripemd160: [10, Wl, Gl, [], [0, 2], !1],
          sha256: [11, Yl, Gl, [], [0, 2], !1],
          hash160: [12, Wl, Gl, [], [0, 2], !1],
          hash256: [13, Yl, Gl, [], [0, 2], !1],
          txid: [14, !1, Yl, [2], [2], !0],
          index: [15, !1, Oh, [2], [2], !0],
          sequence: [16, !1, Oh, [], [2], !0],
          requiredTimeLocktime: [17, !1, Oh, [], [2], !1],
          requiredHeightLocktime: [18, !1, Oh, [], [2], !1],
          tapKeySig: [19, !1, Fl, [], [0, 2], !1],
          tapScriptSig: [20, ql, Fl, [], [0, 2], !1],
          tapLeafScript: [21, zl, Gl, [], [0, 2], !1],
          tapBip32Derivation: [22, Yl, Kl, [], [0, 2], !1],
          tapInternalKey: [23, !1, jl, [], [0, 2], !1],
          tapMerkleRoot: [24, !1, Yl, [], [0, 2], !1],
          proprietary: [252, Gl, Gl, [], [0, 2], !1],
        },
        Jl = [
          "txid",
          "sequence",
          "index",
          "witnessUtxo",
          "nonWitnessUtxo",
          "finalScriptSig",
          "finalScriptWitness",
          "unknown",
        ],
        Ql = [
          "partialSig",
          "finalScriptSig",
          "finalScriptWitness",
          "tapKeySig",
          "tapScriptSig",
        ],
        td = {
          redeemScript: [0, !1, Gl, [], [0, 2], !1],
          witnessScript: [1, !1, Gl, [], [0, 2], !1],
          bip32Derivation: [2, Ll, Hl, [], [0, 2], !1],
          amount: [3, !1, Ah, [2], [2], !0],
          script: [4, !1, Gl, [2], [2], !0],
          tapInternalKey: [5, !1, jl, [], [0, 2], !1],
          tapTree: [6, !1, $l, [], [0, 2], !1],
          tapBip32Derivation: [7, jl, Kl, [], [0, 2], !1],
          proprietary: [252, Gl, Gl, [], [0, 2], !1],
        },
        ed = [],
        rd = Fh(
          th,
          jh({
            key: (function (t, e) {
              if (!vh(e)) throw new Error(`prefix: invalid inner value ${e}`);
              return Uh(Rh(t), _h(e));
            })(hl, jh({ type: hl, key: Rh(null) })),
            value: Rh(hl),
          }),
        );
      function nd(t) {
        const [e, r, n, i, o, s] = t;
        return {
          type: e,
          kc: r,
          vc: n,
          reqInc: i,
          allowInc: o,
          silentIgnore: s,
        };
      }
      jh({ type: hl, key: Rh(null) });
      function id(t) {
        const e = {};
        for (const r in t) {
          const [n, i, o] = t[r];
          e[n] = [r, i, o];
        }
        return bh({
          encodeStream: (e, r) => {
            let n = [];
            for (const e in t) {
              const i = r[e];
              if (void 0 === i) continue;
              const [o, s, a] = t[e];
              if (s) {
                const t = i.map(([t, e]) => [s.encode(t), a.encode(e)]);
                t.sort((t, e) => ol(t[0], e[0]));
                for (const [e, r] of t)
                  n.push({ key: { key: e, type: o }, value: r });
              } else n.push({ key: { type: o, key: Qf }, value: a.encode(i) });
            }
            if (r.unknown) {
              r.unknown.sort((t, e) => ol(t[0].key, e[0].key));
              for (const [t, e] of r.unknown) n.push({ key: t, value: e });
            }
            rd.encodeStream(e, n);
          },
          decodeStream: (t) => {
            const r = rd.decodeStream(t),
              n = {},
              i = {};
            for (const t of r) {
              let r = "unknown",
                o = t.key.key,
                s = t.value;
              if (e[t.key.type]) {
                const [a, u, c] = e[t.key.type];
                if (((r = a), !u && o.length))
                  throw new Error(
                    `PSBT: Non-empty key for ${r} (key=${bu.encode(o)} value=${bu.encode(s)}`,
                  );
                if (((o = u ? u.decode(o) : void 0), (s = c.decode(s)), !u)) {
                  if (n[r])
                    throw new Error(
                      `PSBT: Same keys: ${r} (key=${o} value=${s})`,
                    );
                  (n[r] = s), (i[r] = !0);
                  continue;
                }
              } else o = { type: t.key.type, key: t.key.key };
              if (i[r])
                throw new Error(
                  `PSBT: Key type with empty key and no key=${r} val=${s}`,
                );
              n[r] || (n[r] = []), n[r].push([o, s]);
            }
            return n;
          },
        });
      }
      const od = mh(id(Zl), (t) => {
          if (t.finalScriptWitness && !t.finalScriptWitness.length)
            throw new Error("validateInput: empty finalScriptWitness");
          if (t.partialSig && !t.partialSig.length)
            throw new Error("Empty partialSig");
          if (t.partialSig) for (const [e] of t.partialSig) tl(e, Qh.ecdsa);
          if (t.bip32Derivation)
            for (const [e] of t.bip32Derivation) tl(e, Qh.ecdsa);
          if (void 0 !== t.requiredTimeLocktime && t.requiredTimeLocktime < 5e8)
            throw new Error(
              `validateInput: wrong timeLocktime=${t.requiredTimeLocktime}`,
            );
          if (
            void 0 !== t.requiredHeightLocktime &&
            (t.requiredHeightLocktime <= 0 || t.requiredHeightLocktime >= 5e8)
          )
            throw new Error(
              `validateInput: wrong heighLocktime=${t.requiredHeightLocktime}`,
            );
          if (t.nonWitnessUtxo && void 0 !== t.index) {
            const e = t.nonWitnessUtxo.outputs.length - 1;
            if (t.index > e)
              throw new Error(
                `validateInput: index(${t.index}) not in nonWitnessUtxo`,
              );
            const r = t.nonWitnessUtxo.outputs[t.index];
            if (
              t.witnessUtxo &&
              (!zh(t.witnessUtxo.script, r.script) ||
                t.witnessUtxo.amount !== r.amount)
            )
              throw new Error(
                "validateInput: witnessUtxo different from nonWitnessUtxo",
              );
          }
          if (t.tapLeafScript)
            for (const [e, r] of t.tapLeafScript) {
              if ((254 & e.version) !== r[r.length - 1])
                throw new Error("validateInput: tapLeafScript version mimatch");
              if (1 & r[r.length - 1])
                throw new Error(
                  "validateInput: tapLeafScript version has parity bit!",
                );
            }
          if (t.nonWitnessUtxo && void 0 !== t.index && t.txid) {
            if (t.nonWitnessUtxo.outputs.length - 1 < t.index)
              throw new Error("nonWitnessUtxo: incorect output index");
            const e = Dl.fromRaw(bl.encode(t.nonWitnessUtxo), {
                allowUnknownOutputs: !0,
                disableScriptCheck: !0,
                allowUnknownInputs: !0,
              }),
              r = bu.encode(t.txid);
            if (e.isFinal && e.id !== r)
              throw new Error(
                `nonWitnessUtxo: wrong txid, exp=${r} got=${e.id}`,
              );
          }
          return t;
        }),
        sd = mh(id(td), (t) => {
          if (t.bip32Derivation)
            for (const [e] of t.bip32Derivation) tl(e, Qh.ecdsa);
          return t;
        }),
        ad = mh(id(Xl), (t) => {
          if (0 === (t.version || 0)) {
            if (!t.unsignedTx) throw new Error("PSBTv0: missing unsignedTx");
            for (const e of t.unsignedTx.inputs)
              if (e.finalScriptSig && e.finalScriptSig.length)
                throw new Error("PSBTv0: input scriptSig found in unsignedTx");
          }
          return t;
        }),
        ud = jh({
          magic: Dh(Nh(new Uint8Array([255])), "psbt"),
          global: ad,
          inputs: Fh("global/unsignedTx/inputs/length", od),
          outputs: Fh(null, sd),
        }),
        cd = jh({
          magic: Dh(Nh(new Uint8Array([255])), "psbt"),
          global: ad,
          inputs: Fh("global/inputCount", od),
          outputs: Fh("global/outputCount", sd),
        });
      jh({
        magic: Dh(Nh(new Uint8Array([255])), "psbt"),
        items: Fh(
          null,
          Uh(
            Fh(
              th,
              (function (t) {
                if (!Array.isArray(t))
                  throw new Error(
                    `Packed.Tuple: got ${typeof t} instead of array`,
                  );
                for (let e = 0; e < t.length; e++)
                  if (!vh(t[e]))
                    throw new Error(`tuple: field ${e} is not CoderType`);
                return bh({
                  size: Lh(t),
                  encodeStream: (e, r) => {
                    if (!Array.isArray(r))
                      throw e.err(`tuple: invalid value ${r}`);
                    e.pushObj(r, (n) => {
                      for (let i = 0; i < t.length; i++)
                        n(`${i}`, () => t[i].encodeStream(e, r[i]));
                    });
                  },
                  decodeStream: (e) => {
                    const r = [];
                    return (
                      e.pushObj(r, (n) => {
                        for (let i = 0; i < t.length; i++)
                          n(`${i}`, () => r.push(t[i].decodeStream(e)));
                      }),
                      r
                    );
                  },
                  validate: (e) => {
                    if (!Array.isArray(e))
                      throw new Error(`tuple: invalid value ${e}`);
                    if (e.length !== t.length)
                      throw new Error(
                        `tuple: wrong length=${e.length}, expected ${t.length}`,
                      );
                    return e;
                  },
                });
              })([
                ((t, e = { isLE: !1, with0x: !1 }) => {
                  let r = Uh(Rh(t, e.isLE), bu);
                  const n = e.with0x;
                  if ("boolean" != typeof n)
                    throw new Error(
                      "hex/with0x: expected boolean, got " + typeof n,
                    );
                  return (
                    n &&
                      (r = Uh(r, {
                        encode: (t) => `0x${t}`,
                        decode: (t) => {
                          if (!t.startsWith("0x"))
                            throw new Error(
                              "hex(with0x=true).encode input should start with 0x",
                            );
                          return t.slice(2);
                        },
                      })),
                    r
                  );
                })(hl),
                Rh(fl),
              ]),
            ),
            Eh.dict(),
          ),
        ),
      });
      function fd(t, e, r) {
        for (const n in r) {
          if ("unknown" === n) continue;
          if (!e[n]) continue;
          const { allowInc: r } = nd(e[n]);
          if (!r.includes(t))
            throw new Error(`PSBTv${t}: field ${n} is not allowed`);
        }
        for (const n in e) {
          const { reqInc: i } = nd(e[n]);
          if (i.includes(t) && void 0 === r[n])
            throw new Error(`PSBTv${t}: missing required field ${n}`);
        }
      }
      function hd(t, e, r) {
        const n = {};
        for (const i in r) {
          const o = i;
          if ("unknown" !== o) {
            if (!e[o]) continue;
            const { allowInc: r, silentIgnore: n } = nd(e[o]);
            if (!r.includes(t)) {
              if (n) continue;
              throw new Error(
                `Failed to serialize in PSBTv${t}: ${o} but versions allows inclusion=${r}`,
              );
            }
          }
          n[o] = r[o];
        }
        return n;
      }
      function ld(t) {
        const e = (t && t.global && t.global.version) || 0;
        fd(e, Xl, t.global);
        for (const r of t.inputs) fd(e, Zl, r);
        for (const r of t.outputs) fd(e, td, r);
        const r = e ? t.global.inputCount : t.global.unsignedTx.inputs.length;
        if (t.inputs.length < r) throw new Error("Not enough inputs");
        const n = t.inputs.slice(r);
        if (n.length > 1 || (n.length && Object.keys(n[0]).length))
          throw new Error(`Unexpected inputs left in tx=${n}`);
        const i = e ? t.global.outputCount : t.global.unsignedTx.outputs.length;
        if (t.outputs.length < i) throw new Error("Not outputs inputs");
        const o = t.outputs.slice(i);
        if (o.length > 1 || (o.length && Object.keys(o[0]).length))
          throw new Error(`Unexpected outputs left in tx=${o}`);
        return t;
      }
      function dd(t, e, r, n) {
        const i = { ...r, ...e };
        for (const o in t) {
          const s = o,
            [a, u, c] = t[s],
            f = n && !n.includes(o);
          if (void 0 === e[o] && o in e) {
            if (f) throw new Error(`Cannot remove signed field=${o}`);
            delete i[o];
          } else if (u) {
            const t = r && r[o] ? r[o] : [];
            let n = e[s];
            if (n) {
              if (!Array.isArray(n))
                throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
              n = n.map((t) => {
                if (2 !== t.length)
                  throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
                return [
                  "string" == typeof t[0] ? u.decode(bu.decode(t[0])) : t[0],
                  "string" == typeof t[1] ? c.decode(bu.decode(t[1])) : t[1],
                ];
              });
              const e = {},
                r = (t, r, n) => {
                  if (void 0 === e[t]) return void (e[t] = [r, n]);
                  const i = bu.encode(c.encode(e[t][1])),
                    o = bu.encode(c.encode(n));
                  if (i !== o)
                    throw new Error(
                      `keyMap(${s}): same key=${t} oldVal=${i} newVal=${o}`,
                    );
                };
              for (const [e, n] of t) {
                r(bu.encode(u.encode(e)), e, n);
              }
              for (const [t, i] of n) {
                const n = bu.encode(u.encode(t));
                if (void 0 === i) {
                  if (f)
                    throw new Error(`Cannot remove signed field=${s}/${t}`);
                  delete e[n];
                } else r(n, t, i);
              }
              i[s] = Object.values(e);
            }
          } else if ("string" == typeof i[o]) i[o] = c.decode(bu.decode(i[o]));
          else if (
            f &&
            o in e &&
            r &&
            void 0 !== r[o] &&
            !zh(c.encode(e[o]), c.encode(r[o]))
          )
            throw new Error(`Cannot change signed field=${o}`);
        }
        for (const e in i) t[e] || delete i[e];
        return i;
      }
      const pd = mh(ud, ld),
        yd = mh(cd, ld),
        gd = {
          encode(t) {
            if (
              2 === t.length &&
              1 === t[0] &&
              Vh(t[1]) &&
              "4e73" === bu.encode(t[1])
            )
              return { type: "p2a", script: ul.encode(t) };
          },
          decode: (t) => {
            if ("p2a" === t.type) return [1, bu.decode("4e73")];
          },
        };
      function md(t, e) {
        try {
          return tl(t, e), !0;
        } catch (t) {
          return !1;
        }
      }
      const bd = {
          encode(t) {
            if (
              2 === t.length &&
              Vh(t[0]) &&
              md(t[0], Qh.ecdsa) &&
              "CHECKSIG" === t[1]
            )
              return { type: "pk", pubkey: t[0] };
          },
          decode: (t) => ("pk" === t.type ? [t.pubkey, "CHECKSIG"] : void 0),
        },
        wd = {
          encode(t) {
            if (
              5 === t.length &&
              "DUP" === t[0] &&
              "HASH160" === t[1] &&
              Vh(t[2]) &&
              "EQUALVERIFY" === t[3] &&
              "CHECKSIG" === t[4]
            )
              return { type: "pkh", hash: t[2] };
          },
          decode: (t) =>
            "pkh" === t.type
              ? ["DUP", "HASH160", t.hash, "EQUALVERIFY", "CHECKSIG"]
              : void 0,
        },
        vd = {
          encode(t) {
            if (
              3 === t.length &&
              "HASH160" === t[0] &&
              Vh(t[1]) &&
              "EQUAL" === t[2]
            )
              return { type: "sh", hash: t[1] };
          },
          decode: (t) =>
            "sh" === t.type ? ["HASH160", t.hash, "EQUAL"] : void 0,
        },
        _d = {
          encode(t) {
            if (2 === t.length && 0 === t[0] && Vh(t[1]) && 32 === t[1].length)
              return { type: "wsh", hash: t[1] };
          },
          decode: (t) => ("wsh" === t.type ? [0, t.hash] : void 0),
        },
        Ed = {
          encode(t) {
            if (2 === t.length && 0 === t[0] && Vh(t[1]) && 20 === t[1].length)
              return { type: "wpkh", hash: t[1] };
          },
          decode: (t) => ("wpkh" === t.type ? [0, t.hash] : void 0),
        },
        Sd = {
          encode(t) {
            const e = t.length - 1;
            if ("CHECKMULTISIG" !== t[e]) return;
            const r = t[0],
              n = t[e - 1];
            if ("number" != typeof r || "number" != typeof n) return;
            const i = t.slice(1, -2);
            if (n === i.length) {
              for (const t of i) if (!Vh(t)) return;
              return { type: "ms", m: r, pubkeys: i };
            }
          },
          decode: (t) =>
            "ms" === t.type
              ? [t.m, ...t.pubkeys, t.pubkeys.length, "CHECKMULTISIG"]
              : void 0,
        },
        Id = {
          encode(t) {
            if (2 === t.length && 1 === t[0] && Vh(t[1]))
              return { type: "tr", pubkey: t[1] };
          },
          decode: (t) => ("tr" === t.type ? [1, t.pubkey] : void 0),
        },
        Md = {
          encode(t) {
            const e = t.length - 1;
            if ("CHECKSIG" !== t[e]) return;
            const r = [];
            for (let n = 0; n < e; n++) {
              const i = t[n];
              if (1 & n) {
                if ("CHECKSIGVERIFY" !== i || n === e - 1) return;
              } else {
                if (!Vh(i)) return;
                r.push(i);
              }
            }
            return { type: "tr_ns", pubkeys: r };
          },
          decode: (t) => {
            if ("tr_ns" !== t.type) return;
            const e = [];
            for (let r = 0; r < t.pubkeys.length - 1; r++)
              e.push(t.pubkeys[r], "CHECKSIGVERIFY");
            return e.push(t.pubkeys[t.pubkeys.length - 1], "CHECKSIG"), e;
          },
        },
        Ad = {
          encode(t) {
            const e = t.length - 1;
            if ("NUMEQUAL" !== t[e] || "CHECKSIG" !== t[1]) return;
            const r = [],
              n = (function (t, e = 4, r = !0) {
                if ("number" == typeof t) return t;
                if (Vh(t))
                  try {
                    const n = al(e, r).decode(t);
                    if (n > Number.MAX_SAFE_INTEGER) return;
                    return Number(n);
                  } catch (t) {
                    return;
                  }
              })(t[e - 1]);
            if ("number" == typeof n) {
              for (let n = 0; n < e - 1; n++) {
                const e = t[n];
                if (1 & n) {
                  if (e !== (1 === n ? "CHECKSIG" : "CHECKSIGADD"))
                    throw new Error("OutScript.encode/tr_ms: wrong element");
                } else {
                  if (!Vh(e))
                    throw new Error(
                      "OutScript.encode/tr_ms: wrong key element",
                    );
                  r.push(e);
                }
              }
              return { type: "tr_ms", pubkeys: r, m: n };
            }
          },
          decode: (t) => {
            if ("tr_ms" !== t.type) return;
            const e = [t.pubkeys[0], "CHECKSIG"];
            for (let r = 1; r < t.pubkeys.length; r++)
              e.push(t.pubkeys[r], "CHECKSIGADD");
            return e.push(t.m, "NUMEQUAL"), e;
          },
        },
        Td = [
          gd,
          bd,
          wd,
          vd,
          _d,
          Ed,
          Sd,
          Id,
          Md,
          Ad,
          {
            encode: (t) => ({ type: "unknown", script: ul.encode(t) }),
            decode: (t) =>
              "unknown" === t.type ? ul.decode(t.script) : void 0,
          },
        ],
        kd = mh(Uh(ul, Eh.match(Td)), (t) => {
          if ("pk" === t.type && !md(t.pubkey, Qh.ecdsa))
            throw new Error("OutScript/pk: wrong key");
          if (
            !(
              ("pkh" !== t.type && "sh" !== t.type && "wpkh" !== t.type) ||
              (Vh(t.hash) && 20 === t.hash.length)
            )
          )
            throw new Error(`OutScript/${t.type}: wrong hash`);
          if ("wsh" === t.type && (!Vh(t.hash) || 32 !== t.hash.length))
            throw new Error("OutScript/wsh: wrong hash");
          if (!("tr" !== t.type || (Vh(t.pubkey) && md(t.pubkey, Qh.schnorr))))
            throw new Error("OutScript/tr: wrong taproot public key");
          if (
            ("ms" === t.type || "tr_ns" === t.type || "tr_ms" === t.type) &&
            !Array.isArray(t.pubkeys)
          )
            throw new Error("OutScript/multisig: wrong pubkeys array");
          if ("ms" === t.type) {
            const e = t.pubkeys.length;
            for (const e of t.pubkeys)
              if (!md(e, Qh.ecdsa))
                throw new Error("OutScript/multisig: wrong pubkey");
            if (t.m <= 0 || e > 16 || t.m > e)
              throw new Error("OutScript/multisig: invalid params");
          }
          if ("tr_ns" === t.type || "tr_ms" === t.type)
            for (const e of t.pubkeys)
              if (!md(e, Qh.schnorr))
                throw new Error(`OutScript/${t.type}: wrong pubkey`);
          if ("tr_ms" === t.type) {
            const e = t.pubkeys.length;
            if (t.m <= 0 || e > 999 || t.m > e)
              throw new Error("OutScript/tr_ms: invalid params");
          }
          return t;
        });
      function Od(t, e) {
        if (!zh(t.hash, qu(e)))
          throw new Error("checkScript: wsh wrong witnessScript hash");
        const r = kd.decode(e);
        if ("tr" === r.type || "tr_ns" === r.type || "tr_ms" === r.type)
          throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);
        if ("wpkh" === r.type || "sh" === r.type)
          throw new Error(
            `checkScript: P2${r.type} cannot be wrapped in P2WSH`,
          );
      }
      function xd(t, e, r) {
        if (t) {
          const n = kd.decode(t);
          if (
            "tr_ns" === n.type ||
            "tr_ms" === n.type ||
            "ms" === n.type ||
            "pk" == n.type
          )
            throw new Error(`checkScript: non-wrapped ${n.type}`);
          if ("sh" === n.type && e) {
            if (!zh(n.hash, $h(e)))
              throw new Error("checkScript: sh wrong redeemScript hash");
            const t = kd.decode(e);
            if ("tr" === t.type || "tr_ns" === t.type || "tr_ms" === t.type)
              throw new Error(
                `checkScript: P2${t.type} cannot be wrapped in P2SH`,
              );
            if ("sh" === t.type)
              throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
          }
          "wsh" === n.type && r && Od(n, r);
        }
        if (e) {
          const t = kd.decode(e);
          "wsh" === t.type && r && Od(t, r);
        }
      }
      const Pd = (t, e = 192) =>
        Jh("TapLeaf", new Uint8Array([e]), ll.encode(t));
      const Bd = cu(qu);
      function Cd(t, e) {
        if (e.length < 2 || e.length > 40)
          throw new Error("Witness: invalid length");
        if (t > 16) throw new Error("Witness: invalid version");
        if (0 === t && 20 !== e.length && 32 !== e.length)
          throw new Error("Witness: invalid length for version");
      }
      function Rd(t, e, r = il) {
        Cd(t, e);
        const n = 0 === t ? yu : gu;
        return n.encode(r.bech32, [t].concat(n.toWords(e)));
      }
      function Nd(t, e) {
        return Bd.encode(qh(Uint8Array.from(e), t));
      }
      function Ud(t = il) {
        return {
          encode(e) {
            const { type: r } = e;
            if ("wpkh" === r) return Rd(0, e.hash, t);
            if ("wsh" === r) return Rd(0, e.hash, t);
            if ("tr" === r) return Rd(1, e.pubkey, t);
            if ("pkh" === r) return Nd(e.hash, [t.pubKeyHash]);
            if ("sh" === r) return Nd(e.hash, [t.scriptHash]);
            throw new Error(`Unknown address type=${r}`);
          },
          decode(e) {
            if (e.length < 14 || e.length > 74)
              throw new Error("Invalid address length");
            if (t.bech32 && e.toLowerCase().startsWith(`${t.bech32}1`)) {
              let r;
              try {
                if (((r = yu.decode(e)), 0 !== r.words[0]))
                  throw new Error(`bech32: wrong version=${r.words[0]}`);
              } catch (t) {
                if (((r = gu.decode(e)), 0 === r.words[0]))
                  throw new Error(`bech32m: wrong version=${r.words[0]}`);
              }
              if (r.prefix !== t.bech32)
                throw new Error(`wrong bech32 prefix=${r.prefix}`);
              const [n, ...i] = r.words,
                o = yu.fromWords(i);
              if ((Cd(n, o), 0 === n && 32 === o.length))
                return { type: "wsh", hash: o };
              if (0 === n && 20 === o.length) return { type: "wpkh", hash: o };
              if (1 === n && 32 === o.length) return { type: "tr", pubkey: o };
              throw new Error("Unknown witness program");
            }
            const r = Bd.decode(e);
            if (21 !== r.length) throw new Error("Invalid base58 address");
            if (r[0] === t.pubKeyHash) return { type: "pkh", hash: r.slice(1) };
            if (r[0] === t.scriptHash) return { type: "sh", hash: r.slice(1) };
            throw new Error(`Invalid address prefix=${r[0]}`);
          },
        };
      }
      const {
        Axios: Dd,
        AxiosError: Ld,
        CanceledError: jd,
        isCancel: Fd,
        CancelToken: Hd,
        VERSION: Kd,
        all: Vd,
        Cancel: qd,
        isAxiosError: zd,
        spread: $d,
        toFormData: Gd,
        AxiosHeaders: Wd,
        HttpStatusCode: Yd,
        formToJSON: Xd,
        getAdapter: Zd,
        mergeConfig: Jd,
      } = or;
      var Qd;
      i(76464);
      !(function (t) {
        (t.SEND_BTC = "sendBtc"),
          (t.SEND_UTXO = "sendUtxo"),
          (t.SPLIT_UTXO = "splitUtxo"),
          (t.SCRIPT = "script");
      })(Qd || (Qd = {}));
      new Uint8Array();
      i(48287).Buffer;
      i(48287).Buffer;
      i(48287).Buffer;
      var tp;
      !(function (t) {
        (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
          (t.FAILED_TO_FINALIZE = "FAILED_TO_FINALIZE"),
          (t.UTXOS_MISSING = "UTXOS_MISSING"),
          (t.INVALID_TICK = "INVALID_TICK"),
          (t.INVALID_AMOUNT = "INVALID_AMOUNT"),
          (t.INVALID_FEE_RATE = "INVALID_FEE_RATE"),
          (t.SERVER_ERROR = "SERVER_ERROR"),
          (t.USER_REJECTED = "USER_REJECTED"),
          (t.DEVICE_LOCKED = "DEVICE_LOCKED"),
          (t.GENERAL_HARDWARE_WALLET_ERROR = "GENERAL_HARDWARE_WALLET_ERROR");
      })(tp || (tp = {}));
      var ep;
      !(function (t) {
        (t.CreatingInscriptionOrder = "CreatingInscriptionOrder"),
          (t.CreatingCommitTransaction = "CreatingCommitTransaction"),
          (t.ExecutingInscriptionOrder = "ExecutingInscriptionOrder"),
          (t.CreatingTransferTransaction = "CreatingTransferTransaction"),
          (t.Finalizing = "Finalizing");
      })(ep || (ep = {}));
      var rp;
      !(function (t) {
        (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
          (t.INVALID_FEE_RATE = "INVALID_FEE_RATE"),
          (t.INVALID_SERVICE_FEE_CONFIG = "INVALID_SERVICE_FEE_CONFIG"),
          (t.INVALID_CONTENT = "INVALID_CONTENT"),
          (t.CONTENT_TOO_BIG = "CONTENT_TOO_BIG"),
          (t.INSCRIPTION_VALUE_TOO_LOW = "INSCRIPTION_VALUE_TOO_LOW"),
          (t.NO_NON_ORDINAL_UTXOS = "NO_NON_ORDINAL_UTXOS"),
          (t.FAILED_TO_FINALIZE = "FAILED_TO_FINALIZE"),
          (t.SERVER_ERROR = "SERVER_ERROR"),
          (t.USER_REJECTED = "USER_REJECTED"),
          (t.DEVICE_LOCKED = "DEVICE_LOCKED"),
          (t.GENERAL_HARDWARE_WALLET_ERROR = "GENERAL_HARDWARE_WALLET_ERROR");
      })(rp || (rp = {}));
      i(48287).Buffer;
      i(48287).Buffer;
      i(48287).Buffer;
      cu(qu);
      i(48287).Buffer;
      var np = i(48287).Buffer;
      np.from(
        "0000000000000000000000000000000000000000000000000000000000000000",
        "hex",
      );
      i(18322), i(84711), i(22010), i(48287).Buffer;
      var ip = i(48287).Buffer;
      ip.from(
        "0000000000000000000000000000000000000000000000000000000000000000",
        "hex",
      );
      var op;
      !(function (t) {
        t.NO_PUBLIC_KEY = "No public key returned from Ledger device";
      })(op || (op = {}));
      i(7581), i(91565);
      var sp, ap, up, cp;
      function fp(t) {
        return {
          lang: t?.lang ?? sp?.lang,
          message: t?.message,
          abortEarly: t?.abortEarly ?? sp?.abortEarly,
          abortPipeEarly: t?.abortPipeEarly ?? sp?.abortPipeEarly,
        };
      }
      function hp(t) {
        const e = typeof t;
        return "string" === e
          ? `"${t}"`
          : "number" === e || "bigint" === e || "boolean" === e
            ? `${t}`
            : "object" === e || "function" === e
              ? ((t && Object.getPrototypeOf(t)?.constructor?.name) ?? "null")
              : e;
      }
      function lp(t, e, r, n, i) {
        const o = i && "input" in i ? i.input : r.value,
          s = i?.expected ?? t.expects ?? null,
          a = i?.received ?? hp(o),
          u = {
            kind: t.kind,
            type: t.type,
            input: o,
            expected: s,
            received: a,
            message: `Invalid ${e}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
            requirement: t.requirement,
            path: i?.path,
            issues: i?.issues,
            lang: n.lang,
            abortEarly: n.abortEarly,
            abortPipeEarly: n.abortPipeEarly,
          },
          c = "schema" === t.kind,
          f =
            i?.message ??
            t.message ??
            ((h = t.reference), (l = u.lang), cp?.get(h)?.get(l)) ??
            (c
              ? (function (t) {
                  return up?.get(t);
                })(u.lang)
              : null) ??
            n.message ??
            (function (t) {
              return ap?.get(t);
            })(u.lang);
        var h, l;
        f && (u.message = "function" == typeof f ? f(u) : f),
          c && (r.typed = !1),
          r.issues ? r.issues.push(u) : (r.issues = [u]);
      }
      function dp(t, e) {
        return (
          Object.hasOwn(t, e) &&
          "__proto__" !== e &&
          "prototype" !== e &&
          "constructor" !== e
        );
      }
      function pp(t, e) {
        const r = [...new Set(t)];
        return r.length > 1 ? `(${r.join(` ${e} `)})` : (r[0] ?? "never");
      }
      var yp = class extends Error {
        issues;
        constructor(t) {
          super(t[0].message), (this.name = "ValiError"), (this.issues = t);
        }
      };
      function gp(t) {
        return {
          kind: "transformation",
          type: "brand",
          reference: gp,
          async: !1,
          name: t,
          _run: (t) => t,
        };
      }
      function mp(t, e, r) {
        return "function" == typeof t.default ? t.default(e, r) : t.default;
      }
      function bp(t, e) {
        return {
          kind: "schema",
          type: "array",
          reference: bp,
          expects: "Array",
          async: !1,
          item: t,
          message: e,
          _run(t, e) {
            const r = t.value;
            if (Array.isArray(r)) {
              (t.typed = !0), (t.value = []);
              for (let n = 0; n < r.length; n++) {
                const i = r[n],
                  o = this.item._run({ typed: !1, value: i }, e);
                if (o.issues) {
                  const s = {
                    type: "array",
                    origin: "value",
                    input: r,
                    key: n,
                    value: i,
                  };
                  for (const e of o.issues)
                    e.path ? e.path.unshift(s) : (e.path = [s]),
                      t.issues?.push(e);
                  if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                    t.typed = !1;
                    break;
                  }
                }
                o.typed || (t.typed = !1), t.value.push(o.value);
              }
            } else lp(this, "type", t, e);
            return t;
          },
        };
      }
      function wp(t) {
        return {
          kind: "schema",
          type: "boolean",
          reference: wp,
          expects: "boolean",
          async: !1,
          message: t,
          _run(t, e) {
            return (
              "boolean" == typeof t.value
                ? (t.typed = !0)
                : lp(this, "type", t, e),
              t
            );
          },
        };
      }
      function vp(t, e) {
        return {
          kind: "schema",
          type: "literal",
          reference: vp,
          expects: hp(t),
          async: !1,
          literal: t,
          message: e,
          _run(t, e) {
            return (
              t.value === this.literal
                ? (t.typed = !0)
                : lp(this, "type", t, e),
              t
            );
          },
        };
      }
      function _p(t, e) {
        return {
          kind: "schema",
          type: "object",
          reference: _p,
          expects: "Object",
          async: !1,
          entries: t,
          message: e,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              (t.typed = !0), (t.value = {});
              for (const n in this.entries) {
                const i = r[n],
                  o = this.entries[n]._run({ typed: !1, value: i }, e);
                if (o.issues) {
                  const s = {
                    type: "object",
                    origin: "value",
                    input: r,
                    key: n,
                    value: i,
                  };
                  for (const e of o.issues)
                    e.path ? e.path.unshift(s) : (e.path = [s]),
                      t.issues?.push(e);
                  if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                    t.typed = !1;
                    break;
                  }
                }
                o.typed || (t.typed = !1),
                  (void 0 !== o.value || n in r) && (t.value[n] = o.value);
              }
            } else lp(this, "type", t, e);
            return t;
          },
        };
      }
      function Ep(t, ...e) {
        const r = {
          kind: "schema",
          type: "optional",
          reference: Ep,
          expects: `(${t.expects} | undefined)`,
          async: !1,
          wrapped: t,
          _run(t, e) {
            return void 0 === t.value &&
              ("default" in this && (t.value = mp(this, t, e)),
              void 0 === t.value)
              ? ((t.typed = !0), t)
              : this.wrapped._run(t, e);
          },
        };
        return 0 in e && (r.default = e[0]), r;
      }
      function Sp(t, e) {
        return {
          kind: "schema",
          type: "picklist",
          reference: Sp,
          expects: pp(t.map(hp), "|"),
          async: !1,
          options: t,
          message: e,
          _run(t, e) {
            return (
              this.options.includes(t.value)
                ? (t.typed = !0)
                : lp(this, "type", t, e),
              t
            );
          },
        };
      }
      function Ip(t, e, r) {
        return {
          kind: "schema",
          type: "record",
          reference: Ip,
          expects: "Object",
          async: !1,
          key: t,
          value: e,
          message: r,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              (t.typed = !0), (t.value = {});
              for (const n in r)
                if (dp(r, n)) {
                  const i = r[n],
                    o = this.key._run({ typed: !1, value: n }, e);
                  if (o.issues) {
                    const s = {
                      type: "object",
                      origin: "key",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of o.issues) (e.path = [s]), t.issues?.push(e);
                    if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  const s = this.value._run({ typed: !1, value: i }, e);
                  if (s.issues) {
                    const o = {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: n,
                      value: i,
                    };
                    for (const e of s.issues)
                      e.path ? e.path.unshift(o) : (e.path = [o]),
                        t.issues?.push(e);
                    if ((t.issues || (t.issues = s.issues), e.abortEarly)) {
                      t.typed = !1;
                      break;
                    }
                  }
                  (o.typed && s.typed) || (t.typed = !1),
                    o.typed && (t.value[o.value] = s.value);
                }
            } else lp(this, "type", t, e);
            return t;
          },
        };
      }
      function Mp(t) {
        return {
          kind: "schema",
          type: "string",
          reference: Mp,
          expects: "string",
          async: !1,
          message: t,
          _run(t, e) {
            return (
              "string" == typeof t.value
                ? (t.typed = !0)
                : lp(this, "type", t, e),
              t
            );
          },
        };
      }
      function Ap(t, e, r) {
        return {
          kind: "schema",
          type: "variant",
          reference: Ap,
          expects: "Object",
          async: !1,
          key: t,
          options: e,
          message: r,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              let n,
                i = 0,
                o = this.key,
                s = [];
              const a = (t, u) => {
                for (const c of t.options) {
                  if ("variant" === c.type) a(c, new Set(u).add(c.key));
                  else {
                    let t = !0,
                      a = 0;
                    for (const n of u) {
                      if (
                        c.entries[n]._run({ typed: !1, value: r[n] }, e).issues
                      ) {
                        (t = !1),
                          o !== n &&
                            (i < a || (i === a && n in r && !(o in r))) &&
                            ((i = a), (o = n), (s = [])),
                          o === n && s.push(c.entries[n].expects);
                        break;
                      }
                      a++;
                    }
                    if (t) {
                      const t = c._run({ typed: !1, value: r }, e);
                      (!n || (!n.typed && t.typed)) && (n = t);
                    }
                  }
                  if (n && !n.issues) break;
                }
              };
              if ((a(this, new Set([this.key])), n)) return n;
              lp(this, "type", t, e, {
                input: r[o],
                expected: pp(s, "|"),
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input: r,
                    key: o,
                    value: r[o],
                  },
                ],
              });
            } else lp(this, "type", t, e);
            return t;
          },
        };
      }
      function Tp(t, e) {
        return Sp(Object.keys(t.entries), e);
      }
      function kp(t, e, r) {
        const n = t._run({ typed: !1, value: e }, fp(r));
        if (n.issues) throw new yp(n.issues);
        return n.value;
      }
      function Op(...t) {
        return {
          ...t[0],
          pipe: t,
          _run(e, r) {
            for (const n of t)
              if ("metadata" !== n.kind) {
                if (
                  e.issues &&
                  ("schema" === n.kind || "transformation" === n.kind)
                ) {
                  e.typed = !1;
                  break;
                }
                (e.issues && (r.abortEarly || r.abortPipeEarly)) ||
                  (e = n._run(e, r));
              }
            return e;
          },
        };
      }
      function xp(t, e, r) {
        const n = t._run({ typed: !1, value: e }, fp(r));
        return {
          typed: n.typed,
          success: !n.issues,
          output: n.value,
          issues: n.issues,
        };
      }
      const Pp = _p({
          name: Mp(),
          description: Ap("type", [
            _p({ type: vp("single"), value: Mp() }),
            _p({ type: vp("multiple"), values: bp(Mp()) }),
          ]),
        }),
        Bp = "AccountId",
        Cp = Op(Mp(), gp(Bp));
      const Rp = /^[\da-f]{64}$/,
        Np = Op(
          Mp(),
          (function t(e, r) {
            return {
              kind: "validation",
              type: "check",
              reference: t,
              async: !1,
              expects: null,
              requirement: e,
              message: r,
              _run(t, e) {
                return (
                  t.typed &&
                    !this.requirement(t.value) &&
                    lp(this, "input", t, e),
                  t
                );
              },
            };
          })((t) => Rp.test(t)),
          gp("AccountResourceId"),
        );
      function Up(t) {
        return kp(Np, ku(qu(`account-resource-${t}`)));
      }
      const Dp = _p({ type: vp("account"), id: Np, accountId: Cp, name: Mp() });
      const Lp = _p({ read: Ep(wp()) }),
        jp = Ip(Tp(Lp), Pp),
        Fp = _p({
          type: vp("account"),
          resourceId: Np,
          clientId: Mp(),
          actions: Lp,
        }),
        Hp = _p({ type: vp("wallet"), id: vp("wallet"), name: vp("Wallet") }),
        Kp = _p({ readNetwork: Ep(wp()) }),
        Vp = Ip(Tp(Kp), Pp),
        qp = vp("wallet"),
        zp = _p({
          type: vp("wallet"),
          resourceId: qp,
          clientId: Mp(),
          actions: Kp,
        }),
        $p = {
          accountResourceIdBrandName: "AccountResourceId",
          accountResourceIdSchema: Np,
          accountResourceSchema: Dp,
          accountActionsSchema: Lp,
          accountActionsDescriptionSchema: jp,
          accountPermissionSchema: Fp,
          makeAccountResourceId: Up,
          makeAccountResource: function (t) {
            return {
              type: "account",
              id: Up(t.accountId),
              accountId: t.accountId,
              name: `Account ${t.accountId}, ${t.masterPubKey.slice(0, 6)}...(${t.networkType})`,
            };
          },
        },
        Gp = { actionDescriptionSchema: Pp },
        Wp = {
          walletResourceSchema: Hp,
          walletActionsSchema: Kp,
          walletIdSchema: qp,
          walletPermissionSchema: zp,
          walletActionsDescriptionSchema: Vp,
        };
      function Yp(t) {
        return JSON.parse(JSON.stringify(t));
      }
      function Xp(t, e) {
        const r = t.permissions.filter((t) => t.clientId !== e);
        return { ...t, permissions: r };
      }
      function Zp(t, e) {
        const r = t.clientMetadata.filter((t) => t.clientId !== e);
        return { ...t, clientMetadata: r };
      }
      const Jp = Op(
          Mp(),
          (function t(e) {
            return {
              kind: "validation",
              type: "url",
              reference: t,
              async: !1,
              expects: null,
              requirement(t) {
                try {
                  return new URL(t), !0;
                } catch {
                  return !1;
                }
              },
              message: e,
              _run(t, e) {
                return (
                  t.typed &&
                    !this.requirement(t.value) &&
                    lp(this, "URL", t, e),
                  t
                );
              },
            };
          })(),
          (function t(e) {
            return {
              kind: "transformation",
              type: "transform",
              reference: t,
              async: !1,
              operation: e,
              _run(t) {
                return (t.value = this.operation(t.value)), t;
              },
            };
          })((t) => new URL(t).origin),
          gp("ClientId"),
        ),
        Qp = _p({ id: Jp, origin: Mp(), description: Ep(Mp()) }),
        ty = bp(Qp),
        ey = _p({
          clientId: Qp.entries.id,
          lastUsed: Ep(
            (function t(e) {
              return {
                kind: "schema",
                type: "number",
                reference: t,
                expects: "number",
                async: !1,
                message: e,
                _run(t, e) {
                  return (
                    "number" != typeof t.value || isNaN(t.value)
                      ? lp(this, "type", t, e)
                      : (t.typed = !0),
                    t
                  );
                },
              };
            })(),
          ),
        }),
        ry = bp(ey),
        ny = Ap("type", [Dp, Hp]),
        iy = bp(ny),
        oy = Ap("type", [Fp, zp]),
        sy = bp(oy),
        ay = _p({
          version: vp(4),
          clients: ty,
          clientMetadata: ry,
          resources: iy,
          permissions: sy,
        });
      const uy = {
        "https://app.alexlab.co": "ALEX",
        "https://app.arkadiko.finance": "Arkadiko Protocol",
        "https://app.bitflow.finance": "Bitflow",
        "https://app.console.xyz": "Console",
        "https://app.liquidium.fi": "Liquidium",
        "https://app.lisalab.io": "LISA",
        "https://app.stackingdao.com": "Stacking DAO",
        "https://app.velar.co": "Velar",
        "https://app.xlink.network": "XLink",
        "https://brc20.xverse.app": "Xverse BRC20 Mint",
        "https://btc.fluidtokens.com": "FluidTokens on Bitcoin",
        "https://chisel.xyz": "Chisel",
        "https://gamma.io": "Gamma",
        "https://geniidata.com": "GeniiData",
        "https://idclub.io": "IDclub",
        "https://inscribegpt.xverse.app": "Xverse Inscribe GPT",
        "https://luminex.io": "Luminex",
        "https://magiceden.io": "Magic Eden",
        "https://magisat.io": "Magisat",
        "https://mystic.com": "Mystic",
        "https://ordbit.io": "Ordbit",
        "https://ordinals.market": "Ordinals.Market",
        "https://ordinalsbot.com": "OrdinalsBot",
        "https://ordiscan.com": "Ordiscan",
        "https://ordzaar.com": "Ordzaar",
        "https://pool.xverse.app": "Xverse Pool",
        "https://pro.whales.market": "Whales Market",
        "https://runealpha.xyz": "Rune Alpha",
        "https://runesterminal.io": "Runes Terminal",
        "https://sating.io": "Sating.io",
        "https://satscribe.xyz": "Satscribe",
        "https://unisat.io": "Unisat",
        "https://wallet.xverse.app": "Xverse App",
        "https://www.bsquared.network": "B2 Network",
        "https://www.dots.so": "BNS | Bitcoin Name System",
        "https://www.dotswap.app": "DotSwap",
        "https://www.ninjalerts.com": "Ninjalerts",
        "https://www.okx.com": "OKX",
        "https://www.ord.io": "Ord.io",
        "https://www.ordz.games": "OrdzGames",
        "https://www.runessance.io": "Runessance",
        "https://www.saturnbtc.io": "Saturn",
      };
      const cy = {
          addClient: function (t, e) {
            if (t.clients.some((t) => t.id === e.id)) return t;
            const r = [...t.clients, Yp(e)];
            return { ...t, clients: r };
          },
          addResource: function (t, e) {
            if (t.resources.some((t) => t.id === e.id)) return t;
            const r = [...t.resources, Yp(e)];
            return { ...t, resources: r };
          },
          getClient: function (t, e) {
            return t.clients.find((t) => t.id === e);
          },
          getClients: function (t) {
            return t.clients;
          },
          getClientMetadata: function (t, e) {
            return t.clientMetadata.find((t) => t.clientId === e);
          },
          getClientPermission: function (t, e, r, n) {
            return t.permissions.find(
              (t) => t.type === e && t.clientId === r && t.resourceId === n,
            );
          },
          getClientPermissions: function (t, e) {
            return t.permissions.filter((t) => t.clientId === e);
          },
          getResource: function (t, e) {
            return t.resources.find((t) => t.id === e);
          },
          hasPermission: function (
            t,
            { clientId: e, type: r, resourceId: n, actions: i },
          ) {
            const o = t.permissions.find(
              (t) => t.clientId === e && t.type === r && t.resourceId === n,
            );
            if (!o) return !1;
            for (const [t, e] of Object.entries(i))
              if (o.actions[t] !== e) return !1;
            return !0;
          },
          makeClientId: function (t) {
            const e = xp(Jp, t.origin);
            return e.success
              ? ka(e.output)
              : Oa({
                  name: "ValidationError",
                  message: "Failed to create client ID.",
                  data: e.issues,
                });
          },
          makePermissionsStore: function () {
            return {
              version: 4,
              clients: [],
              clientMetadata: [],
              resources: [],
              permissions: [],
            };
          },
          removeAllClientPermissions: Xp,
          removeAllClients: function (t) {
            return { ...t, clients: [], clientMetadata: [], permissions: [] };
          },
          removeClient: function (t, e) {
            let r = Xp(t, e);
            return (
              (r = Zp(r, e)),
              (r.clients = t.clients.filter((t) => t.id !== e)),
              r
            );
          },
          removeClientMetadata: Zp,
          removePermission: function (t, e, r, n) {
            const i = t.permissions.filter(
              (t) => t.type !== e || t.clientId !== r || t.resourceId !== n,
            );
            return { ...t, permissions: i };
          },
          removeResource: function (t, e) {
            const r = t.permissions.filter((t) => t.resourceId !== e),
              n = t.resources.filter((t) => t.id !== e);
            return { ...t, permissions: r, resources: n };
          },
          setClientMetadata: function (t, e) {
            const r = t.clientMetadata.filter((t) => t.clientId !== e.clientId);
            return r.push(Yp(e)), { ...t, clientMetadata: r };
          },
          setPermission: function (t, e) {
            const r = t.clients.some((t) => t.id === e.clientId),
              n = t.resources.some((t) => t.id === e.resourceId);
            if (!r || !n)
              throw new Error(
                "Attempted to set permission with non-existent client or resource.",
              );
            const i = t.permissions.find(
              (t) =>
                t.type === e.type &&
                t.clientId === e.clientId &&
                t.resourceId === e.resourceId,
            );
            if (i) {
              const r = t.permissions.filter((t) => t !== i);
              return r.push(Yp(e)), { ...t, permissions: r };
            }
            const o = [...t.permissions, Yp(e)];
            return { ...t, permissions: o };
          },
        },
        fy = {
          resources: { account: $p, common: Gp, wallet: Wp },
          utils: {
            store: cy,
            account: {
              makeAccountId: function (t) {
                return kp(
                  Cp,
                  ku(
                    qu(
                      `account-${t.masterPubKey}-${t.accountId}-${t.networkType}`,
                    ),
                  ),
                );
              },
              accountIdBrandName: Bp,
              accountIdSchema: Cp,
            },
            originName: {
              nameFromOrigin: function (t) {
                return uy[t] ?? t;
              },
            },
          },
          store: {
            clientId: Jp,
            client: Qp,
            clientMetadata: ey,
            clientMetadataTable: ry,
            clientsTable: ty,
            resource: ny,
            resourcesTable: iy,
            permission: oy,
            permissionsTable: sy,
            permissionsStore: ay,
          },
        };
      class hy {
        constructor() {
          (this.keyToValue = new Map()), (this.valueToKey = new Map());
        }
        set(t, e) {
          this.keyToValue.set(t, e), this.valueToKey.set(e, t);
        }
        getByKey(t) {
          return this.keyToValue.get(t);
        }
        getByValue(t) {
          return this.valueToKey.get(t);
        }
        clear() {
          this.keyToValue.clear(), this.valueToKey.clear();
        }
      }
      class ly {
        constructor(t) {
          (this.generateIdentifier = t), (this.kv = new hy());
        }
        register(t, e) {
          this.kv.getByValue(t) ||
            (e || (e = this.generateIdentifier(t)), this.kv.set(e, t));
        }
        clear() {
          this.kv.clear();
        }
        getIdentifier(t) {
          return this.kv.getByValue(t);
        }
        getValue(t) {
          return this.kv.getByKey(t);
        }
      }
      class dy extends ly {
        constructor() {
          super((t) => t.name), (this.classToAllowedProps = new Map());
        }
        register(t, e) {
          "object" == typeof e
            ? (e.allowProps && this.classToAllowedProps.set(t, e.allowProps),
              super.register(t, e.identifier))
            : super.register(t, e);
        }
        getAllowedProps(t) {
          return this.classToAllowedProps.get(t);
        }
      }
      function py(t, e) {
        const r = (function (t) {
          if ("values" in Object) return Object.values(t);
          const e = [];
          for (const r in t) t.hasOwnProperty(r) && e.push(t[r]);
          return e;
        })(t);
        if ("find" in r) return r.find(e);
        const n = r;
        for (let t = 0; t < n.length; t++) {
          const r = n[t];
          if (e(r)) return r;
        }
      }
      function yy(t, e) {
        Object.entries(t).forEach(([t, r]) => e(r, t));
      }
      function gy(t, e) {
        return -1 !== t.indexOf(e);
      }
      function my(t, e) {
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          if (e(n)) return n;
        }
      }
      class by {
        constructor() {
          this.transfomers = {};
        }
        register(t) {
          this.transfomers[t.name] = t;
        }
        findApplicable(t) {
          return py(this.transfomers, (e) => e.isApplicable(t));
        }
        findByName(t) {
          return this.transfomers[t];
        }
      }
      const wy = (t) => typeof t > "u",
        vy = (t) =>
          "object" == typeof t &&
          null !== t &&
          t !== Object.prototype &&
          (null === Object.getPrototypeOf(t) ||
            Object.getPrototypeOf(t) === Object.prototype),
        _y = (t) => vy(t) && 0 === Object.keys(t).length,
        Ey = (t) => Array.isArray(t),
        Sy = (t) => t instanceof Map,
        Iy = (t) => t instanceof Set,
        My = (t) =>
          "Symbol" ===
          ((t) => Object.prototype.toString.call(t).slice(8, -1))(t),
        Ay = (t) => "number" == typeof t && isNaN(t),
        Ty = (t) =>
          ((t) => "boolean" == typeof t)(t) ||
          ((t) => null === t)(t) ||
          wy(t) ||
          ((t) => "number" == typeof t && !isNaN(t))(t) ||
          ((t) => "string" == typeof t)(t) ||
          My(t),
        ky = (t) => t.replace(/\./g, "\\."),
        Oy = (t) => t.map(String).map(ky).join("."),
        xy = (t) => {
          const e = [];
          let r = "";
          for (let n = 0; n < t.length; n++) {
            let i = t.charAt(n);
            "\\" !== i || "." !== t.charAt(n + 1)
              ? "." !== i
                ? (r += i)
                : (e.push(r), (r = ""))
              : ((r += "."), n++);
          }
          const n = r;
          return e.push(n), e;
        };
      function Py(t, e, r, n) {
        return { isApplicable: t, annotation: e, transform: r, untransform: n };
      }
      const By = [
        Py(
          wy,
          "undefined",
          () => null,
          () => {},
        ),
        Py(
          (t) => "bigint" == typeof t,
          "bigint",
          (t) => t.toString(),
          (t) =>
            typeof BigInt < "u"
              ? BigInt(t)
              : (console.error("Please add a BigInt polyfill."), t),
        ),
        Py(
          (t) => t instanceof Date && !isNaN(t.valueOf()),
          "Date",
          (t) => t.toISOString(),
          (t) => new Date(t),
        ),
        Py(
          (t) => t instanceof Error,
          "Error",
          (t, e) => {
            const r = { name: t.name, message: t.message };
            return (
              e.allowedErrorProps.forEach((e) => {
                r[e] = t[e];
              }),
              r
            );
          },
          (t, e) => {
            const r = new Error(t.message);
            return (
              (r.name = t.name),
              (r.stack = t.stack),
              e.allowedErrorProps.forEach((e) => {
                r[e] = t[e];
              }),
              r
            );
          },
        ),
        Py(
          (t) => t instanceof RegExp,
          "regexp",
          (t) => "" + t,
          (t) => {
            const e = t.slice(1, t.lastIndexOf("/")),
              r = t.slice(t.lastIndexOf("/") + 1);
            return new RegExp(e, r);
          },
        ),
        Py(
          Iy,
          "set",
          (t) => [...t.values()],
          (t) => new Set(t),
        ),
        Py(
          Sy,
          "map",
          (t) => [...t.entries()],
          (t) => new Map(t),
        ),
        Py(
          (t) => Ay(t) || ((t) => t === 1 / 0 || t === -1 / 0)(t),
          "number",
          (t) => (Ay(t) ? "NaN" : t > 0 ? "Infinity" : "-Infinity"),
          Number,
        ),
        Py(
          (t) => 0 === t && 1 / t == -1 / 0,
          "number",
          () => "-0",
          Number,
        ),
        Py(
          (t) => t instanceof URL,
          "URL",
          (t) => t.toString(),
          (t) => new URL(t),
        ),
      ];
      function Cy(t, e, r, n) {
        return { isApplicable: t, annotation: e, transform: r, untransform: n };
      }
      const Ry = Cy(
          (t, e) => !!My(t) && !!e.symbolRegistry.getIdentifier(t),
          (t, e) => ["symbol", e.symbolRegistry.getIdentifier(t)],
          (t) => t.description,
          (t, e, r) => {
            const n = r.symbolRegistry.getValue(e[1]);
            if (!n) throw new Error("Trying to deserialize unknown symbol");
            return n;
          },
        ),
        Ny = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
          Uint8ClampedArray,
        ].reduce((t, e) => ((t[e.name] = e), t), {}),
        Uy = Cy(
          (t) => ArrayBuffer.isView(t) && !(t instanceof DataView),
          (t) => ["typed-array", t.constructor.name],
          (t) => [...t],
          (t, e) => {
            const r = Ny[e[1]];
            if (!r)
              throw new Error("Trying to deserialize unknown typed array");
            return new r(t);
          },
        );
      function Dy(t, e) {
        return (
          !(null == t || !t.constructor) &&
          !!e.classRegistry.getIdentifier(t.constructor)
        );
      }
      const Ly = Cy(
          Dy,
          (t, e) => ["class", e.classRegistry.getIdentifier(t.constructor)],
          (t, e) => {
            const r = e.classRegistry.getAllowedProps(t.constructor);
            if (!r) return { ...t };
            const n = {};
            return (
              r.forEach((e) => {
                n[e] = t[e];
              }),
              n
            );
          },
          (t, e, r) => {
            const n = r.classRegistry.getValue(e[1]);
            if (!n)
              throw new Error(
                "Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564",
              );
            return Object.assign(Object.create(n.prototype), t);
          },
        ),
        jy = Cy(
          (t, e) => !!e.customTransformerRegistry.findApplicable(t),
          (t, e) => [
            "custom",
            e.customTransformerRegistry.findApplicable(t).name,
          ],
          (t, e) => e.customTransformerRegistry.findApplicable(t).serialize(t),
          (t, e, r) => {
            const n = r.customTransformerRegistry.findByName(e[1]);
            if (!n)
              throw new Error("Trying to deserialize unknown custom value");
            return n.deserialize(t);
          },
        ),
        Fy = [Ly, Ry, jy, Uy],
        Hy = (t, e) => {
          const r = my(Fy, (r) => r.isApplicable(t, e));
          if (r) return { value: r.transform(t, e), type: r.annotation(t, e) };
          const n = my(By, (r) => r.isApplicable(t, e));
          return n ? { value: n.transform(t, e), type: n.annotation } : void 0;
        },
        Ky = {};
      By.forEach((t) => {
        Ky[t.annotation] = t;
      });
      const Vy = (t, e) => {
        const r = t.keys();
        for (; e > 0; ) r.next(), e--;
        return r.next().value;
      };
      function qy(t) {
        if (gy(t, "__proto__"))
          throw new Error("__proto__ is not allowed as a property");
        if (gy(t, "prototype"))
          throw new Error("prototype is not allowed as a property");
        if (gy(t, "constructor"))
          throw new Error("constructor is not allowed as a property");
      }
      const zy = (t, e, r) => {
        if ((qy(e), 0 === e.length)) return r(t);
        let n = t;
        for (let t = 0; t < e.length - 1; t++) {
          const r = e[t];
          if (Ey(n)) {
            n = n[+r];
          } else if (vy(n)) n = n[r];
          else if (Iy(n)) {
            n = Vy(n, +r);
          } else if (Sy(n)) {
            if (t === e.length - 2) break;
            const i = +r,
              o = 0 == +e[++t] ? "key" : "value",
              s = Vy(n, i);
            switch (o) {
              case "key":
                n = s;
                break;
              case "value":
                n = n.get(s);
            }
          }
        }
        const i = e[e.length - 1];
        if ((Ey(n) ? (n[+i] = r(n[+i])) : vy(n) && (n[i] = r(n[i])), Iy(n))) {
          const t = Vy(n, +i),
            e = r(t);
          t !== e && (n.delete(t), n.add(e));
        }
        if (Sy(n)) {
          const t = +e[e.length - 2],
            o = Vy(n, t);
          switch (0 == +i ? "key" : "value") {
            case "key": {
              const t = r(o);
              n.set(t, n.get(o)), t !== o && n.delete(o);
              break;
            }
            case "value":
              n.set(o, r(n.get(o)));
          }
        }
        return t;
      };
      function $y(t, e, r = []) {
        if (!t) return;
        if (!Ey(t)) return void yy(t, (t, n) => $y(t, e, [...r, ...xy(n)]));
        const [n, i] = t;
        i &&
          yy(i, (t, n) => {
            $y(t, e, [...r, ...xy(n)]);
          }),
          e(n, r);
      }
      function Gy(t, e, r) {
        return (
          $y(e, (e, n) => {
            t = zy(t, n, (t) =>
              ((t, e, r) => {
                if (!Ey(e)) {
                  const n = Ky[e];
                  if (!n) throw new Error("Unknown transformation: " + e);
                  return n.untransform(t, r);
                }
                switch (e[0]) {
                  case "symbol":
                    return Ry.untransform(t, e, r);
                  case "class":
                    return Ly.untransform(t, e, r);
                  case "custom":
                    return jy.untransform(t, e, r);
                  case "typed-array":
                    return Uy.untransform(t, e, r);
                  default:
                    throw new Error("Unknown transformation: " + e);
                }
              })(t, e, r),
            );
          }),
          t
        );
      }
      function Wy(t, e) {
        function r(e, r) {
          const n = ((t, e) => {
            qy(e);
            for (let r = 0; r < e.length; r++) {
              const n = e[r];
              if (Iy(t)) t = Vy(t, +n);
              else if (Sy(t)) {
                const i = +n,
                  o = 0 == +e[++r] ? "key" : "value",
                  s = Vy(t, i);
                switch (o) {
                  case "key":
                    t = s;
                    break;
                  case "value":
                    t = t.get(s);
                }
              } else t = t[n];
            }
            return t;
          })(t, xy(r));
          e.map(xy).forEach((e) => {
            t = zy(t, e, () => n);
          });
        }
        if (Ey(e)) {
          const [n, i] = e;
          n.forEach((e) => {
            t = zy(t, xy(e), () => t);
          }),
            i && yy(i, r);
        } else yy(e, r);
        return t;
      }
      const Yy = (t, e, r, n, i = [], o = [], s = new Map()) => {
        const a = Ty(t);
        if (!a) {
          !(function (t, e, r) {
            const n = r.get(t);
            n ? n.push(e) : r.set(t, [e]);
          })(t, i, e);
          const r = s.get(t);
          if (r) return n ? { transformedValue: null } : r;
        }
        if (!((t, e) => vy(t) || Ey(t) || Sy(t) || Iy(t) || Dy(t, e))(t, r)) {
          const e = Hy(t, r),
            n = e
              ? { transformedValue: e.value, annotations: [e.type] }
              : { transformedValue: t };
          return a || s.set(t, n), n;
        }
        if (gy(o, t)) return { transformedValue: null };
        const u = Hy(t, r),
          c = (null == u ? void 0 : u.value) ?? t,
          f = Ey(c) ? [] : {},
          h = {};
        yy(c, (a, u) => {
          if ("__proto__" === u || "constructor" === u || "prototype" === u)
            throw new Error(
              `Detected property ${u}. This is a prototype pollution risk, please remove it from your object.`,
            );
          const c = Yy(a, e, r, n, [...i, u], [...o, t], s);
          (f[u] = c.transformedValue),
            Ey(c.annotations)
              ? (h[u] = c.annotations)
              : vy(c.annotations) &&
                yy(c.annotations, (t, e) => {
                  h[ky(u) + "." + e] = t;
                });
        });
        const l = _y(h)
          ? { transformedValue: f, annotations: u ? [u.type] : void 0 }
          : { transformedValue: f, annotations: u ? [u.type, h] : h };
        return a || s.set(t, l), l;
      };
      function Xy(t) {
        return Object.prototype.toString.call(t).slice(8, -1);
      }
      function Zy(t) {
        return "Array" === Xy(t);
      }
      function Jy(t, e = {}) {
        if (Zy(t)) return t.map((t) => Jy(t, e));
        if (
          !(function (t) {
            if ("Object" !== Xy(t)) return !1;
            const e = Object.getPrototypeOf(t);
            return !!e && e.constructor === Object && e === Object.prototype;
          })(t)
        )
          return t;
        return [
          ...Object.getOwnPropertyNames(t),
          ...Object.getOwnPropertySymbols(t),
        ].reduce((r, n) => {
          if (Zy(e.props) && !e.props.includes(n)) return r;
          return (
            (function (t, e, r, n, i) {
              const o = {}.propertyIsEnumerable.call(n, e)
                ? "enumerable"
                : "nonenumerable";
              "enumerable" === o && (t[e] = r),
                i &&
                  "nonenumerable" === o &&
                  Object.defineProperty(t, e, {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  });
            })(r, n, Jy(t[n], e), t, e.nonenumerable),
            r
          );
        }, {});
      }
      class Qy {
        constructor({ dedupe: t = !1 } = {}) {
          (this.classRegistry = new dy()),
            (this.symbolRegistry = new ly((t) => t.description ?? "")),
            (this.customTransformerRegistry = new by()),
            (this.allowedErrorProps = []),
            (this.dedupe = t);
        }
        serialize(t) {
          const e = new Map(),
            r = Yy(t, e, this, this.dedupe),
            n = { json: r.transformedValue };
          r.annotations && (n.meta = { ...n.meta, values: r.annotations });
          const i = (function (t, e) {
            const r = {};
            let n;
            return (
              t.forEach((t) => {
                if (t.length <= 1) return;
                e ||
                  (t = t
                    .map((t) => t.map(String))
                    .sort((t, e) => t.length - e.length));
                const [i, ...o] = t;
                0 === i.length ? (n = o.map(Oy)) : (r[Oy(i)] = o.map(Oy));
              }),
              n ? (_y(r) ? [n] : [n, r]) : _y(r) ? void 0 : r
            );
          })(e, this.dedupe);
          return i && (n.meta = { ...n.meta, referentialEqualities: i }), n;
        }
        deserialize(t) {
          const { json: e, meta: r } = t;
          let n = Jy(e);
          return (
            null != r && r.values && (n = Gy(n, r.values, this)),
            null != r &&
              r.referentialEqualities &&
              (n = Wy(n, r.referentialEqualities)),
            n
          );
        }
        stringify(t) {
          return JSON.stringify(this.serialize(t));
        }
        parse(t) {
          return this.deserialize(JSON.parse(t));
        }
        registerClass(t, e) {
          this.classRegistry.register(t, e);
        }
        registerSymbol(t, e) {
          this.symbolRegistry.register(t, e);
        }
        registerCustom(t, e) {
          this.customTransformerRegistry.register({ name: e, ...t });
        }
        allowErrorProps(...t) {
          this.allowedErrorProps.push(...t);
        }
      }
      (Qy.defaultInstance = new Qy()),
        (Qy.serialize = Qy.defaultInstance.serialize.bind(Qy.defaultInstance)),
        (Qy.deserialize = Qy.defaultInstance.deserialize.bind(
          Qy.defaultInstance,
        )),
        (Qy.stringify = Qy.defaultInstance.stringify.bind(Qy.defaultInstance)),
        (Qy.parse = Qy.defaultInstance.parse.bind(Qy.defaultInstance)),
        (Qy.registerClass = Qy.defaultInstance.registerClass.bind(
          Qy.defaultInstance,
        )),
        (Qy.registerSymbol = Qy.defaultInstance.registerSymbol.bind(
          Qy.defaultInstance,
        )),
        (Qy.registerCustom = Qy.defaultInstance.registerCustom.bind(
          Qy.defaultInstance,
        )),
        (Qy.allowErrorProps = Qy.defaultInstance.allowErrorProps.bind(
          Qy.defaultInstance,
        ));
      const tg = Qy.stringify;
      Qy.parse;
      function eg(t) {
        return (function (t) {
          const e = Array.from(t, (t) => String.fromCodePoint(t)).join("");
          return btoa(e);
        })(new TextEncoder().encode(tg(t)));
      }
      var rg, ng, ig, og;
      function sg(t) {
        return {
          lang: t?.lang ?? rg?.lang,
          message: t?.message,
          abortEarly: t?.abortEarly ?? rg?.abortEarly,
          abortPipeEarly: t?.abortPipeEarly ?? rg?.abortPipeEarly,
        };
      }
      function ag(t) {
        let e = typeof t;
        return (
          "object" === e &&
            (e = (t && Object.getPrototypeOf(t)?.constructor?.name) ?? "null"),
          "string" === e
            ? `"${t}"`
            : "number" === e || "bigint" === e || "boolean" === e
              ? `${t}`
              : e
        );
      }
      function ug(t, e, r, n, i) {
        const o = i && "input" in i ? i.input : r.value,
          s = i?.expected ?? t.expects ?? null,
          a = i?.received ?? ag(o),
          u = {
            kind: t.kind,
            type: t.type,
            input: o,
            expected: s,
            received: a,
            message: `Invalid ${e}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
            requirement: t.requirement,
            path: i?.path,
            issues: i?.issues,
            lang: n.lang,
            abortEarly: n.abortEarly,
            abortPipeEarly: n.abortPipeEarly,
          },
          c = "schema" === t.kind,
          f =
            i?.message ??
            t.message ??
            ((h = t.reference), (l = u.lang), og?.get(h)?.get(l)) ??
            (c
              ? (function (t) {
                  return ig?.get(t);
                })(u.lang)
              : null) ??
            n.message ??
            (function (t) {
              return ng?.get(t);
            })(u.lang);
        var h, l;
        f && (u.message = "function" == typeof f ? f(u) : f),
          c && (r.typed = !1),
          r.issues ? r.issues.push(u) : (r.issues = [u]);
      }
      Error;
      function cg(t, e, r) {
        return "function" == typeof t.default ? t.default(e, r) : t.default;
      }
      function fg(t, e) {
        return {
          kind: "schema",
          type: "literal",
          reference: fg,
          expects: ag(t),
          async: !1,
          literal: t,
          message: e,
          _run(t, e) {
            return (
              t.value === this.literal
                ? (t.typed = !0)
                : ug(this, "type", t, e),
              t
            );
          },
        };
      }
      function hg(t, e) {
        return {
          kind: "schema",
          type: "object",
          reference: hg,
          expects: "Object",
          async: !1,
          entries: t,
          message: e,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              (t.typed = !0), (t.value = {});
              for (const n in this.entries) {
                const i = r[n],
                  o = this.entries[n]._run({ typed: !1, value: i }, e);
                if (o.issues) {
                  const s = {
                    type: "object",
                    origin: "value",
                    input: r,
                    key: n,
                    value: i,
                  };
                  for (const e of o.issues)
                    e.path ? e.path.unshift(s) : (e.path = [s]),
                      t.issues?.push(e);
                  if ((t.issues || (t.issues = o.issues), e.abortEarly)) {
                    t.typed = !1;
                    break;
                  }
                }
                o.typed || (t.typed = !1),
                  (void 0 !== o.value || n in r) && (t.value[n] = o.value);
              }
            } else ug(this, "type", t, e);
            return t;
          },
        };
      }
      function lg(t, ...e) {
        const r = {
          kind: "schema",
          type: "optional",
          reference: lg,
          expects: `${t.expects} | undefined`,
          async: !1,
          wrapped: t,
          _run(t, e) {
            return void 0 === t.value &&
              ("default" in this && (t.value = cg(this, t, e)),
              void 0 === t.value)
              ? ((t.typed = !0), t)
              : this.wrapped._run(t, e);
          },
        };
        return 0 in e && (r.default = e[0]), r;
      }
      function dg(t, e, r = new Set()) {
        for (const n of e)
          "variant" === n.type
            ? dg(t, n.options, r)
            : r.add(n.entries[t].expects);
        return r;
      }
      function pg(t, e, r) {
        const n = t._run({ typed: !1, value: e }, sg(r));
        return {
          typed: n.typed,
          success: !n.issues,
          output: n.value,
          issues: n.issues,
        };
      }
      const yg = hg({
        origin: (function t(e) {
          return {
            kind: "schema",
            type: "string",
            reference: t,
            expects: "string",
            async: !1,
            message: e,
            _run(t, e) {
              return (
                "string" == typeof t.value
                  ? (t.typed = !0)
                  : ug(this, "type", t, e),
                t
              );
            },
          };
        })(),
        tabId: (function t(e) {
          return {
            kind: "schema",
            type: "number",
            reference: t,
            expects: "number",
            async: !1,
            message: e,
            _run(t, e) {
              return (
                "number" != typeof t.value || isNaN(t.value)
                  ? ug(this, "type", t, e)
                  : (t.typed = !0),
                t
              );
            },
          };
        })(),
      });
      async function gg(t) {
        const e = new URLSearchParams();
        e.append("p", eg({ context: t.context, data: t.data }));
        const r = `/popup.html?${e.toString()}#${t.path}`,
          n = await chrome.windows.create(
            await (async function (t) {
              const { url: e, width: r = Zo, height: n = 600 } = t,
                i = await chrome.windows.getCurrent(),
                { left: o = 0, top: s = 0, width: a = 0, height: u = 0 } = i,
                c = Math.floor(a / 2 - r / 2 + o);
              return {
                url: e,
                width: r,
                height: n,
                top: Math.floor(u / 2 - n / 2 + s),
                left: c,
                focused: !0,
                type: "popup",
              };
            })({ url: r }),
          );
        if (t.onClose) {
          const { onClose: e } = t,
            r = (t) => {
              n.id === t && (e(n), chrome.windows.onRemoved.removeListener(r));
            };
          chrome.windows.onRemoved.addListener(r);
        }
        const { context: i } = t,
          o = (t) => {
            i.tabId === t &&
              (Yo({
                method: s.OriginatingTabClosed,
                payload: { tabId: i.tabId },
              }),
              chrome.windows.onRemoved.removeListener(o));
          };
        chrome.windows.onRemoved.addListener(o);
        const a = (t) => {
          n.id === t &&
            (chrome.windows.onRemoved.removeListener(o),
            chrome.windows.onRemoved.removeListener(a));
        };
        return chrome.windows.onRemoved.addListener(a), n;
      }
      function mg(t) {
        return { origin: Go(t), tabId: $o(t) };
      }
      hg({
        context: yg,
        data: lg(
          (function t() {
            return {
              kind: "schema",
              type: "any",
              reference: t,
              expects: "any",
              async: !1,
              _run: (t) => ((t.typed = !0), t),
            };
          })(),
        ),
      });
      const bg = "client-permissions";
      function wg(t) {
        chrome.storage.local.set({ [bg]: JSON.stringify(t) });
      }
      async function vg() {
        const [t, e] = await xa(chrome.storage.local.get(bg));
        if (t)
          return Oa({
            name: "ItemGetError",
            message: "Failed to get item from storage.",
            data: t,
          });
        if (!e[bg])
          return Oa({
            name: "StoreNotFoundError",
            message: "Permissions store not found.",
          });
        const [r, n] = (function (t) {
          try {
            return ka(t());
          } catch (t) {
            return Oa({
              name: "SafeCallError",
              message: "Safe call failed.",
              data: t,
            });
          }
        })(() => JSON.parse(e[bg]));
        if (r)
          return Oa({
            name: "JsonParseError",
            message: "Failed to parse JSON.",
            data: r,
          });
        const i = pg(fy.store.permissionsStore, n);
        return i.success
          ? ka(i.output)
          : Oa({
              name: "SchemaParseError",
              message: "Failed to parse permissions store.",
              data: i.issues,
            });
      }
      async function _g() {
        const [t, e] = await vg();
        if (t) {
          if ("SchemaParseError" === t.name) {
            const t = fy.utils.store.makePermissionsStore();
            return wg(t), ka(t);
          }
          if ("StoreNotFoundError" === t.name) {
            const t = fy.utils.store.makePermissionsStore();
            return wg(t), ka(t);
          }
          return Oa({
            name: "InitError",
            message: "Failed to initialize permissions store.",
            data: t,
          });
        }
        return ka(e);
      }
      const Eg = (t, e) => ({ jsonrpc: "2.0", id: t, error: e }),
        Sg = (t, e) => ({ id: t, result: e, jsonrpc: "2.0" });
      function Ig(t, e) {
        chrome.tabs.sendMessage(+t, { ...e, source: r });
      }
      function Mg({ tabId: t, messageId: e }) {
        const r = Eg(e, {
          code: Lr.USER_REJECTION,
          message: "User closed the wallet popup.",
        });
        return () => {
          chrome.tabs.sendMessage(t, r);
        };
      }
      const Ag = (t) =>
        ({
          Mainnet: Nr.Mainnet,
          Testnet: Nr.Testnet,
          Testnet4: Nr.Testnet4,
          Regtest: Nr.Regtest,
          Signet: Nr.Signet,
        })[t] ?? Nr.Mainnet;
      function Tg(t, e) {
        if (t)
          return "ledger" === t.accountType || "keystone" === t.accountType
            ? { ...t, ...Pa(t, "native"), btcAddressType: "native" }
            : { ...t, ...Pa(t, e), btcAddressType: e };
      }
      const kg = (t) => {
          const {
            selectedAccountType: e,
            selectedAccountIndex: r,
            selectedWalletId: n,
            ledgerAccountsList: i,
            keystoneAccountsList: o,
            softwareWallets: s,
            network: a,
          } = t;
          let u;
          switch (e) {
            case "software": {
              const t = s?.[a]?.find((t) => t.walletId === n);
              u = t?.accounts;
              break;
            }
            case "ledger":
              u = i;
              break;
            case "keystone":
              u = o;
              break;
            default:
              return;
          }
          if (!u) return;
          const c = u.find((t) => t.id === r);
          return c;
        },
        Og = "alertTracker:alertsToShow",
        xg = () => {
          try {
            const t = localStorage.getItem(Og),
              e = t && JSON.parse(t);
            return Array.isArray(e) ? e : [];
          } catch (t) {
            return [];
          }
        };
      class Pg {
        driver;
        constructor(t) {
          this.driver = t;
        }
        getError() {
          if (chrome.runtime.lastError)
            return new Error(chrome.runtime.lastError.message);
        }
        setItem(t, e) {
          return new Promise((r, n) => {
            this.driver.set({ [t]: e }, () => {
              const t = this.getError();
              return t ? n(t) : r();
            });
          });
        }
        getItem(t, e) {
          return new Promise((r, n) => {
            this.driver.get(t, (i) => {
              const o = this.getError();
              return o ? n(o) : r(i[t] ?? e);
            });
          });
        }
        removeItem(t) {
          return new Promise((e, r) => {
            this.driver.remove(t, () => {
              const t = this.getError();
              return t ? r(t) : e();
            });
          });
        }
      }
      const Bg = {},
        Cg = {
          get session() {
            return (
              Bg.session || (Bg.session = new Pg(chrome.storage.session)),
              Bg.session
            );
          },
          get local() {
            return (
              Bg.local || (Bg.local = new Pg(chrome.storage.local)), Bg.local
            );
          },
        };
      function Rg(t) {
        return (
          (Rg =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          Rg(t)
        );
      }
      function Ng(t) {
        var e = (function (t, e) {
          if ("object" !== Rg(t) || null === t) return t;
          var r = t[Symbol.toPrimitive];
          if (void 0 !== r) {
            var n = r.call(t, e || "default");
            if ("object" !== Rg(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === e ? String : Number)(t);
        })(t, "string");
        return "symbol" === Rg(e) ? e : String(e);
      }
      function Ug(t, e, r) {
        return (
          (e = Ng(e)) in t
            ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = r),
          t
        );
      }
      function Dg(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e &&
            (n = n.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            r.push.apply(r, n);
        }
        return r;
      }
      function Lg(t) {
        for (var e = 1; e < arguments.length; e++) {
          var r = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? Dg(Object(r), !0).forEach(function (e) {
                Ug(t, e, r[e]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r))
              : Dg(Object(r)).forEach(function (e) {
                  Object.defineProperty(
                    t,
                    e,
                    Object.getOwnPropertyDescriptor(r, e),
                  );
                });
        }
        return t;
      }
      function jg(t) {
        return (
          "Minified Redux error #" +
          t +
          "; visit https://redux.js.org/Errors?code=" +
          t +
          " for the full message or use the non-minified dev environment for full errors. "
        );
      }
      var Fg =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable",
        Hg = function () {
          return Math.random().toString(36).substring(7).split("").join(".");
        },
        Kg = {
          INIT: "@@redux/INIT" + Hg(),
          REPLACE: "@@redux/REPLACE" + Hg(),
          PROBE_UNKNOWN_ACTION: function () {
            return "@@redux/PROBE_UNKNOWN_ACTION" + Hg();
          },
        };
      function Vg(t) {
        if ("object" != typeof t || null === t) return !1;
        for (var e = t; null !== Object.getPrototypeOf(e); )
          e = Object.getPrototypeOf(e);
        return Object.getPrototypeOf(t) === e;
      }
      function qg(t, e, r) {
        var n;
        if (
          ("function" == typeof e && "function" == typeof r) ||
          ("function" == typeof r && "function" == typeof arguments[3])
        )
          throw new Error(jg(0));
        if (
          ("function" == typeof e && void 0 === r && ((r = e), (e = void 0)),
          void 0 !== r)
        ) {
          if ("function" != typeof r) throw new Error(jg(1));
          return r(qg)(t, e);
        }
        if ("function" != typeof t) throw new Error(jg(2));
        var i = t,
          o = e,
          s = [],
          a = s,
          u = !1;
        function c() {
          a === s && (a = s.slice());
        }
        function f() {
          if (u) throw new Error(jg(3));
          return o;
        }
        function h(t) {
          if ("function" != typeof t) throw new Error(jg(4));
          if (u) throw new Error(jg(5));
          var e = !0;
          return (
            c(),
            a.push(t),
            function () {
              if (e) {
                if (u) throw new Error(jg(6));
                (e = !1), c();
                var r = a.indexOf(t);
                a.splice(r, 1), (s = null);
              }
            }
          );
        }
        function l(t) {
          if (!Vg(t)) throw new Error(jg(7));
          if (void 0 === t.type) throw new Error(jg(8));
          if (u) throw new Error(jg(9));
          try {
            (u = !0), (o = i(o, t));
          } finally {
            u = !1;
          }
          for (var e = (s = a), r = 0; r < e.length; r++) {
            (0, e[r])();
          }
          return t;
        }
        return (
          l({ type: Kg.INIT }),
          ((n = {
            dispatch: l,
            subscribe: h,
            getState: f,
            replaceReducer: function (t) {
              if ("function" != typeof t) throw new Error(jg(10));
              (i = t), l({ type: Kg.REPLACE });
            },
          })[Fg] = function () {
            var t,
              e = h;
            return (
              ((t = {
                subscribe: function (t) {
                  if ("object" != typeof t || null === t)
                    throw new Error(jg(11));
                  function r() {
                    t.next && t.next(f());
                  }
                  return r(), { unsubscribe: e(r) };
                },
              })[Fg] = function () {
                return this;
              }),
              t
            );
          }),
          n
        );
      }
      function zg() {
        for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
          e[r] = arguments[r];
        return 0 === e.length
          ? function (t) {
              return t;
            }
          : 1 === e.length
            ? e[0]
            : e.reduce(function (t, e) {
                return function () {
                  return t(e.apply(void 0, arguments));
                };
              });
      }
      var $g = "persist:",
        Gg = "persist/FLUSH",
        Wg = "persist/REHYDRATE",
        Yg = "persist/PAUSE",
        Xg = "persist/PERSIST",
        Zg = "persist/PURGE",
        Jg = "persist/REGISTER";
      function Qg(t) {
        return (
          (Qg =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          Qg(t)
        );
      }
      function tm(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e &&
            (n = n.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            r.push.apply(r, n);
        }
        return r;
      }
      function em(t, e, r) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = r),
          t
        );
      }
      function rm(t, e, r, n) {
        n.debug;
        var i = (function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = null != arguments[e] ? arguments[e] : {};
            e % 2
              ? tm(r, !0).forEach(function (e) {
                  em(t, e, r[e]);
                })
              : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(r),
                  )
                : tm(r).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(r, e),
                    );
                  });
          }
          return t;
        })({}, r);
        return (
          t &&
            "object" === Qg(t) &&
            Object.keys(t).forEach(function (n) {
              "_persist" !== n && e[n] === r[n] && (i[n] = t[n]);
            }),
          i
        );
      }
      function nm(t) {
        var e,
          r = t.blacklist || null,
          n = t.whitelist || null,
          i = t.transforms || [],
          o = t.throttle || 0,
          s = ""
            .concat(void 0 !== t.keyPrefix ? t.keyPrefix : $g)
            .concat(t.key),
          a = t.storage;
        e =
          !1 === t.serialize
            ? function (t) {
                return t;
              }
            : "function" == typeof t.serialize
              ? t.serialize
              : im;
        var u = t.writeFailHandler || null,
          c = {},
          f = {},
          h = [],
          l = null,
          d = null;
        function p() {
          if (0 === h.length) return l && clearInterval(l), void (l = null);
          var t = h.shift(),
            r = i.reduce(function (e, r) {
              return r.in(e, t, c);
            }, c[t]);
          if (void 0 !== r)
            try {
              f[t] = e(r);
            } catch (t) {
              console.error(
                "redux-persist/createPersistoid: error serializing state",
                t,
              );
            }
          else delete f[t];
          0 === h.length &&
            (Object.keys(f).forEach(function (t) {
              void 0 === c[t] && delete f[t];
            }),
            (d = a.setItem(s, e(f)).catch(g)));
        }
        function y(t) {
          return (
            (!n || -1 !== n.indexOf(t) || "_persist" === t) &&
            (!r || -1 === r.indexOf(t))
          );
        }
        function g(t) {
          u && u(t);
        }
        return {
          update: function (t) {
            Object.keys(t).forEach(function (e) {
              y(e) && c[e] !== t[e] && -1 === h.indexOf(e) && h.push(e);
            }),
              Object.keys(c).forEach(function (e) {
                void 0 === t[e] &&
                  y(e) &&
                  -1 === h.indexOf(e) &&
                  void 0 !== c[e] &&
                  h.push(e);
              }),
              null === l && (l = setInterval(p, o)),
              (c = t);
          },
          flush: function () {
            for (; 0 !== h.length; ) p();
            return d || Promise.resolve();
          },
        };
      }
      function im(t) {
        return JSON.stringify(t);
      }
      function om(t) {
        var e,
          r = t.transforms || [],
          n = ""
            .concat(void 0 !== t.keyPrefix ? t.keyPrefix : $g)
            .concat(t.key),
          i = t.storage;
        t.debug;
        return (
          (e =
            !1 === t.deserialize
              ? function (t) {
                  return t;
                }
              : "function" == typeof t.deserialize
                ? t.deserialize
                : sm),
          i.getItem(n).then(function (t) {
            if (t)
              try {
                var n = {},
                  i = e(t);
                return (
                  Object.keys(i).forEach(function (t) {
                    n[t] = r.reduceRight(function (e, r) {
                      return r.out(e, t, i);
                    }, e(i[t]));
                  }),
                  n
                );
              } catch (t) {
                throw t;
              }
          })
        );
      }
      function sm(t) {
        return JSON.parse(t);
      }
      function am(t) {
        0;
      }
      function um(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e &&
            (n = n.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            r.push.apply(r, n);
        }
        return r;
      }
      function cm(t) {
        for (var e = 1; e < arguments.length; e++) {
          var r = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? um(r, !0).forEach(function (e) {
                fm(t, e, r[e]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r))
              : um(r).forEach(function (e) {
                  Object.defineProperty(
                    t,
                    e,
                    Object.getOwnPropertyDescriptor(r, e),
                  );
                });
        }
        return t;
      }
      function fm(t, e, r) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = r),
          t
        );
      }
      function hm(t, e) {
        if (null == t) return {};
        var r,
          n,
          i = (function (t, e) {
            if (null == t) return {};
            var r,
              n,
              i = {},
              o = Object.keys(t);
            for (n = 0; n < o.length; n++)
              (r = o[n]), e.indexOf(r) >= 0 || (i[r] = t[r]);
            return i;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          for (n = 0; n < o.length; n++)
            (r = o[n]),
              e.indexOf(r) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, r) &&
                  (i[r] = t[r]));
        }
        return i;
      }
      function lm(t, e) {
        var r = void 0 !== t.version ? t.version : -1,
          n = (t.debug, void 0 === t.stateReconciler ? rm : t.stateReconciler),
          i = t.getStoredState || om,
          o = void 0 !== t.timeout ? t.timeout : 5e3,
          s = null,
          a = !1,
          u = !0,
          c = function (t) {
            return t._persist.rehydrated && s && !u && s.update(t), t;
          };
        return function (f, h) {
          var l = f || {},
            d = l._persist,
            p = hm(l, ["_persist"]);
          if (h.type === Xg) {
            var y = !1,
              g = function (e, r) {
                y || (h.rehydrate(t.key, e, r), (y = !0));
              };
            if (
              (o &&
                setTimeout(function () {
                  !y &&
                    g(
                      void 0,
                      new Error(
                        'redux-persist: persist timed out for persist key "'.concat(
                          t.key,
                          '"',
                        ),
                      ),
                    );
                }, o),
              (u = !1),
              s || (s = nm(t)),
              d)
            )
              return cm({}, e(p, h), { _persist: d });
            if (
              "function" != typeof h.rehydrate ||
              "function" != typeof h.register
            )
              throw new Error(
                "redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.",
              );
            return (
              h.register(t.key),
              i(t).then(
                function (e) {
                  var n =
                    t.migrate ||
                    function (t, e) {
                      return Promise.resolve(t);
                    };
                  n(e, r).then(
                    function (t) {
                      g(t);
                    },
                    function (t) {
                      g(void 0, t);
                    },
                  );
                },
                function (t) {
                  g(void 0, t);
                },
              ),
              cm({}, e(p, h), { _persist: { version: r, rehydrated: !1 } })
            );
          }
          if (h.type === Zg)
            return (
              (a = !0),
              h.result(
                (function (t) {
                  var e = t.storage,
                    r = ""
                      .concat(void 0 !== t.keyPrefix ? t.keyPrefix : $g)
                      .concat(t.key);
                  return e.removeItem(r, am);
                })(t),
              ),
              cm({}, e(p, h), { _persist: d })
            );
          if (h.type === Gg)
            return h.result(s && s.flush()), cm({}, e(p, h), { _persist: d });
          if (h.type === Yg) u = !0;
          else if (h.type === Wg) {
            if (a)
              return cm({}, p, { _persist: cm({}, d, { rehydrated: !0 }) });
            if (h.key === t.key) {
              var m = e(p, h),
                b = h.payload,
                w = cm({}, !1 !== n && void 0 !== b ? n(b, f, m, t) : m, {
                  _persist: cm({}, d, { rehydrated: !0 }),
                });
              return c(w);
            }
          }
          if (!d) return e(f, h);
          var v = e(p, h);
          return v === p ? f : c(cm({}, v, { _persist: d }));
        };
      }
      function dm(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) {
              for (var e = 0, r = new Array(t.length); e < t.length; e++)
                r[e] = t[e];
              return r;
            }
          })(t) ||
          (function (t) {
            if (
              Symbol.iterator in Object(t) ||
              "[object Arguments]" === Object.prototype.toString.call(t)
            )
              return Array.from(t);
          })(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance",
            );
          })()
        );
      }
      function pm(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e &&
            (n = n.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            r.push.apply(r, n);
        }
        return r;
      }
      function ym(t) {
        for (var e = 1; e < arguments.length; e++) {
          var r = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? pm(r, !0).forEach(function (e) {
                gm(t, e, r[e]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r))
              : pm(r).forEach(function (e) {
                  Object.defineProperty(
                    t,
                    e,
                    Object.getOwnPropertyDescriptor(r, e),
                  );
                });
        }
        return t;
      }
      function gm(t, e, r) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = r),
          t
        );
      }
      var mm = { registry: [], bootstrapped: !1 },
        bm = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : mm,
            e = arguments.length > 1 ? arguments[1] : void 0;
          switch (e.type) {
            case Jg:
              return ym({}, t, {
                registry: [].concat(dm(t.registry), [e.key]),
              });
            case Wg:
              var r = t.registry.indexOf(e.key),
                n = dm(t.registry);
              return (
                n.splice(r, 1),
                ym({}, t, { registry: n, bootstrapped: 0 === n.length })
              );
            default:
              return t;
          }
        };
      var wm = i(93204);
      const vm = { selectedSatBundle: null, selectedSatBundleItemIndex: null },
        _m = (t = vm, e) => {
          switch (e.type) {
            case "SetSelectedSatBundle":
              return { ...t, selectedSatBundle: e.selectedSatBundle };
            case "SetSelectedSatBundleItemIndex":
              return {
                ...t,
                selectedSatBundleItemIndex: e.selectedSatBundleItemIndex,
              };
            default:
              return t;
          }
        };
      var Em;
      !(function (t) {
        (t[(t.LOW = 15)] = "LOW"),
          (t[(t.STANDARD = 30)] = "STANDARD"),
          (t[(t.LONG = 60)] = "LONG"),
          (t[(t.VERY_LONG = 180)] = "VERY_LONG");
      })(Em || (Em = {}));
      const Sm = {
          network: { ...Us },
          savedNetworks: Hs,
          softwareWallets: {
            Mainnet: [],
            Testnet: [],
            Testnet4: [],
            Signet: [],
            Regtest: [],
          },
          ledgerAccountsList: [],
          keystoneAccountsList: [],
          selectedAccountIndex: 0,
          selectedAccountType: "software",
          btcPaymentAddressType: "native",
          encryptedSeed: "",
          fiatCurrency: "USD",
          sip10ManageTokens: {},
          brc20ManageTokens: {},
          runesManageTokens: {},
          notificationBanners: {},
          feeMultipliers: null,
          hasActivatedOrdinalsKey: !0,
          hasActivatedRareSatsKey: !0,
          hasActivatedRBFKey: !0,
          rareSatsNoticeDismissed: void 0,
          showDataCollectionAlert: !0,
          walletLockPeriod: Em.STANDARD,
          isUnlocked: !1,
          hideStx: !1,
          accountBalances: {},
          spamToken: null,
          spamTokens: [],
          showSpamTokens: !1,
          hiddenCollectibleIds: {},
          starredCollectibleIds: {},
          avatarIds: {},
          balanceHidden: !1,
          showBalanceInBtc: !1,
          hasBackedUpWallet: !0,
        },
        Im = { current: void 0 },
        Mm = (t = Sm, e) => {
          switch (e.type) {
            case Wg:
              if (e.err)
                throw (
                  ((Im.current = `${e.err}`),
                  new Error("Failed to load state from storage."))
                );
              return t;
            case "ResetWallet":
              return { ...Sm };
            case "UpdateSoftwareWalletsKey": {
              const { network: r, softwareWallets: n } = e,
                i = { ...t.softwareWallets };
              return (i[r] = n), { ...t, softwareWallets: i };
            }
            case "UpdateLedgerAccountsKey":
              return { ...t, ledgerAccountsList: e.ledgerAccountsList };
            case "UpdateKeystoneAccountsKey":
              return { ...t, keystoneAccountsList: e.keystoneAccountsList };
            case "SelectAccount":
              return {
                ...t,
                selectedAccountIndex: e.selectedAccountIndex,
                selectedAccountType: e.selectedAccountType,
                selectedWalletId: e.selectedWalletId,
              };
            case "StoreEncryptedSeed":
              return { ...t, encryptedSeed: e.encryptedSeed };
            case "SetFeeMultiplierKey":
              return { ...t, feeMultipliers: e.feeMultipliers };
            case "ChangeFiatCurrency":
              return {
                ...t,
                fiatCurrency: e.fiatCurrency,
                accountBalances: {},
              };
            case "ChangeNetwork":
              return {
                ...t,
                network: e.network,
                savedNetworks: [
                  ...t.savedNetworks.filter((t) => t.type !== e.network.type),
                  e.network,
                ],
                accountBalances: {},
              };
            case "ChangeBtcPaymentAddressTypeKey":
              return { ...t, btcPaymentAddressType: e.btcPaymentType };
            case "ChangeHasActivatedOrdinalsKey":
              return {
                ...t,
                hasActivatedOrdinalsKey: e.hasActivatedOrdinalsKey,
              };
            case "ChangeHasActivatedRareSatsKey":
              return {
                ...t,
                hasActivatedRareSatsKey: e.hasActivatedRareSatsKey,
              };
            case "ChangeHasActivatedRBFKey":
              return { ...t, hasActivatedRBFKey: e.hasActivatedRBFKey };
            case "RareSatsNoticeDismissedKey":
              return {
                ...t,
                rareSatsNoticeDismissed: e.rareSatsNoticeDismissed,
              };
            case "ChangeShowDataCollectionAlertKey":
              return {
                ...t,
                showDataCollectionAlert: e.showDataCollectionAlert,
              };
            case "SetSip10ManageTokensKey":
              return {
                ...t,
                sip10ManageTokens: {
                  ...t.sip10ManageTokens,
                  [e.principal]: e.isEnabled,
                },
              };
            case "SetBrc20ManageTokensKey":
              return {
                ...t,
                brc20ManageTokens: {
                  ...t.brc20ManageTokens,
                  [e.principal]: e.isEnabled,
                },
              };
            case "SetRunesManageTokens":
              return {
                ...t,
                runesManageTokens: {
                  ...t.runesManageTokens,
                  [e.principal]: e.isEnabled,
                },
              };
            case "SetNotificationBanners":
              return {
                ...t,
                notificationBanners: {
                  ...t.notificationBanners,
                  [e.id]: e.isDismissed,
                },
              };
            case "SetWalletLockPeriod":
              return { ...t, walletLockPeriod: e.walletLockPeriod };
            case "SetWalletUnlocked":
              return { ...t, isUnlocked: e.isUnlocked };
            case "SetAccountBalanceKey":
              return {
                ...t,
                accountBalances: {
                  ...t.accountBalances,
                  [e.accountKey]: e.totalBalance,
                },
              };
            case "SetWalletHideStx":
              return { ...t, hideStx: e.hideStx };
            case "SetSpamTokenKey":
              return { ...t, spamToken: e.spamToken };
            case "SetSpamTokensKey":
              return { ...t, spamTokens: e.spamTokens };
            case "SetShowSpamTokensKey":
              return { ...t, showSpamTokens: e.showSpamTokens };
            case "AddToStarCollectiblesKey":
              return {
                ...t,
                starredCollectibleIds: {
                  ...t.starredCollectibleIds,
                  [e.address]: [
                    ...(t.starredCollectibleIds[e.address] ?? []),
                    { id: e.id, collectionId: e.collectionId ?? "" },
                  ],
                },
              };
            case "RemoveFromStarCollectiblesKey": {
              const r = (t.starredCollectibleIds[e.address] ?? []).filter(
                (t) => t.id !== e.id,
              );
              return {
                ...t,
                starredCollectibleIds: {
                  ...t.starredCollectibleIds,
                  [e.address]: r,
                },
              };
            }
            case "AddToHideCollectiblesKey": {
              const r = (t.starredCollectibleIds[e.address] ?? []).filter(
                (t) => t.id !== e.id && t.collectionId !== e.id,
              );
              return {
                ...t,
                hiddenCollectibleIds: {
                  ...t.hiddenCollectibleIds,
                  [e.address]: {
                    ...t.hiddenCollectibleIds[e.address],
                    [e.id]: e.id ?? "",
                  },
                },
                starredCollectibleIds: {
                  ...t.starredCollectibleIds,
                  [e.address]: r,
                },
              };
            }
            case "RemoveFromHideCollectiblesKey": {
              const { [e.id]: r, ...n } = t.hiddenCollectibleIds[e.address];
              return {
                ...t,
                hiddenCollectibleIds: {
                  ...t.hiddenCollectibleIds,
                  [e.address]: n,
                },
              };
            }
            case "RemoveAllFromHideCollectiblesKey":
              return {
                ...t,
                hiddenCollectibleIds: {
                  ...t.hiddenCollectibleIds,
                  [e.address]: {},
                },
              };
            case "SetHiddenCollectiblesKey":
              return {
                ...t,
                hiddenCollectibleIds: {
                  ...t.hiddenCollectibleIds,
                  ...e.collectibleIds,
                },
              };
            case "SetAccountAvatarKey":
              return {
                ...t,
                avatarIds: { ...t.avatarIds, [e.address]: e.avatar },
              };
            case "RemoveAccountAvatarKey": {
              const r = { ...t.avatarIds };
              return delete r[e.address], { ...t, avatarIds: r };
            }
            case "SetBalanceHiddenToggleKey":
              return { ...t, balanceHidden: e.toggle };
            case "SetShowBalanceInBtcToggleKey":
              return { ...t, showBalanceInBtc: e.toggle };
            case "SetWalletBackupStatusKey":
              return { ...t, hasBackedUpWallet: e.hasBackedUpWallet };
            case "SetAddingAccountKey":
              return { ...t, addingAccount: e.addingAccount };
            default:
              return t;
          }
        },
        Am = {
          version: 1,
          key: "root",
          storage: Cg.local,
          blacklist: ["walletState"],
        },
        Tm = {
          2: (t) =>
            "Mainnet" !== t.network.type
              ? t
              : {
                  ...t,
                  network: {
                    ...t.network,
                    fallbackBtcApiUrl: Sm.network.fallbackBtcApiUrl,
                  },
                },
          3: (t) => ({
            ...t,
            brc20ManageTokens:
              t.brcCoinsList?.reduce(
                (t, e) => (
                  e.principal &&
                    void 0 !== e.visible &&
                    (t[e.principal] = e.visible),
                  t
                ),
                {},
              ) ?? {},
            sip10ManageTokens:
              t.coinsList?.reduce(
                (t, e) => (
                  e.principal &&
                    void 0 !== e.visible &&
                    (t[e.principal] = e.visible),
                  t
                ),
                {},
              ) ?? {},
            runesManageTokens: {},
            coins: void 0,
            coinsList: void 0,
            brcCoinsList: void 0,
          }),
          4: (t) => ({
            ...t,
            selectedAccountIndex:
              t.selectedAccount?.deviceAccountIndex ??
              t.selectedAccount?.id ??
              0,
            selectedAccountType: t.selectedAccount?.accountType ?? "software",
          }),
          5: (t) => {
            const e = (t) => (e) => {
              const {
                btcAddress: r,
                btcPublicKey: n,
                ordinalsAddress: i,
                ordinalsPublicKey: o,
                btcAddresses: s,
                ...a
              } = e;
              if (e.btcAddresses?.taproot.address)
                return { ...e, accountType: t, btcAddresses: e.btcAddresses };
              const u = { address: r, publicKey: n };
              return "ledger" === t
                ? {
                    ...a,
                    accountType: t,
                    btcAddresses: {
                      native: u,
                      taproot: { address: i, publicKey: o },
                    },
                  }
                : {
                    ...a,
                    accountType: t,
                    btcAddresses: {
                      nested: u,
                      taproot: { address: i, publicKey: o },
                    },
                  };
            };
            return (
              void 0 === t.btcPaymentAddressType &&
                ((...t) => {
                  const e = xg();
                  let r = !1;
                  t.forEach((t) => {
                    e.includes(t) || (e.push(t), (r = !0));
                  }),
                    r && localStorage.setItem(Og, JSON.stringify(e));
                })(
                  "native_segwit_intro",
                  "co:panel:address_changed_to_native",
                  "co:receive:address_change_button",
                  "co:receive:address_changed_to_native",
                ),
              {
                ...t,
                btcPaymentAddressType: t.btcPaymentAddressType || "nested",
                accountsList: t.accountsList.map(e("software")),
                ledgerAccountsList: t.ledgerAccountsList.map(e("ledger")),
                allowNestedSegWitAddress: !0,
                hiddenCollectibleIds: t.hiddenCollectibleIds || {},
                starredCollectibleIds: t.starredCollectibleIds || {},
                avatarIds: ((e) => {
                  const r = {},
                    { accountsList: n } = t;
                  return (
                    Object.keys(e).forEach((t) => {
                      if (!e[t]) return;
                      const i = n.find((e) => e.btcAddress === t);
                      i?.ordinalsAddress
                        ? (r[i.ordinalsAddress] = e[i.btcAddress])
                        : (r[t] = e[t]);
                    }),
                    r
                  );
                })(t.avatarIds || {}),
                balanceHidden: !1,
              }
            );
          },
          6: (t) => {
            const { allowNestedSegWitAddress: e, ...r } = t;
            return r;
          },
          7: (t) => ({
            ...t,
            showBalanceInBtc: t.showBalanceInBtc ?? !1,
            hasBackedUpWallet: t.hasBackedUpWallet ?? !0,
          }),
          8: (t) => {
            const e = (t) => ({
              ...t,
              btcApiUrl:
                "https://mempool.space/api" === t.btcApiUrl
                  ? Us.btcApiUrl
                  : t.btcApiUrl,
              fallbackBtcApiUrl:
                t.fallbackBtcApiUrl &&
                "https://btc-1.xverse.app" !== t.fallbackBtcApiUrl
                  ? t.fallbackBtcApiUrl
                  : Us.fallbackBtcApiUrl,
            });
            return {
              ...t,
              savedNetworks:
                t.savedNetworks?.map((t) =>
                  "Mainnet" === t.type ? e(t) : t,
                ) ?? Sm.savedNetworks,
              network:
                ("Mainnet" === t.network?.type ? e(t.network) : t.network) ??
                Sm.network,
            };
          },
          9: (t) => {
            const {
              showBtcReceiveAlert: e,
              showOrdinalReceiveAlert: r,
              ...n
            } = t;
            return { ...n, keystoneAccountsList: [] };
          },
          10: (t) => {
            const {
              accountsList: e,
              savedNames: r,
              ledgerAccountsList: n,
              keystoneAccountsList: i,
              ...o
            } = t;
            localStorage.setItem(
              "migration::v10::accountCount",
              JSON.stringify(e.length),
            );
            const s = { ...r };
            return (
              (s[o.network.type] = e
                .filter((t) => t.accountName)
                .map((t) => ({ name: t.accountName, id: t.id }))),
              Object.values(s).some((t) => t.length > 0) &&
                localStorage.setItem(
                  "migration::v10::migratedSavedNames",
                  JSON.stringify(r),
                ),
              {
                ...o,
                ledgerAccountsList: n,
                keystoneAccountsList: i,
                softwareWallets: {
                  Mainnet: [],
                  Testnet: [],
                  Testnet4: [],
                  Signet: [],
                  Regtest: [],
                },
              }
            );
          },
        },
        km = {
          version: 10,
          key: "walletState",
          storage: Cg.local,
          migrate: (function (t, e) {
            return (
              (e || {}).debug,
              function (e, r) {
                if (!e) return Promise.resolve(void 0);
                var n =
                  e._persist && void 0 !== e._persist.version
                    ? e._persist.version
                    : -1;
                if (n === r) return Promise.resolve(e);
                if (n > r) return Promise.resolve(e);
                var i = Object.keys(t)
                  .map(function (t) {
                    return parseInt(t);
                  })
                  .filter(function (t) {
                    return r >= t && t > n;
                  })
                  .sort(function (t, e) {
                    return t - e;
                  });
                try {
                  var o = i.reduce(function (e, r) {
                    return t[r](e);
                  }, e);
                  return Promise.resolve(o);
                } catch (t) {
                  return Promise.reject(t);
                }
              }
            );
          })(Tm, { debug: !1 }),
          blacklist: ["addingAccount"],
          timeout: 0,
        },
        Om = (function (t) {
          for (var e = Object.keys(t), r = {}, n = 0; n < e.length; n++) {
            var i = e[n];
            0, "function" == typeof t[i] && (r[i] = t[i]);
          }
          var o,
            s = Object.keys(r);
          try {
            !(function (t) {
              Object.keys(t).forEach(function (e) {
                var r = t[e];
                if (void 0 === r(void 0, { type: Kg.INIT }))
                  throw new Error(jg(12));
                if (void 0 === r(void 0, { type: Kg.PROBE_UNKNOWN_ACTION() }))
                  throw new Error(jg(13));
              });
            })(r);
          } catch (t) {
            o = t;
          }
          return function (t, e) {
            if ((void 0 === t && (t = {}), o)) throw o;
            for (var n = !1, i = {}, a = 0; a < s.length; a++) {
              var u = s[a],
                c = r[u],
                f = t[u],
                h = c(f, e);
              if (void 0 === h) {
                e && e.type;
                throw new Error(jg(14));
              }
              (i[u] = h), (n = n || h !== f);
            }
            return (n = n || s.length !== Object.keys(t).length) ? i : t;
          };
        })({ walletState: lm(km, Mm), nftDataState: _m }),
        xm = qg(
          lm(Am, (t, e) => Om(t, e)),
          (function () {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
              e[r] = arguments[r];
            return function (t) {
              return function () {
                var r = t.apply(void 0, arguments),
                  n = function () {
                    throw new Error(jg(15));
                  },
                  i = {
                    getState: r.getState,
                    dispatch: function () {
                      return n.apply(void 0, arguments);
                    },
                  },
                  o = e.map(function (t) {
                    return t(i);
                  });
                return (
                  (n = zg.apply(void 0, o)(r.dispatch)),
                  Lg(Lg({}, r), {}, { dispatch: n })
                );
              };
            };
          })(
            ...[
              (0, wm.PL)({
                blacklist: ["persist/PERSIST", "persist/REHYDRATE"],
              }),
            ],
          ),
        ),
        Pm = (function (t, e, r) {
          var n = r || !1,
            i = qg(bm, mm, e && e.enhancer ? e.enhancer : void 0),
            o = function (t) {
              i.dispatch({ type: Jg, key: t });
            },
            s = function (e, r, o) {
              var s = { type: Wg, payload: r, err: o, key: e };
              t.dispatch(s),
                i.dispatch(s),
                n && a.getState().bootstrapped && (n(), (n = !1));
            },
            a = ym({}, i, {
              purge: function () {
                var e = [];
                return (
                  t.dispatch({
                    type: Zg,
                    result: function (t) {
                      e.push(t);
                    },
                  }),
                  Promise.all(e)
                );
              },
              flush: function () {
                var e = [];
                return (
                  t.dispatch({
                    type: Gg,
                    result: function (t) {
                      e.push(t);
                    },
                  }),
                  Promise.all(e)
                );
              },
              pause: function () {
                t.dispatch({ type: Yg });
              },
              persist: function () {
                t.dispatch({ type: Xg, register: o, rehydrate: s });
              },
            });
          return (e && e.manualPersist) || a.persist(), a;
        })(xm);
      (0, wm.OV)(xm);
      const Bm = { store: xm, persistor: Pm, rehydrateError: Im };
      function Cm({ tabId: t, messageId: e, error: r }) {
        Ig(
          t,
          Eg(e, {
            code: Lr.INVALID_PARAMS,
            message: "Invalid parameters.",
            data: { error: r },
          }),
        );
      }
      function Rm({ tabId: t, messageId: e, message: r, data: n }) {
        Ig(
          t,
          Eg(e, {
            code: Lr.INTERNAL_ERROR,
            message: r ?? "Internal error.",
            data: n,
          }),
        );
      }
      const Nm = {
        [Zr.Ordinals]: (t) => ({
          address: t.ordinalsAddress,
          publicKey: t.ordinalsPublicKey,
          purpose: Zr.Ordinals,
          addressType: Jr.p2tr,
          walletType: t.accountType ?? "software",
        }),
        [Zr.Payment]: (t) => ({
          address: t.btcAddress,
          publicKey: t.btcPublicKey,
          purpose: Zr.Payment,
          addressType: "native" === t.btcAddressType ? Jr.p2wpkh : Jr.p2sh,
          walletType: t.accountType ?? "software",
        }),
        [Zr.Stacks]: (t) => ({
          address: t.stxAddress,
          publicKey: t.stxPublicKey,
          purpose: Zr.Stacks,
          addressType: Jr.stacks,
          walletType: t.accountType ?? "software",
        }),
      };
      function Um(t, e) {
        const r = [];
        if ("all" === e.type) {
          for (const e of Object.values(Zr)) r.push(Nm[e](t));
          return r;
        }
        for (const n of e.purposes) r.push(Nm[n](t));
        return r;
      }
      const Dm = async function (t, e) {
        Ig(
          $o(e),
          Sg(t.id, {
            version: "0.52.0",
            methods: [
              "getInfo",
              "getAddresses",
              "getAccounts",
              "getBalance",
              "signMessage",
              "sendTransfer",
              "signPsbt",
              "stx_callContract",
              "stx_deployContract",
              "stx_getAccounts",
              "stx_getAddresses",
              "stx_signMessage",
              "stx_signStructuredMessage",
              "stx_signTransaction",
              "stx_transferStx",
              "stx_signTransactions",
              "runes_estimateEtch",
              "runes_estimateMint",
              "runes_estimateRbfOrder",
              "runes_etch",
              "runes_getBalance",
              "runes_getOrder",
              "runes_mint",
              "runes_rbfOrder",
              "runes_transfer",
              "wallet_connect",
              "wallet_disconnect",
              "wallet_getAccount",
              "wallet_getCurrentPermissions",
              "wallet_getWalletType",
              "wallet_renouncePermissions",
              "wallet_requestPermissions",
              "wallet_getNetwork",
              "wallet_changeNetwork",
              "ord_getInscriptions",
              "ord_sendInscriptions",
            ],
            supports: [],
          }),
        );
      };
      function Lm(t, e) {
        return async (r, n) => {
          const { origin: i, tabId: o } = mg(n),
            [s, a] = await _g();
          if (s)
            return void Rm({
              tabId: o,
              messageId: r.id,
              message: "Error loading permissions store.",
            });
          const {
            selectedAccountIndex: u,
            selectedAccountType: c,
            selectedWalletId: f,
            softwareWallets: h,
            ledgerAccountsList: l,
            keystoneAccountsList: d,
            network: p,
          } = Bm.store.getState().walletState;
          if (
            !kg({
              selectedAccountIndex: u,
              selectedAccountType: c,
              selectedWalletId: f,
              softwareWallets: h,
              ledgerAccountsList: l,
              keystoneAccountsList: d,
              network: p.type,
            })
          )
            return void Rm({
              tabId: $o(n),
              messageId: r.id,
              message: "Failed to get selected account.",
            });
          const [y, g] = fy.utils.store.makeClientId({ origin: i });
          if (y)
            return void Rm({
              tabId: o,
              messageId: r.id,
              message: "Failed to create client ID during permissons check.",
            });
          const m = fy.utils.store.getClientPermissions(a, g),
            b = t.map((t) => ("function" == typeof t ? t() : t)),
            w = b.every((t) =>
              m.some((e) => {
                if (e.type !== t.type) return !1;
                if (e.resourceId !== t.resourceId) return !1;
                const r = Object.entries(t.actions).every(
                  ([t, r]) => e.actions[t] === r,
                );
                return r;
              }),
            );
          if (w) return e(r, n);
          !(function ({ tabId: t, messageId: e }) {
            Ig(t, Eg(e, { code: Lr.ACCESS_DENIED, message: "Access denied." }));
          })({ tabId: o, messageId: r.id });
        };
      }
      function jm(t, e) {
        return async (r, n) => {
          const i = pg(t, r);
          if (i.success) return e(i.output, n);
          !(function (t, e, r) {
            if (!e)
              return void console.warn(
                "No tab ID provided, unable to send RPC response.",
              );
            const n = t.id;
            n
              ? "string" == typeof n
                ? Cm({ tabId: e, messageId: n, error: r })
                : console.error(
                    "RPC message requests expect string message IDs, received:",
                    typeof n,
                  )
              : console.warn(
                  "No RPC message ID provided, unable to send RPC response.",
                );
          })(r, $o(n), i.issues);
        };
      }
      function Fm() {
        const {
            selectedAccountIndex: t,
            selectedAccountType: e,
            selectedWalletId: r,
            softwareWallets: n,
            ledgerAccountsList: i,
            keystoneAccountsList: o,
            network: s,
          } = Bm.store.getState().walletState,
          a = kg({
            selectedAccountIndex: t,
            selectedAccountType: e,
            selectedWalletId: r,
            softwareWallets: n,
            ledgerAccountsList: i,
            keystoneAccountsList: o,
            network: s.type,
          });
        if (!a)
          throw new Error("Could not find selected account.", {
            cause: {
              selectedAccountIndex: t,
              selectedAccountType: e,
              selectedWalletId: r,
              softwareWallets: n,
              ledgerAccountsList: i,
            },
          });
        const u = fy.utils.account.makeAccountId({
          accountId: t,
          masterPubKey: a.masterPubKey,
          networkType: s.type,
        });
        return fy.resources.account.makeAccountResourceId(u);
      }
      const Hm = {
          [_i]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(Ei, async function (t, e) {
              const r = $o(e),
                {
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  network: c,
                  btcPaymentAddressType: f,
                } = Bm.store.getState().walletState,
                h = kg({
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  network: c.type,
                });
              if (!h) return void Rm({ tabId: r, messageId: t.id });
              const l = Tg(h, f).btcAddress,
                [d, p] = await (async function (t, e) {
                  const r = new oa({
                      network: e.type,
                      url: e.btcApiUrl,
                      fallbackUrl: e.fallbackBtcApiUrl,
                    }),
                    [n, i] = await (async function (t) {
                      try {
                        return [null, await t];
                      } catch (t) {
                        return (function (t) {
                          return [t, null];
                        })({
                          name: "SafeError",
                          message: "Promise rejected.",
                          data: t,
                        });
                      }
                    })(r.getBalance(t));
                  if (n) return [n, null];
                  const o = i.finalBalance,
                    { unconfirmedBalance: s } = i;
                  return [null, { confirmed: o, unconfirmed: s, total: o + s }];
                })(l, c);
              d
                ? Rm({
                    tabId: r,
                    messageId: t.id,
                    message: "Error retrieving balance.",
                  })
                : (function ({ tabId: t, messageId: e, result: r }) {
                    Ig(t, Sg(e, r));
                  })({
                    tabId: r,
                    messageId: t.id,
                    result: {
                      confirmed: p.confirmed.toString(),
                      unconfirmed: p.unconfirmed.toString(),
                      total: p.total.toString(),
                    },
                  });
            }),
          ),
          [ri]: jm(ii, Dm),
          [oi]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(ai, async (t, e) => {
              const r = $o(e),
                {
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  btcPaymentAddressType: c,
                  network: f,
                } = Bm.store.getState().walletState,
                h = kg({
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  network: f.type,
                });
              if (!h) return void Rm({ tabId: r, messageId: t.id });
              const l = Um(Tg(h, c), {
                type: "select",
                purposes: t.params.purposes,
              });
              !(function ({ tabId: t, messageId: e, result: r }) {
                Ig(t, Sg(e, r));
              })({
                tabId: r,
                messageId: t.id,
                result: {
                  addresses: l,
                  network: {
                    bitcoin: { name: Ag(f.type) },
                    stacks: { name: Ag(f.type) },
                  },
                },
              });
            }),
          ),
          [bi]: jm(vi, async (t, e) => {
            await gg({
              path: Qo.AddressRequest,
              data: t,
              context: mg(e),
              onClose: Mg({ tabId: $o(e), messageId: t.id }),
            });
          }),
          [ui]: jm(hi, async (t, e) => {
            const r = [
                ["payload", qo.stringify(t.params)],
                ["requestId", t.id],
              ],
              { urlParams: n, tabId: i } = ts(e, r),
              { id: o } = await is(Qo.SignMessageRequest, n);
            es({
              tabId: i,
              id: o,
              response: Eg(t.id, {
                code: Lr.USER_REJECTION,
                message: "User rejected request to sign Message",
              }),
            }),
              ns({ tabId: i });
          }),
          [li]: jm(pi, async (t, e) => {
            const r = [
                ["recipients", JSON.stringify(t.params.recipients)],
                ["requestId", t.id],
              ],
              { urlParams: n, tabId: i } = ts(e, r),
              { id: o } = await is(Qo.SendBtcTx, n);
            es({
              tabId: i,
              id: o,
              response: Eg(t.id, {
                code: Lr.USER_REJECTION,
                message: "User rejected request to send transfer",
              }),
            }),
              ns({ tabId: i });
          }),
          [yi]: jm(mi, async (t, e) => {
            const r = [
              ["requestId", t.id],
              ["signInputs", JSON.stringify(t.params.signInputs)],
              ["psbt", t.params.psbt],
            ];
            t.params.broadcast &&
              r.push(["broadcast", String(t.params.broadcast)]);
            const { urlParams: n, tabId: i } = ts(e, r),
              { id: o } = await is(Qo.SignBtcTx, n);
            es({
              tabId: i,
              id: o,
              response: Eg(t.id, {
                code: Lr.USER_REJECTION,
                message: "User rejected request to sign a psbt",
              }),
            }),
              ns({ tabId: i });
          }),
        },
        Km = async (t, e) => {
          const r = $o(e),
            {
              selectedAccountIndex: n,
              selectedAccountType: i,
              selectedWalletId: o,
              softwareWallets: s,
              ledgerAccountsList: a,
              keystoneAccountsList: u,
              network: c,
            } = Bm.store.getState().walletState,
            f = kg({
              selectedAccountIndex: n,
              selectedAccountType: i,
              selectedWalletId: o,
              softwareWallets: s,
              ledgerAccountsList: a,
              keystoneAccountsList: u,
              network: c.type,
            });
          if (!f)
            return void Ig(
              r,
              Eg(t.id, {
                code: Lr.INTERNAL_ERROR,
                message: "Could not find selected account.",
              }),
            );
          const h = new ua({ network: c.type });
          try {
            const e = await h.getInscriptions(
              f.btcAddresses.taproot.address,
              t.params.offset,
              t.params.limit,
            );
            Ig(
              r,
              Sg(t.id, {
                total: e.total,
                limit: e.limit,
                offset: e.offset,
                inscriptions: e.results.map((t) => ({
                  inscriptionId: t.id,
                  inscriptionNumber: String(t.number),
                  collectionName: t.collection_name ? t.collection_name : "",
                  contentType: t.content_type,
                  contentLength: String(t.content_length),
                  address: t.address,
                  output: t.output,
                  offset: Number(t.offset),
                  postage: t.value,
                  genesisTransaction: t.genesis_tx_id,
                  timestamp: t.genesis_timestamp,
                })),
              }),
            );
          } catch (e) {
            Ig(r, Eg(t.id, { code: Lr.INTERNAL_ERROR, message: e.message }));
          }
        },
        Vm = {
          Legal: "/legal",
          RestoreWallet: "/restore-wallet",
          CreateWallet: "/create-wallet",
          ConfirmStacksTransaction: "/confirm-stx-tx",
          SendOrdinal: "/send-ordinal",
          SendBtc: "/send-btc",
          SendRune: "/send-rune",
          SendStx: "/send-stx",
          SendBrc20OneStep: "/send-brc20-one-step",
          SendInscriptionsRequest: "/send-inscriptions-request",
          TransferRunesRequest: "/transfer-runes-request",
          AccountList: "/account-list",
          Settings: "/settings",
          About: "/settings/about",
          Preferences: "/settings/preferences",
          Security: "/settings/security",
          AddressBook: "/settings/address-book",
          AddEditAddress: "/settings/address-book/manage/:id?",
          AddAddress: "/settings/address-book/manage",
          EditAddress: (t) => `/settings/address-book/manage/${t}`,
          AdvancedSettings: "/settings/advanced-settings",
          PreferredAddress: "/settings/preferred-address",
          FiatCurrency: "/settings/fiat-currency",
          ConnectedAppsAndPermissions:
            "/settings/connected-apps-and-permissions",
          PrivacyPreferences: "/settings/privacy-preferences",
          LockCountdown: "/settings/lock-countdown",
          RecoverFunds: "/settings/recover-funds",
          RecoverOrdinals: "/settings/recover-ordinals",
          RecoverRunes: "/settings/recover-runes",
          ChangeNetwork: "/settings/change-network",
          BackupWallet: "/settings/backup-wallet",
          ChangePassword: "/settings/change-password",
          ResetWallet: "/settings/reset-wallet",
        },
        qm = async (t, e) => {
          await gg({
            path: Vm.SendInscriptionsRequest,
            data: t,
            context: mg(e),
            onClose: Mg({ tabId: $o(e), messageId: t.id }),
          });
        },
        zm = {
          [Di]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(ji, Km),
          ),
          [Fi]: jm(Ki, qm),
        },
        $m = async (t, e) => {
          const r = [
              ["payload", qo.stringify(t.params)],
              ["requestId", t.id],
            ],
            { urlParams: n, tabId: i } = ts(e, r),
            { id: o } = await is(Qo.EtchRune, n);
          es({
            tabId: i,
            id: o,
            response: Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected request to etch a rune",
            }),
          }),
            ns({ tabId: i });
        },
        Gm = async (t, e) => {
          const r = $o(e),
            {
              selectedAccountIndex: n,
              selectedAccountType: i,
              selectedWalletId: o,
              softwareWallets: s,
              ledgerAccountsList: a,
              keystoneAccountsList: u,
              network: c,
            } = Bm.store.getState().walletState,
            f = kg({
              selectedAccountIndex: n,
              selectedAccountType: i,
              selectedWalletId: o,
              softwareWallets: s,
              ledgerAccountsList: a,
              keystoneAccountsList: u,
              network: c.type,
            });
          if (!f)
            return void Ig(
              r,
              Eg(t.id, {
                code: Lr.INTERNAL_ERROR,
                message: "Could not find selected account.",
              }),
            );
          const h = ((t, e) => (Ma[t] || (Ma[t] = new Ia(t, e)), Ma[t]))(
            c.type,
          );
          try {
            const e = await h.getRuneBalances(
                f.btcAddresses.taproot.address,
                !0,
              ),
              n = await h.getRuneBalances(f.btcAddresses.taproot.address),
              i = e.map((t) => {
                const e = n.find((e) => e.id === t.id);
                return {
                  ...t,
                  amount: t.amount.toString(),
                  spendableBalance: e?.amount.toString() ?? "0",
                };
              });
            Ig(r, Sg(t.id, { balances: i }));
          } catch (e) {
            Ig(r, Eg(t.id, { code: Lr.INTERNAL_ERROR, message: e.message }));
          }
        },
        Wm = async (t, e) => {
          const r = [
              ["payload", qo.stringify(t.params)],
              ["requestId", t.id],
            ],
            { urlParams: n, tabId: i } = ts(e, r),
            { id: o } = await is(Qo.MintRune, n);
          es({
            tabId: i,
            id: o,
            response: Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected request to mint a rune",
            }),
          }),
            ns({ tabId: i });
        },
        Ym = async (t, e) => {
          await gg({
            path: Vm.TransferRunesRequest,
            data: t,
            context: mg(e),
            onClose: Mg({ tabId: $o(e), messageId: t.id }),
          });
        },
        Xm = {
          [ki]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(xi, Gm),
          ),
          [Pi]: jm(Ci, Wm),
          [Si]: jm(Ti, $m),
          [Ri]: jm(Ui, Ym),
        };
      const Zm = async function (t, e) {
        const n = {
            contract: t.params.contract,
            functionName: t.params.functionName,
            arguments: t.params.arguments
              ? Wo(t.params.arguments)
              : t.params.functionArgs
                ? Wo(t.params.functionArgs)
                : void 0,
            postConditions: t.params.postConditions
              ? Wo(t.params.postConditions)
              : void 0,
            postConditionMode: t.params.postConditionMode,
            rpcMethod: "stx_callContract",
            messageId: String(t.id),
          },
          { urlParams: i, tabId: o } = ts(e, n),
          { id: s } = await is(Qo.TransactionRequest, i);
        es({
          tabId: o,
          id: s,
          response: {
            ...Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected the Stacks transaction signing request",
            }),
            source: r,
          },
        });
      };
      const Jm = async function (t, e) {
          const n = {
              name: t.params.name,
              clarityCode: Wo(t.params.clarityCode),
              clarityVersion: t.params.clarityVersion,
              postConditions: t.params.postConditions
                ? Wo(t.params.postConditions)
                : void 0,
              postConditionMode: t.params.postConditionMode,
              rpcMethod: "stx_deployContract",
              messageId: String(t.id),
            },
            { urlParams: i, tabId: o } = ts(e, n),
            { id: s } = await is(Qo.TransactionRequest, i);
          es({
            tabId: o,
            id: s,
            response: {
              ...Eg(t.id, {
                code: Lr.USER_REJECTION,
                message: "User rejected the Stacks transaction signing request",
              }),
              source: r,
            },
          });
        },
        Qm = async (t, e) => {
          const r = { messageId: String(t.id), rpcMethod: "stx_getAccounts" },
            { urlParams: n, tabId: i } = ts(e, r),
            { id: o } = await is(Qo.StxAccountRequest, n);
          es({
            tabId: i,
            id: o,
            response: Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected request to get accounts",
            }),
          });
        };
      const tb = async (t, e) => {
        const r = { messageId: String(t.id), rpcMethod: "stx_getAddresses" },
          n = $o(e),
          {
            selectedAccountIndex: i,
            selectedAccountType: o,
            selectedWalletId: s,
            softwareWallets: a,
            ledgerAccountsList: u,
            keystoneAccountsList: c,
            network: f,
          } = Bm.store.getState().walletState,
          h = kg({
            selectedAccountIndex: i,
            selectedAccountType: o,
            selectedWalletId: s,
            softwareWallets: a,
            ledgerAccountsList: u,
            keystoneAccountsList: c,
            network: f.type,
          });
        if (h)
          !(function ({ tabId: t, messageId: e, result: r }) {
            Ig(t, Sg(e, r));
          })({
            tabId: n,
            messageId: t.id,
            result: {
              addresses: [
                {
                  address: h.stxAddress,
                  publicKey: h.stxPublicKey,
                  addressType: Jr.stacks,
                  purpose: Zr.Stacks,
                  walletType: h.accountType ?? "software",
                },
              ],
              network: {
                bitcoin: { name: Ag(f.type) },
                stacks: { name: Ag(f.type) },
              },
            },
          });
        else {
          const { urlParams: i } = ts(e, r),
            { id: o } = await is(Qo.StxAddressRequest, i);
          es({
            tabId: n,
            id: o,
            response: Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected request to get addresses",
            }),
          });
        }
      };
      const eb = async function (t, e) {
        const n = {
            message: t.params.message,
            messageId: String(t.id),
            rpcMethod: t.method,
          },
          { urlParams: i, tabId: o } = ts(e, n),
          { id: s } = await is(Qo.SignatureRequest, i);
        es({
          tabId: o,
          id: s,
          response: {
            ...Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected the message signing request",
            }),
            source: r,
          },
        });
      };
      const rb = async function (t, e) {
        const n = {
            message: t.params.message,
            domain: t.params.domain,
            messageId: String(t.id),
            rpcMethod: t.method,
          },
          { urlParams: i, tabId: o } = ts(e, n),
          { id: s } = await is(Qo.SignatureRequest, i);
        es({
          tabId: o,
          id: s,
          response: {
            ...Eg(t.id, {
              code: Lr.USER_REJECTION,
              message: "User rejected the structured message signing request",
            }),
            source: r,
          },
        });
      };
      var nb = i(41011);
      const ib = async function (t, e) {
          const n = {
              amount: t.params.amount.toString(),
              recipient: t.params.recipient,
              memo: t.params.memo,
              rpcMethod: t.method,
              messageId: String(t.id),
            },
            { urlParams: i, tabId: o } = ts(e, n),
            { id: s } = await is(Qo.TransactionRequest, i);
          es({
            tabId: o,
            id: s,
            response: {
              ...Eg(t.id, {
                code: Lr.USER_REJECTION,
                message: "User rejected the Stacks transaction signing request",
              }),
              source: r,
            },
          });
        },
        ob = {
          [qr]: jm($r, Zm),
          [Gr]: jm(Yr, Jm),
          [Nn]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(Dn, Qm),
          ),
          [Ln]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(Fn, tb),
          ),
          [Gn]: jm(Yn, async function (t, e) {
            !(function (t) {
              try {
                return (0, nb.qu)(t), !0;
              } catch (t) {
                return !1;
              }
            })(t.params.transaction)
              ? (function ({ tabId: t, messageId: e }) {
                  Ig(
                    t,
                    Eg(e, {
                      code: Lr.INVALID_PARAMS,
                      message: "Invalid Stacks transaction.",
                    }),
                  );
                })({ tabId: $o(e), messageId: t.id })
              : await gg({
                  path: Qo.TransactionRequest,
                  data: t,
                  context: mg(e),
                  onClose: Mg({ tabId: $o(e), messageId: t.id }),
                });
          }),
          [Xn]: jm(Jn, async function (t, e) {
            await gg({
              path: Qo.StxSignTransactions,
              data: t,
              context: mg(e),
              onClose: Mg({ tabId: $o(e), messageId: t.id }),
            });
          }),
          [Qn]: jm(ei, ib),
          [Hn]: jm(Vn, eb),
          [qn]: jm($n, rb),
        };
      const sb = async (t, e) => {
          const [r, n] = await _g();
          if (r)
            return void Rm({
              tabId: $o(e),
              messageId: t.id,
              message: "Error loading permissions store.",
            });
          const {
              selectedAccountIndex: i,
              selectedAccountType: o,
              selectedWalletId: s,
              softwareWallets: a,
              ledgerAccountsList: u,
              keystoneAccountsList: c,
              network: f,
              btcPaymentAddressType: h,
            } = Bm.store.getState().walletState,
            l = kg({
              selectedAccountIndex: i,
              selectedAccountType: o,
              selectedWalletId: s,
              softwareWallets: a,
              ledgerAccountsList: u,
              keystoneAccountsList: c,
              network: f.type,
            });
          if (!l)
            return void Rm({
              tabId: $o(e),
              messageId: t.id,
              message: "Failed to get selected account.",
            });
          const [d, p] = fy.utils.store.makeClientId({ origin });
          if (d)
            return void Rm({
              tabId: $o(e),
              messageId: t.id,
              message: "Failed to create client ID during permissons check.",
            });
          const y = fy.utils.account.makeAccountId({
              accountId: l.id,
              masterPubKey: l.masterPubKey,
              networkType: f.type,
            }),
            g = fy.resources.account.makeAccountResourceId(y),
            m = fy.utils.store.hasPermission(n, {
              type: "account",
              clientId: p,
              resourceId: g,
              actions: { read: !0 },
            }),
            b = fy.utils.store.hasPermission(n, {
              type: "wallet",
              clientId: p,
              resourceId: "wallet",
              actions: { readNetwork: !0 },
            });
          if (!m || !b)
            return void gg({
              path: Qo.ConnectionRequest,
              data: t,
              context: mg(e),
              onClose: Mg({ tabId: $o(e), messageId: t.id }),
            });
          const w = Um(Tg(l, h), { type: "all" }),
            v = {
              id: y,
              walletType: l.accountType ?? "software",
              addresses: w,
              network: {
                bitcoin: { name: Ag(f.type) },
                stacks: { name: Ag(f.type) },
              },
            };
          !(function ({ tabId: t, messageId: e, result: r }) {
            Ig(t, Sg(e, r));
          })({ tabId: $o(e), messageId: t.id, result: v });
        },
        ab = "wallet-event";
      (function t(e, r, n) {
        let i;
        return {
          kind: "schema",
          type: "variant",
          reference: t,
          expects: "Object",
          async: !1,
          key: e,
          options: r,
          message: n,
          _run(t, e) {
            const r = t.value;
            if (r && "object" == typeof r) {
              const n = r[this.key];
              if (this.key in r) {
                let t;
                for (const i of this.options)
                  if (
                    "variant" === i.type ||
                    !i.entries[this.key]._run({ typed: !1, value: n }, e).issues
                  ) {
                    const n = i._run({ typed: !1, value: r }, e);
                    if (!n.issues) return n;
                    (!t || (!t.typed && n.typed)) && (t = n);
                  }
                if (t) return t;
              }
              i || (i = [...dg(this.key, this.options)].join(" | ") || "never"),
                ug(this, "type", t, e, {
                  input: n,
                  expected: i,
                  path: [
                    {
                      type: "object",
                      origin: "value",
                      input: r,
                      key: this.key,
                      value: n,
                    },
                  ],
                });
            } else ug(this, "type", t, e);
            return t;
          },
        };
      })("type", [
        hg({ type: fg(ab), data: Kr }),
        hg({ type: fg("rpc-response"), data: Hr }),
      ]);
      async function ub(t, e) {
        t.forEach((t) =>
          (async function (t, e) {
            chrome.tabs.sendMessage(t, e);
          })(t, e),
        );
      }
      function cb(t) {
        return `${t}/*`;
      }
      async function fb(t, e) {
        !(async function (t, e) {
          const r = cb(t);
          ub(
            (await chrome.tabs.query({ url: r }))
              .filter((t) => "number" == typeof t.id)
              .map((t) => t.id),
            e,
          );
        })(t, { type: ab, data: e });
      }
      const hb = async (t, e) => {
        const { origin: r, tabId: n } = mg(e),
          [i, o] = await _g();
        if (i)
          return void Rm({
            tabId: n,
            messageId: t.id,
            message: "Error loading permissions store.",
          });
        const [s, a] = fy.utils.store.makeClientId({ origin: r });
        s
          ? Rm({
              tabId: n,
              messageId: t.id,
              message: "Error creating client ID.",
            })
          : (wg(fy.utils.store.removeClient(o, a)),
            fb(r, { type: "disconnect" }),
            (function ({ tabId: t, messageId: e, result: r }) {
              Ig(t, Sg(e, r));
            })({ tabId: n, messageId: t.id, result: null }));
      };
      const lb = {
          [Bn]: jm(Rn, sb),
          [dn]: jm(yn, hb),
          [an]: jm(cn, async (t, e) => {
            if (!t.params)
              return sb({ ...t, method: "wallet_connect", params: void 0 }, e);
            Rm({
              tabId: $o(e),
              messageId: t.id,
              message:
                'The wallet does not yet support requesting individual permissions. Use `request("wallet_connect", undefined)` to get account read permissions.',
            });
          }),
          [fn]: jm(ln, async (t, e) => {
            hb({ ...t, method: "wallet_disconnect" }, e);
          }),
          [gn]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(bn, async function (t, e) {
              const r = $o(e),
                {
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  network: c,
                } = Bm.store.getState().walletState,
                f = kg({
                  selectedAccountIndex: n,
                  selectedAccountType: i,
                  selectedWalletId: o,
                  softwareWallets: s,
                  ledgerAccountsList: a,
                  keystoneAccountsList: u,
                  network: c.type,
                });
              f
                ? (function ({ tabId: t, messageId: e, result: r }) {
                    Ig(t, Sg(e, r));
                  })({
                    tabId: r,
                    messageId: t.id,
                    result: f.accountType ?? "software",
                  })
                : Rm({ tabId: r, messageId: t.id });
            }),
          ),
          [wn]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(_n, async function (t, e) {
              const { origin: r, tabId: n } = mg(e),
                [i, o] = await _g();
              if (i)
                return void Rm({
                  tabId: n,
                  messageId: t.id,
                  message: "Error loading permissions store.",
                });
              const [s, a] = fy.utils.store.makeClientId({ origin: r });
              s
                ? Rm({
                    tabId: n,
                    messageId: t.id,
                    message: "Error creating client ID.",
                  })
                : (function ({ tabId: t, messageId: e, result: r }) {
                    Ig(t, Sg(e, r));
                  })({
                    tabId: n,
                    messageId: t.id,
                    result: fy.utils.store.getClientPermissions(o, a),
                  });
            }),
          ),
          [On]: Lm(
            [
              () => ({
                type: "account",
                resourceId: Fm(),
                actions: { read: !0 },
              }),
            ],
            jm(Pn, async function (t, e) {
              const {
                  selectedAccountIndex: r,
                  selectedAccountType: n,
                  selectedWalletId: i,
                  softwareWallets: o,
                  ledgerAccountsList: s,
                  keystoneAccountsList: a,
                  network: u,
                  btcPaymentAddressType: c,
                } = Bm.store.getState().walletState,
                f = kg({
                  selectedAccountIndex: r,
                  selectedAccountType: n,
                  selectedWalletId: i,
                  softwareWallets: o,
                  ledgerAccountsList: s,
                  keystoneAccountsList: a,
                  network: u.type,
                });
              if (!f)
                return void Rm({
                  tabId: $o(e),
                  messageId: t.id,
                  message: "Failed to get selected account.",
                });
              const h = fy.utils.account.makeAccountId({
                  accountId: f.id,
                  masterPubKey: f.masterPubKey,
                  networkType: u.type,
                }),
                l = Um(Tg(f, c), { type: "all" }),
                d = {
                  id: h,
                  walletType: f.accountType ?? "software",
                  network: {
                    bitcoin: { name: Ag(u.type) },
                    stacks: { name: Ag(u.type) },
                  },
                  addresses: l,
                };
              !(function ({ tabId: t, messageId: e, result: r }) {
                Ig(t, Sg(e, r));
              })({ tabId: $o(e), messageId: t.id, result: d });
            }),
          ),
          [En]: Lm(
            [
              {
                type: "wallet",
                resourceId: "wallet",
                actions: { readNetwork: !0 },
              },
            ],
            jm(Mn, function (t, e) {
              const { network: r } = Bm.store.getState().walletState,
                n = { bitcoin: { name: Ag(r.type) }, stacks: { name: r.type } };
              !(function ({ tabId: t, messageId: e, result: r }) {
                Ig(t, Sg(e, r));
              })({ tabId: $o(e), messageId: t.id, result: n });
            }),
          ),
          [An]: Lm(
            [
              {
                type: "wallet",
                resourceId: "wallet",
                actions: { readNetwork: !0 },
              },
            ],
            jm(kn, async function (t, e) {
              const { network: r, _persist: n } =
                  Bm.store.getState().walletState,
                i = t.params?.name;
              r.type === i && n.rehydrated
                ? Cm({
                    tabId: $o(e),
                    messageId: t.id,
                    error: "Network already active",
                  })
                : await gg({
                    path: Qo.ChangeNetworkRequest,
                    data: t,
                    context: mg(e),
                    onClose: Mg({ tabId: $o(e), messageId: t.id }),
                  });
            }),
          ),
        },
        db = { ...lb, ...Hm, ...ob, ...Xm, ...zm };
      const pb = async function (t, e) {
        const r = db[t.method];
        if (!r)
          return Ig(
            $o(e),
            Eg(t.id, {
              code: Lr.METHOD_NOT_FOUND,
              message: `"${t.method}" is not supported.`,
            }),
          );
        const [n] = await (async function (t) {
          const [e, r] = await _g();
          if (e)
            return Oa({
              name: "LoadStoreError",
              message: "Error loading permissions store.",
            });
          const n = Go(t),
            [i, o] = fy.utils.store.makeClientId({ origin: n });
          return i
            ? Oa({
                name: "ClientIdError",
                message: "Failed to create client ID during permissions check.",
              })
            : (wg(
                fy.utils.store.setClientMetadata(r, {
                  clientId: o,
                  lastUsed: new Date().getTime(),
                }),
              ),
              ka(void 0));
        })(e);
        if (n)
          return void Ig(
            $o(e),
            Eg(t.id, {
              code: Lr.INTERNAL_ERROR,
              message: "Error updating client last used time.",
            }),
          );
        const [i] = await xa(r(t, e));
        return i
          ? Ig(
              $o(e),
              Eg(t.id, {
                code: Lr.INTERNAL_ERROR,
                message: "RPC handler error",
                data: i.data,
              }),
            )
          : void 0;
      };
      chrome.runtime.onConnect.addListener((t) => {
        async function e(e, i) {
          const o = pg(Dr, e);
          o.success
            ? pb(o.output, t)
            : (async function (t, e) {
                const { payload: i } = t;
                switch (t.method) {
                  case n.authenticationRequest: {
                    const { urlParams: t, tabId: o } = ts(e, [
                        ["authRequest", i],
                      ]),
                      { id: s } = await is(Qo.AuthenticationRequest, t);
                    es({
                      id: s,
                      tabId: o,
                      response: {
                        source: r,
                        payload: {
                          authenticationRequest: i,
                          authenticationResponse: "cancel",
                        },
                        method: n.authenticationResponse,
                      },
                    }),
                      ns({ tabId: o });
                    break;
                  }
                  case n.transactionRequest: {
                    const { urlParams: t, tabId: o } = ts(e, [["request", i]]),
                      { id: s } = await is(Qo.TransactionRequest, t);
                    es({
                      id: s,
                      tabId: o,
                      response: {
                        source: r,
                        method: n.transactionResponse,
                        payload: {
                          transactionRequest: i,
                          transactionResponse: "cancel",
                        },
                      },
                    }),
                      ns({ tabId: o });
                    break;
                  }
                  case n.signatureRequest: {
                    const { urlParams: t, tabId: r } = ts(e, [
                        ["request", i],
                        ["messageType", "utf8"],
                      ]),
                      { id: n } = await is(Qo.SignatureRequest, t);
                    es({
                      id: n,
                      tabId: r,
                      response: rs({ request: i, response: "cancel" }),
                    }),
                      ns({ tabId: r });
                    break;
                  }
                  case n.structuredDataSignatureRequest: {
                    const { urlParams: t, tabId: r } = ts(e, [
                        ["request", i],
                        ["messageType", "structured"],
                      ]),
                      { id: n } = await is(Qo.SignatureRequest, t);
                    es({
                      id: n,
                      tabId: r,
                      response: rs({ request: i, response: "cancel" }),
                    }),
                      ns({ tabId: r });
                    break;
                  }
                  case a.getAddressRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["addressRequest", i],
                      ]),
                      { id: o } = await is(Qo.AddressRequest, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          addressRequest: i,
                          addressResponse: "cancel",
                        },
                        method: a.getAddressResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.signPsbtRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["signPsbtRequest", i],
                      ]),
                      { id: o } = await is(Qo.SignBtcTx, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          signPsbtRequest: i,
                          signPsbtResponse: "cancel",
                        },
                        method: a.signPsbtResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.signBatchPsbtRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["signBatchPsbtRequest", i],
                      ]),
                      { id: o } = await is(Qo.SignBatchBtcTx, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          signBatchPsbtRequest: i,
                          signBatchPsbtResponse: "cancel",
                        },
                        method: a.signBatchPsbtResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.signMessageRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["signMessageRequest", i],
                      ]),
                      { id: o } = await is(Qo.SignMessageRequest, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          signMessageRequest: i,
                          signMessageResponse: "cancel",
                        },
                        method: a.signMessageResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.sendBtcRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["sendBtcRequest", i],
                      ]),
                      { id: o } = await is(Qo.SendBtcTx, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          sendBtcRequest: i,
                          sendBtcResponse: "cancel",
                        },
                        method: a.sendBtcResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.createInscriptionRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["createInscription", i],
                      ]),
                      { id: o } = await is(Qo.CreateInscription, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          createInscriptionRequest: i,
                          createInscriptionResponse: "cancel",
                        },
                        method: a.createInscriptionResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                  case a.createRepeatInscriptionsRequest: {
                    const { urlParams: t, tabId: n } = ts(e, [
                        ["createRepeatInscriptions", i],
                      ]),
                      { id: o } = await is(Qo.CreateRepeatInscriptions, t);
                    es({
                      id: o,
                      tabId: n,
                      response: {
                        source: r,
                        payload: {
                          createRepeatInscriptionsRequest: i,
                          createRepeatInscriptionsResponse: "cancel",
                        },
                        method: a.createRepeatInscriptionsResponse,
                      },
                    }),
                      ns({ tabId: n });
                    break;
                  }
                }
              })(e, i);
        }
        "xverse-content-script" === t.name &&
          t.onMessage.addListener((t, r) => {
            e(t, r).catch((t) => {
              console.error("Failed to handle message:", t);
            });
          });
      }),
        chrome.runtime.onInstalled.addListener((t) => {
          (async function (t) {
            "install" === t.reason &&
              chrome.tabs.create({
                url: chrome.runtime.getURL("options.html#/landing"),
              });
          })(t).catch((t) => {
            console.error("Failed to handle onInstalled event:", t);
          });
        }),
        "MISSING_ENV_VAR".WALLET_LABEL &&
          chrome.action.setBadgeText({ text: "MISSING_ENV_VAR".WALLET_LABEL });
    })();
})();
